using System;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using BenchmarkDotNet.Engines;
using BenchmarkDotNet.Extensions;
using BenchmarkDotNet.Helpers.Reflection.Emit;

namespace BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation
{
    internal class ConsumableConsumeEmitter : ConsumeEmitter
    {
        private FieldBuilder consumerField;
        private LocalBuilder disassemblyDiagnoserLocal;
        private LocalBuilder resultLocal;

        public ConsumableConsumeEmitter(ConsumableTypeInfo consumableTypeInfo) : base(consumableTypeInfo)
        {
        }

        protected override void OnDefineFieldsOverride(TypeBuilder runnableBuilder)
        {
            consumerField = runnableBuilder.DefineField(RunnableConstants.ConsumerFieldName, typeof(Consumer), FieldAttributes.Private);
        }

        protected override void DeclareDisassemblyDiagnoserLocalsOverride(ILGenerator ilBuilder)
        {
            // optional local if default(T) uses .initobj
            disassemblyDiagnoserLocal = ilBuilder.DeclareOptionalLocalForReturnDefault(ConsumableInfo.WorkloadMethodReturnType);
        }

        protected override void EmitDisassemblyDiagnoserReturnDefaultOverride(ILGenerator ilBuilder)
        {
            ilBuilder.EmitReturnDefault(ConsumableInfo.WorkloadMethodReturnType, disassemblyDiagnoserLocal);
        }

        protected override void DeclareLoopLocalsOverride(ILGenerator ilBuilder)
        {
            /*
                .locals init (
                    [4] native int,
                )
             */
            var consumeField = ConsumableInfo.WorkloadConsumableField;
            if (consumeField == null)
            {
                GetConsumeMethod(ConsumableInfo.WorkloadMethodReturnType, out bool passByRef);
                if (passByRef)
                {
                    resultLocal = ilBuilder.DeclareLocal(ConsumableInfo.WorkloadMethodReturnType);
                }
            }
            else
            {
                GetConsumeMethod(consumeField.FieldType, out bool passByRef);
                if (passByRef)
                {
                    resultLocal = ilBuilder.DeclareLocal(consumeField.FieldType);
                }
            }
        }

        protected override void OnEmitCtorBodyOverride(ConstructorBuilder constructorBuilder, ILGenerator ilBuilder)
        {
            var ctor = typeof(Consumer).GetConstructor(Array.Empty<Type>());
            if (ctor == null)
                throw new InvalidOperationException($"Cannot get default .ctor for {typeof(Consumer)}");

            /*
                // consumer = new Consumer();
                IL_0000: ldarg.0
                IL_0001: newobj instance void [BenchmarkDotNet]BenchmarkDotNet.Engines.Consumer::.ctor()
                IL_0006: stfld class [BenchmarkDotNet]BenchmarkDotNet.Engines.Consumer BenchmarkDotNet.Autogenerated.Runnable_0::consumer
             */
            ilBuilder.Emit(OpCodes.Ldarg_0);
            ilBuilder.Emit(OpCodes.Newobj, ctor);
            ilBuilder.Emit(OpCodes.Stfld, consumerField);
        }

        protected override void EmitActionBeforeCallOverride(ILGenerator ilBuilder)
        {
            /*
                // consumer. ...;
                IL_000c: ldarg.0
                IL_000d: ldfld class [BenchmarkDotNet]BenchmarkDotNet.Engines.Consumer BenchmarkDotNet.Autogenerated.Runnable_0::consumer
             */
            ilBuilder.Emit(OpCodes.Ldarg_0);
            ilBuilder.Emit(OpCodes.Ldfld, consumerField);
        }

        protected override void EmitActionAfterCallOverride(ILGenerator ilBuilder)
        {
            /*
                // ... .Consume( ... )
                IL_001e: callvirt instance void [BenchmarkDotNet]BenchmarkDotNet.Engines.Consumer::Consume(string)
                -or-
                // ... .Consume( ... .ConsumableField);
                IL_001e: callvirt instance void [BenchmarkDotNet]BenchmarkDotNet.Engines.Consumer::Consume(int32)
                // -or- .Consume( ... );
                IL_0018: valuetype [System.Runtime]System.Decimal int32 BenchmarkDotNet.Samples.CustomWithConsumable::ConsumableField
                IL_001d: stloc.1
                IL_001e: ldloca.s 1
                IL_0020: callvirt instance void [BenchmarkDotNet]BenchmarkDotNet.Engines.Consumer::Consume<valuetype [System.Runtime]System.Decimal>(!!0&)
             */
            var consumeField = ConsumableInfo.WorkloadConsumableField;
            if (consumeField == null)
            {
                var consumeMethod = GetConsumeMethod(ConsumableInfo.WorkloadMethodReturnType, out bool passByRef);
                if (passByRef)
                {
                    ilBuilder.EmitStloc(resultLocal);
                    ilBuilder.EmitLdloca(resultLocal);
                }
                ilBuilder.Emit(OpCodes.Callvirt, consumeMethod);
            }
            else
            {
                var consumeMethod = GetConsumeMethod(consumeField.FieldType, out bool passByRef);
                if (passByRef)
                {
                    ilBuilder.EmitStloc(resultLocal);
                    ilBuilder.EmitLdloca(resultLocal);
                    ilBuilder.Emit(OpCodes.Ldflda, consumeField);
                }
                else
                {
                    ilBuilder.Emit(OpCodes.Ldfld, consumeField);
                }
                ilBuilder.Emit(OpCodes.Callvirt, consumeMethod);
            }
        }

        protected static MethodInfo GetGenericConsumeMethod(Type consumableType, Func<ParameterInfo, bool> comparator)
        {
            return typeof(Consumer).GetMethods(BindingFlags.Public | BindingFlags.Instance)
                .Single(m => m.Name == nameof(Consumer.Consume) && m.IsGenericMethodDefinition && comparator(m.GetParameters().Single()))
                .MakeGenericMethod(consumableType);
        }

        private static MethodInfo GetConsumeMethod(Type consumableType, out bool passByRef)
        {
            passByRef = false;
            var consumeMethod = typeof(Consumer).GetMethod(nameof(Consumer.Consume), new[] { consumableType });

            if (consumeMethod == null
                // Use generic method for ref types, except base System.Object.
                || (consumeMethod.GetParameterTypes().FirstOrDefault() == typeof(object) && consumableType != typeof(object)))
            {
                // Consume<T>(T* ptrValue)
                if (consumableType.IsPointer)
                {
                    consumeMethod = GetGenericConsumeMethod(consumableType.GetElementType(), param => param.ParameterType.IsPointer);
                }
                // Consume<T>(T value) where T : class
                else if (consumableType.IsClass || consumableType.IsInterface)
                {
                    consumeMethod = GetGenericConsumeMethod(consumableType, param => !param.IsIn && !param.ParameterType.IsPointer);
                }
                // Everything else, covers non-primitve structs, nullable values, and byref returns.
                // Consume<T>(in T value)
                else
                {
                    passByRef = true;
                    consumeMethod = GetGenericConsumeMethod(consumableType, param => param.IsIn);
                }
            }

            if (consumeMethod == null)
            {
                throw new InvalidOperationException($"Cannot consume result of {consumableType}.");
            }

            return consumeMethod;
        }
    }
}