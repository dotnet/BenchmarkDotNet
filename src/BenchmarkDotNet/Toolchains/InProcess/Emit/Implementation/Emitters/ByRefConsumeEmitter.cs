using System;
using System.Reflection;
using System.Reflection.Emit;
using static BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableConstants;

namespace BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation
{
    internal class ByRefConsumeEmitter : ConsumeEmitter
    {
        private FieldBuilder disassemblerDefaultValueHolderField;

        public ByRefConsumeEmitter(ConsumableTypeInfo consumableTypeInfo) : base(consumableTypeInfo) { }

        protected override void OnDefineFieldsOverride(TypeBuilder runnableBuilder)
        {
            var nonRefType = ConsumableInfo.WorkloadMethodReturnType.GetElementType()
                ?? throw new InvalidOperationException($"Bug: type {ConsumableInfo.WorkloadMethodReturnType} is non-ref type.");

            disassemblerDefaultValueHolderField = runnableBuilder.DefineField(
                DisassemblerDefaultValueHolderName,
                nonRefType, FieldAttributes.Private);
        }

        protected override void EmitDisassemblyDiagnoserReturnDefaultOverride(ILGenerator ilBuilder)
        {
            /*
                // return ref __disassemblerDefaultValueHolder
                IL_0031: ldarg.0
                IL_0032: ldflda int32 BenchmarkDotNet.Autogenerated.Runnable_0::workloadDefaultValueHolder
                IL_0037: ret
             */
            ilBuilder.Emit(OpCodes.Ldarg_0);
            ilBuilder.Emit(OpCodes.Ldflda, disassemblerDefaultValueHolderField);
            ilBuilder.Emit(OpCodes.Ret);
        }

        protected override void EmitActionAfterCallOverride(ILGenerator ilBuilder)
        {
            // IL_000a: pop
            ilBuilder.Emit(OpCodes.Pop);
        }
    }
}