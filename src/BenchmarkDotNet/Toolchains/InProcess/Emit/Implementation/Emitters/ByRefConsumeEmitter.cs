using BenchmarkDotNet.Helpers.Reflection.Emit;
using System;
using System.Reflection;
using System.Reflection.Emit;
using static BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableConstants;

namespace BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation
{
    internal class ByRefConsumeEmitter : ConsumableConsumeEmitter
    {
        private FieldBuilder overheadDefaultValueHolderField;

        public ByRefConsumeEmitter(ConsumableTypeInfo consumableTypeInfo) : base(consumableTypeInfo) { }

        protected override void OnDefineFieldsOverride(TypeBuilder runnableBuilder)
        {
            base.OnDefineFieldsOverride(runnableBuilder);

            var nonRefType = ConsumableInfo.WorkloadMethodReturnType.GetElementType();
            if (nonRefType == null)
                throw new InvalidOperationException($"Bug: type {ConsumableInfo.WorkloadMethodReturnType} is non-ref type.");

            overheadDefaultValueHolderField = runnableBuilder.DefineField(
                OverheadDefaultValueHolderFieldName,
                nonRefType, FieldAttributes.Private);
        }

        protected override void EmitDisassemblyDiagnoserReturnDefaultOverride(ILGenerator ilBuilder)
        {
            /*
                // return ref overheadDefaultValueHolder;
                IL_0031: ldarg.0
                IL_0032: ldflda int32 BenchmarkDotNet.Autogenerated.Runnable_0::overheadDefaultValueHolder
                IL_0037: ret
             */
            ilBuilder.Emit(OpCodes.Ldarg_0);
            ilBuilder.Emit(OpCodes.Ldflda, overheadDefaultValueHolderField);
            ilBuilder.Emit(OpCodes.Ret);
        }

        public override void EmitOverheadImplementation(ILGenerator ilBuilder, Type returnType)
        {
            EmitDisassemblyDiagnoserReturnDefaultOverride(ilBuilder);
        }

        protected override void DeclareLoopLocalsOverride(ILGenerator ilBuilder)
        {
            // We don't need a local to pass by reference since it's returned by reference.
        }

        protected override void EmitActionAfterCallOverride(ILGenerator ilBuilder)
        {
            /*
                // ... .Consume( ... )
                IL_003f: callvirt instance void Consumer::Consume<int32>(!!0&)
             */
            var consumeMethod = GetConsumeMethod(ConsumableInfo.WorkloadMethodReturnType);
            ilBuilder.Emit(OpCodes.Callvirt, consumeMethod);
        }

        private static MethodInfo GetConsumeMethod(Type consumableType)
        {
            // Consume<T>(in T value)
            var consumeMethod = GetGenericConsumeMethod(consumableType.GetElementType(), param => param.IsIn);

            if (consumeMethod == null)
            {
                throw new InvalidOperationException($"Cannot consume result of {consumableType}.");
            }

            return consumeMethod;
        }
    }
}