using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Xml;
using BenchmarkDotNet.Characteristics;
using BenchmarkDotNet.Extensions;
using BenchmarkDotNet.Helpers;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Loggers;
using BenchmarkDotNet.Running;
using BenchmarkDotNet.Toolchains.DotNetCli;
using BenchmarkDotNet.Toolchains.Mono;
using BenchmarkDotNet.Toolchains.Results;
using JetBrains.Annotations;

#nullable enable

namespace BenchmarkDotNet.Toolchains.CsProj
{
    [PublicAPI]
    public class CsProjGenerator : DotNetCliGenerator, IEquatable<CsProjGenerator>
    {
        private const string DefaultSdkName = "Microsoft.NET.Sdk";

        private static readonly ImmutableArray<string> SettingsWeWantToCopy = new[]
        {
            "NetCoreAppImplicitPackageVersion",
            "RuntimeFrameworkVersion",
            "PackageTargetFallback",
            "LangVersion",
            "UseWpf",
            "UseWindowsForms",
            "CopyLocalLockFileAssemblies",
            "PreserveCompilationContext",
            "UserSecretsId",
            "EnablePreviewFeatures",
            "RuntimeHostConfigurationOption",
            "WarningsAsErrors",
        }.ToImmutableArray();

        public string RuntimeFrameworkVersion { get; }

        public CsProjGenerator(string targetFrameworkMoniker, string cliPath, string packagesPath, string runtimeFrameworkVersion, bool isNetCore = true)
            : base(targetFrameworkMoniker, cliPath, packagesPath, isNetCore)
        {
            RuntimeFrameworkVersion = runtimeFrameworkVersion;
        }

        protected override string GetBuildArtifactsDirectoryPath(BuildPartition buildPartition, string programName)
        {
            string assemblyLocation = buildPartition.RepresentativeBenchmarkCase.Descriptor.Type.Assembly.Location;

            //Assembles loaded from a stream will have an empty location (https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.location).
            string directoryName = assemblyLocation.IsEmpty() ?
                Path.Combine(Directory.GetCurrentDirectory(), "BenchmarkDotNet.Bin") :
                Path.GetDirectoryName(buildPartition.AssemblyLocation)!;

            return Path.Combine(directoryName, programName);
        }

        protected override string GetProjectFilePath(string buildArtifactsDirectoryPath)
            => Path.Combine(buildArtifactsDirectoryPath, "BenchmarkDotNet.Autogenerated.csproj");

        protected override string GetBinariesDirectoryPath(string buildArtifactsDirectoryPath, string configuration)
            => Path.Combine(buildArtifactsDirectoryPath, "bin", configuration, TargetFrameworkMoniker);

        protected override void GenerateBuildScript(BuildPartition buildPartition, ArtifactsPaths artifactsPaths)
        {
            string projectFilePath = GetProjectFilePath(buildPartition.RepresentativeBenchmarkCase.Descriptor.Type, NullLogger.Instance).FullName;

            var content = new StringBuilder(300)
                .AppendLine($"call {CliPath ?? "dotnet"} {DotNetCliCommand.GetRestoreCommand(artifactsPaths, buildPartition, projectFilePath)}")
                .AppendLine($"call {CliPath ?? "dotnet"} {DotNetCliCommand.GetBuildCommand(artifactsPaths, buildPartition, projectFilePath, TargetFrameworkMoniker)}")
                .AppendLine($"call {CliPath ?? "dotnet"} {DotNetCliCommand.GetRestoreCommand(artifactsPaths, buildPartition, artifactsPaths.ProjectFilePath)}")
                .AppendLine($"call {CliPath ?? "dotnet"} {DotNetCliCommand.GetBuildCommand(artifactsPaths, buildPartition, artifactsPaths.ProjectFilePath, TargetFrameworkMoniker)}")
                .ToString();

            File.WriteAllText(artifactsPaths.BuildScriptFilePath, content);
        }

        [SuppressMessage("ReSharper", "StringLiteralTypo")] // R# complains about $variables$
        protected override void GenerateProject(BuildPartition buildPartition, ArtifactsPaths artifactsPaths, ILogger logger)
        {
            File.WriteAllText(artifactsPaths.ProjectFilePath,
                GenerateBuildProject(buildPartition, artifactsPaths, logger)
            );

            // Integration tests are built without dependencies, so we skip gathering dlls.
            if (!buildPartition.ForcedNoDependenciesForIntegrationTests)
            {
                GatherReferences(buildPartition, artifactsPaths, logger);
            }
        }

        private string GenerateBuildProject(BuildPartition buildPartition, ArtifactsPaths artifactsPaths, ILogger logger)
        {
            var benchmark = buildPartition.RepresentativeBenchmarkCase;
            var projectFile = GetProjectFilePath(benchmark.Descriptor.Type, logger);

            var xmlDoc = new XmlDocument();
            xmlDoc.Load(projectFile.FullName);
            var (customProperties, sdkName) = GetSettingsThatNeedToBeCopied(xmlDoc, projectFile);

            return new StringBuilder(ResourceHelper.LoadTemplate("CsProj.txt"))
                .Replace("$PLATFORM$", buildPartition.Platform.ToConfig())
                .Replace("$CODEFILENAME$", Path.GetFileName(artifactsPaths.ProgramCodePath))
                .Replace("$CSPROJPATH$", projectFile.FullName)
                .Replace("$TFM$", TargetFrameworkMoniker)
                .Replace("$PROGRAMNAME$", artifactsPaths.ProgramName)
                .Replace("$RUNTIMESETTINGS$", GetRuntimeSettings(benchmark.Job.Environment.Gc, buildPartition.Resolver))
                .Replace("$COPIEDSETTINGS$", customProperties)
                .Replace("$SDKNAME$", sdkName)
                .ToString();
        }

        private static string GetDllGathererPath(string filePath)
            => Path.Combine(Path.GetDirectoryName(filePath)!, $"DllGatherer{Path.GetExtension(filePath)}");

        protected void GatherReferences(BuildPartition buildPartition, ArtifactsPaths artifactsPaths, ILogger logger)
        {
            // Create a project using the default template to build the original project for all necessary runtime dlls.
            // We can't just build the original project directly because it could be a library project, so we need an exe project to reference it.
            var xmlDoc = new XmlDocument();
            xmlDoc.LoadXml(GenerateBuildProject(buildPartition, artifactsPaths, logger));
            var projectElement = xmlDoc.DocumentElement!;

            // Replace the default C# file with an empty Main method to satisfy the exe build.
            var compileNode = projectElement.SelectSingleNode("ItemGroup/Compile")!;
            string emptyMainFile = GetDllGathererPath(artifactsPaths.ProgramCodePath);
            compileNode.Attributes!["Include"]!.Value = emptyMainFile;
            string gathererProject = GetDllGathererPath(artifactsPaths.ProjectFilePath);
            xmlDoc.Save(gathererProject);

            File.WriteAllText(emptyMainFile, """
                namespace BenchmarkDotNet.Autogenerated
                {
                    public class UniqueProgramName
                    {
                        public static int Main(string[] args)
                        {
                            return 0;
                        }
                    }
                }
                """);

            // Build the original project then reference all of the built dlls.
            BuildResult buildResult = new DotNetCliCommand(
                CliPath,
                gathererProject,
                TargetFrameworkMoniker,
                null,
                GenerateResult.Success(artifactsPaths, []),
                logger,
                buildPartition,
                [],
                buildPartition.Timeout
            ).RestoreThenBuild();

            if (!buildResult.IsBuildSuccess)
            {
                if (!buildResult.TryToExplainFailureReason(out string? reason))
                {
                    reason = buildResult.ErrorMessage;
                }
                logger.WriteLineWarning($"Failed to gather assembly references, reason:{Environment.NewLine}{reason}");
                return;
            }

            // Delete the dll from the gatherer project to prevent duplicate references.
            File.Delete(Path.Combine(artifactsPaths.BinariesDirectoryPath, $"{artifactsPaths.ProgramName}.dll"));

            xmlDoc = new XmlDocument();
            xmlDoc.Load(artifactsPaths.ProjectFilePath);
            projectElement = xmlDoc.DocumentElement!;
            var itemGroup = xmlDoc.CreateElement("ItemGroup");
            projectElement.AppendChild(itemGroup);
            foreach (var assemblyFile in Directory.GetFiles(artifactsPaths.BinariesDirectoryPath, "*.dll"))
            {
                var referenceElement = xmlDoc.CreateElement("Reference");
                itemGroup.AppendChild(referenceElement);
                referenceElement.SetAttribute("Include", Path.GetFileNameWithoutExtension(assemblyFile));
                var hintPath = xmlDoc.CreateElement("HintPath");
                referenceElement.AppendChild(hintPath);
                var locationNode = xmlDoc.CreateTextNode(assemblyFile);
                hintPath.AppendChild(locationNode);
                // TODO: Add Aliases here for extern alias #2289
            }

            xmlDoc.Save(artifactsPaths.ProjectFilePath);
        }

        /// <summary>
        /// returns an MSBuild string that defines Runtime settings
        /// </summary>
        [PublicAPI]
        protected virtual string GetRuntimeSettings(GcMode gcMode, IResolver resolver)
        {
            var builder = new StringBuilder(80)
                .AppendLine($"<PropertyGroup>")
                .AppendLine($"    <ServerGarbageCollection>{gcMode.ResolveValue(GcMode.ServerCharacteristic, resolver).ToLowerCase()}</ServerGarbageCollection>")
                .AppendLine($"    <ConcurrentGarbageCollection>{gcMode.ResolveValue(GcMode.ConcurrentCharacteristic, resolver).ToLowerCase()}</ConcurrentGarbageCollection>");

            if (gcMode.HasValue(GcMode.RetainVmCharacteristic))
                builder.AppendLine($"    <RetainVMGarbageCollection>{gcMode.ResolveValue(GcMode.RetainVmCharacteristic, resolver).ToLowerCase()}</RetainVMGarbageCollection>");

            return builder.AppendLine("  </PropertyGroup>").ToString();
        }

        // the host project or one of the .props file that it imports might contain some custom settings that needs to be copied, sth like
        // <NetCoreAppImplicitPackageVersion>2.0.0-beta-001607-00</NetCoreAppImplicitPackageVersion>
        // <RuntimeFrameworkVersion>2.0.0-beta-001607-00</RuntimeFrameworkVersion>
        internal (string customProperties, string sdkName) GetSettingsThatNeedToBeCopied(XmlDocument xmlDoc, FileInfo projectFile)
        {
            if (RuntimeFrameworkVersion.IsNotBlank()) // some power users knows what to configure, just do it and copy nothing more
            {
                return (@$"<PropertyGroup>
    <RuntimeFrameworkVersion>{RuntimeFrameworkVersion}</RuntimeFrameworkVersion>
  </PropertyGroup>", DefaultSdkName);
            }

            XmlElement projectElement = xmlDoc.DocumentElement!;
            // custom SDKs are not added for non-netcoreapp apps (like net471), so when the TFM != netcoreapp we dont parse "<Import Sdk="
            // we don't allow for that mostly to prevent from edge cases like the following
            // <Import Sdk="Microsoft.NET.Sdk.WindowsDesktop" Project="Sdk.props" Condition="'$(TargetFramework)'=='netcoreapp3.0'"/>
            string? sdkName = null;
            if (TargetFrameworkMoniker.StartsWith("netcoreapp", StringComparison.InvariantCultureIgnoreCase))
            {
                foreach (XmlElement importElement in projectElement.GetElementsByTagName("Import"))
                {
                    sdkName = importElement.GetAttribute("Sdk");
                    if (sdkName.IsNotBlank())
                    {
                        break;
                    }
                }
            }
            if (sdkName.IsBlank())
            {
                sdkName = projectElement.GetAttribute("Sdk");
            }
            // If Sdk isn't an attribute on the Project element, it could be a child element.
            if (sdkName.IsBlank())
            {
                foreach (XmlElement sdkElement in projectElement.GetElementsByTagName("Sdk"))
                {
                    sdkName = sdkElement.GetAttribute("Name");
                    if (sdkName.IsBlank())
                    {
                        continue;
                    }
                    string version = sdkElement.GetAttribute("Version");
                    // Version is optional
                    if (version.IsNotBlank())
                    {
                        sdkName += $"/{version}";
                    }
                    break;
                }
            }
            if (sdkName.IsBlank())
            {
                sdkName = DefaultSdkName;
            }

            XmlDocument? itemGroupsettings = null;
            XmlDocument? propertyGroupSettings = null;

            GetSettingsThatNeedToBeCopied(projectElement, ref itemGroupsettings, ref propertyGroupSettings, projectFile);

            List<string> customSettings = new List<string>(2);
            if (itemGroupsettings != null)
            {
                customSettings.Add(GetIndentedXmlString(itemGroupsettings));
            }
            if (propertyGroupSettings != null)
            {
                customSettings.Add(GetIndentedXmlString(propertyGroupSettings));
            }

            return (string.Join(Environment.NewLine + Environment.NewLine, customSettings), sdkName);
        }

        private static void GetSettingsThatNeedToBeCopied(XmlElement projectElement, ref XmlDocument? itemGroupsettings, ref XmlDocument? propertyGroupSettings, FileInfo projectFile)
        {
            CopyProperties(projectElement, ref itemGroupsettings, "ItemGroup");
            CopyProperties(projectElement, ref propertyGroupSettings, "PropertyGroup");

            foreach (XmlElement importElement in projectElement.GetElementsByTagName("Import"))
            {
                string propsFilePath = importElement.GetAttribute("Project");
                var directoryName = projectFile.DirectoryName ?? throw new DirectoryNotFoundException(projectFile.DirectoryName);
                string absolutePath = File.Exists(propsFilePath)
                    ? propsFilePath // absolute path or relative to current dir
                    : Path.Combine(directoryName, propsFilePath); // relative to csproj
                if (File.Exists(absolutePath))
                {
                    var importXmlDoc = new XmlDocument();
                    importXmlDoc.Load(absolutePath);
                    GetSettingsThatNeedToBeCopied(importXmlDoc.DocumentElement!, ref itemGroupsettings, ref propertyGroupSettings, projectFile);
                }
            }
        }

        private static void CopyProperties(XmlElement projectElement, ref XmlDocument? copyToDocument, string groupName)
        {
            XmlElement? itemGroupElement = copyToDocument?.DocumentElement;
            foreach (XmlElement groupElement in projectElement.GetElementsByTagName(groupName))
            {
                foreach (var node in groupElement.ChildNodes)
                {
                    if (node is XmlElement setting && SettingsWeWantToCopy.Contains(setting.Name))
                    {
                        if (copyToDocument is null)
                        {
                            copyToDocument = new XmlDocument();
                            itemGroupElement = copyToDocument.CreateElement(groupName);
                            copyToDocument.AppendChild(itemGroupElement);
                        }
                        XmlNode copiedNode = copyToDocument.ImportNode(setting, true);
                        itemGroupElement!.AppendChild(copiedNode);
                    }
                }
            }
        }

        private static string GetIndentedXmlString(XmlDocument doc)
        {
            StringBuilder sb = new StringBuilder();
            XmlWriterSettings settings = new XmlWriterSettings
            {
                OmitXmlDeclaration = true,
                Indent = true,
                IndentChars = "  "
            };
            using (XmlWriter writer = XmlWriter.Create(sb, settings))
            {
                doc.Save(writer);
            }
            return sb.ToString();
        }

        /// <summary>
        /// returns a path to the project file which defines the benchmarks
        /// </summary>
        [PublicAPI]
        protected virtual FileInfo GetProjectFilePath(Type benchmarkTarget, ILogger logger)
        {
            if (!GetSolutionRootDirectory(out var rootDirectory) && !GetProjectRootDirectory(out rootDirectory))
            {
                logger.WriteLineError(
                    $"Unable to find .sln .slnx or .csproj file. Will use current directory {Directory.GetCurrentDirectory()} to search for project file. If you don't use .sln file on purpose it should not be a problem.");
                rootDirectory = new DirectoryInfo(Directory.GetCurrentDirectory());
            }

            // important assumption! project's file name === output dll name
            string projectName = benchmarkTarget.GetTypeInfo().Assembly.GetName().Name!;

            var projectFile = Helpers.FindProjectFile(rootDirectory, projectName);
            return projectFile;
        }

        public override bool Equals(object? obj) => obj is CsProjGenerator other && Equals(other);

        public bool Equals(CsProjGenerator? other)
        {
            if (ReferenceEquals(this, other))
                return true;

            if (other is null)
                return false;

            return TargetFrameworkMoniker == other.TargetFrameworkMoniker
                && RuntimeFrameworkVersion == other.RuntimeFrameworkVersion
                && CliPath == other.CliPath
                && PackagesPath == other.PackagesPath;
        }

        public override int GetHashCode()
            => HashCode.Combine(TargetFrameworkMoniker, RuntimeFrameworkVersion, CliPath, PackagesPath);
    }

    file static class Helpers
    {
        private static readonly HashSet<string> IgnoredDirectoryNames = new(StringComparer.Ordinal)
        {
            ".git",
            ".vs",
            "bin",
            "obj",
        };

        private static readonly HashSet<string> ProjectExtensions = new(StringComparer.Ordinal)
        {
            ".csproj",
            ".fsproj",
            ".vbproj"
        };

        public static FileInfo FindProjectFile(DirectoryInfo rootDirectory, string projectName)
        {
            var projectFiles = EnumerateProjectFiles(rootDirectory, projectName);

            // Take first 2 items for performance reasons
            var files = projectFiles.Take(2).ToArray();
            return files.Length switch
            {
                1 => files[0],
                0 => throw new NotSupportedException(
                    $"Unable to find {projectName} in {rootDirectory.FullName} and its subfolders. Most probably the name of output exe is different than the name of the .(c/f)sproj"),
                _ => throw new NotSupportedException(
                    $"Found more than one matching project file for {projectName} in {rootDirectory.FullName} and its subfolders: '{files[0].FullName}','{files[1].FullName}'. Benchmark project names needs to be unique."),
            };
        }

        private static IEnumerable<FileInfo> EnumerateProjectFiles(DirectoryInfo rootDirectory, string projectName)
        {
            var stack = new Stack<DirectoryInfo>();
            stack.Push(rootDirectory);

            while (stack.Count > 0)
            {
                var currentDir = stack.Pop();

                // 1. Search '*.proj' files in the current directory
                IEnumerable<FileInfo> files = EnumerateProjectFiles(currentDir);

                foreach (var file in files)
                {
                    if (!ProjectExtensions.Contains(file.Extension))
                        continue;

                    if (Path.GetFileNameWithoutExtension(file.Name) == projectName)
                        yield return file;
                }

                var subDirectories = GetSubDirectories(currentDir);

                // 2. Handle sub directories.
                foreach (var dir in subDirectories)
                {
                    if (IgnoredDirectoryNames.Contains(dir.Name))
                        continue;
#if NETSTANDARD2_0
                    // Ignore reparse point / symlink to avoid infinite loops
                    if (dir.Attributes.HasFlag(FileAttributes.ReparsePoint))
                        continue;
#endif
                    stack.Push(dir);
                }
            }
        }

#if NETSTANDARD2_0
        private static IEnumerable<FileInfo> EnumerateProjectFiles(DirectoryInfo directory)
        {
            IEnumerable<FileInfo> projectFiles;
            try
            {
                projectFiles = directory.EnumerateFiles("*proj", SearchOption.TopDirectoryOnly);
            }
            catch
            {
                yield break;
            }

            foreach (var file in projectFiles)
                yield return file;
        }

        private static IEnumerable<DirectoryInfo> GetSubDirectories(DirectoryInfo currentDir)
        {
            try
            {
                return currentDir.EnumerateDirectories();
            }
            catch
            {
                return [];
            }
        }
#else
        private static readonly EnumerationOptions DirectoryEnumerationOptions = new()
        {
            RecurseSubdirectories = false,
            IgnoreInaccessible = true,
            AttributesToSkip = FileAttributes.ReparsePoint
        };

        private static IEnumerable<FileInfo> EnumerateProjectFiles(DirectoryInfo directory)
            => directory.EnumerateFiles("*proj", DirectoryEnumerationOptions);

        private static IEnumerable<DirectoryInfo> GetSubDirectories(DirectoryInfo currentDir)
            => currentDir.EnumerateDirectories("*", DirectoryEnumerationOptions);
#endif
    }
}