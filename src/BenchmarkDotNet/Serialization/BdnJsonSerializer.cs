using System.Text.Encodings.Web;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace BenchmarkDotNet.Serialization;

internal static class BdnJsonSerializer
{
    private static readonly JsonSerializerOptions DefaultOptions = new()
    {
        Converters =
        {
            new JsonStringEnumConverter(),
        },
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
        DictionaryKeyPolicy = JsonNamingPolicy.CamelCase,
        // Disable escaping non ASCII chars. https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/character-encoding#serialize-all-characters
        Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping, // TODO: Replace to custom encoder that escape minimal chars. (https://github.com/dotnet/runtime/issues/87153)
        NumberHandling = JsonNumberHandling.AllowNamedFloatingPointLiterals, // Required to support NaN
        PropertyNameCaseInsensitive = true, // Accept PascalNaming that generated by JsonExporter.
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        RespectNullableAnnotations = true,
        TypeInfoResolverChain =
        {
            BdnJsonSerializerContext.Default,
        },
        UnmappedMemberHandling = JsonUnmappedMemberHandling.Disallow, // Throw error if unknown entry exists.
    };

    private static readonly JsonSerializerOptions IndentedOptions = new(DefaultOptions)
    {
        WriteIndented = true,
    };

    public static string Serialize<T>(T item, bool indentJson = false)
    {
        if (indentJson)
            return JsonSerializer.Serialize(item, IndentedOptions);
        else
            return JsonSerializer.Serialize(item, DefaultOptions);
    }

    public static T Deserialize<T>(string json)
    {
        return JsonSerializer.Deserialize<T>(json, DefaultOptions);
    }
}
