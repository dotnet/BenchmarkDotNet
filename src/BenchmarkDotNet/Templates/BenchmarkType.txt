    // Type name must be in sync with DisassemblyDiagnoser.BuildClrMdArgs.
    public unsafe sealed class Runnable_$ID$ : $WorkloadTypeName$
    {
        public static void Run(global::BenchmarkDotNet.Engines.IHost host, global::System.String benchmarkName, global::BenchmarkDotNet.Diagnosers.RunMode diagnoserRunMode)
        {
            global::BenchmarkDotNet.Autogenerated.Runnable_$ID$ instance = new global::BenchmarkDotNet.Autogenerated.Runnable_$ID$();

            host.WriteLine();
            foreach (global::System.String infoLine in global::BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            global::BenchmarkDotNet.Jobs.Job job = new global::BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            $JobSetDefinition$;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            global::System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = global::BenchmarkDotNet.Validators.BenchmarkProcessValidator.Validate(job, instance);
            if (global::BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            global::BenchmarkDotNet.Diagnosers.CompositeInProcessDiagnoserHandler compositeInProcessDiagnoserHandler = new global::BenchmarkDotNet.Diagnosers.CompositeInProcessDiagnoserHandler(
                new global::BenchmarkDotNet.Diagnosers.InProcessDiagnoserRouter[] {
                    $InProcessDiagnoserRouters$
                },
                host,
                diagnoserRunMode,
                new global::BenchmarkDotNet.Diagnosers.InProcessDiagnoserActionArgs(instance)
            );
            if (diagnoserRunMode == global::BenchmarkDotNet.Diagnosers.RunMode.SeparateLogic)
            {
                compositeInProcessDiagnoserHandler.Handle(global::BenchmarkDotNet.Engines.BenchmarkSignal.SeparateLogic);
                return;
            }
            compositeInProcessDiagnoserHandler.Handle(global::BenchmarkDotNet.Engines.BenchmarkSignal.BeforeEngine);

            global::BenchmarkDotNet.Engines.EngineParameters engineParameters = new global::BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = $OperationsPerInvoke$,
                RunExtraIteration = $RunExtraIteration$,
                BenchmarkName = benchmarkName,
                InProcessDiagnoserHandler = compositeInProcessDiagnoserHandler
            };

            using (global::BenchmarkDotNet.Engines.IEngine engine = new $EngineFactoryType$().CreateReadyToRun(engineParameters))
            {
                global::BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
            compositeInProcessDiagnoserHandler.Handle(global::BenchmarkDotNet.Engines.BenchmarkSignal.AfterEngine);
        }

        [global::System.Diagnostics.CodeAnalysis.SetsRequiredMembers]
        public Runnable_$ID$()
        {
            this.globalSetupAction = $GlobalSetupMethodName$;
            this.globalCleanupAction = $GlobalCleanupMethodName$;
            this.iterationSetupAction = $IterationSetupMethodName$;
            this.iterationCleanupAction = $IterationCleanupMethodName$;
            $InitializeArgumentFields$
            $ParamsContent$
        }

        private global::System.Action globalSetupAction;
        private global::System.Action globalCleanupAction;
        private global::System.Action iterationSetupAction;
        private global::System.Action iterationCleanupAction;
        $DeclareArgumentFields$

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public global::System.Int32 NotEleven;
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            this.NotEleven = new global::System.Random(123).Next(0, 10);
            $DisassemblerEntryMethodName$();
        }

        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void $DisassemblerEntryMethodName$()
        {
            if (this.NotEleven == 11)
            {
                $LoadArguments$
                $WorkloadMethodCall$;
            }
        }

        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void __Overhead($ArgumentsDefinition$)
        {
        }

        [global::System.Runtime.CompilerServices.MethodImpl(global::BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionUnroll(global::System.Int64 invokeCount)
        {
            $LoadArguments$
            while (--invokeCount >= 0)
            {
                this.__Overhead($PassArguments$);@Unroll@
            }
        }

        [global::System.Runtime.CompilerServices.MethodImpl(global::BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void OverheadActionNoUnroll(global::System.Int64 invokeCount)
        {
            $LoadArguments$
            while (--invokeCount >= 0)
            {
                this.__Overhead($PassArguments$);
            }
        }

        [global::System.Runtime.CompilerServices.MethodImpl(global::BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionUnroll(global::System.Int64 invokeCount)
        {
            $LoadArguments$
            while (--invokeCount >= 0)
            {
                $WorkloadMethodCall$;@Unroll@
            }
        }

        [global::System.Runtime.CompilerServices.MethodImpl(global::BenchmarkDotNet.Portability.CodeGenHelper.AggressiveOptimizationOption)]
        private void WorkloadActionNoUnroll(global::System.Int64 invokeCount)
        {
            $LoadArguments$
            while (--invokeCount >= 0)
            {
                $WorkloadMethodCall$;
            }
        }
    }