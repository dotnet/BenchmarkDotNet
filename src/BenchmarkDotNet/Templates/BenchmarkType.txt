    // the type name must be in sync with WindowsDisassembler.BuildArguments
    public unsafe partial class Runnable_$ID$ : global::$WorkloadTypeName$
    {
        public static void Run(BenchmarkDotNet.Engines.IHost host, System.String benchmarkName)
        {
            BenchmarkDotNet.Autogenerated.Runnable_$ID$ instance = new BenchmarkDotNet.Autogenerated.Runnable_$ID$(); // do NOT change name "instance" (used in SmartParamameter)
            $ParamsContent$

            host.WriteLine();
            foreach (System.String infoLine in BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                host.WriteLine($"// {infoLine}");
            }
            BenchmarkDotNet.Jobs.Job job = new BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            $JobSetDefinition$;
            job.Freeze();
            host.WriteLine($"// Job: {job.DisplayInfo}");
            host.WriteLine();

            System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.Validate(job);
            if (BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAny(errors, host))
                return;

            BenchmarkDotNet.Engines.EngineParameters engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                Dummy1Action = instance.Dummy1,
                Dummy2Action = instance.Dummy2,
                Dummy3Action = instance.Dummy3,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.globalSetupAction,
                GlobalCleanupAction = instance.globalCleanupAction,
                IterationSetupAction = instance.iterationSetupAction,
                IterationCleanupAction = instance.iterationCleanupAction,
                TargetJob = job,
                OperationsPerInvoke = $OperationsPerInvoke$,
                MeasureExtraStats = $MeasureExtraStats$,
                BenchmarkName = benchmarkName
            };

            using (BenchmarkDotNet.Engines.IEngine engine = new $EngineFactoryType$().CreateReadyToRun(engineParameters))
            {
                BenchmarkDotNet.Engines.RunResults results = engine.Run();

                host.ReportResults(results); // printing costs memory, do this after runs

                instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            }
        }

        public delegate $OverheadMethodReturnTypeName$ OverheadDelegate($ArgumentsDefinition$);

        public delegate $WorkloadMethodReturnTypeModifiers$ $WorkloadMethodReturnType$ WorkloadDelegate($ArgumentsDefinition$);

        public Runnable_$ID$()
        {
            globalSetupAction = $GlobalSetupMethodName$;
            globalCleanupAction = $GlobalCleanupMethodName$;
            iterationSetupAction = $IterationSetupMethodName$;
            iterationCleanupAction = $IterationCleanupMethodName$;
            overheadDelegate = __Overhead;
            workloadDelegate = $WorkloadMethodDelegate$;
            $InitializeArgumentFields$
            __SetContinuation();
        }

        private System.Func<System.Threading.Tasks.ValueTask> globalSetupAction;
        private System.Func<System.Threading.Tasks.ValueTask> globalCleanupAction;
        private System.Func<System.Threading.Tasks.ValueTask> iterationSetupAction;
        private System.Func<System.Threading.Tasks.ValueTask> iterationCleanupAction;
        private BenchmarkDotNet.Autogenerated.Runnable_$ID$.OverheadDelegate overheadDelegate;
        private BenchmarkDotNet.Autogenerated.Runnable_$ID$.WorkloadDelegate workloadDelegate;
        $DeclareArgumentFields$

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public System.Int32 NotEleven;
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            NotEleven = new System.Random(123).Next(0, 10);
            $DisassemblerEntryMethodName$();
        }

        private System.Int32 dummyVar;

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            @DummyUnroll@
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            @DummyUnroll@
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            @DummyUnroll@
        }

        private $OverheadMethodReturnTypeName$ __Overhead($ArgumentsDefinition$) // __ is to avoid possible name conflict
        {
            $OverheadImplementation$
        }

        partial void __SetContinuation();

#if RETURNS_AWAITABLE_$ID$

        private readonly BenchmarkDotNet.Helpers.AutoResetValueTaskSource<Perfolizer.Horology.ClockSpan> valueTaskSource = new BenchmarkDotNet.Helpers.AutoResetValueTaskSource<Perfolizer.Horology.ClockSpan>();
        private System.Int64 repeatsRemaining;
        private System.Action continuation;
        private Perfolizer.Horology.StartedClock startedClock;
        private $AwaiterTypeName$ currentAwaiter;

        partial void __SetContinuation() => continuation = __Continuation;

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        // Awaits are not unrolled.
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> OverheadActionUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            return OverheadActionImpl(invokeCount, clock);
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> OverheadActionNoUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            return OverheadActionImpl(invokeCount, clock);
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> OverheadActionImpl(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            repeatsRemaining = invokeCount;
            $OverheadMethodReturnTypeName$ value = default($OverheadMethodReturnTypeName$);
            startedClock = Perfolizer.Horology.ClockExtensions.Start(clock);
            try
            {
                $LoadArguments$
                while (--repeatsRemaining >= 0)
                {
                    value = overheadDelegate($PassArguments$);
                }
            }
            catch (System.Exception)
            {
                BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
                throw;
            }
            return new System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan>(startedClock.GetElapsed());
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> WorkloadActionUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            return WorkloadActionImpl(invokeCount, clock);
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> WorkloadActionNoUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            return WorkloadActionImpl(invokeCount, clock);
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> WorkloadActionImpl(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            repeatsRemaining = invokeCount;
            startedClock = Perfolizer.Horology.ClockExtensions.Start(clock);
            __RunTask();
            return new System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan>(valueTaskSource, valueTaskSource.Version);
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void __RunTask()
        {
            try
            {
                $LoadArguments$
                while (--repeatsRemaining >= 0)
                {
                    currentAwaiter = workloadDelegate($PassArguments$).GetAwaiter();
                    if (!currentAwaiter.IsCompleted)
                    {
                        currentAwaiter.UnsafeOnCompleted(continuation);
                        return;
                    }
                    currentAwaiter.GetResult();
                }
            }
            catch (System.Exception e)
            {
                __SetException(e);
                return;
            }
            var clockspan = startedClock.GetElapsed();
            currentAwaiter = default($AwaiterTypeName$);
            startedClock = default(Perfolizer.Horology.StartedClock);
            valueTaskSource.SetResult(clockspan);
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private void __Continuation()
        {
            try
            {
                currentAwaiter.GetResult();
            }
            catch (System.Exception e)
            {
                __SetException(e);
                return;
            }
            __RunTask();
        }

        private void __SetException(System.Exception e)
        {
            currentAwaiter = default($AwaiterTypeName$);
            startedClock = default(Perfolizer.Horology.StartedClock);
            valueTaskSource.SetException(e);
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public $WorkloadMethodReturnType$ $DisassemblerEntryMethodName$()
        {
            if (NotEleven == 11)
            {
                $LoadArguments$
                return $WorkloadMethodCall$;
            }
            
            return default($WorkloadMethodReturnType$);
        }

#elif RETURNS_CONSUMABLE_$ID$

        private BenchmarkDotNet.Engines.Consumer consumer = new BenchmarkDotNet.Engines.Consumer();

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> OverheadActionUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            $LoadArguments$
            var startedClock = Perfolizer.Horology.ClockExtensions.Start(clock);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate($PassArguments$));@Unroll@
            }
            return new System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan>(startedClock.GetElapsed());
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> OverheadActionNoUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            $LoadArguments$
            var startedClock = Perfolizer.Horology.ClockExtensions.Start(clock);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(overheadDelegate($PassArguments$));
            }
            return new System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan>(startedClock.GetElapsed());
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> WorkloadActionUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            $LoadArguments$
            var startedClock = Perfolizer.Horology.ClockExtensions.Start(clock);
            for (System.Int64  i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate($PassArguments$)$ConsumeField$);@Unroll@
            }
            return new System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan>(startedClock.GetElapsed());
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> WorkloadActionNoUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            $LoadArguments$
            var startedClock = Perfolizer.Horology.ClockExtensions.Start(clock);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                consumer.Consume(workloadDelegate($PassArguments$)$ConsumeField$);
            }
            return new System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan>(startedClock.GetElapsed());
        }
        
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public $WorkloadMethodReturnType$ $DisassemblerEntryMethodName$()
        {
            if (NotEleven == 11)
            {
                $LoadArguments$
                return $WorkloadMethodCall$;
            }
            
            return default($WorkloadMethodReturnType$);
        }

#elif RETURNS_NON_CONSUMABLE_STRUCT_$ID$

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> OverheadActionUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            $LoadArguments$
            $OverheadMethodReturnTypeName$ result = default($OverheadMethodReturnTypeName$);
            var startedClock = Perfolizer.Horology.ClockExtensions.Start(clock);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate($PassArguments$);@Unroll@
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
            return new System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan>(startedClock.GetElapsed());
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> OverheadActionNoUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            $LoadArguments$
            $OverheadMethodReturnTypeName$ result = default($OverheadMethodReturnTypeName$);
            var startedClock = Perfolizer.Horology.ClockExtensions.Start(clock);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = overheadDelegate($PassArguments$);
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(result);
            return new System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan>(startedClock.GetElapsed());
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> WorkloadActionUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            $LoadArguments$
            $WorkloadMethodReturnType$ result = default($WorkloadMethodReturnType$);
            var startedClock = Perfolizer.Horology.ClockExtensions.Start(clock);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate($PassArguments$);@Unroll@
            }
            NonGenericKeepAliveWithoutBoxing(result);
            return new System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan>(startedClock.GetElapsed());
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> WorkloadActionNoUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            $LoadArguments$
            $WorkloadMethodReturnType$ result = default($WorkloadMethodReturnType$);
            var startedClock = Perfolizer.Horology.ClockExtensions.Start(clock);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                result = workloadDelegate($PassArguments$);
            }
            NonGenericKeepAliveWithoutBoxing(result);
            return new System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan>(startedClock.GetElapsed());
        }

        // we must not simply use DeadCodeEliminationHelper.KeepAliveWithoutBoxing<T> because it's generic method
        // and stack-only types like Span<T> can not be generic type arguments http://adamsitnik.com/Span/#span-must-not-be-a-generic-type-argument
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private void NonGenericKeepAliveWithoutBoxing($WorkloadMethodReturnType$ _) { }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public $WorkloadMethodReturnType$ $DisassemblerEntryMethodName$()
        {
            if (NotEleven == 11)
            {
                $LoadArguments$
                return $WorkloadMethodCall$;
            }
            
            return default($WorkloadMethodReturnType$);
        }

#elif RETURNS_BYREF_$ID$

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> OverheadActionUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            $LoadArguments$
            $OverheadMethodReturnTypeName$ value = default($OverheadMethodReturnTypeName$);
            var startedClock = Perfolizer.Horology.ClockExtensions.Start(clock);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate($PassArguments$);@Unroll@
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
            return new System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan>(startedClock.GetElapsed());
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> OverheadActionNoUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            $LoadArguments$
            $OverheadMethodReturnTypeName$ value = default($OverheadMethodReturnTypeName$);
            var startedClock = Perfolizer.Horology.ClockExtensions.Start(clock);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate($PassArguments$);
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
            return new System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan>(startedClock.GetElapsed());
        }

        private $WorkloadMethodReturnType$ workloadDefaultValueHolder = default($WorkloadMethodReturnType$);

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> WorkloadActionUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            $LoadArguments$
            ref $WorkloadMethodReturnType$ alias = ref workloadDefaultValueHolder;
            var startedClock = Perfolizer.Horology.ClockExtensions.Start(clock);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate($PassArguments$);@Unroll@
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
            return new System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan>(startedClock.GetElapsed());
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> WorkloadActionNoUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            $LoadArguments$
            ref $WorkloadMethodReturnType$ alias = ref workloadDefaultValueHolder;
            var startedClock = Perfolizer.Horology.ClockExtensions.Start(clock);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate($PassArguments$);
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(ref alias);
            return new System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan>(startedClock.GetElapsed());
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref $WorkloadMethodReturnType$ $DisassemblerEntryMethodName$()
        {
            if (NotEleven == 11)
            {
                $LoadArguments$
                return ref $WorkloadMethodCall$;
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_BYREF_READONLY_$ID$

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> OverheadActionUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            $LoadArguments$
            $OverheadMethodReturnTypeName$ value = default($OverheadMethodReturnTypeName$);
            var startedClock = Perfolizer.Horology.ClockExtensions.Start(clock);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate($PassArguments$);@Unroll@
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
            return new System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan>(startedClock.GetElapsed());
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> OverheadActionNoUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            $LoadArguments$
            $OverheadMethodReturnTypeName$ value = default($OverheadMethodReturnTypeName$);
            var startedClock = Perfolizer.Horology.ClockExtensions.Start(clock);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                value = overheadDelegate($PassArguments$);
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxing(value);
            return new System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan>(startedClock.GetElapsed());
        }

        private $WorkloadMethodReturnType$ workloadDefaultValueHolder = default($WorkloadMethodReturnType$);

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> WorkloadActionUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            $LoadArguments$
            ref $WorkloadMethodReturnType$ alias = ref workloadDefaultValueHolder;
            var startedClock = Perfolizer.Horology.ClockExtensions.Start(clock);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate($PassArguments$);@Unroll@
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
            return new System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan>(startedClock.GetElapsed());
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> WorkloadActionNoUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            $LoadArguments$
            ref $WorkloadMethodReturnType$ alias = ref workloadDefaultValueHolder;
            var startedClock = Perfolizer.Horology.ClockExtensions.Start(clock);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                alias = workloadDelegate($PassArguments$);
            }
            BenchmarkDotNet.Engines.DeadCodeEliminationHelper.KeepAliveWithoutBoxingReadonly(alias);
            return new System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan>(startedClock.GetElapsed());
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public ref readonly $WorkloadMethodReturnType$ $DisassemblerEntryMethodName$()
        {
            if (NotEleven == 11)
            {
                $LoadArguments$
                return ref $WorkloadMethodCall$;
            }
            
            return ref workloadDefaultValueHolder;
        }
#elif RETURNS_VOID_$ID$

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> OverheadActionUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            $LoadArguments$
            var startedClock = Perfolizer.Horology.ClockExtensions.Start(clock);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate($PassArguments$);@Unroll@
            }
            return new System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan>(startedClock.GetElapsed());
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> OverheadActionNoUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            $LoadArguments$
            var startedClock = Perfolizer.Horology.ClockExtensions.Start(clock);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                overheadDelegate($PassArguments$);
            }
            return new System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan>(startedClock.GetElapsed());
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> WorkloadActionUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            $LoadArguments$
            var startedClock = Perfolizer.Horology.ClockExtensions.Start(clock);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate($PassArguments$);@Unroll@
            }
            return new System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan>(startedClock.GetElapsed());
        }

#if NETCOREAPP3_0_OR_GREATER
        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization)]
#endif
        private System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan> WorkloadActionNoUnroll(System.Int64 invokeCount, Perfolizer.Horology.IClock clock)
        {
            $LoadArguments$
            var startedClock = Perfolizer.Horology.ClockExtensions.Start(clock);
            for (System.Int64 i = 0; i < invokeCount; i++)
            {
                workloadDelegate($PassArguments$);
            }
            return new System.Threading.Tasks.ValueTask<Perfolizer.Horology.ClockSpan>(startedClock.GetElapsed());
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void $DisassemblerEntryMethodName$()
        {
            if (NotEleven == 11)
            {
                $LoadArguments$
                $WorkloadMethodCall$;
            }
        }
#endif // RETURNS
    }