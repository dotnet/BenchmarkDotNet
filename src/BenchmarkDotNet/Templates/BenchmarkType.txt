    // Type name must be in sync with DisassemblyDiagnoser.BuildClrMdArgs.
    [global::BenchmarkDotNet.Attributes.CompilerServices.AggressivelyOptimizeMethods]
    public sealed partial class Runnable_$ID$ : $WorkloadTypeName$
    {
        public static async global::System.Threading.Tasks.ValueTask Run(global::BenchmarkDotNet.Engines.IHost host, global::System.String benchmarkName, global::BenchmarkDotNet.Diagnosers.RunMode diagnoserRunMode)
        {
            global::BenchmarkDotNet.Autogenerated.Runnable_$ID$ instance = new global::BenchmarkDotNet.Autogenerated.Runnable_$ID$();

            await host.WriteLineAsync();
            foreach (global::System.String infoLine in global::BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                await host.WriteLineAsync($"// {infoLine}");
            }
            global::BenchmarkDotNet.Jobs.Job job = new global::BenchmarkDotNet.Jobs.Job(); // use full name to avoid naming conflicts, #778
            $JobSetDefinition$;
            job.Freeze();
            await host.WriteLineAsync($"// Job: {job.DisplayInfo}");
            await host.WriteLineAsync();

            global::System.Collections.Generic.IEnumerable<BenchmarkDotNet.Validators.ValidationError> errors = global::BenchmarkDotNet.Validators.BenchmarkProcessValidator.Validate(job, instance);
            if (await global::BenchmarkDotNet.Validators.ValidationErrorReporter.ReportIfAnyAsync(errors, host))
                return;

            global::BenchmarkDotNet.Diagnosers.CompositeInProcessDiagnoserHandler compositeInProcessDiagnoserHandler = new global::BenchmarkDotNet.Diagnosers.CompositeInProcessDiagnoserHandler(
                new global::BenchmarkDotNet.Diagnosers.InProcessDiagnoserRouter[] {
                    $InProcessDiagnoserRouters$
                },
                host,
                diagnoserRunMode,
                new global::BenchmarkDotNet.Diagnosers.InProcessDiagnoserActionArgs(instance)
            );
            if (diagnoserRunMode == global::BenchmarkDotNet.Diagnosers.RunMode.SeparateLogic)
            {
                await compositeInProcessDiagnoserHandler.HandleAsync(global::BenchmarkDotNet.Engines.BenchmarkSignal.SeparateLogic);
                return;
            }
            await compositeInProcessDiagnoserHandler.HandleAsync(global::BenchmarkDotNet.Engines.BenchmarkSignal.BeforeEngine);

            global::BenchmarkDotNet.Engines.EngineParameters engineParameters = new global::BenchmarkDotNet.Engines.EngineParameters()
            {
                Host = host,
                WorkloadActionUnroll = instance.WorkloadActionUnroll,
                WorkloadActionNoUnroll = instance.WorkloadActionNoUnroll,
                OverheadActionNoUnroll = instance.OverheadActionNoUnroll,
                OverheadActionUnroll = instance.OverheadActionUnroll,
                GlobalSetupAction = instance.__GlobalSetup,
                GlobalCleanupAction = instance.__GlobalCleanup,
                IterationSetupAction = instance.__IterationSetup,
                IterationCleanupAction = instance.__IterationCleanup,
                TargetJob = job,
                OperationsPerInvoke = $OperationsPerInvoke$,
                RunExtraIteration = $RunExtraIteration$,
                BenchmarkName = benchmarkName,
                InProcessDiagnoserHandler = compositeInProcessDiagnoserHandler
            };

            global::BenchmarkDotNet.Engines.RunResults results = await new $EngineFactoryType$().Create(engineParameters).RunAsync();
            await host.ReportResultsAsync(results); // printing costs memory, do this after runs

            instance.__TrickTheJIT__(); // compile the method for disassembler, but without actual run of the benchmark ;)
            await compositeInProcessDiagnoserHandler.HandleAsync(global::BenchmarkDotNet.Engines.BenchmarkSignal.AfterEngine);
        }

        [global::System.Diagnostics.CodeAnalysis.SetsRequiredMembers]
        public unsafe Runnable_$ID$()
        {
            $InitializeArgumentFields$
            $ParamsContent$
        }

        $DeclareFieldsContainer$

        private $GlobalSetupModifiers$ global::System.Threading.Tasks.ValueTask __GlobalSetup()
        {
            $GlobalSetupImpl$
        }

        private $GlobalCleanupModifiers$ global::System.Threading.Tasks.ValueTask __GlobalCleanup()
        {
            $GlobalCleanupImpl$
        }

        private $IterationSetupModifiers$ global::System.Threading.Tasks.ValueTask __IterationSetup()
        {
            $IterationSetupImpl$
        }

        private $IterationCleanupModifiers$ global::System.Threading.Tasks.ValueTask __IterationCleanup()
        {
            $IterationCleanupImpl$
        }

        // this method is used only for the disassembly diagnoser purposes
        // the goal is to get this and the benchmarked method jitted, but without executing the benchmarked method itself
        public global::System.Int32 NotEleven;
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public void __TrickTheJIT__()
        {
            this.NotEleven = new global::System.Random(123).Next(0, 10);
            $DisassemblerEntryMethodName$();
        }

        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoOptimization | global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        public unsafe void $DisassemblerEntryMethodName$()
        {
            if (this.NotEleven == 11)
            {
                $DisassemblerEntryMethodImpl$
            }
        }

        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private unsafe void __Overhead($ArgumentsDefinition$)
        {
        }

        $CoreImpl$
    }