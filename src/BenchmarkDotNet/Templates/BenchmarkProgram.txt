$ShadowCopyDefines$
$ExtraDefines$
using System;
using System.Diagnostics;
using System.Linq; // must not be removed, used by SmartParameter and SmartArgument
using System.Threading;
using System.Reflection;
using System.Runtime.CompilerServices;
using BenchmarkDotNet;
using BenchmarkDotNet.Characteristics;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Extensions;
using BenchmarkDotNet.Helpers;
using BenchmarkDotNet.Running;
using BenchmarkDotNet.Engines;
using BenchmarkDotNet.Validators;
$TargetTypeNamespace$
$TargetMethodReturnTypeNamespace$

$AdditionalLogic$

// the namespace name must be in sync with WindowsDisassembler.BuildArguments
namespace BenchmarkDotNet.Autogenerated
{
    public class UniqueProgramName // we need different name than typical "Program" to avoid problems with referencing "Program" types from benchmarked code, #691
    {
        $ExtraAttribute$
        public static int Main(string[] args)
        {
            // this method MUST NOT have any dependencies to BenchmarkDotNet and any other external dlls! (CoreRT is exception from this rule)
            // otherwise if LINQPad's shadow copy is enabled, we will not register for AssemblyLoading event
            // before .NET Framework tries to load it for this method
            HelpAssemblyResolving();
            return AfterAssemblyLoadingAttached(args);
        }

        private static int AfterAssemblyLoadingAttached(string[] args)
        {
            var host = new BenchmarkDotNet.Engines.ConsoleHost(Console.Out, Console.In); // this variable name is used by CodeGenerator.GetCoreRtSwitch, do NOT change it

            // the first thing to do is to let diagnosers hook in before anything happens
            // so all jit-related diagnosers can catch first jit compilation!
            host.BeforeAnythingElse();

            try
            {
                // we are not using Runnable here in any direct way in order to avoid strong dependency Main<=>Runnable
                // which could cause the jitting/assembly loading to happen before we do anything
                // we have some jitting diagnosers and we want them to catch all the informations!!

                int id = int.Parse(args.Last()); // this variable name is used by CodeGenerator.GetCoreRtSwitch, do NOT change it

#if CORERT
                $CoreRtSwitch$
#else
                Type type = typeof(UniqueProgramName).GetTypeInfo().Assembly.GetType($"BenchmarkDotNet.Autogenerated.Runnable_{id}");
                type.GetMethod("Run", BindingFlags.Public | BindingFlags.Static).Invoke(null, new object[] { host });
#endif
                return 0;
            }
            catch (Exception oom) when (oom is OutOfMemoryException || oom is TargetInvocationException reflection && reflection.InnerException is OutOfMemoryException)
            {
                host.WriteLine();
                host.WriteLine("OutOfMemoryException!");
                host.WriteLine("BenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects.");
                host.WriteLine("If your benchmark allocates memory and keeps it alive, you are creating a memory leak.");
                host.WriteLine("You should redesign your benchmark and remove the side-effects. You can use `OperationsPerInvoke`, `IterationSetup` and `IterationCleanup` to do that.");
                host.WriteLine();
                host.WriteLine(oom.ToString());

                return -1;
            }
            catch(Exception ex)
            {
                host.WriteLine();
                host.WriteLine(ex.ToString());
                return -1;
            }
            finally
            {
                host.AfterAll();
            }
        }

        private static void HelpAssemblyResolving()
        {
#if SHADOWCOPY
            AppDomain.CurrentDomain.AssemblyResolve += (_, args) =>
            {
                const string shadowCopyFolderPath = @"$ShadowCopyFolderPath$";

                var guessedPath = System.IO.Path.Combine(shadowCopyFolderPath, $"{new System.Reflection.AssemblyName(args.Name).Name}.dll");

                return System.IO.File.Exists(guessedPath) ? System.Reflection.Assembly.LoadFrom(guessedPath) : null;
            };
#endif
        }
    }

    $DerivedTypes$
}
