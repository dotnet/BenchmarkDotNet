// <auto-generated />
// this file must not be importing any namespaces
// we should use full names everywhere to avoid any potential naming conflicts, example: #1007, #778

#if !NET7_0_OR_GREATER
// User code could poly-fill the type and leave it public, so we disable the warning just in case.
#pragma warning disable CS0436 // Type conflicts with imported type
namespace System.Diagnostics.CodeAnalysis
{
    [global::System.AttributeUsage(global::System.AttributeTargets.Constructor, AllowMultiple = false, Inherited = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class SetsRequiredMembersAttribute : global::System.Attribute
    {
    }
}
#endif

// the namespace name must be in sync with DisassemblyDiagnoser.BuildClrMdArgs
namespace BenchmarkDotNet.Autogenerated
{
    public class UniqueProgramName // we need different name than typical "Program" to avoid problems with referencing "Program" types from benchmarked code, #691
    {
        $EntryPoint$

        private static async global::System.Threading.Tasks.ValueTask<System.Int32> MainCore(global::System.String[] args)
        {
            // This variable name is used by CodeGenerator.GetBenchmarkRunCall, do NOT change it!
            global::BenchmarkDotNet.Engines.IHost host = await global::BenchmarkDotNet.Engines.NamedPipeHost.GetHostAsync(args);

            // the first thing to do is to let diagnosers hook in before anything happens
            // so all jit-related diagnosers can catch first jit compilation!
            await global::BenchmarkDotNet.Engines.HostExtensions.BeforeAnythingElseAsync(host);

            try
            {
                // These variable names are used by CodeGenerator.GetBenchmarkRunCall, do NOT change them!
                global::System.String benchmarkName = global::System.Linq.Enumerable.FirstOrDefault(global::System.Linq.Enumerable.Skip(global::System.Linq.Enumerable.SkipWhile(args, arg => arg != "--benchmarkName"), 1)) ?? "not provided";
                global::BenchmarkDotNet.Diagnosers.RunMode diagnoserRunMode = (global::BenchmarkDotNet.Diagnosers.RunMode) global::System.Int32.Parse(global::System.Linq.Enumerable.FirstOrDefault(global::System.Linq.Enumerable.Skip(global::System.Linq.Enumerable.SkipWhile(args, arg => arg != "--diagnoserRunMode"), 1)) ?? "0");
                global::System.Int32 id = args.Length > 0
                    ? global::System.Int32.Parse(args[args.Length - 1])
                    : 0; // used when re-using generated exe without BDN (typically to repro a bug)

                if (args.Length == 0)
                {
                    await host.WriteLineAsync("You have not specified benchmark id (an integer) so the first benchmark will be executed.");
                }
                $BenchmarkRunCall$
                return 0;
            }
            catch (global::System.Exception oom) when (oom is global::System.OutOfMemoryException || oom is global::System.Reflection.TargetInvocationException reflection && reflection.InnerException is global::System.OutOfMemoryException)
            {
                await host.WriteLineAsync();
                await host.WriteLineAsync("OutOfMemoryException!");
                await host.WriteLineAsync("BenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects.");
                await host.WriteLineAsync("If your benchmark allocates memory and keeps it alive, you are creating a memory leak.");
                await host.WriteLineAsync("You should redesign your benchmark and remove the side-effects. You can use `OperationsPerInvoke`, `IterationSetup` and `IterationCleanup` to do that.");
                await host.WriteLineAsync();
                await host.WriteLineAsync(oom.ToString());

                return -1;
            }
            catch(global::System.Exception ex)
            {
                await host.WriteLineAsync();
                await host.WriteLineAsync(ex.ToString());
                return -1;
            }
            finally
            {
                await global::BenchmarkDotNet.Engines.HostExtensions.AfterAllAsync(host);

                host.Dispose();
            }
        }
    }

    $DerivedTypes$
}
