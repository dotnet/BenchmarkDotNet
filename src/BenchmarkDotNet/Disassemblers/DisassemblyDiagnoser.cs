using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using BenchmarkDotNet.Analysers;
using BenchmarkDotNet.Columns;
using BenchmarkDotNet.Detectors;
using BenchmarkDotNet.Disassemblers;
using BenchmarkDotNet.Disassemblers.Exporters;
using BenchmarkDotNet.Engines;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Exporters;
using BenchmarkDotNet.Helpers;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Loggers;
using BenchmarkDotNet.Portability;
using BenchmarkDotNet.Reports;
using BenchmarkDotNet.Running;
using BenchmarkDotNet.Toolchains.InProcess.NoEmit;
using BenchmarkDotNet.Validators;
using JetBrains.Annotations;
using Perfolizer.Metrology;
using SimpleJson;

namespace BenchmarkDotNet.Diagnosers
{
    public class DisassemblyDiagnoser : IInProcessDiagnoser
    {
        private static readonly Lazy<string> ptrace_scope = new(() => ProcessHelper.RunAndReadOutput("cat", "/proc/sys/kernel/yama/ptrace_scope").Trim());

        private ClrMdDisassembler? _clrMdDisassembler;

        // Lazy create to avoid exceptions at Disassembler ctor
        private ClrMdDisassembler ClrMdDisassembler => _clrMdDisassembler ??= GetClrMdDisassembler();

        internal static ClrMdDisassembler GetClrMdDisassembler() =>
            RuntimeInformation.GetCurrentPlatform() switch
            {
                Platform.X86 or Platform.X64 => new IntelDisassembler(),
                Platform.Arm64 => new Arm64Disassembler(),
                var platform => throw new NotSupportedException($"{platform} is not supported")
            };

        private readonly MonoDisassembler monoDisassembler = new();
        private readonly Dictionary<BenchmarkCase, DisassemblyResult> results = [];

        public DisassemblyDiagnoser(DisassemblyDiagnoserConfig config)
        {
            Config = config;

            Exporters = GetExporters(results, config);
        }

        public DisassemblyDiagnoserConfig Config { get; }

        public IReadOnlyDictionary<BenchmarkCase, DisassemblyResult> Results => results;

        public IEnumerable<string> Ids => [nameof(DisassemblyDiagnoser)];

        public IEnumerable<IExporter> Exporters { get; }

        public IEnumerable<IAnalyser> Analysers => [new DisassemblyAnalyzer(results)];

        public IEnumerable<Metric> ProcessResults(DiagnoserResults diagnoserResults)
        {
            if (results.TryGetValue(diagnoserResults.BenchmarkCase, out var disassemblyResult))
                yield return new Metric(NativeCodeSizeMetricDescriptor.Instance, SumNativeCodeSize(disassemblyResult));
        }

        public RunMode GetRunMode(BenchmarkCase benchmarkCase)
        {
            if (ShouldUseClrMdDisassembler(benchmarkCase))
                return RunMode.NoOverhead;
            else if (ShouldUseMonoDisassembler(benchmarkCase))
                return RunMode.SeparateLogic;

            return RunMode.None;
        }

        private ClrMdArgs BuildClrMdArgs(BenchmarkCase benchmarkCase, string typeName, int processId)
            => new(
                processId: processId,
                typeName: typeName,
                methodName: DisassemblerConstants.DisassemblerEntryMethodName,
                printSource: Config.PrintSource,
                maxDepth: Config.MaxDepth,
                filters: Config.Filters,
                syntax: Config.Syntax.ToString(),
                tfm: benchmarkCase.Job.Environment.GetRuntime().MsBuildMoniker
            );

        public void Handle(HostSignal signal, DiagnoserActionParameters parameters)
        {
            var benchmark = parameters.BenchmarkCase;
            bool isInProcess = parameters.BenchmarkCase.Job.Infrastructure.TryGetToolchain(out var toolchain) && toolchain.IsInProcess;

            switch (signal)
            {
                case HostSignal.AfterAll when (Config.RunInHost || isInProcess) && ShouldUseClrMdDisassembler(benchmark):
                    results.Add(benchmark, ClrMdDisassembler.AttachAndDisassemble(
                        BuildClrMdArgs(parameters.BenchmarkCase, $"BenchmarkDotNet.Autogenerated.Runnable_{parameters.BenchmarkId.Value}", parameters.Process.Id))
                    );
                    break;
                case HostSignal.SeparateLogic when ShouldUseMonoDisassembler(benchmark):
                    results.Add(benchmark, monoDisassembler.Disassemble(benchmark, benchmark.Job.Environment.Runtime as MonoRuntime));
                    break;
            }
        }

        public void DisplayResults(ILogger logger)
            => logger.WriteInfo(
                results.Count > 0
                    ? "Disassembled benchmarks got exported to \".\\BenchmarkDotNet.Artifacts\\results\\*asm.md\""
                    : "No benchmarks were disassembled");

        public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters)
        {
            var currentPlatform = RuntimeInformation.GetCurrentPlatform();
            if (!(currentPlatform is Platform.X64 or Platform.X86 or Platform.Arm64))
            {
                yield return new ValidationError(true, $"{currentPlatform} is not supported");
                yield break;
            }

            if (Config.RunInHost && OsDetector.IsMacOS())
            {
                yield return new ValidationError(true, "Disassembling in the host process is not supported on MacOS");
                yield break;
            }

            foreach (var benchmark in validationParameters.Benchmarks)
            {
                if (benchmark.Job.Infrastructure.TryGetToolchain(out var toolchain) && toolchain is InProcessNoEmitToolchain)
                {
                    yield return new ValidationError(true, "InProcessToolchain has no DisassemblyDiagnoser support", benchmark);
                }
                else if (benchmark.Job.IsNativeAOT())
                {
                    yield return new ValidationError(true, "Currently NativeAOT has no DisassemblyDiagnoser support", benchmark);
                }

                if (ShouldUseClrMdDisassembler(benchmark))
                {
                    if (Config.RunInHost && toolchain?.IsInProcess != true && !PlatformsMatch(currentPlatform, benchmark.Job.Environment.Platform))
                    {
                        yield return new ValidationError(true, "DisassemblyDiagnoser cannot run in host for a job that targets a different platform", benchmark);
                    }

                    if (OsDetector.IsLinux())
                    {
                        var runtime = benchmark.Job.ResolveValue(EnvironmentMode.RuntimeCharacteristic, EnvironmentResolver.Instance);

                        if (runtime.RuntimeMoniker < RuntimeMoniker.NetCoreApp30)
                        {
                            yield return new ValidationError(true, $"{nameof(DisassemblyDiagnoser)} supports only .NET Core 3.0+", benchmark);
                        }

                        if (ptrace_scope.Value == "2")
                        {
                            yield return new ValidationError(false, $"ptrace_scope is set to 2, {nameof(DisassemblyDiagnoser)} is going to work only if you run as sudo");
                        }
                        else if (ptrace_scope.Value == "3")
                        {
                            yield return new ValidationError(true, $"ptrace_scope is set to 3, {nameof(DisassemblyDiagnoser)} is not going to work");
                        }
                    }
                }
                else if (!ShouldUseMonoDisassembler(benchmark))
                {
                    yield return new ValidationError(true, $"Only Windows and Linux are supported in DisassemblyDiagnoser without Mono. Current OS is {System.Runtime.InteropServices.RuntimeInformation.OSDescription}");
                }
            }
        }

        private static bool PlatformsMatch(Platform currentPlatform, Platform targetPlatform)
        {
            Debug.Assert(currentPlatform != Platform.AnyCpu);

            return targetPlatform == Platform.AnyCpu
                // AnyCpu compiles to the bit-ness of the operating system.
                // Legacy Framework also supports <Prefer32Bit> in Visual Studio,
                // but we don't need to bother checking for it since we use dotnet sdk to build and we don't use or copy that property in generated csproj.
                ? Environment.Is64BitProcess == Environment.Is64BitOperatingSystem
                : currentPlatform == targetPlatform;
        }

        private static bool ShouldUseMonoDisassembler(BenchmarkCase benchmarkCase)
            => benchmarkCase.Job.Environment.Runtime is MonoRuntime
            || (RuntimeInformation.IsMono && benchmarkCase.Job.Infrastructure.TryGetToolchain(out var toolchain) && toolchain.IsInProcess);

        private static bool ShouldUseClrMdDisassembler(BenchmarkCase benchmarkCase)
            => !ShouldUseMonoDisassembler(benchmarkCase) && (OsDetector.IsWindows() || OsDetector.IsLinux() || OsDetector.IsMacOS());

        private static IEnumerable<IExporter> GetExporters(Dictionary<BenchmarkCase, DisassemblyResult> results, DisassemblyDiagnoserConfig config)
        {
            if (config.ExportGithubMarkdown)
            {
                yield return new GithubMarkdownDisassemblyExporter(results, config);
            }
            if (config.ExportHtml)
            {
                yield return new HtmlDisassemblyExporter(results, config);
            }
            if (config.ExportCombinedDisassemblyReport)
            {
                yield return new CombinedDisassemblyExporter(results, config);
            }
            if (config.ExportDiff)
            {
                yield return new GithubMarkdownDiffDisassemblyExporter(results, config);
            }
        }

        private static long SumNativeCodeSize(DisassemblyResult disassembly)
            => disassembly.Methods.Sum(method => method.Maps.Sum(map => map.SourceCodes.OfType<Asm>().Sum(asm => asm.InstructionLength)));

        InProcessDiagnoserHandlerData IInProcessDiagnoser.GetHandlerData(BenchmarkCase benchmarkCase)
        {
            if (GetRunMode(benchmarkCase) == RunMode.None
                || Config.RunInHost
                // We don't use handler for InProcess toolchains, the host diagnoser already handles it without needing to serialize data.
                || (benchmarkCase.Job.Infrastructure.TryGetToolchain(out var toolchain) && toolchain.IsInProcess)
                // Mono disassembler always runs another process.
                || ShouldUseMonoDisassembler(benchmarkCase))
            {
                return default;
            }
            return new(typeof(DisassemblyDiagnoserInProcessHandler), BuildClrMdArgs(benchmarkCase, null, 0).Serialize());
        }

        void IInProcessDiagnoser.DeserializeResults(BenchmarkCase benchmarkCase, string results)
        {
            var json = SimpleJsonSerializer.DeserializeObject<JsonObject>(results);
            var result = new DisassemblyResult();
            result.Deserialize(json);
            this.results.Add(benchmarkCase, result);
        }

        private class NativeCodeSizeMetricDescriptor : IMetricDescriptor
        {
            internal static readonly IMetricDescriptor Instance = new NativeCodeSizeMetricDescriptor();

            public string Id => "Native Code Size";
            public string DisplayName => Column.CodeSize;
            public string Legend => "Native code size of the disassembled method(s)";
            public string NumberFormat => "N0";
            public UnitType UnitType => UnitType.CodeSize;
            public string Unit => SizeUnit.B.Abbreviation;
            public bool TheGreaterTheBetter => false;
            public int PriorityInCategory => 0;
            public bool GetIsAvailable(Metric metric) => true;
        }
    }

    [UsedImplicitly]
    [EditorBrowsable(EditorBrowsableState.Never)]
    public sealed class DisassemblyDiagnoserInProcessHandler : IInProcessDiagnoserHandler
    {
        private ClrMdArgs _clrMdArgs;
        private DisassemblyResult _result;

        void IInProcessDiagnoserHandler.Initialize(string serializedConfig)
        {
            _clrMdArgs.Deserialize(serializedConfig);
        }

        void IInProcessDiagnoserHandler.Handle(BenchmarkSignal signal, InProcessDiagnoserActionArgs args)
        {
            if (signal != BenchmarkSignal.AfterEngine)
            {
                return;
            }

            var clrMdArgs = _clrMdArgs;
            clrMdArgs.ProcessId = Process.GetCurrentProcess().Id;
            clrMdArgs.TypeName = args.BenchmarkInstance.GetType().FullName;
            _result = DisassemblyDiagnoser.GetClrMdDisassembler().AttachAndDisassemble(clrMdArgs);
        }

        string IInProcessDiagnoserHandler.SerializeResults()
        {
            SimpleJsonSerializer.CurrentJsonSerializerStrategy.Indent = false;
            return _result.Serialize().ToString();
        }
    }
}