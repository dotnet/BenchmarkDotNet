using System;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Reflection;
using System.Runtime.CompilerServices;
using BenchmarkDotNet;
using BenchmarkDotNet.Characteristics;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Extensions;
using BenchmarkDotNet.Helpers;
using BenchmarkDotNet.Running;
using BenchmarkDotNet.Engines;
$TargetTypeNamespace$
$TargetMethodReturnTypeNamespace$

$AdditionalLogic$

namespace BenchmarkDotNet.Autogenerated
{
    public class Program
    {
        $ExtraAttribute$
        public static int Main(string[] args)
        {
            BenchmarkDotNet.ServicesProviderContract.Initialize();

            bool isDiagnoserAttached = args != null && args.Contains(BenchmarkDotNet.Engines.Engine.Signals.DiagnoserIsAttachedParam);
            var host = new ConsoleHost(Console.Out, isDiagnoserAttached);

            // the first thing to do is to let diagnosers hook in before anything happens
            // so all jit-related diagnosers can catch first jit compilation!
            if(isDiagnoserAttached)
                host.BeforeAnythingElse();

            try
            {
                // we are not using Runnable here in any direct way in order to avoid strong dependency Main<=>Runnable
                // which could cause the jitting/assembly loading to happen before we do anything
                // we have some jitting diagnosers and we want them to catch all the informations!!

                Type type = typeof(Program).GetTypeInfo().Assembly.GetType("BenchmarkDotNet.Autogenerated.Runnable");

                type.GetMethod("Run", BindingFlags.Public | BindingFlags.Static).Invoke(null, new object[] { host });

                return 0;
            }
            catch(Exception ex)
            {
                host.WriteLine(ex.ToString());
                return -1;
            }
        }
    }

    $CommonRunnableDefinition$

}
