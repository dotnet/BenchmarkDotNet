using BenchmarkDotNet.Engines;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using System;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using Windows.UI.Xaml;
using Windows.Foundation.Diagnostics;
using System.Threading.Tasks;
using Windows.ApplicationModel.Activation;
using Windows.UI.Xaml.Controls;
using BenchmarkDotNet.Engines;
using System.IO;
using System.Text;

$TargetTypeNamespace$
$TargetMethodReturnTypeNamespace$

$AdditionalLogic$

namespace BenchmarkDotNet.Autogenerated
{
    class LoggingChannelTextWriterAdapter : TextWriter
    {
        private readonly LoggingChannel lc;

        public LoggingChannelTextWriterAdapter(LoggingChannel lc)
        {
            this.lc = lc;
        }

        public override Encoding Encoding => Encoding.UTF8;

        public override void Write(char value)
        {
            throw new NotImplementedException();
        }

        public override void Write(char[] buffer, int index, int count)
        {
            lc.LogEvent(new string(buffer, index, count));
        }
    }

    public static class Program
    {
        static void Main(string[] args)
        {
            global::Windows.UI.Xaml.Application.Start((p) => new App(args));
        }
        }
        
        $ExtraAttribute$
    sealed partial class App : Application
    {
        LoggingChannel lc = new LoggingChannel("BenchmarkDotNet.Autogenerated", null, new Guid("4bd2826e-54a1-4ba9-bf63-92b73ea1ac4a"));

        public App(string[] args)
        {
            this.InitializeComponent();

            bool isDiagnoserAttached = args != null && args.Contains(BenchmarkDotNet.Engines.Engine.Signals.DiagnoserIsAttachedParam);
            ConsoleHost host = new ConsoleHost(new LoggingChannelTextWriterAdapter(lc), isDiagnoserAttached);

            // the first thing to do is to let diagnosers hook in before anything happens
            // so all jit-related diagnosers can catch first jit compilation!
            if (isDiagnoserAttached)
                host.BeforeAnythingElse();

			Action action = () =>
			{
				try
				{
					// we are not using Runnable here in any direct way in order to avoid strong dependency Main<=>Runnable
					// which could cause the jitting/assembly loading to happen before we do anything
					// we have some jitting diagnosers and we want them to catch all the informations!!

					Type type = typeof(Program).GetTypeInfo().Assembly.GetType("BenchmarkDotNet.Autogenerated.Runnable");

					type.GetMethod("Run", BindingFlags.Public | BindingFlags.Static).Invoke(null, new object[] { host });
				}
				catch (Exception ex)
				{
					lc.LogMessage(string.Format("// Exception #1: {0}. StackTrace: {1}", ex.Message, ex.StackTrace));
					throw;
				}
				finally
				{
					lc.Dispose();
					Application.Current.Exit();
				}
			};

			Task.Factory.StartNew(action);
        }

        protected override void OnLaunched(LaunchActivatedEventArgs e)
        {
            Frame rootFrame = Window.Current.Content as Frame;

            // Do not repeat app initialization when the Window already has content,
            // just ensure that the window is active
            if (rootFrame == null)
            {
                // Create a Frame to act as the navigation context and navigate to the first page
                rootFrame = new Frame();
                
                if (e.PreviousExecutionState == ApplicationExecutionState.Terminated)
                {
                    //TODO: Load state from previously suspended application
                }

                // Place the frame in the current Window
                Window.Current.Content = rootFrame;
            }

            if (e.PrelaunchActivated == false)
            {
                if (rootFrame.Content == null)
                {
                    // When the navigation stack isn't restored navigate to the first page,
                    // configuring the new page by passing required information as a navigation
                    // parameter
                    rootFrame.Navigate(typeof(MainPage), e.Arguments);
                }
                // Ensure the current window is active
                Window.Current.Activate();
            }
        }
    }

    public class Runnable : global::$TargetTypeName$
    {
        public static void Run(IHost host)
        {
            try
            {
                Runnable instance = new Runnable();
                $ParamsContent$

                host.WriteLine();
                foreach (var infoLine in BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
                {
                    host.WriteLine("// {0}", infoLine);
                }
                var job = new Job();
                $JobSetDefinition$;
                job.Freeze();
                host.WriteLine("// Job: {0}", job.DisplayInfo);

                var engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
                {
                    Host = host,
                    MainAction = instance.MainMultiAction,
                    Dummy1Action = instance.Dummy1,
                    Dummy2Action = instance.Dummy2,
                    Dummy3Action = instance.Dummy3,
                    IdleAction = instance.IdleMultiAction, 
                    SetupAction = instance.setupAction,
                    CleanupAction = instance.cleanupAction,
                    TargetJob = job,
                    OperationsPerInvoke = $OperationsPerInvoke$
                };

                var engine = new $EngineFactoryType$().Create(engineParameters);
                host.WriteLine("// Engine create");

                engine.PreAllocate();
                host.WriteLine("// Engine preallocate");

                instance?.setupAction();
                host.WriteLine("// SetupAction");

                engine.Jitting(); // does first call to main action, must be executed after setup()!            
                host.WriteLine("// Engine jitting");

                if (host.IsDiagnoserAttached)
                    host.WriteLine(BenchmarkDotNet.Engines.Engine.Signals.AfterSetup);

                var results = engine.Run();
                host.WriteLine("// Engine run");

                if (host.IsDiagnoserAttached)
                    host.WriteLine(BenchmarkDotNet.Engines.Engine.Signals.BeforeCleanup);
                instance?.cleanupAction();
                host.WriteLine("// CleanupAction");

                host.WriteLine("// Main count: " + results.Main.Count);
                host.WriteLine("// Meas count: " + results.GetMeasurements().Count());
                host.ReportResults(results);
            }
            catch(Exception ex)
            {
                host.WriteLine("// Exception #2: {0}. StackTrace: {1}", ex.Message, ex.StackTrace);
                throw;
            }
        }

        public Runnable()
        {
            setupAction = $SetupMethodName$;
            cleanupAction = $CleanupMethodName$;
            idleAction = Idle;
            mainAction = $TargetMethodDelegate$;
        }

        private Action setupAction;
        private Action cleanupAction;
        private $IdleMethodDelegateType$ idleAction;
        private $TargetMethodDelegateType$ mainAction;
        
        private int dummyVar;

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy1()
        {
            dummyVar++;@DummyUnroll@
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy2()
        {
            dummyVar++;@DummyUnroll@
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void Dummy3()
        {
            dummyVar++;@DummyUnroll@
        }

        private $IdleMethodReturnType$ Idle()
        {
            $IdleImplementation$
        }

#if $HasReturnValue$

        private Consumer consumer = new Consumer();

        private void IdleMultiAction(long invokeCount)
        {
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(idleAction());@Unroll@
            }
        }

        private void MainMultiAction(long invokeCount)
        {
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(mainAction());@Unroll@
            }
        }

#else

        private void IdleMultiAction(long invokeCount)
        {
            for (long i = 0; i < invokeCount; i++)
            {
                idleAction();@Unroll@
            }
        }

        private void MainMultiAction(long invokeCount)
        {
            for (long i = 0; i < invokeCount; i++)
            {
                mainAction();@Unroll@
            }
        }

#endif
    }
}
