using BenchmarkDotNet.Engines;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using System;
using System.Linq;
using System.Reflection;
using Windows.UI.Xaml;
using Windows.Foundation.Diagnostics;
using System.Threading.Tasks;

$TargetTypeNamespace$
$TargetMethodReturnTypeNamespace$

$AdditionalLogic$

namespace BenchmarkDotNet.Autogenerated
{
    public static class Program
    {
		static void Main(string[] args)
        {
            global::Windows.UI.Xaml.Application.Start((p) => new App(args));
        }
        }
		
        $ExtraAttribute$
    sealed partial class App : Application
    {
        LoggingChannel lc = new LoggingChannel("BenchmarkDotNet.Autogenerated", null, new Guid("4bd2826e-54a1-4ba9-bf63-92b73ea1ac4a"));

        public App(string[] args)
        {
            bool isDiagnoserAttached = args != null && args.Contains(BenchmarkDotNet.Engines.Engine.Signals.DiagnoserIsAttachedParam);

            // the first thing to do is to let diagnosers hook in before anything happens
            // so all jit-related diagnosers can catch first jit compilation!
            if (isDiagnoserAttached)
                lc.LogMessage(BenchmarkDotNet.Engines.Engine.Signals.BeforeAnythingElse);

            try
            {
                Action action = () =>
                {
                    try
                    {
                        // we are not using Runnable here in any direct way in order to avoid strong dependency Main<=>Runnable
                        // which could cause the jitting/assembly loading to happen before we do anything
                        // we have some jitting diagnosers and we want them to catch all the informations!!

                        Type type = typeof(Program).GetTypeInfo().Assembly.GetType("BenchmarkDotNet.Autogenerated.Runnable");

                        type.GetMethod("Run", BindingFlags.Public | BindingFlags.Static).Invoke(null, new object[] { isDiagnoserAttached, lc });
                    }
                    catch (Exception ex)
                    {
                        lc.LogMessage(string.Format("// Exception: {0}. StackTrace: {1}", ex.Message, ex.StackTrace));
                    }
                    finally
                    {
						lc.Dispose();
                        Application.Current.Exit();
                    }
                };

                Task.Factory.StartNew(action);
            }
            catch (Exception ex)
            {
				lc.LogMessage(string.Format("// Exception: {0}. StackTrace: {1}", ex.Message, ex.StackTrace));
            }
        }
    }

    public class Runnable : global::$TargetTypeName$
    {
        public static void Run(bool isDiagnoserAttached, LoggingChannel lc)
        {
            Runnable instance = new Runnable();
            $ParamsContent$

            System.Console.WriteLine();
            foreach (var infoLine in BenchmarkEnvironmentInfo.GetCurrent().ToFormattedString())
            {
                lc.LogMessage(string.Format("// {0}", infoLine));
            }
            var job = new Job();
            $JobSetDefinition$;
            job.Freeze();
            lc.LogMessage(string.Format("// Job: {0}", job.DisplayInfo));

            var engineParameters = new BenchmarkDotNet.Engines.EngineParameters()
            {
                MainAction = instance.MainMultiAction,
                IdleAction = instance.IdleMultiAction, 
                SetupAction = instance.setupAction,
                CleanupAction = instance.cleanupAction,
                TargetJob = job,
                OperationsPerInvoke = $OperationsPerInvoke$,    
                IsDiagnoserAttached = isDiagnoserAttached
            };

            var engine = new $EngineFactoryType$().Create(engineParameters);
			lc.LogMessage("// Engine create");

            engine.PreAllocate();
			lc.LogMessage("// Engine preallocate");

            instance?.setupAction();
			lc.LogMessage("// SetupAction");

            engine.Jitting(); // does first call to main action, must be executed after setup()!			
			lc.LogMessage("// Engine jitting");

            if (isDiagnoserAttached)
                lc.LogMessage(string.Format(BenchmarkDotNet.Engines.Engine.Signals.AfterSetup));

            var results = engine.Run();
			lc.LogMessage("// Engine run");

            if (isDiagnoserAttached)
                lc.LogMessage(string.Format(BenchmarkDotNet.Engines.Engine.Signals.BeforeCleanup));
            instance?.cleanupAction();
			lc.LogMessage("// CleanupAction");

			lc.LogMessage("// Main count: " + results.Main.Count);
			lc.LogMessage("// Meas count: " + results.GetMeasurements().Count());
            results.Print(line => lc.LogMessage(line)); // printing costs memory, do this after runs
        }

        public Runnable()
        {
            setupAction = $SetupMethodName$;
            cleanupAction = $CleanupMethodName$;
            idleAction = Idle;
            mainAction = $TargetMethodDelegate$;
        }

        private Action setupAction;
        private Action cleanupAction;
        private $IdleMethodDelegateType$ idleAction;
        private $TargetMethodDelegateType$ mainAction;

        private $IdleMethodReturnType$ Idle()
        {
            $IdleImplementation$
        }

#if $HasReturnValue$

        private Consumer consumer = new Consumer();

        private void IdleMultiAction(long invokeCount)
        {
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(idleAction());@Unroll@
            }
        }

        private void MainMultiAction(long invokeCount)
        {
            for (long i = 0; i < invokeCount; i++)
            {
                consumer.Consume(mainAction());@Unroll@
            }
        }

#else

        private void IdleMultiAction(long invokeCount)
        {
            for (long i = 0; i < invokeCount; i++)
            {
                idleAction();@Unroll@
            }
        }

        private void MainMultiAction(long invokeCount)
        {
            for (long i = 0; i < invokeCount; i++)
            {
                mainAction();@Unroll@
            }
        }

#endif
    }
}
