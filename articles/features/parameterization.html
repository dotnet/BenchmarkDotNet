<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Parameterization | BenchmarkDotNet </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Parameterization | BenchmarkDotNet ">
      
      
      <link rel="icon" href="../../logo/icon-32.png">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/dotnet/BenchmarkDotNet/blob/master/docs/articles/features/parameterization.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo/icon.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="docs.parameterization">
<h1 id="parameterization">Parameterization</h1>

<hr>
<h2 id="sample-introparams">Sample: IntroParams</h2>
<p>You can mark one or several fields or properties in your class by
the <a class="xref" href="../../api/BenchmarkDotNet.Attributes.ParamsAttribute.html"><code>[Params]</code></a> attribute.
In this attribute, you can specify set of values.
Every value must be a compile-time constant.
As a result, you will get results for each combination of params values.</p>
<h3 id="source-code">Source code</h3>
<pre><code class="lang-csharp" name="IntroParams.cs">using System.Threading;
using BenchmarkDotNet.Attributes;

namespace BenchmarkDotNet.Samples
{
    public class IntroParams
    {
        [Params(100, 200)]
        public int A { get; set; }

        [Params(10, 20)]
        public int B { get; set; }

        [Benchmark]
        public void Benchmark() =&gt; Thread.Sleep(A + B + 5);
    }
}
</code></pre><h3 id="output">Output</h3>
<pre><code class="lang-markdown">|    Method |   A |  B |     Mean |   Error |  StdDev |
|---------- |---- |--- |---------:|--------:|--------:|
| Benchmark | 100 | 10 | 115.3 ms | 0.13 ms | 0.12 ms |
| Benchmark | 100 | 20 | 125.4 ms | 0.14 ms | 0.12 ms |
| Benchmark | 200 | 10 | 215.5 ms | 0.19 ms | 0.18 ms |
| Benchmark | 200 | 20 | 225.4 ms | 0.17 ms | 0.16 ms |
</code></pre>
<h3 id="links">Links</h3>
<ul>
<li><a class="xref" href="parameterization.html">Parameterization</a></li>
<li>The permanent link to this sample: <a class="xref" href="../samples/IntroParams.html">BenchmarkDotNet.Samples.IntroParams</a></li>
</ul>
<hr>
<h2 id="sample-introparamssource">Sample: IntroParamsSource</h2>
<p>In case you want to use a lot of values, you should use
<a class="xref" href="../../api/BenchmarkDotNet.Attributes.ParamsSourceAttribute.html"><code>[ParamsSource]</code></a>
You can mark one or several fields or properties in your class by the
<a class="xref" href="../../api/BenchmarkDotNet.Attributes.ParamsAttribute.html"><code>[Params]</code></a> attribute.
In this attribute, you have to specify the name of public method/property which is going to provide the values
(something that implements <code>IEnumerable</code>).
The source may be instance or static. If the source is not in the same type as the benchmark, the type containing the source must be specified in the attribute constructor.</p>
<h3 id="source-code">Source code</h3>
<pre><code class="lang-csharp" name="IntroParamsSource.cs">using System.Collections.Generic;
using System.Threading;
using BenchmarkDotNet.Attributes;

namespace BenchmarkDotNet.Samples
{
    public class IntroParamsSource
    {
        // property with public setter
        [ParamsSource(nameof(ValuesForA))]
        public int A { get; set; }

        // public field
        [ParamsSource(nameof(ValuesForB))]
        public int B;

        // public property
        public IEnumerable&lt;int&gt; ValuesForA =&gt; new[] { 100, 200 };

        // public static method
        public static IEnumerable&lt;int&gt; ValuesForB() =&gt; new[] { 10, 20 };

        // public field getting its params from a method in another type
        [ParamsSource(typeof(ParamsValues), nameof(ParamsValues.ValuesForC))]
        public int C;

        [Benchmark]
        public void Benchmark() =&gt; Thread.Sleep(A + B + C + 5);
    }

    public static class ParamsValues
    {
        public static IEnumerable&lt;int&gt; ValuesForC() =&gt; new[] { 1000, 2000 };
    }
}
</code></pre><h3 id="output">Output</h3>
<pre><code class="lang-markdown">|    Method |  B |   A |     Mean |   Error |  StdDev |
|---------- |--- |---- |---------:|--------:|--------:|
| Benchmark | 10 | 100 | 115.5 ms | 0.17 ms | 0.16 ms |
| Benchmark | 10 | 200 | 215.6 ms | 0.15 ms | 0.14 ms |
| Benchmark | 20 | 100 | 125.5 ms | 0.19 ms | 0.18 ms |
| Benchmark | 20 | 200 | 225.5 ms | 0.23 ms | 0.22 ms |
</code></pre>
<h3 id="remarks">Remarks</h3>
<p><strong>A remark about IParam.</strong></p>
<p>You don't need to use <code>IParam</code> anymore since <code>0.11.0</code>.
Just use complex types as you wish and override <code>ToString</code> method to change the display names used in the results.</p>
<h3 id="links">Links</h3>
<ul>
<li><a class="xref" href="parameterization.html">Parameterization</a></li>
<li>The permanent link to this sample: <a class="xref" href="../samples/IntroParamsSource.html">BenchmarkDotNet.Samples.IntroParamsSource</a></li>
</ul>
<hr>
<h2 id="sample-introparamsallvalues">Sample: IntroParamsAllValues</h2>
<p>If you want to use all possible values of an <code>enum</code> or another type with a small number of values, you can use the <a class="xref" href="../../api/BenchmarkDotNet.Attributes.ParamsAllValuesAttribute.html"><code>[ParamsAllValues]</code></a> attribute, instead of listing all the values by hand. The types supported by the attribute are:</p>
<ul>
<li><code>bool</code></li>
<li>any <code>enum</code> that is not marked with <code>[Flags]</code></li>
<li><code>Nullable&lt;T&gt;</code>, where <code>T</code> is an enum or boolean</li>
</ul>
<h3 id="source-code">Source code</h3>
<pre><code class="lang-csharp" name="IntroParamsAllValues.cs">using BenchmarkDotNet.Attributes;
using System.Threading;

namespace BenchmarkDotNet.Samples
{
    [DryJob]
    public class IntroParamsAllValues
    {
        public enum CustomEnum
        {
            One = 1,
            Two,
            Three
        }

        [ParamsAllValues]
        public CustomEnum E { get; set; }

        [ParamsAllValues]
        public bool? B { get; set; }

        [Benchmark]
        public void Benchmark()
        {
            Thread.Sleep(
                (int)E * 100 +
                (B == true ? 20 : B == false ? 10 : 0));
        }
    }
}
</code></pre><h3 id="output">Output</h3>
<pre><code class="lang-markdown">    Method |     E |     B |     Mean | Error |
---------- |------ |------ |---------:|------:|
 Benchmark |   One |     ? | 101.4 ms |    NA |
 Benchmark |   One | False | 111.1 ms |    NA |
 Benchmark |   One |  True | 122.0 ms |    NA |
 Benchmark |   Two |     ? | 201.3 ms |    NA |
 Benchmark |   Two | False | 212.1 ms |    NA |
 Benchmark |   Two |  True | 221.3 ms |    NA |
 Benchmark | Three |     ? | 301.4 ms |    NA |
 Benchmark | Three | False | 311.5 ms |    NA |
 Benchmark | Three |  True | 320.8 ms |    NA |
</code></pre>
<h3 id="links">Links</h3>
<ul>
<li><a class="xref" href="parameterization.html">Parameterization</a></li>
<li>The permanent link to this sample: <a class="xref" href="../samples/IntroParamsAllValues.html">BenchmarkDotNet.Samples.IntroParamsAllValues</a></li>
</ul>
<hr>
<h2 id="sample-introparamspriority">Sample: IntroParamsPriority</h2>
<p>In order to sort columns of parameters in the results table you can use the Property <code>Priority</code> inside the params attribute. The priority range is <code>[Int32.MinValue;Int32.MaxValue]</code>, lower priorities will appear earlier in the column order. The default priority is set to <code>0</code>.</p>
<h3 id="source-code">Source code</h3>
<pre><code class="lang-csharp" name="IntroParamsPriority.cs">using System.Threading;
using BenchmarkDotNet.Attributes;

namespace BenchmarkDotNet.Samples
{
    public class IntroParamsPriority
    {
        [Params(100)]
        public int A { get; set; }

        [Params(10, Priority = -100)]
        public int B { get; set; }

        [Benchmark]
        public void Benchmark() =&gt; Thread.Sleep(A + B + 5);
    }
}
</code></pre><h3 id="output">Output</h3>
<pre><code class="lang-markdown">|    Method |  B |   A |     Mean |   Error |  StdDev |
|---------- |--- |---- |---------:|--------:|--------:|
| Benchmark | 10 | 100 | 115.4 ms | 0.12 ms | 0.11 ms |
</code></pre>
<h3 id="links">Links</h3>
<ul>
<li>Priority BaseClass <a class="xref" href="../../api/BenchmarkDotNet.Attributes.PriorityAttribute.html"><code>PriorityAttribute.cs</code></a></li>
<li><a class="xref" href="parameterization.html">Parameterization</a></li>
<li>The permanent link to this sample: <a class="xref" href="../samples/IntroParamsPriority.html">BenchmarkDotNet.Samples.IntroParamsPriority</a></li>
</ul>
<hr>
<h2 id="sample-introarguments">Sample: IntroArguments</h2>
<p>As an alternative to using <a class="xref" href="../../api/BenchmarkDotNet.Attributes.ParamsAttribute.html"><code>[Params]</code></a>,
you can specify arguments for your benchmarks.
There are several ways to do it (described below).</p>
<p>The <a class="xref" href="../../api/BenchmarkDotNet.Attributes.ArgumentsAttribute.html"><code>[Arguments]</code></a> allows you to provide a set of values.
Every value must be a compile-time constant (it's C# language limitation for attributes in general).
You can also combine
<a class="xref" href="../../api/BenchmarkDotNet.Attributes.ArgumentsAttribute.html"><code>[Arguments]</code></a> with
<a class="xref" href="../../api/BenchmarkDotNet.Attributes.ParamsAttribute.html"><code>[Params]</code></a>.
As a result, you will get results for each combination of params values.</p>
<h3 id="source-code">Source code</h3>
<pre><code class="lang-csharp" name="IntroArguments.cs">using System.Threading;
using BenchmarkDotNet.Attributes;

namespace BenchmarkDotNet.Samples
{
    public class IntroArguments
    {
        [Params(true, false)] // Arguments can be combined with Params
        public bool AddExtra5Milliseconds;

        [Benchmark]
        [Arguments(100, 10)]
        [Arguments(100, 20)]
        [Arguments(200, 10)]
        [Arguments(200, 20)]
        public void Benchmark(int a, int b)
        {
            if (AddExtra5Milliseconds)
                Thread.Sleep(a + b + 5);
            else
                Thread.Sleep(a + b);
        }
    }
}
</code></pre><h3 id="output">Output</h3>
<pre><code class="lang-markdown">|    Method | AddExtra5Miliseconds |   a |  b |     Mean |     Error |    StdDev |
|---------- |--------------------- |---- |--- |---------:|----------:|----------:|
| Benchmark |                False | 100 | 10 | 110.1 ms | 0.0056 ms | 0.0044 ms |
| Benchmark |                False | 100 | 20 | 120.1 ms | 0.0155 ms | 0.0138 ms |
| Benchmark |                False | 200 | 10 | 210.2 ms | 0.0187 ms | 0.0175 ms |
| Benchmark |                False | 200 | 20 | 220.3 ms | 0.1055 ms | 0.0986 ms |
| Benchmark |                 True | 100 | 10 | 115.3 ms | 0.1375 ms | 0.1286 ms |
| Benchmark |                 True | 100 | 20 | 125.3 ms | 0.1212 ms | 0.1134 ms |
| Benchmark |                 True | 200 | 10 | 215.4 ms | 0.0779 ms | 0.0691 ms |
| Benchmark |                 True | 200 | 20 | 225.4 ms | 0.0775 ms | 0.0725 ms |
</code></pre>
<h3 id="links">Links</h3>
<ul>
<li><a class="xref" href="parameterization.html">Parameterization</a></li>
<li>The permanent link to this sample: <a class="xref" href="../samples/IntroArguments.html">BenchmarkDotNet.Samples.IntroArguments</a></li>
</ul>
<hr>
<h2 id="sample-introargumentssource">Sample: IntroArgumentsSource</h2>
<p>In case you want to use a lot of values, you should use
<a class="xref" href="../../api/BenchmarkDotNet.Attributes.ArgumentsSourceAttribute.html"><code>[ArgumentsSource]</code></a>.</p>
<p>You can mark one or several fields or properties in your class by the
<a class="xref" href="../../api/BenchmarkDotNet.Attributes.ArgumentsSourceAttribute.html"><code>[ArgumentsSource]</code></a> attribute.
In this attribute, you have to specify the name of public method/property which is going to provide the values
(something that implements <code>IEnumerable</code>).
The source may be instance or static. If the source is not in the same type as the benchmark, the type containing the source must be specified in the attribute constructor.</p>
<h3 id="source-code">Source code</h3>
<pre><code class="lang-csharp" name="IntroArgumentsSource.cs">using System;
using System.Collections.Generic;
using System.Threading;
using BenchmarkDotNet.Attributes;

namespace BenchmarkDotNet.Samples
{
    public class IntroArgumentsSource
    {
        [Benchmark]
        [ArgumentsSource(nameof(Numbers))]
        public double ManyArguments(double x, double y) =&gt; Math.Pow(x, y);

        public IEnumerable&lt;object[]&gt; Numbers() // for multiple arguments it's an IEnumerable of array of objects (object[])
        {
            yield return new object[] { 1.0, 1.0 };
            yield return new object[] { 2.0, 2.0 };
            yield return new object[] { 4.0, 4.0 };
            yield return new object[] { 10.0, 10.0 };
        }

        [Benchmark]
        [ArgumentsSource(typeof(BenchmarkArguments), nameof(BenchmarkArguments.TimeSpans))] // when the arguments come from a different type, specify that type here
        public void SingleArgument(TimeSpan time) =&gt; Thread.Sleep(time);
    }

    public static class BenchmarkArguments
    {
        public static IEnumerable&lt;object&gt; TimeSpans() // for single argument it's an IEnumerable of objects (object)
        {
            yield return TimeSpan.FromMilliseconds(10);
            yield return TimeSpan.FromMilliseconds(100);
        }
    }
}
</code></pre><h3 id="output">Output</h3>
<pre><code class="lang-markdown">| Method |  x |  y |      Mean |     Error |    StdDev |
|------- |--- |--- |----------:|----------:|----------:|
|    Pow |  1 |  1 |  9.360 ns | 0.0190 ns | 0.0149 ns |
|    Pow |  2 |  2 | 40.624 ns | 0.3413 ns | 0.3192 ns |
|    Pow |  4 |  4 | 40.537 ns | 0.0560 ns | 0.0524 ns |
|    Pow | 10 | 10 | 40.395 ns | 0.3274 ns | 0.3063 ns |
</code></pre>
<h3 id="another-example">Another example</h3>
<p>If the values are complex types you need to override <code>ToString</code> method to change the display names used in the results.</p>
<pre><code class="lang-cs">[DryJob]
public class WithNonPrimitiveArgumentsSource
{
    [Benchmark]
    [ArgumentsSource(nameof(NonPrimitive))]
    public void Simple(SomeClass someClass, SomeStruct someStruct)
    {
        for (int i = 0; i &lt; someStruct.RangeEnd; i++)
            Console.WriteLine($&quot;// array.Values[{i}] = {someClass.Values[i]}&quot;);
    }

    public IEnumerable&lt;object[]&gt; NonPrimitive()
    {
        yield return new object[] { new SomeClass(Enumerable.Range(0, 10).ToArray()), new SomeStruct(10) };
        yield return new object[] { new SomeClass(Enumerable.Range(0, 15).ToArray()), new SomeStruct(15) };
    }

    public class SomeClass
    {
        public SomeClass(int[] initialValues) =&gt; Values = initialValues.Select(val =&gt; val * 2).ToArray();

        public int[] Values { get; }

        public override string ToString() =&gt; $&quot;{Values.Length} items&quot;;
    }

    public struct SomeStruct
    {
        public SomeStruct(int rangeEnd) =&gt; RangeEnd = rangeEnd;

        public int RangeEnd { get; }

        public override string ToString() =&gt; $&quot;{RangeEnd}&quot;;
    }
}
</code></pre>
<pre><code class="lang-markdown">| Method | someClass | someStruct |     Mean | Error |
|------- |---------- |----------- |---------:|------:|
| Simple |  10 items |         10 | 887.2 us |    NA |
| Simple |  15 items |         15 | 963.1 us |    NA |
</code></pre>
<h3 id="links">Links</h3>
<ul>
<li><a class="xref" href="parameterization.html">Parameterization</a></li>
<li>The permanent link to this sample: <a class="xref" href="../samples/IntroArgumentsSource.html">BenchmarkDotNet.Samples.IntroArgumentsSource</a></li>
</ul>
<hr>
<h2 id="sample-introarrayparam">Sample: IntroArrayParam</h2>
<div class="WARNING">
<h5>Warning</h5>
<p>The cost of creating the arguments is not included in the benchmark.</p>
</div>
<p>So if you want to pass an array as an argument, we are going to allocate it before running the benchmark,
and the benchmark will not include this operation.</p>
<h3 id="source-code">Source code</h3>
<pre><code class="lang-csharp" name="IntroArrayParam.cs">using System;
using System.Collections.Generic;
using System.Linq;
using BenchmarkDotNet.Attributes;

namespace BenchmarkDotNet.Samples
{
    public class IntroArrayParam
    {
        [Benchmark]
        [ArgumentsSource(nameof(Data))]
        public int ArrayIndexOf(int[] array, int value)
            =&gt; Array.IndexOf(array, value);

        [Benchmark]
        [ArgumentsSource(nameof(Data))]
        public int ManualIndexOf(int[] array, int value)
        {
            for (int i = 0; i &lt; array.Length; i++)
                if (array[i] == value)
                    return i;

            return -1;
        }

        public IEnumerable&lt;object[]&gt; Data()
        {
            yield return new object[] { new int[] { 1, 2, 3 }, 4 };
            yield return new object[] { Enumerable.Range(0, 100).ToArray(), 4 };
            yield return new object[] { Enumerable.Range(0, 100).ToArray(), 101 };
        }
    }
}
</code></pre><h3 id="output">Output</h3>
<pre><code class="lang-markdown">|        Method |      array | value |      Mean |     Error |    StdDev | Allocated |
|-------------- |----------- |------ |----------:|----------:|----------:|----------:|
|  ArrayIndexOf | Array[100] |     4 | 15.558 ns | 0.0638 ns | 0.0597 ns |       0 B |
| ManualIndexOf | Array[100] |     4 |  5.345 ns | 0.0668 ns | 0.0625 ns |       0 B |
|  ArrayIndexOf |   Array[3] |     4 | 14.334 ns | 0.1758 ns | 0.1558 ns |       0 B |
| ManualIndexOf |   Array[3] |     4 |  2.758 ns | 0.0905 ns | 0.1208 ns |       0 B |
|  ArrayIndexOf | Array[100] |   101 | 78.359 ns | 1.8853 ns | 2.0955 ns |       0 B |
| ManualIndexOf | Array[100] |   101 | 80.421 ns | 0.6391 ns | 0.5978 ns |       0 B |
</code></pre>
<h3 id="links">Links</h3>
<ul>
<li><a class="xref" href="parameterization.html">Parameterization</a></li>
<li>The permanent link to this sample: <a class="xref" href="../samples/IntroArrayParam.html">BenchmarkDotNet.Samples.IntroArrayParam</a></li>
</ul>
<hr>
<h2 id="sample-introargumentspriority">Sample: IntroArgumentsPriority</h2>
<p>Like Params also Argument columns can be sorted in the table result through their <code>Priority</code>. The priority should be defined only once for multiple Arguments and will keep their inner order as they are defined in the method.</p>
<h3 id="source-code">Source code</h3>
<pre><code class="lang-csharp" name="IntroArgumentsPriority.cs">using System.Collections.Generic;
using System.Threading;
using BenchmarkDotNet.Attributes;

namespace BenchmarkDotNet.Samples
{
    public class IntroArgumentsPriority
    {
        [Params(100, Priority = 0)] // Argument priority can be combined with Params priority
        public int A { get; set; }

        [Arguments(5, Priority = -10)] // Define priority just once for multiple argument attributes
        [Arguments(10)]
        [Arguments(20)]
        [Benchmark]
        public void Benchmark(int b) =&gt; Thread.Sleep(A + b);

        [Benchmark]
        [ArgumentsSource(nameof(Numbers), Priority = 10)]
        public void ManyArguments(int c, int d) =&gt; Thread.Sleep(A + c + d);

        public IEnumerable&lt;object[]&gt; Numbers()
        {
            yield return new object[] { 1, 2 };
        }
    }
}
</code></pre><h3 id="output">Output</h3>
<pre><code class="lang-markdown">|        Method |  b |   A | c | d |     Mean |   Error |  StdDev |
|-------------- |--- |---- |-- |-- |---------:|--------:|--------:|
| ManyArguments |  ? | 100 | 1 | 2 | 103.4 ms | 0.09 ms | 0.08 ms |
|     Benchmark |  5 | 100 | ? | ? | 105.5 ms | 0.21 ms | 0.19 ms |
|     Benchmark | 10 | 100 | ? | ? | 110.5 ms | 0.14 ms | 0.14 ms |
|     Benchmark | 20 | 100 | ? | ? | 120.4 ms | 0.16 ms | 0.15 ms |
</code></pre>
<h3 id="links">Links</h3>
<ul>
<li>Priority BaseClass <a class="xref" href="../../api/BenchmarkDotNet.Attributes.PriorityAttribute.html"><code>PriorityAttribute.cs</code></a></li>
<li><a class="xref" href="parameterization.html">Parameterization</a></li>
<li>The permanent link to this sample: <a class="xref" href="../samples/IntroArgumentsPriority.html">BenchmarkDotNet.Samples.IntroArgumentsPriority</a></li>
</ul>
<hr>

</article>


        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright &copy; 2013â€“2024 .NET Foundation and contributors
        </div>
      </div>
    </footer>
  </body>
</html>
