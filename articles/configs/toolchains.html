<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Toolchains | BenchmarkDotNet </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Toolchains | BenchmarkDotNet ">
      
      
      <link rel="icon" href="../../logo/icon-32.png">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="../../toc.html">
      <meta name="docfx:tocrel" content="../toc.html">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/dotnet/BenchmarkDotNet/blob/master/docs/articles/configs/toolchains.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo/icon.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="docs.toolchains">
<h1 id="toolchains">Toolchains</h1>

<p>To achieve process-level isolation, BenchmarkDotNet generates, builds and executes a new console app per every benchmark. A <strong>toolchain</strong> contains generator, builder, and executor.</p>
<p>When you run your benchmarks without specifying the toolchain in an explicit way, the default one is used:</p>
<ul>
<li>Roslyn for Full .NET Framework and Mono</li>
<li>dotnet cli for .NET Core and NativeAOT</li>
</ul>
<h2 id="multiple-frameworks-support">Multiple frameworks support</h2>
<p>If you want to test multiple frameworks, your project file <strong>MUST target all of them</strong> and you <strong>MUST install the corresponding SDKs</strong>:</p>
<pre><code class="lang-xml">&lt;TargetFrameworks&gt;netcoreapp3.1;net8.0;net48&lt;/TargetFrameworks&gt;
</code></pre>
<p>If you run your benchmarks without specifying any custom settings, BenchmarkDotNet is going to run the benchmarks <strong>using the same framework as the host process</strong>:</p>
<pre><code class="lang-cmd">dotnet run -c Release -f netcoreapp3.1 # is going to run the benchmarks using .NET Core 3.1
dotnet run -c Release -f net8.0 # is going to run the benchmarks using .NET 8.0
dotnet run -c Release -f net48         # is going to run the benchmarks using .NET 4.8
mono $pathToExe                        # is going to run the benchmarks using Mono from your PATH
</code></pre>
<p>To run the benchmarks for multiple runtimes with a single command, you need to specify the target framework moniker names via <code>--runtimes|-r</code> console argument:</p>
<pre><code class="lang-cmd">dotnet run -c Release -f net8.0 --runtimes net8.0 netcoreapp3.1 # is going to run the benchmarks using .NET 8.0 and .NET Core 3.1
dotnet run -c Release -f net8.0 --runtimes net8.0 net48         # is going to run the benchmarks using .NET 8.0 and .NET 4.8
</code></pre>
<p>What is going to happen if you provide multiple Full .NET Framework monikers? Let's say:</p>
<pre><code class="lang-cmd">dotnet run -c Release -f net461 net472 net48
</code></pre>
<p>Full .NET Framework always runs every .NET executable using the latest .NET Framework available on a given machine. If you try to run the benchmarks for a few .NET TFMs, they are all going to be executed using the latest .NET Framework from your machine. The only difference is that they are all going to have different features enabled depending on target version they were compiled for. You can read more about this <a href="https://docs.microsoft.com/en-us/dotnet/framework/migration-guide/version-compatibility">here</a> and <a href="https://docs.microsoft.com/en-us/dotnet/framework/migration-guide/application-compatibility">here</a>. This is <strong>.NET Framework behavior which can not be controlled by BenchmarkDotNet or any other tool</strong>.</p>
<p><strong>Note:</strong> Console arguments support works only if you pass the <code>args</code> to <code>BenchmarkSwitcher</code>:</p>
<pre><code class="lang-cs">class Program
{
    static void Main(string[] args) 
        =&gt; BenchmarkSwitcher
            .FromAssembly(typeof(Program).Assembly)
            .Run(args); // crucial to make it work
}
</code></pre>
<p>You can achieve the same thing using <code>[SimpleJobAttribute]</code>:</p>
<pre><code class="lang-cs">using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Jobs;

namespace BenchmarkDotNet.Samples
{
    [SimpleJob(RuntimeMoniker.Net48)]
    [SimpleJob(RuntimeMoniker.Mono)]
    [SimpleJob(RuntimeMoniker.NetCoreApp31)]
    [SimpleJob(RuntimeMoniker.Net80)]
    public class TheClassWithBenchmarks
</code></pre>
<p>Or using a custom config:</p>
<pre><code class="lang-cs">using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;

namespace BenchmarkDotNet.Samples
{
    class Program
    {
        static void Main(string[] args)
        {
            var config = DefaultConfig.Instance
                .AddJob(Job.Default.WithRuntime(CoreRuntime.Core80))
                .AddJob(Job.Default.WithRuntime(ClrRuntime.Net48))
                .AddJob(Job.Default.WithRuntime(MonoRuntime.Default));

            BenchmarkSwitcher
                .FromAssembly(typeof(Program).Assembly)
                .Run(args, config);
        }
    }
}
</code></pre>
<p>The recommended way of running the benchmarks for multiple runtimes is to use the <code>--runtimes</code> console line argument. By using the console line argument you don't need to edit the source code anytime you want to change the list of runtimes. Moreover, if you share the source code of the benchmark other people can run it even if they don't have the exact same framework version installed.</p>
<h2 id="custom-net-core-runtime">Custom .NET Core Runtime</h2>
<p>We can run your benchmarks for custom <code>&lt;RuntimeFrameworkVersion&gt;</code> if you want. All you need to do is to create custom toolchain by calling <code>CsProjCoreToolchain.From</code> method, which accepts <code>NetCoreAppSettings</code>.</p>
<pre><code class="lang-cs">public class MyConfig : ManualConfig
{
    public MyConfig()
    {
        Add(Job.Default.With(
            CsProjCoreToolchain.From(
                new NetCoreAppSettings(
                    targetFrameworkMoniker: &quot;net8.0-windows&quot;,
                    runtimeFrameworkVersion: &quot;8.0.101&quot;,
                    name: &quot;.NET 8.0 Windows&quot;))));
    }
}
</code></pre>
<h2 id="custom-net-runtime">Custom .NET Runtime</h2>
<p>It's possible to benchmark a private build of .NET Runtime. All you need to do is to define a job with the right version of <code>ClrRuntime</code>.</p>
<pre><code class="lang-cs">BenchmarkSwitcher
    .FromAssembly(typeof(Program).Assembly)
    .Run(args, 
        DefaultConfig.Instance.AddJob(
            Job.ShortRun.WithRuntime(ClrRuntime.CreateForLocalFullNetFrameworkBuild(version: &quot;4.0&quot;))));
</code></pre>
<p>This sends the provided version as a <code>COMPLUS_Version</code> env var to the benchmarked process.</p>
<h2 id="custom-dotnet-cli-path">Custom dotnet cli path</h2>
<p>We internally use dotnet cli to build and run .NET Core executables. Sometimes it might be mandatory to use non-default dotnet cli path. An example scenario could be a comparison of RyuJit 32bit vs 64 bit. It required due this <a href="https://github.com/dotnet/cli/issues/7532">limitation</a> of dotnet cli</p>
<pre><code class="lang-cs">public class CustomPathsConfig : ManualConfig
{
    public CustomPathsConfig() 
    {
        var dotnetCli32bit = NetCoreAppSettings
            .NetCoreApp31
            .WithCustomDotNetCliPath(@&quot;C:\Program Files (x86)\dotnet\dotnet.exe&quot;, &quot;32 bit cli&quot;);

        var dotnetCli64bit = NetCoreAppSettings
            .NetCoreApp31
            .WithCustomDotNetCliPath(@&quot;C:\Program Files\dotnet\dotnet.exe&quot;, &quot;64 bit cli&quot;);

        AddJob(Job.RyuJitX86.WithToolchain(CsProjCoreToolchain.From(dotnetCli32bit)).WithId(&quot;32 bit cli&quot;));
        AddJob(Job.RyuJitX64.WithToolchain(CsProjCoreToolchain.From(dotnetCli64bit)).WithId(&quot;64 bit cli&quot;));
    }
}
</code></pre>
<pre><code class="lang-ini">BenchmarkDotNet=v0.10.9.20170910-develop, OS=Windows 10 Redstone 1 (10.0.14393)
Processor=Intel Core i7-6600U CPU 2.60GHz (Skylake), ProcessorCount=4
Frequency=2742185 Hz, Resolution=364.6727 ns, Timer=TSC
.NET Core SDK=2.1.0-preview1-007074
  [Host]     : .NET Core 2.0.0 (Framework 4.6.00001.0), 64bit RyuJIT
  32 bit cli : .NET Core 2.0.0 (Framework 4.6.00001.0), 32bit RyuJIT
  64 bit cli : .NET Core 2.0.0 (Framework 4.6.00001.0), 64bit RyuJIT

Jit=RyuJit  
</code></pre>
<p>This feature is now also exposed with the <code>--cli</code> console argument.</p>
<p>Example: <code>dotnet run -c Release -- --cli &quot;C:\Projects\machinelearning\Tools\dotnetcli\dotnet.exe&quot;</code></p>
<h2 id="corerun">CoreRun</h2>
<p>To use CoreRun for running the benchmarks you need to use <code>--coreRun </code>command line argument. You can combine it with <code>--cli</code> described above. This is most probably the easiest and most reliable way of running benchmarks against local CoreFX/CoreCLR builds.</p>
<p>Example: <code>dotnet run -c Release -- --coreRun &quot;C:\Projects\corefx\bin\testhost\netcoreapp-Windows_NT-Release-x64\shared\Microsoft.NETCore.App\9.9.9\CoreRun.exe&quot;</code></p>
<hr>
<h2 id="sample-introinprocess">Sample: IntroInProcess</h2>
<p>InProcessEmitToolchain is our toolchain which does not generate any new executable.
It emits IL on the fly and runs it from within the process itself.
It can be useful if want to run the benchmarks very fast or if you want to run them for framework which we don't support.
An example could be a local build of CoreCLR.</p>
<h3 id="usage">Usage</h3>
<pre><code class="lang-cs">[InProcessAttribute]
public class TypeWithBenchmarks
{
}
</code></pre>
<h3 id="source-code">Source code</h3>
<pre><code class="lang-csharp" name="IntroInProcess.cs">using System.Runtime.CompilerServices;
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Order;
using BenchmarkDotNet.Toolchains.InProcess.Emit;

namespace BenchmarkDotNet.Samples
{
    [Config(typeof(Config))]
    [Orderer(SummaryOrderPolicy.FastestToSlowest)]
    [MemoryDiagnoser]
    public class IntroInProcess
    {
        private class Config : ManualConfig
        {
            public Config()
            {
                AddJob(Job.MediumRun
                    .WithLaunchCount(1)
                    .WithId(&quot;OutOfProc&quot;));

                AddJob(Job.MediumRun
                    .WithLaunchCount(1)
                    .WithToolchain(InProcessEmitToolchain.Instance)
                    .WithId(&quot;InProcess&quot;));
            }
        }

        [Benchmark(Description = &quot;new byte[10kB]&quot;)]
        public byte[] Allocate()
        {
            return new byte[10000];
        }

        [Benchmark(Description = &quot;stackalloc byte[10kB]&quot;)]
        public unsafe void AllocateWithStackalloc()
        {
            var array = stackalloc byte[10000];
            Consume(array);
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private static unsafe void Consume(byte* input)
        {
        }
    }
}
</code></pre><h3 id="output">Output</h3>
<h3 id="links">Links</h3>
<ul>
<li><a class="xref" href="toolchains.html">Toolchains</a></li>
<li>The permanent link to this sample: <a class="xref" href="../samples/IntroInProcess.html">BenchmarkDotNet.Samples.IntroInProcess</a></li>
</ul>
<hr>
<h2 id="sample-introinprocesswrongenv">Sample: IntroInProcessWrongEnv</h2>
<h3 id="source-code">Source code</h3>
<pre><code class="lang-csharp" name="IntroInProcessWrongEnv.cs">using System;
using System.Runtime.CompilerServices;
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Order;
using BenchmarkDotNet.Toolchains.InProcess;
using BenchmarkDotNet.Toolchains.InProcess.Emit;

namespace BenchmarkDotNet.Samples
{
    [Config(typeof(Config))]
    [Orderer(SummaryOrderPolicy.FastestToSlowest)]
    [MemoryDiagnoser]
    public class IntroInProcessWrongEnv
    {
        private class Config : ManualConfig
        {
            public Config()
            {
                var wrongPlatform = Environment.Is64BitProcess
                    ? Platform.X64
                    : Platform.X86;

                AddJob(Job.MediumRun
                    .WithLaunchCount(1)
                    .WithPlatform(wrongPlatform)
                    .WithToolchain(InProcessEmitToolchain.Instance)
                    .WithId(&quot;InProcess&quot;));

                AddValidator(InProcessValidator.DontFailOnError);
            }
        }

        [Benchmark(Description = &quot;new byte[10kB]&quot;)]
        public byte[] Allocate()
        {
            return new byte[10000];
        }

        [Benchmark(Description = &quot;stackalloc byte[10kB]&quot;)]
        public unsafe void AllocateWithStackalloc()
        {
            var array = stackalloc byte[10000];
            Consume(array);
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private static unsafe void Consume(byte* input)
        {
        }
    }
}
</code></pre><h3 id="output">Output</h3>
<h3 id="links">Links</h3>
<ul>
<li><a class="xref" href="toolchains.html">Toolchains</a></li>
<li>The permanent link to this sample: <a class="xref" href="../samples/IntroInProcessWrongEnv.html">BenchmarkDotNet.Samples.IntroInProcessWrongEnv</a></li>
</ul>
<hr>
<h2 id="nativeaot">NativeAOT</h2>
<p>BenchmarkDotNet supports <a href="https://github.com/dotnet/runtime/tree/main/src/coreclr/nativeaot">NativeAOT</a>! However, you might want to know how it works to get a better understanding of the results that you get.</p>
<p>As every AOT solution, NativeAOT has some <a href="https://github.com/dotnet/runtime/blob/main/src/coreclr/nativeaot/docs/limitations.md">limitations</a> like limited reflection support or lack of dynamic assembly loading. Because of that, the host process (what you run from command line) is never an AOT process, but just a regular .NET process. This process (called Host process) uses reflection to read benchmarks metadata (find all <code>[Benchmark]</code> methods etc), generates a new project that references the benchmarks and compiles it using ILCompiler. Such compilation produces a native executable, which is later started by the Host process. This process (called Benchmark or Child process) performs the actual benchmarking and reports the results back to the Host process. By default BenchmarkDotNet uses the latest version of <code>Microsoft.DotNet.ILCompiler</code> to build the NativeAOT benchmark according to <a href="https://github.com/dotnet/runtime/blob/main/src/coreclr/nativeaot/docs/compiling.md">this instructions</a>.</p>
<p>This is why you need to:</p>
<ul>
<li>install <a href="https://docs.microsoft.com/en-us/dotnet/core/deploying/native-aot/#prerequisites">pre-requisites</a> required by NativeAOT compiler</li>
<li>target .NET to be able to run NativeAOT benchmarks (example: <code>&lt;TargetFramework&gt;net7.0&lt;/TargetFramework&gt;</code> in the .csproj file)</li>
<li>run the app as a .NET process (example: <code>dotnet run -c Release -f net7.0</code>).</li>
<li>specify the NativeAOT runtime in an explicit way, either by using console line arguments <code>--runtimes nativeaot7.0</code> (the recommended approach), or by using<code>[SimpleJob]</code> attribute or by using the fluent Job config API <code>Job.ShortRun.With(NativeAotRuntime.Net70)</code>:</li>
</ul>
<pre><code class="lang-cmd">dotnet run -c Release -f net7.0 --runtimes nativeaot7.0
</code></pre>
<p>or:</p>
<pre><code class="lang-cs">var config = DefaultConfig.Instance
    .AddJob(Job.Default.WithRuntime(NativeAotRuntime.Net70)); // compiles the benchmarks as net7.0 and uses the latest NativeAOT to build a native app

BenchmarkSwitcher
    .FromAssembly(typeof(Program).Assembly)
    .Run(args, config);
</code></pre>
<p>or:</p>
<pre><code class="lang-cs">[SimpleJob(RuntimeMoniker.NativeAot70)] // compiles the benchmarks as net7.0 and uses the latest NativeAOT to build a native app
public class TheTypeWithBenchmarks
{
   [Benchmark] // the benchmarks go here
}
</code></pre>
<h3 id="customization">Customization</h3>
<p>If you want to benchmark some particular version of NativeAOT (or from a different NuGet feed) you have to specify it in an explicit way:</p>
<pre><code class="lang-cs">var config = DefaultConfig.Instance
    .AddJob(Job.ShortRun
        .WithToolchain(NativeAotToolchain.CreateBuilder()
            .UseNuGet(
                microsoftDotNetILCompilerVersion: &quot;7.0.0-*&quot;, // the version goes here
                nuGetFeedUrl: &quot;https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet7/nuget/v3/index.json&quot;) // this address might change over time
            .DisplayName(&quot;NativeAOT NuGet&quot;)
            .TargetFrameworkMoniker(&quot;net7.0&quot;)
            .ToToolchain()));
</code></pre>
<p>The builder allows to configure more settings:</p>
<ul>
<li>specify packages restore path by using <code>PackagesRestorePath($path)</code></li>
<li>rooting all application assemblies by using <code>RootAllApplicationAssemblies($bool)</code>. This is disabled by default.</li>
<li>generating complete type metadata by using <code>IlcGenerateCompleteTypeMetadata($bool)</code>. This option is enabled by default.</li>
<li>generating stack trace metadata by using <code>IlcGenerateStackTraceData($bool)</code>. This option is enabled by default.</li>
<li>set optimization preference by using <code>IlcOptimizationPreference($value)</code>. The default is <code>Speed</code>, you can configure it to <code>Size</code> or nothing</li>
<li>set instruction set for the target OS, architecture and hardware by using <code>IlcInstructionSet($value)</code>. By default BDN recognizes most of the instruction sets on your machine and enables them.</li>
</ul>
<p>BenchmarkDotNet supports <a href="https://github.com/dotnet/runtime/blob/main/src/coreclr/nativeaot/docs/rd-xml-format.md">rd.xml</a> files. To get given file respected by BenchmarkDotNet you need to place it in the same folder as the project that defines benchmarks and name it <code>rd.xml</code> or in case of multiple files give them <code>.rd.xml</code> extension. The alternative to <code>rd.xml</code> files is annotating types with <a href="https://devblogs.microsoft.com/dotnet/app-trimming-in-net-5/">DynamicallyAccessedMembers</a> attribute.</p>
<p>If given benchmark is not supported by NativeAOT, you need to apply <code>[AotFilter]</code> attribute for it. Example:</p>
<pre><code class="lang-cs">[Benchmark]
[AotFilter(&quot;Not supported by design.&quot;)]
public object CreateInstanceNames() =&gt; System.Activator.CreateInstance(_assemblyName, _typeName);
</code></pre>
<h3 id="generated-files">Generated files</h3>
<p>By default BenchmarkDotNet removes the generates files after finishing the run. To keep them on the disk  you need to pass <code>--keepFiles true</code> command line argument or apply <code>[KeepBenchmarkFiles]</code> attribute to the class which defines benchmark(s). Then, read the folder from the tool output. In the example below it's <code>D:\projects\performance\artifacts\bin\MicroBenchmarks\Release\net7.0\Job-KRLVKQ</code>:</p>
<pre><code class="lang-log">// ***** Building 1 exe(s) in Parallel: Start   *****
// start dotnet  restore -r win-x64 /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in D:\projects\performance\artifacts\bin\MicroBenchmarks\Release\net7.0\Job-KRLVKQ
// command took 2.74s and exited with 0
// start dotnet  build -c Release -r win-x64 --no-restore /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in D:\projects\performance\artifacts\bin\MicroBenchmarks\Release\net7.0\Job-KRLVKQ
// command took 3.82s and exited with 0
</code></pre>
<p>If you go to <code>D:\projects\performance\artifacts\bin\MicroBenchmarks\Release\net7.0\Job-KRLVKQ</code>, you can see the generated project file (named <code>BenchmarkDotNet.Autogenerated.csproj</code>), code (file name ends with <code>.notcs</code>) and find the native executable (in the <code>bin\**\native</code> subfolder). Example:</p>
<pre><code class="lang-cmd">cd D:\projects\performance\artifacts\bin\MicroBenchmarks\Release\net7.0\Job-KRLVKQ
cat .\BenchmarkDotNet.Autogenerated.csproj
</code></pre>
<pre><code class="lang-log">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;
  &lt;PropertyGroup&gt;
    &lt;ImportDirectoryBuildProps&gt;false&lt;/ImportDirectoryBuildProps&gt;
    &lt;ImportDirectoryBuildTargets&gt;false&lt;/ImportDirectoryBuildTargets&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net7.0&lt;/TargetFramework&gt;
    &lt;RuntimeIdentifier&gt;win-x64&lt;/RuntimeIdentifier&gt;
    &lt;RuntimeFrameworkVersion&gt;&lt;/RuntimeFrameworkVersion&gt;
    &lt;AssemblyName&gt;Job-KRLVKQ&lt;/AssemblyName&gt;
    &lt;AssemblyTitle&gt;Job-KRLVKQ&lt;/AssemblyTitle&gt;
    &lt;AllowUnsafeBlocks&gt;true&lt;/AllowUnsafeBlocks&gt;
    &lt;PlatformTarget&gt;x64&lt;/PlatformTarget&gt;
    &lt;TreatWarningsAsErrors&gt;False&lt;/TreatWarningsAsErrors&gt;
    &lt;DebugSymbols&gt;false&lt;/DebugSymbols&gt;
    &lt;UseSharedCompilation&gt;false&lt;/UseSharedCompilation&gt;
    &lt;Deterministic&gt;true&lt;/Deterministic&gt;
    &lt;RunAnalyzers&gt;false&lt;/RunAnalyzers&gt;
    &lt;IlcOptimizationPreference&gt;Speed&lt;/IlcOptimizationPreference&gt;
    &lt;TrimMode&gt;link&lt;/TrimMode&gt;&lt;TrimmerDefaultAction&gt;link&lt;/TrimmerDefaultAction&gt;
    &lt;IlcGenerateCompleteTypeMetadata&gt;True&lt;/IlcGenerateCompleteTypeMetadata&gt;
    &lt;IlcGenerateStackTraceData&gt;True&lt;/IlcGenerateStackTraceData&gt;
    &lt;EnsureNETCoreAppRuntime&gt;false&lt;/EnsureNETCoreAppRuntime&gt;
    &lt;ValidateExecutableReferencesMatchSelfContained&gt;false&lt;/ValidateExecutableReferencesMatchSelfContained&gt;
  &lt;/PropertyGroup&gt;
  &lt;PropertyGroup&gt;
    &lt;ServerGarbageCollection&gt;false&lt;/ServerGarbageCollection&gt;
    &lt;ConcurrentGarbageCollection&gt;true&lt;/ConcurrentGarbageCollection&gt;
  &lt;/PropertyGroup&gt;
  &lt;ItemGroup&gt;
    &lt;Compile Include=&quot;Job-KRLVKQ.notcs&quot; Exclude=&quot;bin\**;obj\**;**\*.xproj;packages\**&quot; /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;PackageReference Include=&quot;Microsoft.DotNet.ILCompiler&quot; Version=&quot;7.0.0-*&quot; /&gt;
    &lt;ProjectReference Include=&quot;D:\projects\performance\src\benchmarks\micro\MicroBenchmarks.csproj&quot; /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;RdXmlFile Include=&quot;bdn_generated.rd.xml&quot; /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;IlcArg Include=&quot;--instructionset:base,sse,sse2,sse3,sse4.1,sse4.2,avx,avx2,aes,bmi,bmi2,fma,lzcnt,pclmul,popcnt&quot; /&gt;
  &lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
<h3 id="compiling-source-to-native-code-using-the-ilcompiler-you-built">Compiling source to native code using the ILCompiler you built</h3>
<p>If you are a NativeAOT contributor and you want to benchmark your local build of NativeAOT you have to provide necessary info (path to shipping packages).</p>
<p>You can do that from command line:</p>
<pre><code class="lang-cmd">dotnet run -c Release -f net7.0 --runtimes nativeaot7.0 --ilcPackages D:\projects\runtime\artifacts\packages\Release\Shipping\
</code></pre>
<p>or explicitly in the code:</p>
<pre><code class="lang-cs">var config = DefaultConfig.Instance
    .AddJob(Job.ShortRun
        .WithToolchain(NativeAotToolchain.CreateBuilder()
            .UseLocalBuild(@&quot;C:\Projects\runtime\artifacts\packages\Release\Shipping\&quot;)
            .DisplayName(&quot;NativeAOT local build&quot;)
            .TargetFrameworkMoniker(&quot;net7.0&quot;)
            .ToToolchain()));
</code></pre>
<p>BenchmarkDotNet is going to follow <a href="https://github.com/dotnet/runtime/blob/main/docs/workflow/building/coreclr/nativeaot.md#building">these instructrions</a> to get it working for you.</p>
<p><strong>Note</strong>: BenchmarkDotNet is going to run <code>dotnet restore</code> on the auto-generated project and restore the packages to a temporary folder. It might take some time, but the next time you rebuild dotnet/runtime repo and run the same command BenchmarkDotNet is going to use the new ILCompiler package.</p>
<h2 id="wasm">Wasm</h2>
<p>BenchmarkDotNet supports Web Assembly on Unix! However, currently you need to build the <strong>dotnet runtime</strong> yourself to be able to run the benchmarks.</p>
<p>For up-to-date docs, you should visit <a href="https://github.com/dotnet/runtime/blob/main/docs/workflow/testing/libraries/testing-wasm.md">dotnet/runtime repository</a>.</p>
<p>The docs below are specific to Ubuntu 18.04 at the moment of writing this document (16/07/2020).</p>
<p>Firs of all, you need to install.... <strong>npm</strong> 10+:</p>
<pre><code class="lang-cmd">curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -
sudo apt install nodejs
</code></pre>
<p>After this, you need to install <a href="https://github.com/GoogleChromeLabs/jsvu">jsvu</a>:</p>
<pre><code class="lang-cmd">npm install jsvu -g
</code></pre>
<p>Add it to PATH:</p>
<pre><code class="lang-cmd">export PATH=&quot;${HOME}/.jsvu:${PATH}&quot;
</code></pre>
<p>And use it to install V8, JavaScriptCore and SpiderMonkey:</p>
<pre><code class="lang-cmd">jsvu --os=linux64 --engines=javascriptcore,spidermonkey,v8
</code></pre>
<p>Now you need to install <a href="https://emscripten.org/docs/getting_started/downloads.html#installation-instructions">Emscripten</a>:</p>
<pre><code class="lang-cmd">git clone https://github.com/emscripten-core/emsdk.git
cd emsdk
./emsdk install latest
./emsdk activate latest
source ./emsdk_env.sh
</code></pre>
<p>The last thing before cloning dotnet/runtime repository is creation of <code>EMSDK_PATH</code> env var used by Mono build scripts:</p>
<pre><code class="lang-cmd">export EMSDK_PATH=$EMSDK
</code></pre>
<p>Now you need to clone dotnet/runtime repository:</p>
<pre><code class="lang-cmd">git clone https://github.com/dotnet/runtime
cd runtime
</code></pre>
<p>Install <a href="https://github.com/dotnet/runtime/blob/main/docs/workflow/testing/libraries/testing-wasm.md">all Mono prerequisites</a>:</p>
<pre><code class="lang-cmd">sudo apt-get install cmake llvm-9 clang-9 autoconf automake libtool build-essential python curl git lldb-6.0 liblldb-6.0-dev libunwind8 libunwind8-dev gettext libicu-dev liblttng-ust-dev libssl-dev libnuma-dev libkrb5-dev zlib1g-dev
</code></pre>
<p>And FINALLY build Mono Runtime with Web Assembly support:</p>
<pre><code class="lang-cmd">./build.sh --arch wasm --os Browser -c release
</code></pre>
<p>And that you have .NET 5 feed added to your <code>nuget.config</code> file:</p>
<pre><code class="lang-xml">&lt;add key=&quot;dotnet5&quot; value=&quot;https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5/nuget/v3/index.json&quot; /&gt;
</code></pre>
<p>Now you should be able to run the Wasm benchmarks!</p>
<h2 id="sample-introwasm">Sample: IntroWasm</h2>
<p>WasmToolchain uses a local Mono Runtime build to run the benchmarks compiled as WebAssembly using V8 JavaScript Engine.</p>
<h3 id="source-code">Source code</h3>
<pre><code class="lang-csharp" name="IntroInProcess.cs">using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;
using BenchmarkDotNet.Toolchains;
using BenchmarkDotNet.Toolchains.DotNetCli;
using BenchmarkDotNet.Toolchains.MonoWasm;

namespace BenchmarkDotNet.Samples
{
    // *** Command Line Arguments ***
    public class IntroWasmCmdConfig
    {
        // the args must contain:
        // an information that we want to run benchmark as Wasm:
        // --runtimes Wasm
        // path to dotnet cli
        // --cli /home/adam/projects/runtime/dotnet.sh
        public static void Run(string[] args) =&gt; BenchmarkSwitcher.FromAssembly(typeof(IntroWasmCmdConfig).Assembly).Run(args);

        [Benchmark]
        public void Foo()
        {
            // Benchmark body
        }
    }

    // *** Fluent Config ***
    public class IntroWasmFluentConfig
    {
        public static void Run()
        {
            // the Wasm Toolchain requires two mandatory arguments:
            const string cliPath = @&quot;/home/adam/projects/runtime/dotnet.sh&quot;;

            WasmRuntime runtime = new WasmRuntime(msBuildMoniker: &quot;net5.0&quot;);
            NetCoreAppSettings netCoreAppSettings = new NetCoreAppSettings(
                targetFrameworkMoniker: &quot;net5.0&quot;, runtimeFrameworkVersion: null, name: &quot;Wasm&quot;,
                customDotNetCliPath: cliPath);
            IToolchain toolChain = WasmToolchain.From(netCoreAppSettings);

            BenchmarkRunner.Run&lt;IntroCustomMonoFluentConfig&gt;(DefaultConfig.Instance
                .AddJob(Job.ShortRun.WithRuntime(runtime).WithToolchain(toolChain)));
        }

        [Benchmark]
        public void Foo()
        {
            // Benchmark body
        }
    }
}
</code></pre><h3 id="links">Links</h3>
<ul>
<li><a class="xref" href="toolchains.html">Toolchains</a></li>
<li>The permanent link to this sample: <a class="xref" href="../samples/IntroWasm.html">BenchmarkDotNet.Samples.IntroWasm</a></li>
</ul>
<hr>
<h2 id="monoaotllvm">MonoAotLLVM</h2>
<p>BenchmarkDotNet supports doing Mono AOT runs with both the Mono-Mini compiler and the Mono-LLVM compiler (which uses llvm on the back end).</p>
<p>Using this tool chain requires the following flags:</p>
<pre><code>--runtimes monoaotllvm
--aotcompilerpath &lt;path to mono aot compiler&gt;
--customruntimepack &lt;path to runtime pack&gt;
</code></pre>
<p>and optionally (defaults to mini)</p>
<pre><code>--aotcompilermode &lt;mini|llvm&gt;  
</code></pre>
<p>As of this writing, the mono aot compiler is not available as a seperate download or nuget package. Therefore, it is required to build the compiler in the [dotnet/runtime repository].</p>
<p>The compiler binary (mono-sgen) is built as part of the <code>mono</code> subset, so it can be built (along with the runtime pack) like so (in the root of [dotnet/runtime]).</p>
<p><code>./build.sh -subset mono+libs -c Release</code></p>
<p>The compiler binary should be generated here (modify for your platform):</p>
<pre><code>&lt;runtime root&gt;/artifacts/obj/mono/OSX.x64.Release/mono/mini/mono-sgen
</code></pre>
<p>And the runtime pack should be generated here:</p>
<pre><code>&lt;runtimeroot&gt;artifacts/bin/microsoft.netcore.app.runtime.osx-x64/Release/
</code></pre>

</article>


        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright &copy; 2013â€“2024 .NET Foundation and contributors
        </div>
      </div>
    </footer>
  </body>
</html>
