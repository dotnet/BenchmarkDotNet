<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Diagnostics.Runtime</name>
    </assembly>
    <members>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.SOURCE_PATH_HAS_SOURCE_SERVER">
            <summary>
            InBuffer - Unused.
            OutBuffer - Unused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.TARGET_EXCEPTION_CONTEXT">
            <summary>
            InBuffer - Unused.
            OutBuffer - Machine-specific CONTEXT.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.TARGET_EXCEPTION_THREAD">
            <summary>
            InBuffer - Unused.
            OutBuffer - ULONG system ID of thread.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.TARGET_EXCEPTION_RECORD">
            <summary>
            InBuffer - Unused.
            OutBuffer - EXCEPTION_RECORD64.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_ADDITIONAL_CREATE_OPTIONS">
            <summary>
            InBuffer - Unused.
            OutBuffer - DEBUG_CREATE_PROCESS_OPTIONS.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.SET_ADDITIONAL_CREATE_OPTIONS">
            <summary>
            InBuffer - DEBUG_CREATE_PROCESS_OPTIONS.
            OutBuffer - Unused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_WIN32_MAJOR_MINOR_VERSIONS">
            <summary>
            InBuffer - Unused.
            OutBuffer - ULONG[2] major/minor.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.READ_USER_MINIDUMP_STREAM">
            <summary>
            InBuffer - DEBUG_READ_USER_MINIDUMP_STREAM.
            OutBuffer - Unused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.TARGET_CAN_DETACH">
            <summary>
            InBuffer - Unused.
            OutBuffer - Unused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.SET_LOCAL_IMPLICIT_COMMAND_LINE">
            <summary>
            InBuffer - PTSTR.
            OutBuffer - Unused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_CAPTURED_EVENT_CODE_OFFSET">
            <summary>
            InBuffer - Unused.
            OutBuffer - Event code stream offset.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.READ_CAPTURED_EVENT_CODE_STREAM">
            <summary>
            InBuffer - Unused.
            OutBuffer - Event code stream information.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.EXT_TYPED_DATA_ANSI">
            <summary>
            InBuffer - Input data block.
            OutBuffer - Processed data block.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_EXTENSION_SEARCH_PATH_WIDE">
            <summary>
            InBuffer - Unused.
            OutBuffer - Returned path.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_TEXT_COMPLETIONS_WIDE">
            <summary>
            InBuffer - DEBUG_GET_TEXT_COMPLETIONS_IN.
            OutBuffer - DEBUG_GET_TEXT_COMPLETIONS_OUT.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_CACHED_SYMBOL_INFO">
            <summary>
            InBuffer - ULONG64 cookie.
            OutBuffer - DEBUG_CACHED_SYMBOL_INFO.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.ADD_CACHED_SYMBOL_INFO">
            <summary>
            InBuffer - DEBUG_CACHED_SYMBOL_INFO.
            OutBuffer - ULONG64 cookie.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.REMOVE_CACHED_SYMBOL_INFO">
            <summary>
            InBuffer - ULONG64 cookie.
            OutBuffer - Unused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_TEXT_COMPLETIONS_ANSI">
            <summary>
            InBuffer - DEBUG_GET_TEXT_COMPLETIONS_IN.
            OutBuffer - DEBUG_GET_TEXT_COMPLETIONS_OUT.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.CURRENT_OUTPUT_CALLBACKS_ARE_DML_AWARE">
            <summary>
            InBuffer - Unused.
            OutBuffer - Unused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_OFFSET_UNWIND_INFORMATION">
            <summary>
            InBuffer - ULONG64 offset.
            OutBuffer - Unwind information.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.GET_DUMP_HEADER">
            <summary>
            InBuffer - Unused
            OutBuffer - returned DUMP_HEADER32/DUMP_HEADER64 structure.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.SET_DUMP_HEADER">
            <summary>
            InBuffer - DUMP_HEADER32/DUMP_HEADER64 structure.
            OutBuffer - Unused
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.MIDORI">
            <summary>
            InBuffer - Midori specific
            OutBuffer - Midori specific
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.PROCESS_DESCRIPTORS">
            <summary>
            InBuffer - Unused
            OutBuffer - PROCESS_NAME_ENTRY blocks
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.MISC_INFORMATION">
            <summary>
            InBuffer - Unused
            OutBuffer - MINIDUMP_MISC_INFO_N blocks
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.OPEN_PROCESS_TOKEN">
            <summary>
            InBuffer - Unused
            OutBuffer - ULONG64 as TokenHandle value
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.OPEN_THREAD_TOKEN">
            <summary>
            InBuffer - Unused
            OutBuffer - ULONG64 as TokenHandle value
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.DUPLICATE_TOKEN">
            <summary>
            InBuffer -  ULONG64 as TokenHandle being duplicated
            OutBuffer - ULONG64 as new duplicated TokenHandle
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.QUERY_INFO_TOKEN">
            <summary>
            InBuffer - a ULONG64 as TokenHandle and a ULONG as NtQueryInformationToken() request code
            OutBuffer - NtQueryInformationToken() return
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.CLOSE_TOKEN">
            <summary>
            InBuffer - ULONG64 as TokenHandle
            OutBuffer - Unused
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.WOW_PROCESS">
            <summary>
            InBuffer - ULONG64 for process server identification and ULONG as PID
            OutBuffer - Unused
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.WOW_MODULE">
            <summary>
            InBuffer - ULONG64 for process server identification and PWSTR as module path
            OutBuffer - Unused
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.LIVE_USER_NON_INVASIVE">
            <summary>
            InBuffer - Unused
            OutBuffer - Unused
            return - S_OK if non-invasive user-mode attach, S_FALSE if not (but still live user-mode), E_FAIL otherwise.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_REQUEST.RESUME_THREAD">
            <summary>
            InBuffer - TID
            OutBuffer - Unused
            return - ResumeThreads() return.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_STATUS_FLAGS.INSIDE_WAIT">
            <summary>
               This bit is added in DEBUG_CES_EXECUTION_STATUS notifications when the
               engines execution status is changing due to operations performed during a
               wait, such as making synchronous callbacks. If the bit is not set the
               execution status is changing due to a wait being satisfied.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_STATUS_FLAGS.WAIT_TIMEOUT">
            <summary>
               This bit is added in DEBUG_CES_EXECUTION_STATUS notifications when the
               engines execution status update is coming after a wait has timed-out. It
               indicates that the execution status change was not due to an actual event.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.ECreationDisposition.New">
            <summary>
            Creates a new file. The function fails if a specified file exists.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.ECreationDisposition.CreateAlways">
            <summary>
            Creates a new file, always.
            If a file exists, the function overwrites the file, clears the existing attributes, combines the specified file attributes,
            and flags with FILE_ATTRIBUTE_ARCHIVE, but does not set the security descriptor that the SECURITY_ATTRIBUTES structure specifies.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.ECreationDisposition.OpenExisting">
            <summary>
            Opens a file. The function fails if the file does not exist.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.ECreationDisposition.OpenAlways">
            <summary>
            Opens a file, always.
            If a file does not exist, the function creates a file as if dwCreationDisposition is CREATE_NEW.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.ECreationDisposition.TruncateExisting">
            <summary>
            Opens a file and truncates it so that its size is 0 (zero) bytes. The function fails if the file does not exist.
            The calling process must open the file with the GENERIC_WRITE access right.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Interop.IDebugOutputCallbacks2.Output(Microsoft.Diagnostics.Runtime.Interop.DEBUG_OUTPUT,System.String)">
            <summary>
               This method is not used.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Interop.DEBUG_MODULE_AND_ID">
            <summary>
               Describes a symbol within a module.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_MODULE_AND_ID.ModuleBase">
            <summary>
               The location in the target's virtual address space of the module's base address.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Interop.DEBUG_MODULE_AND_ID.Id">
            <summary>
               The symbol ID of the symbol within the module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopAppDomain.Address">
            <summary>
            Address of the AppDomain.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopAppDomain.Id">
            <summary>
            The AppDomain's ID.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopAppDomain.Name">
            <summary>
            The name of the AppDomain, as specified when the domain was created.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopStaticField.Offset">
            <summary>
            If the field has a well defined offset from the base of the object, return it (otherwise -1). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopStaticField.HasSimpleValue">
            <summary>
            Given an object reference, fetch the address of the field. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopThreadStaticField.Offset">
            <summary>
            If the field has a well defined offset from the base of the object, return it (otherwise -1). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopThreadStaticField.HasSimpleValue">
            <summary>
            Given an object reference, fetch the address of the field. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopInstanceField.Offset">
            <summary>
            If the field has a well defined offset from the base of the object, return it (otherwise -1). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopInstanceField.HasSimpleValue">
            <summary>
            Given an object reference, fetch the address of the field. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.CLRVersion">
            <summary>
            Returns the version of the target process (v2, v4, v45)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.PointerSize">
            <summary>
            Returns the pointer size of the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.ArrayMethodTable">
            <summary>
            Returns the MethodTable for an array of objects.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.Threads">
            <summary>
            Enumerates all managed threads in the process.  Only threads which have previously run managed
            code will be enumerated.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.StringMethodTable">
            <summary>
            Returns the MethodTable for string objects.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.FreeMethodTable">
            <summary>
            Returns the MethodTable for free space markers.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.GetHeap(System.IO.TextWriter)">
            <summary>
            Gets the GC heap of the process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.SystemDomainAddress">
            <summary>
            The address of the system domain in CLR.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.SharedDomainAddress">
            <summary>
            The address of the shared domain in CLR.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.EnumerateMemoryRegions">
            <summary>
            Enumerates regions of memory which CLR has allocated with a description of what data
            resides at that location.  Note that this does not return every chunk of address space
            that CLR allocates.
            </summary>
            <returns>An enumeration of memory regions in the process.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.GetAppDomainByAddress(System.UInt64)">
            <summary>
            Converts an address into an AppDomain.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.Flush">
            <summary>
            Flushes the dac cache.  This function MUST be called any time you expect to call the same function
            but expect different results.  For example, after walking the heap, you need to call Flush before
            attempting to walk the heap again.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Desktop.DesktopRuntimeBase.GetTypeName(Microsoft.Diagnostics.Runtime.Desktop.TypeHandle)">
            <summary>
            
            Returns the name of the type as specified by the TypeHandle.  Note this returns the name as specified by the
            metadata, NOT as you would expect to see it in a C# program.  For example, generics are denoted with a ` and
            the number of params.  Thus a Dictionary (with two type params) would look like:
                System.Collections.Generics.Dictionary`2
            </summary>
            <param name="id">The TypeHandle to get the name of.</param>
            <returns>The name of the type, or null on error.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Desktop.MemoryRegion.ToString">
            <summary>
            Equivalent to GetDisplayString(false).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.SubHeap.AllocPointers">
            <summary>
            The allocation context pointers/limits for this heap.  The keys of this
            dictionary are the allocation pointers, the values of this dictionary are
            the limits.  If an allocation pointer is ever reached while walking a
            segment, you must "skip" past the allocation limit.  That is:
                if (curr_obj is in AllocPointers)
                    curr_obj = AllocPointers[curr_obj] + min_object_size;
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.SubHeap.EphemeralSegment">
            <summary>
            Returns the address of the ephemeral segment.  Users of this API should use
            HeapSegment.Ephemeral instead of this property.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Desktop.SubHeap.EphemeralEnd">
            <summary>
            Returns the actual end of the ephemeral segment.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Desktop.DesktopHeapType.FixGenericsWorker(System.String,System.Int32,System.Int32,System.Text.StringBuilder)">
            <summary>
            A messy version with better performance that doesn't use regular expression.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Architecture">
            <summary>
            The architecture of a process.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Architecture.Unknown">
            <summary>
            Unknown.  Should never be exposed except in case of error.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Architecture.X86">
            <summary>
            x86.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Architecture.Amd64">
            <summary>
            x64
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Architecture.Arm">
            <summary>
            ARM
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrElementType">
            <summary>
            This is a representation of the metadata element type.  These values
            directly correspond with Clr's CorElementType.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Unknown">
            <summary>
            Not one of the other types.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Boolean">
            <summary>
            ELEMENT_TYPE_BOOLEAN
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Char">
            <summary>
            ELEMENT_TYPE_CHAR
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Int8">
            <summary>
            ELEMENT_TYPE_I1
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.UInt8">
            <summary>
            ELEMENT_TYPE_U1
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Int16">
            <summary>
            ELEMENT_TYPE_I2
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.UInt16">
            <summary>
            ELEMENT_TYPE_U2
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Int32">
            <summary>
            ELEMENT_TYPE_I4
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.UInt32">
            <summary>
            ELEMENT_TYPE_U4
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Int64">
            <summary>
            ELEMENT_TYPE_I8
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.UInt64">
            <summary>
            ELEMENT_TYPE_U8
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Float">
            <summary>
            ELEMENT_TYPE_R4
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Double">
            <summary>
            ELEMENT_TYPE_R8
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.String">
            <summary>
            ELEMENT_TYPE_STRING
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Pointer">
            <summary>
            ELEMENT_TYPE_PTR
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Struct">
            <summary>
            ELEMENT_TYPE_VALUETYPE
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Class">
            <summary>
            ELEMENT_TYPE_CLASS
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Array">
            <summary>
            ELEMENT_TYPE_ARRAY
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.NativeInt">
            <summary>
            ELEMENT_TYPE_I
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.NativeUInt">
            <summary>
            ELEMENT_TYPE_U
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.FunctionPointer">
            <summary>
            ELEMENT_TYPE_FNPTR
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Object">
            <summary>
            ELEMENT_TYPE_OBJECT
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.SZArray">
            <summary>
            ELEMENT_TYPE_SZARRAY
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrHeap">
            <summary>
            A ClrHeap is a abstraction for the whole GC Heap.   Subclasses allow you to implement this for 
            a particular kind of heap (whether live,
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetObjectType(System.UInt64)">
            <summary>
            And the ability to take an address of an object and fetch its type (The type alows further exploration)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetExceptionObject(System.UInt64)">
            <summary>
            Returns a  wrapper around a System.Exception object (or one of its subclasses).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetRuntime">
            <summary>
            Returns the runtime associated with this heap.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.Segments">
            <summary>
            A heap is has a list of contiguous memory regions called segments.  This list is returned in order of
            of increasing object addresses.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateRoots">
            <summary>
            Enumerate the roots of the process.  (That is, all objects which keep other objects alive.)
            Equivalent to EnumerateRoots(true).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetTypeByIndex(System.Int32)">
            <summary>
            Returns a type by its index.
            </summary>
            <param name="index">The type to get.</param>
            <returns>The ClrType of that index.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetTypeByName(System.String)">
            <summary>
            Looks up a type by name.
            </summary>
            <param name="name">The name of the type.</param>
            <returns>The ClrType matching 'name', null if the type was not found, and undefined if more than one
            type shares the same name.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.TypeIndexLimit">
            <summary>
            Returns the max index.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateRoots(System.Boolean)">
            <summary>
            Enumerate the roots in the process.
            </summary>
            <param name="enumerateStatics">True if we should enumerate static variables.  Enumerating with statics 
            can take much longer than enumerating without them.  Additionally these will be be "double reported",
            since all static variables are pinned by handles on the HandleTable (which is also enumerated with 
            EnumerateRoots).  You would want to enumerate statics with roots if you care about what exact statics
            root what objects, but not if you care about performance.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateTypes">
            <summary>
            Enumerates all types in the runtime.
            </summary>
            <returns>An enumeration of all types in the target process.  May return null if it's unsupported for
            that version of CLR.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateFinalizableObjects">
            <summary>
            Enumerates all finalizable objects on the heap.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateBlockingObjects">
            <summary>
            Enumerates all managed locks in the process.  That is anything using System.Monitor either explictly
            or implicitly through "lock (obj)".  This is roughly equivalent to combining SOS's !syncblk command
            with !dumpheap -thinlock.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.CanWalkHeap">
            <summary>
            Returns true if the GC heap is in a consistent state for heap enumeration.  This will return false
            if the process was stopped in the middle of a GC, which can cause the GC heap to be unwalkable.
            Note, you may still attempt to walk the heap if this function returns false, but you will likely
            only be able to partially walk each segment.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateObjects">
            <summary>
            Enumerates all objects on the heap.  This is equivalent to enumerating all segments then walking
            each object with ClrSegment.FirstObject, ClrSegment.NextObject, but in a simple enumerator
            for easier use in linq queries.
            </summary>
            <returns>An enumerator for all objects on the heap.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.TotalHeapSize">
            <summary>
            TotalHeapSize is defined as the sum of the length of all segments.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetSizeByGen(System.Int32)">
            <summary>
            Get the size by generation 0, 1, 2, 3.  The large object heap is Gen 3 here. 
            The sum of all of these should add up to the TotalHeapSize.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetGeneration(System.UInt64)">
            <summary>
            Returns the generation of an object.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.NextObject(System.UInt64)">
            <summary>
            Returns the object after this one on the segment.
            </summary>
            <param name="obj">The object to find the next for.</param>
            <returns>The next object on the segment, or 0 if the object was the last one on the segment.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetSegmentByAddress(System.UInt64)">
            <summary>
            Returns the GC segment for the given object.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.IsInHeap(System.UInt64)">
            <summary>
            Returns true if the given address resides somewhere on the managed heap.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.PointerSize">
            <summary>
            Pointer size of on the machine (4 or 8 bytes).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.ToString">
            <summary>
            Returns a string representation of this heap, including the size and number of segments.
            </summary>
            <returns>The string representation of this heap.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.ReadMemory(System.UInt64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read 'count' bytes from the ClrHeap at 'address' placing it in 'buffer' starting at offset 'offset'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.ReadPointer(System.UInt64,System.UInt64@)">
            <summary>
            Attempts to efficiently read a pointer from memory.  This acts exactly like ClrRuntime.ReadPointer, but
            there is a greater chance you will hit a chache for a more efficient memory read.
            </summary>
            <param name="addr">The address to read.</param>
            <param name="value">The pointer value.</param>
            <returns>True if we successfully read the value, false if addr is not mapped into the process space.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.BlockingObject">
            <summary>
            Represents a managed lock within the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.Object">
            <summary>
            The object associated with the lock.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.Taken">
            <summary>
            Whether or not the object is currently locked.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.RecursionCount">
            <summary>
            The recursion count of the lock (only valid if Locked is true).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.Owner">
            <summary>
            The thread which currently owns the lock.  This is only valid if Taken is true and
            only valid if HasSingleOwner is true.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.HasSingleOwner">
            <summary>
            Returns true if this lock has only one owner.  Returns false if this lock
            may have multiple owners (for example, readers on a RW lock).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.Owners">
            <summary>
            Returns the list of owners for this object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.Waiters">
            <summary>
            Returns the list of threads waiting on this object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.BlockingObject.Reason">
            <summary>
            The reason why it's blocking.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.GCRootKind">
            <summary>
            The type of GCRoot that a ClrRoot represnts.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.StaticVar">
            <summary>
            The root is a static variable.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.ThreadStaticVar">
            <summary>
            The root is a thread static.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.LocalVar">
            <summary>
            The root is a local variable (or compiler generated temporary variable).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.Strong">
            <summary>
            The root is a strong handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.Weak">
            <summary>
            The root is a weak handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.Pinning">
            <summary>
            The root is a strong pinning handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.Finalizer">
            <summary>
            The root comes from the finalizer queue.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.AsyncPinning">
            <summary>
            The root is an async IO (strong) pinning handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCRootKind.Max">
            <summary>
            The max value of this enum.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrRoot">
            <summary>
            Represents a root in the target process.  A root is the base entry to the GC's mark and sweep algorithm.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.Kind">
            <summary>
            A GC Root also has a Kind, which says if it is a strong or weak root
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.Name">
            <summary>
            The name of the root. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.Type">
            <summary>
            The type of the object this root points to.  That is, ClrHeap.GetObjectType(ClrRoot.Object).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.Object">
            <summary>
            The object on the GC heap that this root keeps alive.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.Address">
            <summary>
            The address of the root in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.AppDomain">
            <summary>
            If the root can be identified as belonging to a particular AppDomain this is that AppDomain.
            It an be null if there is no AppDomain associated with the root.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.Thread">
            <summary>
            If the root has a thread associated with it, this will return that thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.IsInterior">
            <summary>
            Returns true if Object is an "interior" pointer.  This means that the pointer may actually
            point inside an object instead of to the start of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.IsPinned">
            <summary>
            Returns true if the root "pins" the object, preventing the GC from relocating it.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRoot.IsPossibleFalsePositive">
            <summary>
            Unfortunately some versions of the APIs we consume do not give us perfect information.  If
            this property is true it means we used a heuristic to find the value, and it might not
            actually be considered a root by the GC.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRoot.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
            <returns>A string representation of this object.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrInterface">
            <summary>
            An interface implementation in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInterface.Name">
            <summary>
            The typename of the interface.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInterface.BaseInterface">
            <summary>
            The interface that this interface inherits from.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInterface.ToString">
            <summary>
            Display string for this interface.
            </summary>
            <returns>Display string for this interface.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInterface.Equals(System.Object)">
            <summary>
            Equals override.
            </summary>
            <param name="obj">Object to compare to.</param>
            <returns>True if this interface equals another.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInterface.GetHashCode">
            <summary>
            GetHashCode override.
            </summary>
            <returns>A hashcode for this object.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrType">
            <summary>
            A representation of a type in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Index">
            <summary>
            The index of this type.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.MetadataToken">
            <summary>
            Returns the metadata token of this type.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Name">
            <summary>
            Types have names.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetSize(System.UInt64)">
            <summary>
            GetSize returns the size in bytes for the total overhead of the object 'objRef'.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.EnumerateRefsOfObject(System.UInt64,System.Action{System.UInt64,System.Int32})">
            <summary>
            EnumeationRefsOfObject will call 'action' once for each object reference inside 'objRef'.  
            'action' is passed the address of the outgoing refernece as well as an integer that
            represents the field offset.  While often this is the physical offset of the outgoing
            refernece, abstractly is simply something that can be given to GetFieldForOffset to 
            return the field information for that object reference  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.EnumerateRefsOfObjectCarefully(System.UInt64,System.Action{System.UInt64,System.Int32})">
            <summary>
            Does the same as EnumerateRefsOfObject, but does additional bounds checking to ensure
            we don't loop forever with inconsistent data.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ContainsPointers">
            <summary>
            Returns true if the type CAN contain references to other objects.  This is used in optimizations 
            and 'true' can always be returned safely.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Heap">
            <summary>
            All types know the heap they belong to.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsRuntimeType">
            <summary>
            Returns true if this object is a 'RuntimeType' (that is, the concrete System.RuntimeType class
            which is what you get when calling "typeof" in C#).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetRuntimeType(System.UInt64)">
            <summary>
            Returns the concrete type (in the target process) that this RuntimeType represents.
            Note you may only call this function if IsRuntimeType returns true.
            </summary>
            <param name="obj">The RuntimeType object to get the concrete type for.</param>
            <returns>The underlying type that this RuntimeType actually represents.  May return null if the
                     underlying type has not been fully constructed by the runtime, or if the underlying type
                     is actually a typehandle (which unfortunately ClrMD cannot convert into a ClrType due to
                     limitations in the underlying APIs.  (So always null-check the return value of this
                     function.) </returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Module">
            <summary>
            Returns the module this type is defined in.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ElementType">
            <summary>
            Returns the ElementType of this Type.  Can return ELEMENT_TYPE_VOID on error.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsPrimitive">
            <summary>
            Returns true if this type is a primitive (int, float, etc), false otherwise.
            </summary>
            <returns>True if this type is a primitive (int, float, etc), false otherwise.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsValueClass">
            <summary>
            Returns true if this type is a ValueClass (struct), false otherwise.
            </summary>
            <returns>True if this type is a ValueClass (struct), false otherwise.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsObjectReference">
            <summary>
            Returns true if this type is an object reference, false otherwise.
            </summary>
            <returns>True if this type is an object reference, false otherwise.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Interfaces">
            <summary>
            Returns the list of interfaces this type implements.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.IsFinalizeSuppressed(System.UInt64)">
            <summary>
            Returns true if the finalization is suppressed for an object.  (The user program called
            System.GC.SupressFinalize.  The behavior of this function is undefined if the object itself
            is not finalizable.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsFinalizable">
            <summary>
            Returns whether objects of this type are finalizable.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsPublic">
            <summary>
            Returns true if this type is marked Public.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsPrivate">
            <summary>
            returns true if this type is marked Private.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsInternal">
            <summary>
            Returns true if this type is accessable only by items in its own assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsProtected">
            <summary>
            Returns true if this nested type is accessable only by subtypes of its outer type.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsAbstract">
            <summary>
            Returns true if this class is abstract.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsSealed">
            <summary>
            Returns true if this class is sealed.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsInterface">
            <summary>
            Returns true if this type is an interface.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Fields">
            <summary>
            Returns all possible fields in this type.   It does not return dynamically typed fields.  
            Returns an empty list if there are no fields.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.StaticFields">
            <summary>
            Returns a list of static fields on this type.  Returns an empty list if there are no fields.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ThreadStaticFields">
            <summary>
            Returns a list of thread static fields on this type.  Returns an empty list if there are no fields.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Methods">
            <summary>
            Gets the list of methods this type implements.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetFieldForOffset(System.Int32,System.Boolean,Microsoft.Diagnostics.Runtime.ClrInstanceField@,System.Int32@)">
            <summary>
            When you enumerate a object, the offset within the object is returned.  This offset might represent
            nested fields (obj.Field1.Field2).    GetFieldOffset returns the first of these field (Field1), 
            and 'remaining' offset with the type of Field1 (which must be a struct type).   Calling 
            GetFieldForOffset repeatedly until the childFieldOffset is 0 will retrieve the whole chain.  
            </summary>
            <returns>true if successful.  Will fail if it 'this' is an array type</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetFieldByName(System.String)">
            <summary>
            Returns the field given by 'name', case sensitive.  Returns NULL if no such field name exists (or on error).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetStaticFieldByName(System.String)">
            <summary>
            Returns the field given by 'name', case sensitive.  Returns NULL if no such field name exists (or on error).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetFieldValue(System.UInt64,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Convenience function which dereferences fields.  For example, if you wish to dereference m_foo.m_bar.m_baz, you can pass:
            { "m_foo", "m_bar", "m_baz" } into this function's second parameter to dereference those fields to get the value.
            Throws Exception if a field you expect does not exist.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.TryGetFieldValue(System.UInt64,System.Collections.Generic.ICollection{System.String},System.Object@)">
            <summary>
            Same as GetFieldValue but returns true on success, false on failure, and does not throw.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.BaseType">
            <summary>
            If this type inherits from another type, this is that type.  Can return null if it does not inherit (or is unknown)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.IsCCW(System.UInt64)">
            <summary>
            Returns true if the given object is a Com-Callable-Wrapper.  This is only supported in v4.5 and later.
            </summary>
            <param name="obj">The object to check.</param>
            <returns>True if this is a CCW.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetCCWData(System.UInt64)">
            <summary>
            Returns the CCWData for the given object.  Note you may only call this function if IsCCW returns true.
            </summary>
            <returns>The CCWData associated with the object, undefined result of obj is not a CCW.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.IsRCW(System.UInt64)">
            <summary>
            Returns true if the given object is a Runtime-Callable-Wrapper.  This is only supported in v4.5 and later.
            </summary>
            <param name="obj">The object to check.</param>
            <returns>True if this is an RCW.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetRCWData(System.UInt64)">
            <summary>
            Returns the RCWData for the given object.  Note you may only call this function if IsRCW returns true.
            </summary>
            <returns>The RCWData associated with the object, undefined result of obj is not a RCW.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsArray">
            <summary>
            A type is an array if you can use the array operators below, Abstractly arrays are objects 
            that whose children are not statically known by just knowing the type.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ArrayComponentType">
            <summary>
            Gets the type of the elements in the array.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetArrayLength(System.UInt64)">
            <summary>
            If the type is an array, then GetArrayLength returns the number of elements in the array.  Undefined
            behavior if this type is not an array.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetArrayElementAddress(System.UInt64,System.Int32)">
            <summary>
            Returns the absolute address to the given array element.  You may then make a direct memory read out
            of the process to get the value if you want.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetArrayElementValue(System.UInt64,System.Int32)">
            <summary>
            Returns the array element value at the given index.  Returns 'null' if the array element is of type
            VALUE_CLASS.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ElementSize">
            <summary>
            Returns the size of individual elements of an array.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.BaseSize">
            <summary>
            Returns the base size of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsString">
            <summary>
            Returns true if this type is System.String.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsFree">
            <summary>
            Returns true if this type represents free space on the heap.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsException">
            <summary>
            Returns true if this type is an exception (that is, it derives from System.Exception).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsEnum">
            <summary>
            Returns true if this type is an enum.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetEnumElementType">
            <summary>
            Returns the element type of this enum.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetEnumNames">
            <summary>
            Returns a list of names in the enum.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetEnumName(System.Object)">
            <summary>
            Gets the name of the value in the enum, or null if the value doesn't have a name.
            This is a convenience function, and has undefined results if the same value appears
            twice in the enum.
            </summary>
            <param name="value">The value to lookup.</param>
            <returns>The name of one entry in the enum with this value, or null if none exist.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetEnumName(System.Int32)">
            <summary>
            Gets the name of the value in the enum, or null if the value doesn't have a name.
            This is a convenience function, and has undefined results if the same value appears
            twice in the enum.
            </summary>
            <param name="value">The value to lookup.</param>
            <returns>The name of one entry in the enum with this value, or null if none exist.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.TryGetEnumValue(System.String,System.Int32@)">
            <summary>
            Attempts to get the integer value for a given enum entry.  Note you should only call this function if
            GetEnumElementType returns ELEMENT_TYPE_I4.
            </summary>
            <param name="name">The name of the value to get (taken from GetEnumNames).</param>
            <param name="value">The value to write out.</param>
            <returns>True if we successfully filled value, false if 'name' is not a part of the enumeration.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.TryGetEnumValue(System.String,System.Object@)">
            <summary>
            Attempts to get the value for a given enum entry.  The type of "value" can be determined by the
            return value of GetEnumElementType.
            </summary>
            <param name="name">The name of the value to get (taken from GetEnumNames).</param>
            <param name="value">The value to write out.</param>
            <returns>True if we successfully filled value, false if 'name' is not a part of the enumeration.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.HasSimpleValue">
            <summary>
            Returns true if instances of this type have a simple value.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetValue(System.UInt64)">
            <summary>
            Returns the simple value of an instance of this type.  Undefined behavior if HasSimpleValue returns false.
            For example ELEMENT_TYPE_I4 is an "int" and the return value of this function would be an int.
            </summary>
            <param name="address">The address of an instance of this type.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
            <returns>A string representation of this object.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrField">
            <summary>
            A representation of a field in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.Name">
            <summary>
            The name of the field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.Type">
            <summary>
            The type of the field.  Note this property may return null on error.  There is a bug in several versions
            of our debugging layer which causes this.  You should always null-check the return value of this field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.ElementType">
            <summary>
            Returns the element type of this field.  Note that even when Type is null, this should still tell you
            the element type of the field.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrField.IsPrimitive">
            <summary>
            Returns true if this field is a primitive (int, float, etc), false otherwise.
            </summary>
            <returns>True if this field is a primitive (int, float, etc), false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrField.IsValueClass">
            <summary>
            Returns true if this field is a ValueClass (struct), false otherwise.
            </summary>
            <returns>True if this field is a ValueClass (struct), false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrField.IsObjectReference">
            <summary>
            Returns true if this field is an object reference, false otherwise.
            </summary>
            <returns>True if this field is an object reference, false otherwise.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.Size">
            <summary>
            Gets the size of this field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.IsPublic">
            <summary>
            Returns true if this field is public.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.IsPrivate">
            <summary>
            Returns true if this field is private.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.IsInternal">
            <summary>
            Returns true if this field is internal.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.IsProtected">
            <summary>
            Returns true if this field is protected.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.HasSimpleValue">
            <summary>
            Returns true if this field has a simple value (meaning you may call "GetFieldValue" in one of the subtypes
            of this class).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.Offset">
            <summary>
            If the field has a well defined offset from the base of the object, return it (otherwise -1). 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrField.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
            <returns>A string representation of this object.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrInstanceField">
            <summary>
            Represents an instance field of a type.   Fundamentally it respresents a name and a type 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetFieldValue(System.UInt64)">
            <summary>
            Obsolete.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetFieldValue(System.UInt64,System.Boolean)">
            <summary>
            Obsolete.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetFieldAddress(System.UInt64)">
            <summary>
            Obsolete.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetFieldAddress(System.UInt64,System.Boolean)">
            <summary>
            Obsolete.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetValue(System.UInt64)">
            <summary>
            Returns the value of this field.  Equivalent to GetFieldValue(objRef, false).
            </summary>
            <param name="objRef">The object to get the field value for.</param>
            <returns>The value of the field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetValue(System.UInt64,System.Boolean)">
            <summary>
            Returns the value of this field, optionally specifying if this field is
            on a value class which is on the interior of another object.
            </summary>
            <param name="objRef">The object to get the field value for.</param>
            <param name="interior">Whether the enclosing type of this field is a value class,
            and that value class is embedded in another object.</param>
            <returns>The value of the field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetAddress(System.UInt64)">
            <summary>
            Returns the address of the value of this field.  Equivalent to GetFieldAddress(objRef, false).
            </summary>
            <param name="objRef">The object to get the field address for.</param>
            <returns>The value of the field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetAddress(System.UInt64,System.Boolean)">
            <summary>
            Returns the address of the value of this field.  Equivalent to GetFieldAddress(objRef, false).
            </summary>
            <param name="objRef">The object to get the field address for.</param>
            <param name="interior">Whether the enclosing type of this field is a value class,
            and that value class is embedded in another object.</param>
            <returns>The value of the field.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrStaticField">
            <summary>
            Represents a static field in the target process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.GetFieldValue(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Obsolete.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.GetFieldAddress(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Obsolete.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.IsInitialized(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Returns whether this static field has been initialized in a particular AppDomain
            or not.  If a static variable has not been initialized, then its class constructor
            may have not been run yet.  Calling GetFieldValue on an uninitialized static
            will result in returning either NULL or a value of 0.
            </summary>
            <param name="appDomain">The AppDomain to see if the variable has been initialized.</param>
            <returns>True if the field has been initialized (even if initialized to NULL or a default
            value), false if the runtime has not initialized this variable.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.GetValue(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Gets the value of the static field.
            </summary>
            <param name="appDomain">The AppDomain in which to get the value.</param>
            <returns>The value of this static field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.GetAddress(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Returns the address of the static field's value in memory.
            </summary>
            <param name="appDomain">The AppDomain in which to get the field's address.</param>
            <returns>The address of the field's value.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStaticField.HasDefaultValue">
            <summary>
            Returns true if the static field has a default value (and if we can obtain it).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.GetDefaultValue">
            <summary>
            The default value of the field.
            </summary>
            <returns>The default value of the field.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrThreadStaticField">
            <summary>
            Represents a thread static value in the target process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadStaticField.GetFieldValue(Microsoft.Diagnostics.Runtime.ClrAppDomain,Microsoft.Diagnostics.Runtime.ClrThread)">
            <summary>
            Obsolete.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadStaticField.GetFieldAddress(Microsoft.Diagnostics.Runtime.ClrAppDomain,Microsoft.Diagnostics.Runtime.ClrThread)">
            <summary>
            Obsolete.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadStaticField.GetValue(Microsoft.Diagnostics.Runtime.ClrAppDomain,Microsoft.Diagnostics.Runtime.ClrThread)">
            <summary>
            Gets the value of the field.
            </summary>
            <param name="appDomain">The AppDomain in which to get the field's value.</param>
            <param name="thread">The thread on which to get the field's value.</param>
            <returns>The value of the field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadStaticField.GetAddress(Microsoft.Diagnostics.Runtime.ClrAppDomain,Microsoft.Diagnostics.Runtime.ClrThread)">
            <summary>
            Gets the address of the field.
            </summary>
            <param name="appDomain">The AppDomain in which to get the field's address.</param>
            <param name="thread">The thread on which to get the field's address.</param>
            <returns>The address of the field.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrException">
            <summary>
            A wrapper class for exception objects which help with common tasks for exception objects.
            Create this using GCHeap.GetExceptionObject.  You may call that when GCHeapType.IsException
            returns true.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.Type">
            <summary>
            Returns the GCHeapType for this exception object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.Message">
            <summary>
            Returns the exception message.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.Address">
            <summary>
            Returns the address of the exception object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.Inner">
            <summary>
            Returns the inner exception, if one exists, null otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.HResult">
            <summary>
            Returns the HRESULT associated with this exception (or S_OK if there isn't one).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.StackTrace">
            <summary>
            Returns the StackTrace for this exception.  Note that this may be empty or partial depending
            on the state of the exception in the process.  (It may have never been thrown or we may be in
            the middle of constructing the stackwalk.)  This returns an empty list if no stack trace is
            associated with this exception object.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrSegment">
            <summary>
            A GCHeapSegment represents a contiguous region of memory that is devoted to the GC heap. 
            Segments.  It has a start and end and knows what heap it belongs to.   Segments can
            optional have regions for Gen 0, 1 and 2, and Large properties.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Start">
            <summary>
            The start address of the segment.  All objects in this segment fall within Start &lt;= object &lt; End.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.End">
            <summary>
            The end address of the segment.  All objects in this segment fall within Start &lt;= object &lt; End.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Length">
            <summary>
            The number of bytes in the segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Heap">
            <summary>
            The GC heap associated with this segment.  There's only one GCHeap per process, so this is
            only a convenience method to keep from having to pass the heap along with a segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.ProcessorAffinity">
            <summary>
            The processor that this heap is affinitized with.  In a workstation GC, there is no processor
            affinity (and the return value of this property is undefined).  In a server GC each segment
            has a logical processor in the PC associated with it.  This property returns that logical
            processor number (starting at 0).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Reserved">
            <summary>
            The address of the end of memory reserved for the segment, but not committed.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Committed">
            <summary>
            The address of the end of memory committed for the segment (this may be longer than Length).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.ReservedEnd">
            <summary>
            The address of the end of memory reserved for the segment, but not committed.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.CommittedEnd">
            <summary>
            The address of the end of memory committed for the segment (this may be longer than Length).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.FirstObject">
            <summary>
            If it is possible to move from one object to the 'next' object in the segment. 
            Then FirstObject returns the first object in the heap (or null if it is not
            possible to walk the heap.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrSegment.NextObject(System.UInt64)">
            <summary>
            Given an object on the segment, return the 'next' object in the segment.  Returns
            0 when there are no more objects.   (Or enumeration is not possible)  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.IsLarge">
            <summary>
            Returns true if this is a segment for the Large Object Heap.  False otherwise.
            Large objects (greater than 85,000 bytes in size), are stored in their own segments and
            only collected on full (gen 2) collections. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Large">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.IsEphemeral">
            <summary>
            Returns true if this segment is the ephemeral segment (meaning it contains gen0 and gen1
            objects).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Ephemeral">
            <summary>
            Obsolete.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Gen0Start">
            <summary>
            Ephemeral heap sements have geneation 0 and 1 in them.  Gen 1 is always above Gen 2 and
            Gen 0 is above Gen 1.  This property tell where Gen 0 start in memory.   Note that
            if this is not an Ephemeral segment, then this will return End (which makes Gen 0 empty
            for this segment)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Gen0Length">
            <summary>
            The length of the gen0 portion of this segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Gen1Start">
            <summary>
            The start of the gen1 portion of this segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Gen1Length">
            <summary>
            The length of the gen1 portion of this segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Gen2Start">
            <summary>
            The start of the gen2 portion of this segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Gen2Length">
            <summary>
            The length of the gen2 portion of this segment.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrSegment.EnumerateObjects">
            <summary>
            Enumerates all objects on the segment.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrSegment.GetGeneration(System.UInt64)">
            <summary>
            Returns the generation of an object in this segment.
            </summary>
            <param name="obj">An object in this segment.</param>
            <returns>The generation of the given object if that object lies in this segment.  The return
                     value is undefined if the object does not lie in this segment.
            </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrSegment.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
            <returns>A string representation of this object.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrStackFrameType">
            <summary>
            The type of frame the ClrStackFrame represents.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrStackFrameType.ManagedMethod">
            <summary>
            Indicates this stack frame is a standard managed method.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrStackFrameType.Runtime">
            <summary>
            Indicates this stack frame is a special stack marker that the Clr runtime leaves on the stack.
            Note that the ClrStackFrame may still have a ClrMethod associated with the marker.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrStackFrame">
            <summary>
            A frame in a managed stack trace.  Note you can call ToString on an instance of this object to get the
            function name (or clr!Frame name) similar to SOS's !clrstack output.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.InstructionPointer">
            <summary>
            The instruction pointer of this frame.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.StackPointer">
            <summary>
            The stack pointer of this frame.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.Kind">
            <summary>
            The type of frame (managed or internal).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.DisplayString">
            <summary>
            The string to display in a stack trace.  Similar to !clrstack output.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.Method">
            <summary>
            Returns the ClrMethod which corresponds to the current stack frame.  This may be null if the
            current frame is actually a CLR "Internal Frame" representing a marker on the stack, and that
            stack marker does not have a managed method associated with it.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStackFrame.GetFileAndLineNumber">
            <summary>
            Returns the source file and line number of the location represented by this stack frame.
            This will return null if the location cannot be determined (or the module containing it does
            not have PDBs loaded).
            </summary>
            <returns>The file and line number for this stack frame, null if not found.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.SourceLocation">
            <summary>
            A SourceLocation represents a point in the source code.  That is the file and the line number.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.SourceLocation.FilePath">
            <summary>
            The source file for the code
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.SourceLocation.LineNumber">
            <summary>
            The line number for the code.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.SourceLocation.LineNumberEnd">
            <summary>
            The end line number of the location (if multiline this will be different from LineNumber).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.SourceLocation.ColStart">
            <summary>
            The start column of the source line.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.SourceLocation.ColEnd">
            <summary>
            The end column of the source line.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.SourceLocation.ToString">
            <summary>
            Generates a human readable form of the source location.
            </summary>
            <returns>File:Line-Line</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ILOffsetSourceLocation">
            <summary>
            Contains the mapping of IL Offset -> Source Location
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.GcMode">
            <summary>
            Defines the state of the thread from the runtime's perspective.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GcMode.Cooperative">
            <summary>
            In Cooperative mode the thread must cooperate before a GC may proceed.  This means when a GC
            starts, the runtime will attempt to suspend the thread at a safepoint but cannot immediately
            stop the thread until it synchronizes.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GcMode.Preemptive">
            <summary>
            In Preemptive mode the runtime is free to suspend the thread at any time for a GC to occur.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrThread">
            <summary>
            Represents a managed thread in the target process.  Note this does not wrap purely native threads
            in the target process (that is, threads which have never run managed code before).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.GcMode">
            <summary>
            The suspension state of the thread according to the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsFinalizer">
            <summary>
            Returns true if this is the finalizer thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.Address">
            <summary>
            The address of the underlying datastructure which makes up the Thread object.  This
            serves as a unique identifier.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsAlive">
            <summary>
            Returns true if the thread is alive in the process, false if this thread was recently terminated.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.OSThreadId">
            <summary>
            The OS thread id for the thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.ManagedThreadId">
            <summary>
            The managed thread ID (this is equivalent to System.Threading.Thread.ManagedThreadId
            in the target process).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.AppDomain">
            <summary>
            The AppDomain the thread is running in.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.LockCount">
            <summary>
            The number of managed locks (Monitors) the thread has currently entered but not left.
            This will be highly inconsistent unless the process is stopped.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.Teb">
            <summary>
            The TEB (thread execution block) address in the process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.StackBase">
            <summary>
            The base of the stack for this thread, or 0 if the value could not be obtained.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.StackLimit">
            <summary>
            The limit of the stack for this thread, or 0 if the value could not be obtained.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThread.EnumerateStackObjects">
            <summary>
            Enumerates the GC references (objects) on the stack.  This is equivalent to
            EnumerateStackObjects(true).
            </summary>
            <returns>An enumeration of GC references on the stack as the GC sees them.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThread.EnumerateStackObjects(System.Boolean)">
            <summary>
            Enumerates the GC references (objects) on the stack.
            </summary>
            <param name="includePossiblyDead">Include all objects found on the stack.  Passing
            false attempts to replicate the behavior of the GC, reporting only live objects.</param>
            <returns>An enumeration of GC references on the stack as the GC sees them.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.StackTrace">
            <summary>
            Returns the managed stack trace of the thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.CurrentException">
            <summary>
            Returns the exception currently on the thread.  Note that this field may be null.  Also note
            that this is basically the "last thrown exception", and may be stale...meaning the thread could
            be done processing the exception but a crash dump was taken before the current exception was
            cleared off the field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsGC">
            <summary>
            Returns if this thread is a GC thread.  If the runtime is using a server GC, then there will be
            dedicated GC threads, which this will indicate.  For a runtime using the workstation GC, this flag
            will only be true for a thread which is currently running a GC (and the background GC thread).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsDebuggerHelper">
            <summary>
            Returns if this thread is the debugger helper thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsThreadpoolTimer">
            <summary>
            Returns true if this thread is a threadpool timer thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsThreadpoolCompletionPort">
            <summary>
            Returns true if this thread is a threadpool IO completion port.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsThreadpoolWorker">
            <summary>
            Returns true if this is a threadpool worker thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsThreadpoolWait">
            <summary>
            Returns true if this is a threadpool wait thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsThreadpoolGate">
            <summary>
            Returns true if this is the threadpool gate thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsSuspendingEE">
            <summary>
            Returns if this thread currently suspending the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsShutdownHelper">
            <summary>
            Returns true if this thread is currently the thread shutting down the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsAbortRequested">
            <summary>
            Returns true if an abort was requested for this thread (such as Thread.Abort, or AppDomain unload).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsAborted">
            <summary>
            Returns true if this thread was aborted.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsGCSuspendPending">
            <summary>
            Returns true if the GC is attempting to suspend this thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsUserSuspended">
            <summary>
            Returns true if the user has suspended the thread (using Thread.Suspend).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsDebugSuspended">
            <summary>
            Returns true if the debugger has suspended the thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsBackground">
            <summary>
            Returns true if this thread is a background thread.  (That is, if the thread does not keep the
            managed execution environment alive and running.)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsUnstarted">
            <summary>
            Returns true if this thread was created, but not started.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsCoInitialized">
            <summary>
            Returns true if the Clr runtime called CoIntialize for this thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsSTA">
            <summary>
            Returns true if this thread is in a COM single threaded apartment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsMTA">
            <summary>
            Returns true if the thread is a COM multithreaded apartment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.BlockingObjects">
            <summary>
            Returns the object this thread is blocked waiting on, or null if the thread is not blocked.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.BlockingReason">
            <summary>
            Every thread which is blocking on an object specifies why the object is waiting.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.None">
            <summary>
            Object is not locked.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.Unknown">
            <summary>
            Not able to determine why the object is blocking.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.Monitor">
            <summary>
            The thread is waiting for a Mutex or Semaphore (such as Monitor.Enter, lock(obj), etc).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.MonitorWait">
            <summary>
            The thread is waiting for a mutex with Monitor.Wait.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.WaitOne">
            <summary>
            The thread is waiting for an event (ManualResetEvent.WaitOne, AutoResetEvent.WaitOne).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.WaitAll">
            <summary>
            The thread is waiting in WaitHandle.WaitAll.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.WaitAny">
            <summary>
            The thread is waiting in WaitHandle.WaitAny.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.ThreadJoin">
            <summary>
            The thread is blocked on a call to Thread.Join.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.ReaderAcquired">
            <summary>
            ReaderWriterLock, reader lock is taken.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.BlockingReason.WriterAcquired">
            <summary>
            ReaderWriterLock, writer lock is taken.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrModule">
            <summary>
            Represents a managed module in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.IsPdbLoaded">
            <summary>
            Returns true if ClrMD has loaded the the PDB for this module into memory.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.IsMatchingPdb(System.String)">
            <summary>
            Determines whether a PDB on disk matches this module.  (Note that TryDownloadPdb
            always provides a matching PDB if it finds one, so you do not need to check pdbs
            downloaded with TryDownloadPdb with this function.)
            </summary>
            <param name="pdbPath">The location of the PDB on disk.</param>
            <returns>True if the pdb matches, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.LoadPdb(System.String)">
            <summary>
            Loads the pdb for this module.
            </summary>
            <param name="path">The path to the PDB on disk.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.TryDownloadPdb(Microsoft.Diagnostics.Runtime.ISymbolNotification)">
            <summary>
            Attempts to download the PDB for this module from the symbol server.
            </summary>
            <param name="notification">A notification callback (null is ok).</param>
            <returns>The path on disk of the downloaded PDB, or null if not found.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.PdbInterface">
            <summary>
            Returns the IDiaSession interface if the pdb is loaded for this module.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.GetSourceInformation(System.UInt32,System.Int32)">
            <summary>
            Gets the source location of a given metadata token for a function and offset.
            </summary>
            <param name="mdMethodToken">A method def token (ClrMethod.MetadataToken).</param>
            <param name="ilOffset">The il offset to look up the source information.</param>
            <returns>The SourceLocation for the given IL offset, or null if no mapping exists.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.GetSourceInformation(Microsoft.Diagnostics.Runtime.ClrMethod,System.Int32)">
            <summary>
            Gets the source location of a given metadata token for a function and offset.
            </summary>
            <param name="method">The method to look up the source information.</param>
            <param name="ilOffset">The il offset to look up the source information.</param>
            <returns>The SourceLocation for the given IL offset, or null if no mapping exists.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.AssemblyName">
            <summary>
            Returns the name of the assembly that this module is defined in.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.AssemblyId">
            <summary>
            Returns an identifier to uniquely represent this assembly.  This value is not used by any other
            function in ClrMD, but can be used to group modules by their assembly.  (Do not use AssemblyName
            for this, as reflection and other special assemblies can share the same name, but actually be
            different.)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.Name">
            <summary>
            Returns the name of the module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.IsDynamic">
            <summary>
            Returns true if this module was created through Reflection.Emit (and thus has no associated
            file).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.IsFile">
            <summary>
            Returns true if this module is an actual PEFile on disk.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.FileName">
            <summary>
            Returns the filename of where the module was loaded from on disk.  Undefined results if
            IsPEFile returns false.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.ImageBase">
            <summary>
            Returns the base of the image loaded into memory.  This may be 0 if there is not a physical
            file backing it.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.Size">
            <summary>
            Returns the size of the image in memory.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.EnumerateTypes">
            <summary>
            Enumerate all types defined by this module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.MetadataAddress">
            <summary>
            The location of metadata for this module in the process's memory.  This is useful if you
            need to manually create IMetaData* objects.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.MetadataLength">
            <summary>
            The length of the metadata for this module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.MetadataImport">
            <summary>
            The IMetaDataImport interface for this module.  Note that this API does not provide a
            wrapper for IMetaDataImport.  You will need to wrap the API yourself if you need to use this.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.DebuggingMode">
            <summary>
            The debugging attributes for this module.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.GetTypeByName(System.String)">
            <summary>
            Attempts to obtain a ClrType based on the name of the type.  Note this is a "best effort" due to
            the way that the dac handles types.  This function will fail for Generics, and types which have
            never been constructed in the target process.  Please be sure to null-check the return value of
            this function.
            </summary>
            <param name="name">The name of the type.  (This would be the EXACT value returned by ClrType.Name.</param>
            <returns>The requested ClrType, or null if the type doesn't exist or couldn't be constructed.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.ToString">
            <summary>
            Returns a name for the assembly.
            </summary>
            <returns>A name for the assembly.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrAppDomain">
            <summary>
            Represents an AppDomain in the target runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Address">
            <summary>
            Address of the AppDomain.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Id">
            <summary>
            The AppDomain's ID.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Name">
            <summary>
            The name of the AppDomain, as specified when the domain was created.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Modules">
            <summary>
            Returns a list of modules loaded into this AppDomain.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.ConfigurationFile">
            <summary>
            Returns the config file used for the AppDomain.  This may be null if there was no config file
            loaded, or if the targeted runtime does not support enumerating that data.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.ApplicationBase">
            <summary>
            Returns the base directory for this AppDomain.  This may return null if the targeted runtime does
            not support enumerating this information.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.AppBase">
            <summary>
            Returns the base directory for this AppDomain.  This may return null if the targeted runtime does
            not support enumerating this information.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ComInterfaceData">
            <summary>
            The COM implementation details of a single CCW entry.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ComInterfaceData.Type">
            <summary>
            The CLR type this represents.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ComInterfaceData.InterfacePointer">
            <summary>
            The interface pointer of Type.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.CcwData">
            <summary>
            Helper for Com Callable Wrapper objects.  (CCWs are CLR objects exposed to native code as COM
            objects).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CcwData.IUnknown">
            <summary>
            Returns the pointer to the IUnknown representing this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CcwData.Object">
            <summary>
            Returns the pointer to the managed object representing this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CcwData.Handle">
            <summary>
            Returns the CLR handle associated with this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CcwData.RefCount">
            <summary>
            Returns the refcount of this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CcwData.Interfaces">
            <summary>
            Returns the interfaces that this CCW implements.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.RcwData">
            <summary>
            Helper for Runtime Callable Wrapper objects.  (RCWs are COM objects which are exposed to the runtime
            as managed objects.)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.IUnknown">
            <summary>
            Returns the pointer to the IUnknown representing this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.VTablePointer">
            <summary>
            Returns the external VTable associated with this RCW.  (It's useful to resolve the VTable as a symbol
            which will tell you what the underlying native type is...if you have the symbols for it loaded).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.RefCount">
            <summary>
            Returns the RefCount of the RCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.Object">
            <summary>
            Returns the managed object associated with this of RCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.Disconnected">
            <summary>
            Returns true if the RCW is disconnected from the underlying COM type.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.CreatorThread">
            <summary>
            Returns the thread which created this RCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.WinRTObject">
            <summary>
            Returns the internal WinRT object associated with this RCW (if one exists).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RcwData.Interfaces">
            <summary>
            Returns the list of interfaces this RCW implements.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.VersionInfo">
            <summary>
            Represents the version of a DLL.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.VersionInfo.Major">
            <summary>
            In a version 'A.B.C.D', this field represents 'A'.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.VersionInfo.Minor">
            <summary>
            In a version 'A.B.C.D', this field represents 'B'.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.VersionInfo.Revision">
            <summary>
            In a version 'A.B.C.D', this field represents 'C'.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.VersionInfo.Patch">
            <summary>
            In a version 'A.B.C.D', this field represents 'D'.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.VersionInfo.ToString">
            <summary>
            To string.
            </summary>
            <returns>The A.B.C.D version prepended with 'v'.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrFlavor">
            <summary>
            Returns the "flavor" of CLR this module represents.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrFlavor.Desktop">
            <summary>
            This is the full version of CLR included with windows.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrFlavor.CoreCLR">
            <summary>
            This is a reduced CLR used in other projects.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrInfo">
            <summary>
            Represents information about a single Clr runtime in a process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.Version">
            <summary>
            The version number of this runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.Flavor">
            <summary>
            The type of CLR this module represents.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.DacInfo">
            <summary>
            Returns module information about the Dac needed create a ClrRuntime instance for this runtime.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfo.TryGetDacLocation">
            <summary>
            The location of the Dac on the local machine, if a matching Dac could be found.
            If this returns null it means that no matching Dac could be found, and you will
            need to make a symbol server request using DacInfo.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfo.TryDownloadDac(Microsoft.Diagnostics.Runtime.ISymbolNotification)">
            <summary>
            Attemps to download the matching dac for this runtime from the symbol server.  Note that this command
            does not attempt to inspect or parse _NT_SYMBOL_PATH, so if you want to use that as a "default", you
            need to add that path to the sympath parameter manually.  This function will return a local dac location
            (and bypass the symbol server) if a matching dac exists locally on your computer.
            </summary>
            <param name="notification">A notification callback (null ok).</param>
            <returns>The local path (in the cache) of the dac if found, null otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfo.TryDownloadDac">
            <summary>
            Attemps to download the matching dac for this runtime from the symbol server.  Note that this command
            does not attempt to inspect or parse _NT_SYMBOL_PATH, so if you want to use that as a "default", you
            need to add that path to the sympath parameter manually.  This function will return a local dac location
            (and bypass the symbol server) if a matching dac exists locally on your computer.
            </summary>
            <returns>The local path (in the cache) of the dac if found, null otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfo.ToString">
            <summary>
            To string.
            </summary>
            <returns>A version string for this Clr runtime.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfo.CompareTo(System.Object)">
            <summary>
            IComparable.  Sorts the object by version.
            </summary>
            <param name="obj">The object to compare to.</param>
            <returns>-1 if less, 0 if equal, 1 if greater.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.AttachFlag">
            <summary>
            Specifies how to attach to a live process.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.AttachFlag.Invasive">
            <summary>
            Performs an invasive debugger attach.  Allows the consumer of this API to control the target
            process through normal IDebug function calls.  The process will be paused.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.AttachFlag.NonInvasive">
            <summary>
            Performs a non-invasive debugger attach.  The process will be paused by this attached (and
            for the duration of the attach) but the caller cannot control the target process.  This is
            useful when there's already a debugger attached to the process.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.AttachFlag.Passive">
            <summary>
            Performs a "passive" attach, meaning no debugger is actually attached to the target process.
            The process is not paused, so queries for quickly changing data (such as the contents of the
            GC heap or callstacks) will be highly inconsistent unless the user pauses the process through
            other means.  Useful when attaching with ICorDebug (managed debugger), as you cannot use a
            non-invasive attach with ICorDebug.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.PdbInfo">
            <summary>
            Information about a specific PDB instance obtained from a PE image.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.PdbInfo.Guid">
            <summary>
            The Guid of the PDB.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.PdbInfo.Revision">
            <summary>
            The pdb revision.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.PdbInfo.FileName">
            <summary>
            The filename of the pdb.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ModuleInfo">
            <summary>
            Provides information about loaded modules in a DataTarget
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.ImageBase">
            <summary>
            The base address of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.FileSize">
            <summary>
            The filesize of the image.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.TimeStamp">
            <summary>
            The build timestamp of the image.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.FileName">
            <summary>
            The filename of the module on disk.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ModuleInfo.ToString">
            <summary>
            To string.
            </summary>
            <returns>The filename of the module.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.Pdb">
            <summary>
            The PDB associated with this module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.Version">
            <summary>
            The version information for this file.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ModuleInfo.#ctor">
            <summary>
            Empty constructor for serialization.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ModuleInfo.#ctor(Microsoft.Diagnostics.Runtime.IDataReader)">
            <summary>
            Creates a ModuleInfo object with an IDataReader instance.  This is used when
            lazily evaluating VersionInfo. 
            </summary>
            <param name="reader"></param>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.VirtualQueryData">
            <summary>
            The result of a VirtualQuery.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.VirtualQueryData.BaseAddress">
            <summary>
            The base address of the allocation.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.VirtualQueryData.Size">
            <summary>
             The size of the allocation.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.VirtualQueryData.#ctor(System.UInt64,System.UInt64)">
            <summary>
            Constructor.
            </summary>
            <param name="addr">Base address of the memory range.</param>
            <param name="size">The size of the memory range.</param>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.AsyncMemoryReadResult">
            <summary>
            The result of an asynchronous memory read.  This is returned by an IDataReader
            when an async memory read is requested.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AsyncMemoryReadResult.Complete">
            <summary>
            A wait handle which is signaled when the read operation is complete.
            Complete must be assigned a valid EventWaitHandle before this object is
            returned by ReadMemoryAsync, and Complete must be signaled after the
            request is completed.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AsyncMemoryReadResult.Address">
            <summary>
            The address to read from.  Address must be assigned to before this objct is
            returned by ReadMemoryAsync.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AsyncMemoryReadResult.BytesRequested">
            <summary>
            The number of bytes requested in this async read.  BytesRequested must be
            assigned to before this objct is returned by ReadMemoryAsync.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AsyncMemoryReadResult.BytesRead">
            <summary>
            The actual number of bytes read out of the data target.  This must be
            assigned to before Complete is signaled.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.AsyncMemoryReadResult.Result">
            <summary>
            The result of the memory read.  This must be assigned to before Complete is
            signaled.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.AsyncMemoryReadResult.#ctor">
            <summary>
            Empty constructor, no properties/fields assigned.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.AsyncMemoryReadResult.#ctor(System.UInt64,System.Int32)">
            <summary>
            Constructor.  Assigns Address, BytesRequested, and Complete.  (Uses a ManualResetEvent
            for Complete).
            </summary>
            <param name="addr">The address of the memory read.</param>
            <param name="requested">The number of bytes requested.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.AsyncMemoryReadResult.ToString">
            <summary>
            To string.
            </summary>
            <returns>The memory range requested.</returns>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.AsyncMemoryReadResult.m_read">
            <summary>
            The amount read, backing variable for BytesRead.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.AsyncMemoryReadResult.m_result">
            <summary>
            The actual data buffer, backing variable for Result.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.IDataReader">
            <summary>
            An interface for reading data out of the target process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.Close">
            <summary>
            Called when the DataTarget is closing (Disposing).  Used to clean up resources.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.Flush">
            <summary>
            Informs the data reader that the user has requested all data be flushed.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.GetArchitecture">
            <summary>
            Gets the architecture of the target.
            </summary>
            <returns>The architecture of the target.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.GetPointerSize">
            <summary>
            Gets the size of a pointer in the target process.
            </summary>
            <returns>The pointer size of the target process.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.EnumerateModules">
            <summary>
            Enumerates modules in the target process.
            </summary>
            <returns>A list of the modules in the target process.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.GetVersionInfo(System.UInt64,Microsoft.Diagnostics.Runtime.VersionInfo@)">
            <summary>
            Gets the version information for a given module (given by the base address of the module).
            </summary>
            <param name="baseAddress">The base address of the module to look up.</param>
            <param name="version">The version info for the given module.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.ReadMemory(System.UInt64,System.Byte[],System.Int32,System.Int32@)">
            <summary>
            Read memory out of the target process.
            </summary>
            <param name="address">The address of memory to read.</param>
            <param name="buffer">The buffer to write to.</param>
            <param name="bytesRequested">The number of bytes to read.</param>
            <param name="bytesRead">The number of bytes actually read out of the target process.</param>
            <returns>True if any bytes were read at all, false if the read failed (and no bytes were read).</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.ReadMemory(System.UInt64,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            Read memory out of the target process.
            </summary>
            <param name="address">The address of memory to read.</param>
            <param name="buffer">The buffer to write to.</param>
            <param name="bytesRequested">The number of bytes to read.</param>
            <param name="bytesRead">The number of bytes actually read out of the target process.</param>
            <returns>True if any bytes were read at all, false if the read failed (and no bytes were read).</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IDataReader.CanReadAsync">
            <summary>
            Returns true if this data reader can read data out of the target process asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.ReadMemoryAsync(System.UInt64,System.Int32)">
            <summary>
            Reads memory from the target process asynchronously.  Only called if CanReadAsync returns true.
            </summary>
            <param name="address">The address of memory to read.</param>
            <param name="bytesRequested">The number of bytes to read.</param>
            <returns>A data structure containing an event to wait for as well as a new byte array to read from.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IDataReader.IsMinidump">
            <summary>
            Returns true if the data target is a minidump (or otherwise may not contain full heap data).
            </summary>
            <returns>True if the data target is a minidump (or otherwise may not contain full heap data).</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.GetThreadTeb(System.UInt32)">
            <summary>
            Gets the TEB of the specified thread.
            </summary>
            <param name="thread">The OS thread ID to get the TEB for.</param>
            <returns>The address of the thread's teb.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.EnumerateAllThreads">
            <summary>
            Enumerates the OS thread ID of all threads in the process.
            </summary>
            <returns>An enumeration of all threads in the target process.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.VirtualQuery(System.UInt64,Microsoft.Diagnostics.Runtime.VirtualQueryData@)">
            <summary>
            Gets information about the given memory range.
            </summary>
            <param name="addr">An arbitrary address in the target process.</param>
            <param name="vq">The base address and size of the allocation.</param>
            <returns>True if the address was found and vq was filled, false if the address is not valid memory.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.GetThreadContext(System.UInt32,System.UInt32,System.UInt32,System.IntPtr)">
            <summary>
            Gets the thread context for the given thread.
            </summary>
            <param name="threadID">The OS thread ID to read the context from.</param>
            <param name="contextFlags">The requested context flags, or 0 for default flags.</param>
            <param name="contextSize">The size (in bytes) of the context parameter.</param>
            <param name="context">A pointer to the buffer to write to.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.GetThreadContext(System.UInt32,System.UInt32,System.UInt32,System.Byte[])">
            <summary>
            Gets the thread context for the given thread.
            </summary>
            <param name="threadID">The OS thread ID to read the context from.</param>
            <param name="contextFlags">The requested context flags, or 0 for default flags.</param>
            <param name="contextSize">The size (in bytes) of the context parameter.</param>
            <param name="context">A pointer to the buffer to write to.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.ReadPointerUnsafe(System.UInt64)">
            <summary>
            Read a pointer out of the target process.
            </summary>
            <returns>The pointer at the give address, or 0 if that pointer doesn't exist in
            the data target.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.ReadDwordUnsafe(System.UInt64)">
            <summary>
            Read an int out of the target process.
            </summary>
            <returns>The int at the give address, or 0 if that pointer doesn't exist in
            the data target.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.CrashDumpReader">
            <summary>
            The type of crash dump reader to use.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.CrashDumpReader.DbgEng">
            <summary>
            Use DbgEng.  This allows the user to obtain an instance of IDebugClient through the
            DataTarget.DebuggerInterface property, at the cost of strict threading requirements.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.CrashDumpReader.ClrMD">
            <summary>
            Use a simple dump reader to read data out of the crash dump.  This allows processing
            multiple dumps (using separate DataTargets) on multiple threads, but the
            DataTarget.DebuggerInterface property will return null.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DataTarget">
            <summary>
            A crash dump or live process to read out of.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.LoadCrashDump(System.String)">
            <summary>
            Creates a DataTarget from a crash dump.
            </summary>
            <param name="fileName">The crash dump's filename.</param>
            <returns>A DataTarget instance.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.LoadCrashDump(System.String,Microsoft.Diagnostics.Runtime.CrashDumpReader)">
            <summary>
            Creates a DataTarget from a crash dump, specifying the dump reader to use.
            </summary>
            <param name="fileName">The crash dump's filename.</param>
            <param name="dumpReader">The type of dump reader to use.</param>
            <returns>A DataTarget instance.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.CreateFromDataReader(Microsoft.Diagnostics.Runtime.IDataReader)">
            <summary>
            Create an instance of DataTarget from a user defined DataReader
            </summary>
            <param name="reader">A user defined DataReader.</param>
            <returns>A new DataTarget instance.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.CreateFromDebuggerInterface(Microsoft.Diagnostics.Runtime.Interop.IDebugClient)">
            <summary>
            Creates a data target from an existing IDebugClient interface.  If you created and attached
            a dbgeng based debugger to a process you may pass the IDebugClient RCW object to this function
            to create the DataTarget.
            </summary>
            <param name="client">The dbgeng IDebugClient object.  We will query interface on this for IDebugClient.</param>
            <returns>A DataTarget instance.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.AttachToProcess(System.Int32,System.UInt32)">
            <summary>
            Invasively attaches to a live process.
            </summary>
            <param name="pid">The process ID of the process to attach to.</param>
            <param name="msecTimeout">Timeout in milliseconds.</param>
            <returns>A DataTarget instance.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.AttachToProcess(System.Int32,System.UInt32,Microsoft.Diagnostics.Runtime.AttachFlag)">
            <summary>
            Attaches to a live process.
            </summary>
            <param name="pid">The process ID of the process to attach to.</param>
            <param name="msecTimeout">Timeout in milliseconds.</param>
            <param name="attachFlag">The type of attach requested for the target process.</param>
            <returns>A DataTarget instance.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.DefaultSymbolNotification">
            <summary>
            The ISymbolNotification to use if none is specified.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.IsMinidump">
            <summary>
            Returns true if the target process is a minidump, or otherwise might have limited memory.  If IsMinidump
            returns true, a greater range of functions may fail to return data due to the data not being present in
            the application/crash dump you are debugging.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.SetSymbolPath(System.String)">
            <summary>
            Sets the symbol path for ClrMD.
            </summary>
            <param name="path">This should be in the format that Windbg/dbgeng expects with the '.sympath' command.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.ClearSymbolPath">
            <summary>
            Clears the symbol path.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.AppendSymbolPath(System.String)">
            <summary>
            Appends 'path' to the symbol path.
            </summary>
            <param name="path">The location to add.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.GetSymbolPath">
            <summary>
            Returns the current symbol path.
            </summary>
            <returns>The symbol path.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.Architecture">
            <summary>
            Returns the architecture of the target process or crash dump.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.ClrVersions">
            <summary>
            Returns the list of Clr versions loaded into the process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.PointerSize">
            <summary>
            Returns the pointer size for the target process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.ReadProcessMemory(System.UInt64,System.Byte[],System.Int32,System.Int32@)">
            <summary>
            Reads memory from the target.
            </summary>
            <param name="address">The address to read from.</param>
            <param name="buffer">The buffer to store the data in.  Size must be greator or equal to
            bytesRequested.</param>
            <param name="bytesRequested">The amount of bytes to read from the target process.</param>
            <param name="bytesRead">The actual number of bytes read.</param>
            <returns>True if any bytes were read out of the process (including a partial read).  False
            if no bytes could be read from the address.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.CreateRuntime(System.String)">
            <summary>
            Creates a runtime from the given Dac file on disk.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.CreateRuntime(System.Object)">
            <summary>
            Creates a runtime from a given IXClrDataProcess interface.  Used for debugger plugins.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.DebuggerInterface">
            <summary>
            Returns the IDebugClient interface associated with this datatarget.  (Will return null if the
            user attached passively.)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.EnumerateModules">
            <summary>
            Enumerates information about the loaded modules in the process (both managed and unmanaged).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.Dispose">
            <summary>
            IDisposable implementation.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ISymbolNotification">
            <summary>
            Interface for receiving callback notifications when downloading symbol files.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ISymbolNotification.FoundSymbolInCache(System.String)">
            <summary>
            Symbol lookup was initiated, but found in a cache without needing to fetch it
            from the symbol path.
            </summary>
            <param name="localPath">The location of the file on disk.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ISymbolNotification.ProbeFailed(System.String)">
            <summary>
            Called when attempting to resolve a location (either local or remote), but we did
            not find the file.
            </summary>
            <param name="url">The path/url attempted.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ISymbolNotification.FoundSymbolOnPath(System.String)">
            <summary>
            We found the symbol on the symbol path.
            </summary>
            <param name="url">Where we found the symbol from.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ISymbolNotification.DownloadProgress(System.Int32)">
            <summary>
            Called periodically when downloading the symbol from the symbol server.
            </summary>
            <param name="bytesDownloaded">The total bytes downloaded thus far.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ISymbolNotification.DownloadComplete(System.String,System.Boolean)">
            <summary>
            Called when the download is complete.
            </summary>
            <param name="localPath">Where the file was placed.</param>
            <param name="requiresDecompression">True if the file requires us to decompress it (done automatically).</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ISymbolNotification.DecompressionComplete(System.String)">
            <summary>
            Called when the file is finished decompressing.
            </summary>
            <param name="localPath">The location of the resulting decompressed file.</param>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrRuntime">
            <summary>
            Represents a single runtime in a target process or crash dump.  This serves as the primary
            entry point for getting diagnostic information.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.DataTarget">
            <summary>
            Returns the DataTarget associated with this runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.ServerGC">
            <summary>
            Whether or not the process is running in server GC mode or not.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.EnumerateGCThreads">
            <summary>
            Enumerates the OS thread ID of GC threads in the runtime.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.HeapCount">
            <summary>
            The number of logical GC heaps in the process.  This is always 1 for a workstation
            GC, and usually it's the number of logical processors in a server GC application.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.PointerSize">
            <summary>
            Returns the pointer size of the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.AppDomains">
            <summary>
            Enumerates the list of appdomains in the process.  Note the System appdomain and Shared
            AppDomain are omitted.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.Threads">
            <summary>
            Enumerates all managed threads in the process.  Only threads which have previously run managed
            code will be enumerated.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.EnumerateFinalizerQueue">
            <summary>
            Enumerates all objects currently on the finalizer queue.  (Not finalizable objects, but objects
            which have been collected and will be imminently finalized.)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.ReadVirtual(System.UInt64,System.Byte[],System.Int32,System.Int32@)">
            <summary>
            Read data out of the target process.
            </summary>
            <param name="address">The address to start the read from.</param>
            <param name="buffer">The buffer to write memory to.</param>
            <param name="bytesRequested">How many bytes to read (must be less than/equal to buffer.Length)</param>
            <param name="bytesRead">The number of bytes actually read out of the process.  This will be less than
            bytes requested if the request falls off the end of an allocation.</param>
            <returns>False if the memory is not readable (free or no read permission), true if *some* memory was read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.ReadMemory(System.UInt64,System.Byte[],System.Int32,System.Int32@)">
            <summary>
            Read data out of the target process.
            </summary>
            <param name="address">The address to start the read from.</param>
            <param name="buffer">The buffer to write memory to.</param>
            <param name="bytesRequested">How many bytes to read (must be less than/equal to buffer.Length)</param>
            <param name="bytesRead">The number of bytes actually read out of the process.  This will be less than
            bytes requested if the request falls off the end of an allocation.</param>
            <returns>False if the memory is not readable (free or no read permission), true if *some* memory was read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.ReadPointer(System.UInt64,System.UInt64@)">
            <summary>
            Reads a pointer value out of the target process.  This function reads only the target's pointer size,
            so if this is used on an x86 target, only 4 bytes is read and written to val.
            </summary>
            <param name="address">The address to read from.</param>
            <param name="value">The value at that address.</param>
            <returns>True if the read was successful, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.EnumerateHandles">
            <summary>
            Enumerates a list of GC handles currently in the process.  Note that this list may be incomplete
            depending on the state of the process when we attempt to walk the handle table.
            </summary>
            <returns>The list of GC handles in the process, NULL on catastrophic error.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetHeap">
            <summary>
            Gets the GC heap of the process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetHeap(System.IO.TextWriter)">
            <summary>
            Gets the GC heap of the process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetThreadPool">
            <summary>
            Returns data on the CLR thread pool for this runtime.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.EnumerateMemoryRegions">
            <summary>
            Enumerates regions of memory which CLR has allocated with a description of what data
            resides at that location.  Note that this does not return every chunk of address space
            that CLR allocates.
            </summary>
            <returns>An enumeration of memory regions in the process.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetMethodByAddress(System.UInt64)">
            <summary>
            Attempts to get a ClrMethod for the given instruction pointer.  This will return NULL if the
            given instruction pointer is not within any managed method.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.EnumerateModules">
            <summary>
            Enumerates all modules in the process.
            </summary>
            <returns>An enumeration of modules.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.Flush">
            <summary>
            Flushes the dac cache.  This function MUST be called any time you expect to call the same function
            but expect different results.  For example, after walking the heap, you need to call Flush before
            attempting to walk the heap again.  After calling this function, you must discard ALL ClrMD objects
            you have cached other than DataTarget and ClrRuntime and re-request the objects and data you need.
            (E.G. if you want to use the ClrHeap object after calling flush, you must call ClrRuntime.GetHeap
            again after Flush to get a new instance.)
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrRuntime.RuntimeFlushedCallback">
            <summary>
            Delegate called when the RuntimeFlushed event is triggered.
            </summary>
            <param name="runtime">Which runtime was flushed.</param>
        </member>
        <member name="E:Microsoft.Diagnostics.Runtime.ClrRuntime.RuntimeFlushed">
            <summary>
            Called whenever the runtime is being flushed.  All references to ClrMD objects need to be released
            and not used for the given runtime after this call.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.OnRuntimeFlushed">
            <summary>
            Call when flushing the runtime.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrThreadPool">
            <summary>
            Provides information about CLR's threadpool.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.TotalThreads">
            <summary>
            The total number of threadpool worker threads in the process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.RunningThreads">
            <summary>
            The number of running threadpool threads in the process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.IdleThreads">
            <summary>
            The number of idle threadpool threads in the process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.MinThreads">
            <summary>
            The minimum number of threadpool threads allowable.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.MaxThreads">
            <summary>
            The maximum number of threadpool threads allowable.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.MinCompletionPorts">
            <summary>
            Returns the minimum number of completion ports (if any).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.MaxCompletionPorts">
            <summary>
            Returns the maximum number of completion ports.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.CpuUtilization">
            <summary>
            Returns the CPU utilization of the threadpool (as a percentage out of 100).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.FreeCompletionPortCount">
            <summary>
            The number of free completion port threads.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThreadPool.MaxFreeCompletionPorts">
            <summary>
            The maximum number of free completion port threads.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadPool.EnumerateNativeWorkItems">
            <summary>
            Enumerates the work items on the threadpool (native side).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThreadPool.EnumerateManagedWorkItems">
            <summary>
            Enumerates work items on the thread pool (managed side).
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ManagedWorkItem">
            <summary>
            A managed threadpool object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ManagedWorkItem.Object">
            <summary>
            The object address of this entry.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ManagedWorkItem.Type">
            <summary>
            The type of Object.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.WorkItemKind">
            <summary>
            The type of work item this is.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.WorkItemKind.Unknown">
            <summary>
            Unknown.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.WorkItemKind.AsyncTimer">
            <summary>
            Callback for an async timer.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.WorkItemKind.AsyncCallback">
            <summary>
            Async callback.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.WorkItemKind.QueueUserWorkItem">
            <summary>
            From ThreadPool.QueueUserWorkItem.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.WorkItemKind.TimerDelete">
            <summary>
            Timer delete callback.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.NativeWorkItem">
            <summary>
            Represents a work item on CLR's thread pool (native side).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.NativeWorkItem.Kind">
            <summary>
            The type of work item this is.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.NativeWorkItem.Callback">
            <summary>
            Returns the callback's address.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.NativeWorkItem.Data">
            <summary>
            Returns the pointer to the user's data.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.HandleType">
            <summary>
            Types of Clr handles.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.WeakShort">
            <summary>
            Weak, short lived handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.WeakLong">
            <summary>
            Weak, long lived handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.Strong">
            <summary>
            Strong handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.Pinned">
            <summary>
            Strong handle, prevents relocation of target object.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.RefCount">
            <summary>
            RefCounted handle (strong when the reference count is greater than 0).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.Dependent">
            <summary>
            A weak handle which may keep its "secondary" object alive if the "target" object is also alive.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.AsyncPinned">
            <summary>
            A strong, pinned handle (keeps the target object from being relocated), used for async IO operations.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.HandleType.SizedRef">
            <summary>
            Strong handle used internally for book keeping.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrHandle">
            <summary>
            Represents a Clr handle in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.Address">
            <summary>
            The address of the handle itself.  That is, *Address == Object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.Object">
            <summary>
            The Object the handle roots.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.Type">
            <summary>
            The the type of the Object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.Strong">
            <summary>
            Whether the handle is strong (roots the object) or not.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.IsStrong">
            <summary>
            Whether the handle is strong (roots the object) or not.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.IsPinned">
            <summary>
            Whether or not the handle pins the object (doesn't allow the GC to
            relocate it) or not.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.HandleType">
            <summary>
            Gets the type of handle.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.RefCount">
            <summary>
            If this handle is a RefCount handle, this returns the reference count.
            RefCount handles with a RefCount > 0 are strong.
            NOTE: v2 CLR CANNOT determine the RefCount.  We always set the RefCount
                  to 1 in a v2 query since a strong RefCount handle is the common case.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.DependentTarget">
            <summary>
            Set only if the handle type is a DependentHandle.  Dependent handles add
            an extra edge to the object graph.  Meaning, this.Object now roots the
            dependent target, but only if this.Object is alive itself.
            NOTE: CLRs prior to v4.5 cannot obtain the dependent target.  This field will
                  be 0 for any CLR prior to v4.5.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.DependentType">
            <summary>
            The type of the dependent target, if non 0.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.AppDomain">
            <summary>
            The AppDomain the handle resides in.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType">
            <summary>
            Types of memory regions in a Clr process.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.LowFrequencyLoaderHeap">
            <summary>
            Data on the loader heap.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.HighFrequencyLoaderHeap">
            <summary>
            Data on the loader heap.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.StubHeap">
            <summary>
            Data on the stub heap.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.IndcellHeap">
            <summary>
            Clr implementation detail (this is here to allow you to distinguish from other
            heap types).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.LookupHeap">
            <summary>
            Clr implementation detail (this is here to allow you to distinguish from other
            heap types).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.ResolveHeap">
            <summary>
            Clr implementation detail (this is here to allow you to distinguish from other
            heap types).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.DispatchHeap">
            <summary>
            Clr implementation detail (this is here to allow you to distinguish from other
            heap types).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.CacheEntryHeap">
            <summary>
            Clr implementation detail (this is here to allow you to distinguish from other
            heap types).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.JitHostCodeHeap">
            <summary>
            Heap for JIT code data.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.JitLoaderCodeHeap">
            <summary>
            Heap for JIT loader data.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.ModuleThunkHeap">
            <summary>
            Heap for module jump thunks.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.ModuleLookupTableHeap">
            <summary>
            Heap for module lookup tables.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.GCSegment">
            <summary>
            A segment on the GC heap (committed memory).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.ReservedGCSegment">
            <summary>
            A segment on the GC heap (reserved, but not committed, memory).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrMemoryRegionType.HandleTableChunk">
            <summary>
            A portion of Clr's handle table.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.GCSegmentType">
            <summary>
            Types of GC segments.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCSegmentType.Ephemeral">
            <summary>
            Ephemeral segments are the only segments to contain Gen0 and Gen1 objects.
            It may also contain Gen2 objects, but not always.  Objects are only allocated
            on the ephemeral segment.  There is one ephemeral segment per logical GC heap.
            It is important to not have too many pinned objects in the ephemeral segment,
            or you will run into a performance problem where the runtime runs too many GCs.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCSegmentType.Regular">
            <summary>
            Regular GC segments only contain Gen2 objects.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCSegmentType.LargeObject">
            <summary>
            The large object heap contains objects greater than a certain threshold.  Large
            object segments are never compacted.  Large objects are directly allocated
            onto LargeObject segments, and all large objects are considered gen2.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrMemoryRegion">
            <summary>
            Represents a region of memory in the process which Clr allocated and controls.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.Address">
            <summary>
            The start address of the memory region.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.Size">
            <summary>
            The size of the memory region in bytes.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.Type">
            <summary>
            The type of heap/memory that the region contains.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.AppDomain">
            <summary>
            The AppDomain pointer that corresponds to this heap.  You can obtain the
            name of the AppDomain index or name by calling the appropriate function
            on RuntimeBase.
            Note:  HasAppDomainData must be true before getting this property.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.Module">
            <summary>
            The Module pointer that corresponds to this heap.  You can obtain the
            filename of the module with this property.
            Note:  HasModuleData must be true or this property will be null.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.HeapNumber">
            <summary>
            Returns the heap number associated with this data.  Returns -1 if no
            GC heap is associated with this memory region.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.GCSegmentType">
            <summary>
            Returns the gc segment type associated with this data.  Only callable if
            HasGCHeapData is true.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.ToString(System.Boolean)">
            <summary>
            Returns a string describing the region of memory (for example "JIT Code Heap"
            or "GC Segment").
            </summary>
            <param name="detailed">Whether or not to include additional data such as the module,
            AppDomain, or GC Heap associated with it.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrMemoryRegion.ToString">
            <summary>
            Equivalent to GetDisplayString(false).
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.MethodCompilationType">
            <summary>
            The way a method was JIT'ed.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.MethodCompilationType.None">
            <summary>
            Method is not yet JITed and no NGEN image exists.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.MethodCompilationType.Jit">
            <summary>
            Method was JITed.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.MethodCompilationType.Ngen">
            <summary>
            Method was NGEN'ed (pre-JITed).
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrMethod">
            <summary>
            Represents a method on a class.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.Name">
            <summary>
            The name of the method.  For example, "void System.Foo.Bar(object o, int i)" would return "Bar".
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrMethod.GetFullSignature">
            <summary>
            Returns the full signature of the function.  For example, "void System.Foo.Bar(object o, int i)"
            would return "System.Foo.Bar(System.Object, System.Int32)"
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.NativeCode">
            <summary>
            Returns the instruction pointer in the target process for the start of the method's assembly.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrMethod.GetSourceLocationForOffset(System.UInt64)">
            <summary>
            Returns the file and line number for the given offset in the method.
            </summary>
            <param name="nativeOffset">The offset within the method (not the address in memory) of the instruction pointer.</param>
            <returns>The file and line number for the given offset.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.CompilationType">
            <summary>
            Returns the way this method was compiled.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.ILOffsetMap">
            <summary>
            Returns the IL to native offset mapping.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.MetadataToken">
            <summary>
            Returns the metadata token of the current method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.Type">
            <summary>
            Returns the enclosing type of this method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsPublic">
            <summary>
            Returns if this method is public.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsPrivate">
            <summary>
            Returns if this method is private.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsInternal">
            <summary>
            Returns if this method is internal.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsProtected">
            <summary>
            Returns if this method is protected.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsStatic">
            <summary>
            Returns if this method is static.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsFinal">
            <summary>
            Returns if this method is final.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsPInvoke">
            <summary>
            Returns if this method is a PInvoke.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsSpecialName">
            <summary>
            Returns if this method is a special method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsRTSpecialName">
            <summary>
            Returns if this method is runtime special method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsVirtual">
            <summary>
            Returns if this method is virtual.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsAbstract">
            <summary>
            Returns if this method is abstract.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ILToNativeMap">
            <summary>
            A method's mapping from IL to native offsets.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ILToNativeMap.ILOffset">
            <summary>
            The IL offset for this entry.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ILToNativeMap.StartAddress">
            <summary>
            The native start offset of this IL entry.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ILToNativeMap.EndAddress">
            <summary>
            The native end offset of this IL entry.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ILToNativeMap.ToString">
            <summary>
            To string.
            </summary>
            <returns>A visual display of the map entry.</returns>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ILToNativeMap.Reserved">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException">
            <summary>
            Exception thrown by Microsoft.Diagnostics.Runtime unless there is a more appropriate
            exception subclass.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.HR">
            <summary>
            Specific HRESULTS for errors.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.HR.UnknownError">
            <summary>
            Unknown error occured.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.HR.RuntimeUninitialized">
            <summary>
            The dll of the specified runtime (mscorwks.dll or clr.dll) is loaded into the process, but
            has not actually been initialized and thus cannot be debugged.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.HR.DebuggerError">
            <summary>
            Something unexpected went wrong with the debugger we used to attach to the process or load
            the crash dump.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.HR.DataRequestError">
            <summary>
            Something unexpected went wrong when requesting data from the target process.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.HR.DacError">
            <summary>
            Hit an unexpected (non-recoverable) dac error.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.HR.RevisionError">
            <summary>
            The caller attempted to re-use an object after calling ClrRuntime.Flush.  See the
            documentation for ClrRuntime.Flush for more details.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.HR.CrashDumpError">
            <summary>
            An error occurred while processing the given crash dump.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.HR.ApplicationError">
            <summary>
            There is an issue with the configuration of this application.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.HResult">
            <summary>
            The HRESULT of this exception.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions">
            <summary>
            CommandOptions is a helper class for the Command class.  It stores options
            that affect the behavior of the execution of ETWCommands and is passes as a 
            parapeter to the constuctor of a Command.  
            
            It is useful for these options be be on a separate class (rather than 
            on Command itself), because it is reasonably common to want to have a set
            of options passed to several commands, which is not easily possible otherwise. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Infinite">
            <summary>
            Can be assigned to the Timeout Property to indicate infinite timeout. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.#ctor">
            <summary>
            CommanOptions holds a set of options that can be passed to the constructor
            to the Command Class as well as Command.Run*
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Clone">
            <summary>
            Return a copy an existing set of command options
            </summary>
            <returns>The copy of the command options</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.NoThrow">
            <summary>
            Normally commands will throw if the subprocess returns a non-zero 
            exit code.  NoThrow suppresses this. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddNoThrow">
            <summary>
            Updates the NoThrow propery and returns the updated commandOptions.
            <returns>Updated command options</returns>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Start">
            <summary>
            ShortHand for UseShellExecute and NoWait
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddStart">
            <summary>
            Updates the Start propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.UseShellExecute">
            <summary>
            Normally commands are launched with CreateProcess.  However it is
            also possible use the Shell Start API.  This causes Command to look
            up the executable differently 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddUseShellExecute">
            <summary>
            Updates the Start propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.NoWindow">
            <summary>
            Indicates that you want to hide any new window created.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddNoWindow">
            <summary>
            Updates the NoWindow propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.NoWait">
            <summary>
            Indicates that you want don't want to wait for the command to complete.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddNoWait">
            <summary>
            Updates the NoWait propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Elevate">
            <summary>
            Indicates that the command must run at elevated Windows privledges (causes a new command window)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddElevate">
            <summary>
            Updates the Elevate propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Timeout">
            <summary>
            By default commands have a 10 minute timeout (600,000 msec), If this
            is inappropriate, the Timeout property can change this.  Like all
            timouts in .NET, it is in units of milliseconds, and you can use
            CommandOptions.Infinite to indicate no timeout. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddTimeout(System.Int32)">
            <summary>
            Updates the Timeout propery and returns the updated commandOptions.
            CommandOptions.Infinite can be used for infinite
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Input">
            <summary>
            Indicates the string will be sent to Console.In for the subprocess.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddInput(System.String)">
            <summary>
            Updates the Input propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.CurrentDirectory">
            <summary>
            Indicates the current directory the subProcess will have. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddCurrentDirectory(System.String)">
            <summary>
            Updates the CurrentDirectory propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.OutputFile">
            <summary>
            Indicates the standard output and error of the command should be redirected
            to a archiveFile rather than being stored in Memory in the 'Output' property of the
            command.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddOutputFile(System.String)">
            <summary>
            Updates the OutputFile propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.OutputStream">
            <summary>
            Indicates the standard output and error of the command should be redirected
            to a a TextWriter rather than being stored in Memory in the 'Output' property 
            of the command.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddOutputStream(System.IO.TextWriter)">
            <summary>
            Updates the OutputStream propery and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.EnvironmentVariables">
            <summary>
            Gets the Environment variables that will be set in the subprocess that
            differ from current process's environment variables.  Any time a string
            of the form %VAR% is found in a value of a environment variable it is
            replaced with the value of the environment variable at the time the
            command is launched.  This is useful for example to update the PATH
            environment variable eg. "%PATH%;someNewPath"
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddEnvironmentVariable(System.String,System.String)">
            <summary>
            Adds the environment variable with the give value to the set of 
            environmetn variables to be passed to the sub-process and returns the 
            updated commandOptions.   Any time a string
            of the form %VAR% is found in a value of a environment variable it is
            replaced with the value of the environment variable at the time the
            command is launched.  This is useful for example to update the PATH
            environment variable eg. "%PATH%;someNewPath"
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.Command">
            <summary>
            Command represents a running of a command lineNumber process.  It is basically
            a wrapper over System.Diagnostics.Process, which hides the complexitity
            of System.Diagnostics.Process, and knows how to capture output and otherwise
            makes calling commands very easy.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.StartTime">
            <summary>
            The time the process started.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.HasExited">
            <summary>
            returns true if the process has exited. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.ExitTime">
            <summary>
            The time the processed Exited.  (HasExited should be true before calling)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.Duration">
            <summary>
            The duration of the command (HasExited should be true before calling)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.Id">
            <summary>
            The operating system ID for the subprocess.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.ExitCode">
            <summary>
            The process exit code for the subprocess.  (HasExited should be true before calling)
            Often this does not need to be checked because Command.Run will throw an exception 
            if it is not zero.   However it is useful if the CommandOptions.NoThrow property 
            was set.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.Output">
            <summary>
            The standard output and standard error output from the command.  This
            is accumulated in real time so it can vary if the process is still running.
            
            This property is NOT available if the CommandOptions.OutputFile or CommandOptions.OutputStream
            is specified since the output is being redirected there.   If a large amount of output is 
            expected (> 1Meg), the Run.AddOutputStream(Stream) is recommended for retrieving it since
            the large string is never materialized at one time. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.Options">
            <summary>
            Returns that CommandOptions structure that holds all the options that affect
            the running of the command (like Timeout, Input ...)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.RunToConsole(System.String,Microsoft.Diagnostics.Runtime.Utilities.CommandOptions)">
            <summary>
            Run 'commandLine', sending the output to the console, and wait for the command to complete.
            This simulates what batch filedo when executing their commands.  It is a bit more verbose
            by default, however 
            </summary>
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            <param variable="options">Additional qualifiers that control how the process is run</param>
            <returns>A Command structure that can be queried to determine ExitCode, Output, etc.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.Run(System.String,Microsoft.Diagnostics.Runtime.Utilities.CommandOptions)">
            <summary>
            Run 'commandLine' as a subprocess and waits for the command to complete.
            Output is captured and placed in the 'Output' property of the returned Command 
            structure. 
            </summary>
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            <param variable="options">Additional qualifiers that control how the process is run</param>
            <returns>A Command structure that can be queried to determine ExitCode, Output, etc.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.#ctor(System.String,Microsoft.Diagnostics.Runtime.Utilities.CommandOptions)">
            <summary>
            Launch a new command and returns the Command object that can be used to monitor
            the restult.  It does not wait for the command to complete, however you 
            can call 'Wait' to do that, or use the 'Run' or 'RunToConsole' methods. */
            </summary>
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            <param variable="options">Additional qualifiers that control how the process is run</param>
            <returns>A Command structure that can be queried to determine ExitCode, Output, etc.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.#ctor(System.String)">
            <summary>
            Create a subprocess to run 'commandLine' with no special options. 
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.Wait">
            <summary>
            Wait for a started process to complete (HasExited will be true on return)
            </summary>
            <returns>Wait returns that 'this' pointer.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.ThrowCommandFailure(System.String)">
            <summary>
            Throw a error if the command exited with a non-zero exit code
            printing useful diagnostic information along with the thrown message.
            This is useful when NoThrow is specified, and after post-processing
            you determine that the command really did fail, and an normal 
            Command.Run failure was the appropriate action.  
            </summary>
            <param name="message">An additional message to print in the throw (can be null)</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.Process">
            <summary>
            Get the underlying process object.  Generally not used. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.Kill">
            <summary>
            Kill the process (and any child processses (recursively) associated with the 
            running command).   Note that it may not be able to kill everything it should
            if the child-parent' chain is broken by a child that creates a subprocess and
            then dies itself.   This is reasonably uncommon, however. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.Quote(System.String)">
            <summary>
            Put double quotes around 'str' if necessary (handles quotes quotes.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.FindOnPath(System.String)">
            <summary>
            Given a string 'commandExe' look for it on the path the way cmd.exe would.   
            Returns null if it was not found.   
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DirectoryUtilities">
            <summary>
            General purpose utilities dealing with archiveFile system directories. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DirectoryUtilities.Copy(System.String,System.String)">
            <summary>
            SafeCopy sourceDirectory to directoryToVersion recursively. The target directory does
            no need to exist
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DirectoryUtilities.Copy(System.String,System.String,System.IO.SearchOption)">
            <summary>
            SafeCopy all files from sourceDirectory to directoryToVersion.  If searchOptions == AllDirectories
            then the copy is recursive, otherwise it is just one level.  The target directory does not
            need to exist. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DirectoryUtilities.Clean(System.String)">
            <summary>
            Clean is sort of a 'safe' recursive delete of a directory.  It either deletes the
            files or moves them to '*.deleting' names.  It deletes directories that are completely
            empty.  Thus it will do a recursive delete when that is possible.  There will only 
            be *.deleting files after this returns.  It returns the number of files and directories
            that could not be deleted.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DirectoryUtilities.DeleteOldest(System.String,System.Int32)">
            <summary>
            Removes the oldest directories directly under 'directoryPath' so that 
            only 'numberToKeep' are left. 
            </summary>
            <param variable="directoryPath">Directory to removed old files from.</param>
            <param variable="numberToKeep">The number of files to keep.</param>
            <returns> true if there were no errors deleting files</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DirectoryUtilities.GetFiles(System.String,System.String,System.IO.SearchOption)">
             <summary>
             DirectoryUtilities.GetFiles is basicaly the same as Directory.GetFiles 
             however it returns IEnumerator, which means that it lazy.  This is very important 
             for large directory trees.  A searchPattern can be specified (Windows wildcard conventions)
             that can be used to filter the set of archiveFile names returned. 
             
             Suggested Usage
             
                 foreach(string fileName in DirectoryUtilities.GetFiles("c:\", "*.txt")){
                     Console.WriteLine(fileName);
                 }
            
             </summary>
             <param variable="directoryPath">The base directory to enumerate</param>
             <param variable="searchPattern">A pattern to filter the names (windows filename wildcards * ?)</param>
             <param variable="searchOptions">Indicate if the search is recursive or not.  </param>
             <returns>The enumerator for all archiveFile names in the directory (recursively). </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DirectoryUtilities.GetFiles(System.String,System.String)">
            <summary>
            return a lazy enumerable for every path in 'directoryName' that matchs 'searchPattern' (default is *)MO
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpPointer">
            <summary>
            Immutable pointer into the dump file. Has associated size for runtime checking.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpPointer.Shrink(System.UInt32)">
            <summary>
            Returns a DumpPointer to the same memory, but associated with a smaller size.
            </summary>
            <param name="size">smaller size to shrink the pointer to.</param>
            <returns>new DumpPointer</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpPointer.Copy(System.IntPtr,System.UInt32,System.UInt32)">
            <summary>
            Copy numberBytesToCopy from the DumpPointer into &amp;destinationBuffer[indexDestination].
            </summary>
            <param name="dest"></param>
            <param name="destinationBufferSizeInBytes"></param>
            <param name="numberBytesToCopy"></param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpPointer.Copy(System.IntPtr,System.UInt32)">
            <summary>
            Copy raw bytes to buffer
            </summary>
            <param name="destinationBuffer">buffer to copy to.</param>
            <param name="sizeBytes">number of bytes to copy. Caller ensures the destinationBuffer
            is large enough</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpPointer.PtrToStructure``1">
            <summary>
            Marshal this into a managed structure, and do bounds checks.
            </summary>
            <typeparam name="T">Type of managed structure to marshal as</typeparam>
            <returns>a managed copy of the structure</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpReader">
            <summary>
            Read contents of a minidump. 
            If we have a 32-bit dump, then there's an addressing collision possible.
            OS debugging code sign extends 32 bit wide addresses into 64 bit wide addresses.
            The CLR does not sign extend, thus you cannot round-trip target addresses exposed by this class.
            Currently we read these addresses once and don't hand them back, so it's not an issue.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_STREAM_TYPE">
            <summary>
            Type of stream within the minidump.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.ZeroExtendAddress(System.UInt64)">
            <summary>
            Remove the OS sign-extension from a target address.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_LOCATION_DESCRIPTOR">
            <summary>
            Describes a data stream within the minidump
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_LOCATION_DESCRIPTOR.DataSize">
            <summary>
            Size of the stream in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_LOCATION_DESCRIPTOR.Rva">
            <summary>
            Offset (in bytes) from the start of the minidump to the data stream.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_LOCATION_DESCRIPTOR.IsNull">
            <summary>
            True iff the data is missing.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_LOCATION_DESCRIPTOR64">
            <summary>
            Describes a data stream within the minidump
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_LOCATION_DESCRIPTOR64.DataSize">
            <summary>
            Size of the stream in bytes.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_LOCATION_DESCRIPTOR64.Rva">
            <summary>
            Offset (in bytes) from the start of the minidump to the data stream.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MEMORY_DESCRIPTOR">
            <summary>
            Describes a range of memory in the target.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MEMORY_DESCRIPTOR.startofmemoryrange">
            <summary>
            Starting Target address of the memory range.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MEMORY_DESCRIPTOR.Memory">
            <summary>
            Location in minidump containing the memory corresponding to StartOfMemoryRage
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MEMORY_DESCRIPTOR64">
            <summary>
            Describes a range of memory in the target.
            </summary>
            <remarks>
            This is used for full-memory minidumps where
            all of the raw memory is laid out sequentially at the
            end of the dump.  There is no need for individual RVAs
            as the RVA is the base RVA plus the sum of the preceeding
            data blocks.
            </remarks>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MEMORY_DESCRIPTOR64.startofmemoryrange">
            <summary>
            Starting Target address of the memory range.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MEMORY_DESCRIPTOR64.DataSize">
            <summary>
            Size of memory in bytes.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_EXCEPTION">
            <summary>
            The struct that holds an EXCEPTION_RECORD
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_EXCEPTION_STREAM">
            <summary>
            The struct that holds contents of a dump's MINIDUMP_STREAM_TYPE.ExceptionStream
            which is a MINIDUMP_EXCEPTION_STREAM.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_SYSTEM_INFO">
            <summary>
            Describes system information about the system the dump was taken on.
            This is returned by the MINIDUMP_STREAM_TYPE.SystemInfoStream stream.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MODULE.baseofimage">
            <summary>
            Address that module is loaded within target.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MODULE.SizeOfImage">
            <summary>
            Size of image within memory copied from IMAGE_OPTIONAL_HEADER.SizeOfImage.
            Note that this is usually different than the file size.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MODULE.CheckSum">
            <summary>
            Checksum, copied from IMAGE_OPTIONAL_HEADER.CheckSum. May be 0 if not optional
            header is not available.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MODULE.TimeDateStamp">
            <summary>
            TimeStamp in Unix 32-bit time_t format. Copied from IMAGE_FILE_HEADER.TimeDateStamp
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MODULE.ModuleNameRva">
            <summary>
            RVA within minidump of the string containing the full path of the module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MODULE.Timestamp">
            <summary>
            Gets TimeDateStamp as a DateTime. This is based off a 32-bit value and will overflow in 2038.
            This is not the same as the timestamps on the file.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_THREAD">
            <summary>
            Raw MINIDUMP_THREAD structure imported from DbgHelp.h
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_THREAD.Stack">
            <summary>
            Describes the memory location of the thread's raw stack.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_THREAD_LIST`1">
            <summary>
            List of Threads in the minidump.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.TranslateRVA(System.UInt64)">
            <summary>
            Translates from an RVA to Dump Pointer. 
            </summary>
            <param name="rva">RVA within the dump</param>
            <returns>DumpPointer representing RVA.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.TranslateRVA(Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.RVA)">
            <summary>
            Translates from an RVA to Dump Pointer. 
            </summary>
            <param name="rva">RVA within the dump</param>
            <returns>DumpPointer representing RVA.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.TranslateRVA(Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.RVA64)">
            <summary>
            Translates from an RVA to Dump Pointer. 
            </summary>
            <param name="rva">RVA within the dump</param>
            <returns>DumpPointer representing RVA.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.GetString(Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.RVA)">
            <summary>
            Gets a MINIDUMP_STRING at the given RVA as an System.String.
            </summary>
            <param name="rva">RVA of MINIDUMP_STRING</param>
            <returns>System.String representing contents of MINIDUMP_STRING at the given RVA</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.GetString(Microsoft.Diagnostics.Runtime.Utilities.DumpPointer)">
            <summary>
            Gets a MINIDUMP_STRING at the given DumpPointer as an System.String.
            </summary>
            <param name="ptr">DumpPointer to a MINIDUMP_STRING</param>
            <returns>System.String representing contents of MINIDUMP_STRING at the given location
            in the dump</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.ReadMemory(System.UInt64,System.Int32)">
            <summary>
            Read memory from the dump file and return results in newly allocated buffer
            </summary>
            <param name="targetAddress">target address in dump to read length bytes from</param>
            <param name="length">number of bytes to read</param>
            <returns>newly allocated byte array containing dump memory</returns>
            <remarks>All memory requested must be readable or it throws.</remarks>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.ReadMemory(System.UInt64,System.Byte[],System.Int32)">
            <summary>
            Read memory from the dump file and copy into the buffer
            </summary>
            <param name="targetAddress">target address in dump to read buffer.Length bytets from</param>
            <param name="buffer">destination buffer to copy target memory to.</param>
            <remarks>All memory requested must be readable or it throws.</remarks>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.ReadMemory(System.UInt64,System.IntPtr,System.UInt32)">
            <summary>
            Read memory from target and copy it to the local buffer pointed to by
            destinationBuffer. Throw if any portion of the requested memory is unavailable.
            </summary>
            <param name="targetRequestStart">target address in dump file to copy
            destinationBufferSizeInBytes bytes from. </param>
            <param name="destinationBuffer">pointer to copy the memory to.</param>
            <param name="destinationBufferSizeInBytes">size of the destinationBuffer in bytes.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.ReadPartialMemory(System.UInt64,System.IntPtr,System.UInt32)">
            <summary>
            Read memory from target and copy it to the local buffer pointed to by destinationBuffer.
            
            </summary>
            <param name="targetRequestStart">target address in dump file to copy
            destinationBufferSizeInBytes bytes from. </param>
            <param name="destinationBuffer">pointer to copy the memory to.</param>
            <param name="destinationBufferSizeInBytes">size of the destinationBuffer in bytes.</param>
            <returns>Number of contiguous bytes successfuly copied into the destination buffer.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.ToString">
            <summary>
            ToString override. 
            </summary>
            <returns>string description of the DumpReader.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="path">filename to open dump file</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.Dispose">
            <summary>
            Dispose method.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.GetStream(Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_STREAM_TYPE)">
            <summary>
            Get a DumpPointer for the given stream. That can then be used to further decode the stream.
            </summary>
            <param name="type">type of stream to lookup</param>
            <returns>DumpPointer refering into the stream. </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.TryGetStream(Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_STREAM_TYPE,Microsoft.Diagnostics.Runtime.Utilities.DumpPointer@)">
            <summary>
            Get a DumpPointer for the given stream. That can then be used to further decode the stream.
            </summary>
            <param name="type">type of stream to lookup</param>
            <param name="stream">DumpPointer refering into the stream. </param>
            <returns>True if stream was succesfully retrived</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.Version">
            <summary>
            Version numbers of OS that this dump was taken on.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.OSVersion">
            <summary>
            Operating system that the dump was taken on.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.OSVersionString">
            <summary>
            Friendly helper to get full OS version string (including CSDVersion) that the dump was taken on.
            </summary>
            <remarks>This is really just to compensate that public OperatingSystem's ctor doesn't let us
            add the service pack string, so we need a special helper for that.</remarks>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.ProcessorArchitecture">
            <summary>
            The processor architecture that this dump was taken on.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.GetThread(System.Int32)">
            <summary>
            Get the thread for the given thread Id.
            </summary>
            <param name="threadId">thread Id to lookup.</param>
            <returns>a DumpThread object representing a thread in the dump whose thread id matches
            the requested id.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.EnumerateThreads">
            <summary>
            Enumerate all the native threads in the dump
            </summary>
            <returns>an enumerate of DumpThread objects</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.IsExceptionStream">
            <summary>
            Check on whether there's an exception stream in the dump
            </summary>
            <returns> true iff there is a MINIDUMP_EXCEPTION_STREAM in the dump. </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.ExceptionStreamThreadId">
            <summary>
            Return the TID from the exception stream.
            </summary>
            <returns> The TID from the exception stream. </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.LookupModule(System.String)">
            <summary>
            Lookup the first module in the target with a matching. 
            </summary>
            <param name="nameModule">The name can either be a matching full name, or just shortname</param>
            <returns>The first DumpModule that has a matching name. </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.TryLookupModuleByAddress(System.UInt64)">
            <summary>
            Return the module containing the target address, or null if no match.
            </summary>
            <param name="targetAddress">address in target</param>
            <returns>Null if no match. Else a DumpModule such that the target address is in between the range specified
            by the DumpModule's .BaseAddress and .Size property </returns>
            <remarks>This can be useful for symbol lookups or for using module images to
            supplement memory read requests for minidumps.</remarks>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpReader.EnumerateModules">
            <summary>
            Enumerate all the modules in the dump.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpModule">
            <summary>
            Represents a native module in a dump file. This is a flyweight object.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpModule.#ctor(Microsoft.Diagnostics.Runtime.Utilities.DumpReader,Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_MODULE)">
            <summary>
            Constructor
            </summary>
            <param name="owner">owning DumpReader</param>
            <param name="raw">unmanaged dump structure describing the module</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpModule.FullName">
            <summary>
             Usually, the full filename of the module. Since the dump may not be captured on the local
             machine, be careful of using this filename with the local file system.
             In some cases, this could be a short filename, or unavailable.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpModule.BaseAddress">
            <summary>
            Base address within the target of where this module is loaded.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpModule.Size">
            <summary>
            Size of this module in bytes as loaded in the target.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpModule.Timestamp">
            <summary>
            UTC Time stamp of module. This is based off a 32-bit value and will overflow in 2038.
            This is different than any of the filestamps. Call ToLocalTime() to convert from UTC.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpModule.RawTimestamp">
            <summary>
            Gets the raw 32 bit time stamp. Use the Timestamp property to get this as a System.DateTime.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpThread">
            <summary>
            Represents a thread from a minidump file. This is a flyweight object.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpThread.#ctor(Microsoft.Diagnostics.Runtime.Utilities.DumpReader,Microsoft.Diagnostics.Runtime.Utilities.DumpReader.DumpNative.MINIDUMP_THREAD)">
            <summary>
            Constructor for DumpThread
            </summary>
            <param name="owner">owning DumpReader object</param>
            <param name="raw">unmanaged structure in dump describing the thread</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpThread.ThreadId">
            <summary>
            The native OS Thread Id of this thread.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpThread.GetThreadContext(System.IntPtr,System.Int32)">
            <summary>
            Get a thread's context using a raw buffer and size
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.DumpUtility">
            <summary>
            Utility class to provide various random Native debugging operations.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.DumpUtility.IMAGE_DOS_HEADER.IsValid">
            <summary>
            Determine if this is a valid DOS image. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpUtility.MarshalAt``1(System.Byte[],System.UInt32)">
            <summary>
            Marshal a structure from the given buffer. Effectively returns ((T*) &amp;buffer[offset]).
            </summary>
            <typeparam name="T">type of structure to marshal</typeparam>
            <param name="buffer">array of bytes representing binary buffer to marshal</param>
            <param name="offset">offset in buffer to marhsal from</param>
            <returns>marshaled structure</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.DumpUtility.GetTimestamp(System.String)">
            <summary>
            Gets the raw compilation timestamp of a file. 
            This can be matched with the timestamp of a module in a dump file.
            NOTE: This is NOT the same as the file's creation or last-write time.
            </summary>
            <param name="file"></param>
            <returns>0 for common failures like file not found or invalid format. Throws on gross
            errors. Else returns the module's timestamp for comparison against the minidump
            module's stamp.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.FileUtilities">
            <summary>
            General purpose utilities dealing with archiveFile system files. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.FileUtilities.ReadAllLines(System.String)">
            <summary>
            GetLines works much like File.ReadAllLines, however instead of returning a
            array of lines, it returns a IEnumerable so that the archiveFile is not read all
            at once.  This allows 'foreach' syntax to be used on very large files.  
            
            Suggested Usage
            
                foreach(string lineNumber in FileUtilities.GetLines("largeFile.txt")){
                    Console.WriteLine(lineNumber);
                }
            </summary>
            <param variable="fileName">The base directory to enumerate.</param>
            <returns>The enumerator for all lines in the archiveFile.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.FileUtilities.ExpandWildcards(System.String[],System.IO.SearchOption)">
            <summary>
            Given archiveFile specifications possibly with wildcards in them
            return an enumerator that returns each expanded archiveFile name in turn. 
            
            If searchOpt is AllDirectories it does a recursive match. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.FileUtilities.ForceDelete(System.String)">
            <summary>
            Delete works much like File.Delete, except that it will succeed if the
            archiveFile does not exist, and will rename the archiveFile so that even if the archiveFile 
            is locked the original archiveFile variable will be made available.  
            
            It renames the  archiveFile with a '[num].deleting'.  These files might be left 
            behind.  
            
            It returns true if it was competely successful.  If there is a *.deleting
            archiveFile left behind, it returns false. 
            </summary>
            <param variable="fileName">The variable of the archiveFile to delete</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.FileUtilities.TryDelete(System.String)">
            <summary>
            Try to delete 'fileName' catching any exception.  Returns true if successful.   It will delete read-only files.  
            </summary>  
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.FileUtilities.ForceCopy(System.String,System.String)">
            <summary>
            SafeCopy sourceFile to destinationFile.  If the destination exists
            used ForceDelete to get rid of it first.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.FileUtilities.ForceMove(System.String,System.String)">
            <summary>
            Moves sourceFile to destinationFile.  If the destination exists
            used ForceDelete to get rid of it first.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.FileUtilities.Equals(System.String,System.String)">
            <summary>
            Returns true if the two file have exactly the same content (as a stream of bytes). 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.PathUtil">
            <summary>
            Utilties associated with file name paths. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PathUtil.PathRelativeTo(System.String,System.String)">
            <summary>
            Given a path and a superdirectory path relativeToDirectory compute the relative path (the path from) relativeToDirectory
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.PEFile">
            <summary>
            PEFile is a reader for the information in a Portable Exectable (PE) FILE.   This is what EXEs and DLLs are.  
            
            It can read both 32 and 64 bit PE files.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEFile.#ctor(System.String)">
            <summary>
            Create a new PEFile header reader that inspects the 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEFile.Header">
            <summary>
            The Header for the PE file.  This contains the infor in a link /dump /headers 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEFile.GetPdbSignature(System.String@,System.Guid@,System.Int32@,System.Boolean)">
            <summary>
            Looks up the debug signature information in the EXE.   Returns true and sets the parameters if it is found. 
            
            If 'first' is true then the first entry is returned, otherwise (by default) the last entry is used 
            (this is what debuggers do today).   Thus NGEN images put the IL PDB last (which means debuggers 
            pick up that one), but we can set it to 'first' if we want the NGEN PDB.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEFile.GetFileVersionInfo">
            <summary>
            Gets the File Version Information that is stored as a resource in the PE file.  (This is what the
            version tab a file's property page is populated with).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEFile.GetSxSManfest">
            <summary>
            For side by side dlls, the manifest that decribes the binding information is stored as the RT_MANIFEST resource, and it
            is an XML string.   This routine returns this.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEFile.Dispose">
            <summary>
            Closes any file handles and cleans up resources.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.PEHeader">
            <summary>
            A PEHeader is a reader of the data at the begining of a PEFile.    If the header bytes of a 
            PEFile are read or mapped into memory, this class can parse it when given a poitner to it. 
            It can read both 32 and 64 bit PE files.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.#ctor(System.Void*,System.Boolean)">
            <summary>
            Returns a PEHeader for void* pointer in memory.  It does NO validity checking. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.PEHeaderSize">
            <summary>
            The total s,ize of the header,  including section array of the the PE header.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.VirtualAddressToRva(System.Void*)">
            <summary>
            Given a virtual address to data in a mapped PE file, return the relative virtual address (displacement from start of the image)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.RvaToVirtualAddress(System.Int32)">
            <summary>
            Given a relative virtual address (displacement from start of the image) return the virtual address to data in a mapped PE file
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.RvaToFileOffset(System.Int32)">
            <summary>
            Given a relative virtual address (displacement from start of the image) return a offset in the file data for that data.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.IsPE64">
            <summary>
            Returns true if this is PE file for a 64 bit architecture.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.IsManaged">
            <summary>
            Returns true if this file contains managed code (might also contain native code). 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.Signature">
            <summary>   
            Returns the 'Signture' of the PE HEader PE\0\0 = 0x4550, used for sanity checking.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.Machine">
            <summary>
            The machine this PE file is intended to run on 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.NumberOfSections">
            <summary>
            PE files have a number of sections that represent regions of memory with the access permisions.  This is the nubmer of such sections.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.TimeDateStampSec">
            <summary>
            The the PE file was created represented as the number of seconds since Jan 1 1970 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.TimeDateStamp">
            <summary>
            The the PE file was created represented as a DateTime object
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.PointerToSymbolTable">
            <summary>
            PointerToSymbolTable (see IMAGE_FILE_HEADER in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.NumberOfSymbols">
            <summary>
            NumberOfSymbols (see IMAGE_FILE_HEADER PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.SizeOfOptionalHeader">
            <summary>
            SizeOfOptionalHeader (see IMAGE_FILE_HEADER PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.Characteristics">
            <summary>
            Characteristics (see IMAGE_FILE_HEADER PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.Magic">
            <summary>
            Magic (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.MajorLinkerVersion">
            <summary>
            MajorLinkerVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.MinorLinkerVersion">
            <summary>
            MinorLinkerVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.SizeOfCode">
            <summary>
            SizeOfCode (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.SizeOfInitializedData">
            <summary>
            SizeOfInitializedData (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.SizeOfUninitializedData">
            <summary>
            SizeOfUninitializedData (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.AddressOfEntryPoint">
            <summary>
            AddressOfEntryPoint (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.BaseOfCode">
            <summary>
            BaseOfCode (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.ImageBase">
            <summary>
            ImageBase (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.SectionAlignment">
            <summary>
            SectionAlignment (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.FileAlignment">
            <summary>
            FileAlignment (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.MajorOperatingSystemVersion">
            <summary>
            MajorOperatingSystemVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.MinorOperatingSystemVersion">
            <summary>
            MinorOperatingSystemVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.MajorImageVersion">
            <summary>
            MajorImageVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.MinorImageVersion">
            <summary>
            MinorImageVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.MajorSubsystemVersion">
            <summary>
            MajorSubsystemVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.MinorSubsystemVersion">
            <summary>
            MinorSubsystemVersion (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.Win32VersionValue">
            <summary>
            Win32VersionValue (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.SizeOfImage">
            <summary>
            SizeOfImage (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.SizeOfHeaders">
            <summary>
            SizeOfHeaders (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.CheckSum">
            <summary>
            CheckSum (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.Subsystem">
            <summary>
            Subsystem (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.DllCharacteristics">
            <summary>
            DllCharacteristics (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.SizeOfStackReserve">
            <summary>
            SizeOfStackReserve (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.SizeOfStackCommit">
            <summary>
            SizeOfStackCommit (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.SizeOfHeapReserve">
            <summary>
            SizeOfHeapReserve (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.SizeOfHeapCommit">
            <summary>
            SizeOfHeapCommit (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.LoaderFlags">
            <summary>
            LoaderFlags (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.NumberOfRvaAndSizes">
            <summary>
            NumberOfRvaAndSizes (see IMAGE_OPTIONAL_HEADER32 or IMAGE_OPTIONAL_HEADER64 in PE File spec)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.Directory(System.Int32)">
            <summary>
            returns the data directory (virtual address an blob, of a data directory with index 'idx'.   14 are currently defined.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.ExportDirectory">
            <summary>
            Return the data directory for DLL Exports see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.ImportDirectory">
            <summary>
            Return the data directory for DLL Imports see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.ResourceDirectory">
            <summary>
            Return the data directory for DLL Resources see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.ExceptionDirectory">
            <summary>
            Return the data directory for DLL Exceptions see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.CertificatesDirectory">
            <summary>
            Return the data directory for DLL securiy certificates (Authenticode) see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.BaseRelocationDirectory">
            <summary>
            Return the data directory Image Base Relocations (RELOCS) see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.DebugDirectory">
            <summary>
            Return the data directory for Debug information see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.ArchitectureDirectory">
            <summary>
            Return the data directory for DLL Exports see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.GlobalPointerDirectory">
            <summary>
            Return the data directory for GlobalPointer (IA64) see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.ThreadStorageDirectory">
            <summary>
            Return the data directory for THread local storage see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.LoadConfigurationDirectory">
            <summary>
            Return the data directory for Load Configuration see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.BoundImportDirectory">
            <summary>
            Return the data directory for Bound Imports see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.ImportAddressTableDirectory">
            <summary>
            Return the data directory for the DLL Import Address Table (IAT) see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.DelayImportDirectory">
            <summary>
            Return the data directory for Delayed Imports see PE file spec for more
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEHeader.ComDescriptorDirectory">
            <summary>
             see PE file spec for more .NET Runtime infomration.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.MachineType">
            <summary>
            The Machine types supporte by the portable executable (PE) File format
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.MachineType.Native">
            <summary>
            Unknown machine type
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.MachineType.X86">
            <summary>
            Intel X86 CPU 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.MachineType.ia64">
            <summary>
            Intel IA64 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.MachineType.ARM">
            <summary>
            ARM 32 bit 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.MachineType.Amd64">
            <summary>
            Arm 64 bit 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.IMAGE_DATA_DIRECTORY">
            <summary>
            Represents a Portable Executable (PE) Data directory.  This is just a well known optional 'Blob' of memory (has a starting point and size)
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.IMAGE_DATA_DIRECTORY.VirtualAddress">
            <summary>
            The start of the data blob when the file is mapped into memory
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.IMAGE_DATA_DIRECTORY.Size">
            <summary>
            The length of the data blob.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.FileVersionInfo">
            <summary>
            FileVersionInfo reprents the extended version formation that is optionally placed in the PE file resource area. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.FileVersionInfo.FileVersion">
            <summary>
            The verison string 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.PEBuffer">
            <summary>
            A PEBuffer represents 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.SymPath">
            <summary>
            SymPath is a class that knows how to parse _NT_SYMBOL_PATH syntax.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymPath.SymbolPath">
            <summary>
            This is the _NT_SYMBOL_PATH exposed as a SymPath type setting this sets the environment variable.
            If you only set _NT_SYMBOL_PATH through the SymPath class, everything stays in sync. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymPath._NT_SYMBOL_PATH">
            <summary>
            This allows you to set the _NT_SYMBOL_PATH as a string.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymPath.CleanSymbolPath">
            <summary>
            This 'cleans up' a symbol path.  In particular
            Empty ones are replaced with good defaults (symweb or msdl)
            All symbol server specs have local caches (%Temp%\symbols if nothing else is specified).  
            
            Note that this routine does NOT update _NT_SYMBOL_PATH.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymPath.MicrosoftSymbolServerPath">
            <summary>
            Return the string representing a symbol path for the 'standard' microsoft symbol servers.   
            This returns the public msdl.microsoft.com server if outside Microsoft.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymPath.#ctor">
            <summary>
            Create an empty symbol path
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymPath.#ctor(System.String)">
            <summary>
            Create a symbol that represents 'path' (the standard semicolon separated list of locations)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymPath.Elements">
            <summary>
            Returns the List of elements in the symbol path. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymPath.Add(System.String)">
            <summary>
            Append all the elements in the semicolon separated list, 'path', to the symbol path represented by 'this'. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymPath.Add(Microsoft.Diagnostics.Runtime.Utilities.SymPathElement)">
            <summary>
            append a new symbol path element to the begining of the symbol path represented by 'this'.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymPath.Insert(System.String)">
            <summary>
            insert all the elements in the semicolon separated list, 'path' to the begining of the symbol path represented by 'this'.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymPath.Insert(Microsoft.Diagnostics.Runtime.Utilities.SymPathElement)">
            <summary>
            insert a new symbol path element to the begining of the symbol path represented by 'this'.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymPath.DefaultSymbolCache">
            <summary>
            If you need to cache files locally, put them here.  It is defined
            to be the first local path of a SRV* qualification or %TEMP%\symbols
            if not is present.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymPath.InsureHasCache(System.String)">
            <summary>
            People can use symbol servers without a local cache.  This is bad, add one if necessary. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymPath.LocalOnly">
            <summary>
            Removes all references to remote paths.  This insures that network issues don't cause grief.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymPath.CacheFirst">
            <summary>
            Create a new symbol path which first search all machine local locations (either explicit location or symbol server cache locations)
            folloed by all non-local symbol server.   This produces better behavior (If you can find it locally it will be fast)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymPath.ToString">
            <summary>
            returns the string representation (semicolon separated) for the symbol path.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymPath.ComputerNameExists(System.String,System.Int32)">
            <summary>
            Checks to see 'computerName' exists (there is a Domain Names Service (DNS) reply to it)
            This routine times out relative quickly (after 700 msec) if there is a problem reaching 
            the computer, and returns false.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.SymPathElement">
            <summary>
            SymPathElement represents the text between the semicolons in a symbol path.  It can be a symbol server specification or a simple directory path. 
            
            SymPathElement follows functional conventions.  After construction everything is read-only. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymPathElement.IsSymServer">
            <summary>
            returns true if this element of the symbol server path a symbol server specification
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymPathElement.Cache">
            <summary>
            returns the local cache for a symbol server specifcation.  returns null if not specified
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymPathElement.Target">
            <summary>
            returns location to look for symbols.  This is either a directory specification or an URL (for symbol servers)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymPathElement.IsRemote">
            <summary>
            IsRemote returns true if it looks like the target is not on the local machine.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymPathElement.ToString">
            <summary>
            returns the string repsentation for the symbol server path element (e.g. SRV*c:\temp*\\symbols\symbols)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymPathElement.Equals(System.Object)">
            <summary>
            Implements object interface
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymPathElement.GetHashCode">
            <summary>
            Implements object interface
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.SymbolReaderNativeMethods.SSRVOPT_DWORD">
                    [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
                    public static extern int GetCurrentProcessId();
            
                    [DllImport("kernel32.dll",  SetLastError = true)]
                    public static extern IntPtr OpenProcess(int access, bool inherit, int processID);
                    *
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.SymbolReader">
            <summary>
            A symbol reader represents something that can FIND pdbs (either on a symbol server or via a symbol path)
            Its job is to find a full path a PDB.  Then you can use OpenSymbolFile to get a SymbolReaderModule and do more. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolReader.#ctor(System.IO.TextWriter,Microsoft.Diagnostics.Runtime.Utilities.SymPath)">
            <summary>
            Opens a new SymbolReader.   All diagnostics messages about symbol lookup go to 'log'.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolReader.FindSymbolFilePathForModule(System.String)">
            <summary>
            Finds the symbol file for 'exeFilePath' that exists on the current machine (we open
            it to find the needed info).   Uses the SymbolReader.SymbolPath (including Symbol servers) to 
            look up the PDB, and will download the PDB to the local cache if necessary.   It will also
            generate NGEN pdbs unless SymbolReaderFlags.NoNGenPDB is set.   
            
            returns null if the pdb can't be found.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolReader.GenerateNGenPdbForModule(System.String)">
            <summary>
            Given a full filename path to an NGEN image, insure that there is an NGEN image for it
            in the symbol cache.  If one already exists, this method simply returns that.   If not
            it is generated and placed in the symbol cache.  When generating the PDB this routine
            attempt to resolve line numbers, which DOES require looking up the PDB for the IL image. 
            Thus routine may do network accesses (to download IL PDBs).  
            
            Note that FindSymbolFilePathForModule calls this, so normally you don't need to call 
            this method directly.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolReader.FindSymbolFilePath(System.String,System.Guid,System.Int32,System.String,System.String)">
            <summary>
            Find the complete PDB path, given just the simple name (filename + pdb extension) as well as its 'signature', 
            which uniquely identifies it (on symbol servers).   Uses the SymbolReader.SymbolPath (including Symbol servers) to 
            look up the PDB, and will download the PDB to the local cache if necessary.  
            
            A Guid of 0, means 'unknown' and will match the first PDB that matches simple name.  Thus it is unsafe. 
            
            Returns null if the PDB could  not be found
            
            </summary>
            <param name="pdbSimpleName">The name of the PDB file (we only use the file name part)</param>
            <param name="pdbIndexGuid">The GUID that is embedded in the DLL in the debug information that allows matching the DLL and the PDB</param>
            <param name="pdbIndexAge">Tools like BBT transform a DLL into another DLL (with the same GUID) the 'pdbAge' is a small integers
            that indicates how many transformations were done</param>
            <param name="dllFilePath">If you know the path to the DLL for this pdb add it here.  That way we can probe next to the DLL
            for the PDB file.</param>
            <param name="fileVersion">This is an optional string that identifies the file version (the 'Version' resource information.  
            It is used only to provided better error messages for the log.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolReader.FindExecutableFilePath(System.String,System.Int32,System.Int32,Microsoft.Diagnostics.Runtime.ISymbolNotification)">
            <summary>
            This API looks up an executable file, by its build-timestamp and size (on a symbol server),  'fileName' should be 
            a simple name (no directory), and you need the buildTimeStamp and sizeOfImage that are found in the PE header.
            
            Returns null if it cannot find anything.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolReader.OpenSymbolFile(System.String)">
            <summary>
            Given the path name to a particular PDB file, load it so that you can resolve symbols in it.  
            </summary>
            <param name="symbolFilePath">The name of the PDB file to open.</param>
            <returns>The SymbolReaderModule that represents the information in the symbol file (PDB)</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymbolReader.SymbolPath">
            <summary>
            The symbol path used to look up PDB symbol files.   Set when the reader is initialized.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymbolReader.SourcePath">
            <summary>
            The paths used to look up source files.  defaults to _NT_SOURCE_PATH.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymbolReader.SymbolCacheDirectory">
            <summary>
            Where symbols are downloaded if needed.   Derived from symbol path
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymbolReader.SourceCacheDirectory">
            <summary>
            The place where source is downloaded from a source server.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymbolReader.Flags">
            <summary>
            Is this symbol reader limited to just the local machine cache or not?
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.SymbolReader.CacheUnsafePdbs">
            <summary>
            Cache even the unsafe pdbs to the SymbolCacheDirectory.   TODO: is this a hack?
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymbolReader.SecurityCheck">
            <summary>
            We call back on this when we find a PDB by probing in 'unsafe' locations (like next to the EXE or in the Built location)
            If this function returns true, we assume that it is OK to use the PDB.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymbolReader.Log">
            <summary>
            A place to log additional messages 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolReader.Dispose">
            <summary>
            Note that all SymbolReaderModules returned by 'OpenSymbolFile' become invalid after disposing of the SymbolReader.  
            </summary>
            
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymbolReader.IsDisposed">
            <summary>
            Returns true if Dispose was called.  Meant for asserts. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolReader.GetPhysicalFileFromServer(System.String,System.String,System.String,Microsoft.Diagnostics.Runtime.ISymbolNotification)">
            <summary>
            Fetches a file from the server 'serverPath' weith pdb signature path 'pdbSigPath' and places it in its
            correct location in 'symbolCacheDir'  Will return the path of the cached copy if it succeeds, null otherwise.  
            
            You should probably be using GetFileFromServer
            </summary>
            <param name="serverPath">path to server (eg. \\symbols\symbols or http://symweb) </param>
            <param name="pdbIndexPath">pdb path with signature (e.g clr.pdb/1E18F3E494DC464B943EA90F23E256432/clr.pdb)</param>
            <param name="symbolCacheDir">path to the symbol cache where files are fetched (e.g. %TEMP%\symbols) </param>
            <param name="notification">A callback to provide progress updates.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolReader.CopyStreamToFile(System.IO.Stream,System.String,System.String,Microsoft.Diagnostics.Runtime.ISymbolNotification)">
            <summary>
            This just copies a stream to a file path with logging.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolReader.GetFileFromServer(System.String,System.String,System.String,Microsoft.Diagnostics.Runtime.ISymbolNotification)">
            <summary>
            Looks up 'fileIndexPath' on the server 'urlForServer' copying the file to 'symbolCacheDir' and returning the
            path name there (thus it is always a local file).  Unlike  GetPhysicalFileFromServer, GetFileFromServer understands
            how to deal with compressed files and file.ptr (redirection).  
            </summary>
            <returns>The path to a local file or null if the file cannot be found.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolReader.GetClrDirectoryForNGenImage(System.String,System.IO.TextWriter)">
            <summary>
            Deduce the path to where CLR.dll (and in particular NGEN.exe live for the NGEN image 'ngenImagepath')
            Returns null if it can't be found
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolReader.CacheFileLocally(System.String,System.Guid,System.Int32)">
            <summary>
            This is an optional routine.  It is already the case that if you find a PDB on a symbol server
            that it will be cached locally, however if you find it on a network path by NOT using a symbol
            server, it will be used in place.  This is annoying, and this routine makes up for this by
            mimicking this behavior.  Basically if pdbPath is not a local file name, it will copy it to
            the local symbol cache and return the local path. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolReader.BypassSystem32FileRedirection(System.String)">
            <summary>
            We may be a 32 bit app which has File system redirection turned on
            Morph System32 to SysNative in that case to bypass file system redirection         
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.SymbolModule">
            <summary>
            A symbolReaderModule represents a single PDB.   You get one from SymbolReader.OpenSymbolFile
            It is effecively a managed interface to the Debug Interface Access (DIA) see 
            http://msdn.microsoft.com/en-us/library/x93ctkx8.aspx for more.   I have only exposed what
            I need, and the interface is quite large (and not super pretty).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymbolModule.PdbPath">
            <summary>
            The path name to the PDB itself
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymbolModule.ExePath">
            <summary>
            This is the EXE associated with the Pdb.  It may be null or an invalid path.  It is used
            to help look up source code (it is implicitly part of the Source Path search) 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolModule.FindNameForRva(System.UInt32)">
            <summary>
            Finds a (method) symbolic name for a given relative virtual address of some code.  
            Returns an empty string if a name could not be found. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolModule.SourceLocationForRva(System.UInt32)">
            <summary>
            Fetches the source location (line number and file), given the relative virtual address (RVA)
            of the location in the executable.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolModule.SourceLocationForManagedCode(System.UInt32,System.Int32)">
            <summary>
            Managed code is shipped as IL, so RVA to NATIVE mapping can't be placed in the PDB. Instead
            what is placed in the PDB is a mapping from a method's meta-data token and IL offset to source
            line number.  Thus if you have a metadata token and IL offset, you can again get a source location
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolModule.SourceLocationsForMethod(System.UInt32)">
            <summary>
            Get the full list of SourceLocations (with corresponding ILOffset) for the given method
            Based on the commented out code from "SourceLocationForManagedCode(uint methodMetaDataToken, int ilOffset)"
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SymbolModule.AllSourceFiles">
            <summary>
            Returns a list of all source files referenced in the PDB
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymbolModule.PdbGuid">
            <summary>
            The a unique identifier that is used to relate the DLL and its PDB.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymbolModule.PdbAge">
            <summary>
            Along with the PdbGuid, there is a small integer 
            call the age is also used to find the PDB (it represents the differnet 
            post link transformations the DLL has undergone).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SymbolModule.SymbolReader">
            <summary>
            The symbol reader this SymbolModule was created from.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.SymbolReaderFlags">
            <summary>
            SymbolReaderFlags indicates preferences on how agressively symbols should be looked up.  
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.SymbolReaderFlags.None">
            <summary>
            No options this is the common case, where you want to look up everything you can. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.SymbolReaderFlags.CacheOnly">
            <summary>
            Only fetch the PDB if it lives in the symbolCacheDirectory (is local an is generated).  
            This will generate NGEN pdbs unless the NoNGenPDBs flag is set. 
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.SymbolReaderFlags.NoNGenPDB">
            <summary>
            No NGEN PDB generation.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.SourceFile">
            <summary>
            A source file represents a source file from a PDB.  This is not just a string
            because the file has a build time path, a checksum, and it needs to be 'smart'
            to copy down the file if requested.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SourceFile.BuildTimeFilePath">
            <summary>
            The path of the file at the time the source file was built. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SourceFile.HasChecksum">
            <summary>
            true if the PDB has a checksum for the data in the source file. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.SourceFile.GetSourceFile(System.Boolean)">
            <summary>
            This may fetch things from the source server, and thus can be very slow, which is why it is not a property. 
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.SourceFile.CheckSumMatches">
            <summary>
            If GetSourceFile is called and 'requireChecksumMatch' == false then you can call this property to 
            determine if the checksum actually matched or not.   This will return true if the original
            PDB does not have a checksum (HasChecksum == false)
            </summary>
        </member>
        <member name="T:DiaLoader">
            <summary>
            The DiaLoader class knows how to load the msdia120.dll (the Debug Access Interface) (see docs at
            http://msdn.microsoft.com/en-us/library/x93ctkx8.aspx), without it being registered as a COM object.
            Basically it just called the DllGetClassObject interface directly.
            
            It has one public method 'GetDiaSourceObject' which knows how to create a IDiaDataSource object. 
            From there you can do anything you need.  
            
            In order to get IDiaDataSource3 which includes'getStreamSize' API, you need to use the 
            vctools\langapi\idl\dia2_internal.idl file from devdiv to produce Interop.Dia2Lib.dll
            
            roughly what you need to do is 
                copy vctools\langapi\idl\dia2_internal.idl .
                copy vctools\langapi\idl\dia2.idl .
                copy vctools\langapi\include\cvconst.h .
                Change dia2.idl to include interface IDiaDataSource3 inside library Dia2Lib->importlib->coclass DiaSource
                midl dia2_internal.idl /D CC_DP_CXX
                tlbimp dia2_internal.tlb
                xcopy Dia2Lib.dll Interop.Dia2Lib.dll
            </summary>
        </member>
        <member name="M:DiaLoader.GetDiaSourceObject">
            <summary>
            Load the msdia100 dll and get a IDiaDataSource from it.  This is your gateway to PDB reading.   
            </summary>
        </member>
    </members>
</doc>
