<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>BenchmarkDotNet v0.11.0 | BenchmarkDotNet </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="BenchmarkDotNet v0.11.0 | BenchmarkDotNet ">
      
      
      <link rel="icon" href="../logo/icon-32.png">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/dotnet/BenchmarkDotNet/blob/docs-stable/docs/changelog/v0.11.0.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo/icon.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="changelog.v0.11.0">
<h1 id="benchmarkdotnet-v0110">BenchmarkDotNet v0.11.0</h1>

<p>This is one of the biggest releases of BenchmarkDotNet ever.
There are so many improvements.
We have
new documentation,
many performance improvements,
Job Mutators,
better user experience,
correct Ctrl+C handling,
better generic benchmarks support,
more scenarios for passing arguments to benchmarks,
awesome support of console arguments,
unicode support,
LLVM support in MonoDisassembler,
and many-many other improvements and bug fixes!</p>
<p>A big part of the features and bug fixes were implemented to meet the enterprise requirements of Microsoft to make it possible to port CoreCLR, CoreFX, and CoreFXLab to BenchmarkDotNet.</p>
<p>The release would not be possible without many contributions from amazing community members. This release is a combined effort. We build BenchmarkDotNet together to make benchmarking .NET code easy and available to everyone for free!</p>
<h1 id="new-documentation">New documentation</h1>
<p>We have many improvements in our documentation!
The new docs include:</p>
<ul>
<li><a href="https://dotnet.github.io/docfx/">DocFX</a> under the hood</li>
<li>Detailed changelogs which includes all commits, merged pull requests and resolved issues</li>
<li>API references</li>
<li>Code samples for main features:
we generate it automatically based on the <code>BenchmarkDotNet.Samples</code> project;
it means that all samples can always be compiled
(no more samples with outdated API)</li>
<li>Better UI</li>
<li>Documentation versioning: now it's possible to look at the documentation for recent BenchmarkDotNet versions</li>
</ul>
<h1 id="performance-improvements">Performance improvements</h1>
<p>BenchmarkDotNet needs to be capable of running few thousands of CoreFX and CoreCLR benchmarks in an acceptable amount of time. The code itself was already optimized so we needed architectural and design changes to meet this requirement.</p>
<h2 id="generate-one-executable-per-runtime-settings">Generate one executable per runtime settings</h2>
<p>To ensure that the side effects of one benchmark run does not affect another benchmark run BenchmarkDotNet generates, builds and runs every benchmark in a dedicated process. So far we were generating and building one executable per benchmark, now we generate and build one executable per runtime settings. So if you want to run ten thousands of benchmarks for .NET Core 2.1 we are going to generate and build single executable, not ten thousand. If you target multiple runtimes the build is going to be executed in parallel. Moreover, if one of the parallel builds fail it's going to be repeated in a sequential way.</p>
<p>Previously the time to generate and build 650 benchmarks from our Samples project was <strong>one hour</strong>. Now it's something around <strong>13 seconds</strong> which means <strong>276 X</strong> improvement for this particular scenario. You can see the changes <a href="https://github.com/dotnet/BenchmarkDotNet/issues/699">here</a>.</p>
<h2 id="dont-execute-long-operations-more-than-once-per-iteration">Don't execute long operations more than once per iteration</h2>
<p>BenchmarkDotNet was designed to allow for very accurate and stable micro-benchmarking. One of the techniques that we use is manual loop unrolling. In practice, it meant that for every iteration we were executing the benchmark at least 16 times (the default <code>UnrollFactor</code> value). It was of course not desired for the very time-consuming benchmarks.</p>
<p>So far this feature was always enabled by default and users would need to configure <code>UnrollFactor=1</code> to disable it. Now BenchmarkDotNet is going to discover such scenario and don't perform manual loop unrolling for the very time-consuming benchmarks. BenchmarkDotNet uses <code>Job.IterationTime</code> setting (the default is 0.5s) in the Pilot Experiment stage to determine how many times given benchmark should be executed per iteration.</p>
<p>Example:</p>
<pre><code class="lang-cs">public class Program
{
    static void Main() =&gt; BenchmarkRunner.Run&lt;Program&gt;();

    [Benchmark]
    public void Sleep1s() =&gt; Thread.Sleep(TimeSpan.FromSeconds(1));
}
</code></pre>
<p>Time to run with the previous version: <strong>374 seconds</strong>. With <code>0.11.0</code> it's <strong>27 seconds</strong> which gives us almost <strong>14 X</strong> improvement. A good example of benchmarks that are going to benefit from this change are computer game benchmarks and ML.NET benchmarks. You can see the changes <a href="https://github.com/dotnet/BenchmarkDotNet/pull/760">here</a> and <a href="https://github.com/dotnet/BenchmarkDotNet/pull/771">here</a>.</p>
<h2 id="exposing-more-configuration-settings">Exposing more configuration settings</h2>
<p>The default settings were configured to work well with every scenario. Before running the benchmark, BenchmarkDotNet does not know anything about it. This is why it performs many warmup iterations before running the benchmarks.</p>
<p>When you author benchmarks and run them many times you can come up with custom settings that produce similar results but in a shorter manner of time. To allow you to do that we have exposed:</p>
<ul>
<li><code>Job.MinIterationCount</code> (default value is 15)</li>
<li><code>Job.MaxIterationCount</code> (default value is 100)</li>
<li><code>Job.MinWarmupIterationCount</code> (default value is 6)</li>
<li><code>Job.MaxWarmupIterationCount</code> (default value is 50)</li>
</ul>
<h1 id="user-experience">User Experience</h1>
<p>One of the biggest success factors of BenchmarkDotNet is a great user experience. The tool just works as expected and makes your life easy. We want to make it even better!</p>
<h2 id="net-standard-20">.NET Standard 2.0</h2>
<p>We have ported BenchmarkDotNet to .NET Standard 2.0 and thanks to that we were able to not only simplify our code and build process but also merge <code>BenchmarkDotNet.Core.dll</code> and <code>BenchmarkDotNet.Toolchains.Roslyn.dll</code> into <code>BenchmarkDotNet.dll</code>. We still support .NET 4.6 but we have dropped .NET Core 1.1 support. More information and full discussion can be found <a href="https://github.com/dotnet/BenchmarkDotNet/pull/688">here</a>.</p>
<p><strong>Note:</strong> Our <code>BenchmarkDotNet.Diagnostics.Windows</code> package which uses <code>EventTrace</code> to implement ETW-based diagnosers was also ported to .NET Standard 2.0 and you can now use all the ETW diagnosers with .NET Core on Windows. We plan to add EventPipe support and make this page fully cross-platform and Unix compatible soon.</p>
<h2 id="using-complex-types-as-benchmark-arguments">Using complex types as benchmark arguments</h2>
<p>So far we have required the users to implement <code>IParam</code> interface to make the custom complex types work as benchmark arguments/parameters. This has changed, now the users can use any complex types as arguments and it will just work (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/754">more</a>).</p>
<pre><code class="lang-cs">public class Program
{
    static void Main(string[] args) =&gt; BenchmarkRunner.Run&lt;Program&gt;();

    public IEnumerable&lt;object&gt; Arguments()
    {
        yield return new Point2D(10, 200);
    }

    [Benchmark]
    [ArgumentsSource(nameof(Arguments))]
    public int WithArgument(Point2D point) =&gt; point.X + point.Y;
}

public class Point2D
{
    public int X, Y;

    public Point2D(int x, int y)
    {
        X = x;
        Y = y;
    }

    public override string ToString() =&gt; $&quot;[{X},{Y}]&quot;;
}
</code></pre>
<p><strong>Note</strong>: If you want to control what will be displayed in the summary you should override <code>ToString</code>.</p>
<h2 id="if-iterationsetup-is-provided-run-benchmark-once-per-iteration">If IterationSetup is provided run benchmark once per iteration</h2>
<p>When Stephen Toub says that something is <a href="https://github.com/dotnet/BenchmarkDotNet/issues/730">buggy</a>, it most probably is. BenchmarkDotNet performs multiple invocations of benchmark per every iteration. When we have exposed the <code>[IterationSetup]</code> attribute many users were expecting that the <code>IterationSetup</code> is going to be invoked before every benchmark execution.</p>
<p>It was invoked before every iteration, and iteration was more than one benchmark call if the user did not configure that explicitly. We have changed that and now if you provide an <code>[IterationSetup]</code> method it is going to be executed before every iteration and iteration will invoke the benchmark just once.</p>
<pre><code class="lang-cs">public class Test
{
    public static void Main() =&gt; BenchmarkRunner.Run&lt;Test&gt;();

    [IterationSetup]
    public void MySetup() =&gt; Console.WriteLine(&quot;MySetup&quot;);

    [Benchmark]
    public void MyBenchmark() =&gt; Console.WriteLine(&quot;MyBenchmark&quot;);
}
</code></pre>
<p>Before:</p>
<pre><code class="lang-log">MySetup
MyBenchmark
MyBenchmark
MyBenchmark
MyBenchmark
(...)
</code></pre>
<p>After:</p>
<pre><code class="lang-log">MySetup
MyBenchmark
MySetup
MyBenchmark
MySetup
MyBenchmark
(...)
</code></pre>
<p><strong>Note:</strong> If you want to configure how many times benchmark should be invoked per iteration you can use the new <code>[InvocationCountAttribute]</code>.</p>
<h2 id="job-mutators">Job Mutators</h2>
<p><code>Job</code> represents a set of settings to run the benchmarks. We run every benchmark for every job defined by the user. The problem was that so far many jobs were just added to the config instead of being merged with other jobs.</p>
<p>An example:</p>
<pre><code class="lang-cs">[ClrJob, CoreJob]
[GcServer(true)]
public class MyBenchmarkClass
</code></pre>
<p>Resulted in 3 jobs and 3 benchmark executions: <code>ClrJob</code>,  <code>CoreJob</code> and <code>GcServer(true)</code> for current runtime.</p>
<p>Now all Jobs and their corresponding attributes marked as mutators are going to be applied to other jobs, not just added to the config. So in this particular scenario, the benchmarks from <code>MyBenchmarkClass</code> are going to be executed for .NET with Server GC enabled and .NET Core with Server GC enabled.</p>
<p>Mutators are great when you want to have a single, global config for all benchmarks and apply given settings only to selected types. You can find out more about mutators <a href="https://github.com/dotnet/BenchmarkDotNet/pull/800">here</a>.</p>
<h2 id="ctrlc">Ctrl+C</h2>
<p>When the user:</p>
<ul>
<li>presses <code>Ctrl+C</code></li>
<li>presses <code>Ctrl+Break</code></li>
<li>logs off</li>
<li>closes console window</li>
</ul>
<p>We are now going to close any existing ETW session created by BenchmarkDotNet and <strong>restore console colors</strong> (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/761">read more</a>).</p>
<h2 id="handle-outofmemoryexception-more-gracefully">Handle OutOfMemoryException more gracefully</h2>
<p>When our benchmark hits <code>OutOfMemoryException</code> we print some nice explanation:</p>
<pre><code class="lang-cs">public class Program
{
    static void Main(string[] args) =&gt; BenchmarkRunner.Run&lt;Program&gt;();

    private List&lt;object&gt; list = new List&lt;object&gt;();

    [Benchmark]
    public void AntiPattern() =&gt; list.Add(new int[int.MaxValue / 2]);
}
</code></pre>
<pre><code class="lang-log">OutOfMemoryException!
BenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects.
If your benchmark allocates memory and keeps it alive, you are creating a memory leak.
You should redesign your benchmark and remove the side-effects. You can use `OperationsPerInvoke`, `IterationSetup` and `IterationCleanup` to do that.
</code></pre>
<h2 id="trimming-long-strings">Trimming long strings</h2>
<p>We used to display the values &quot;as is&quot; which was bad for long strings. Now the values are trimmed (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/748">more</a>).</p>
<pre><code class="lang-cs">public class Long
{
    [Params(&quot;text/plain,text/html;q=0.9,application/xhtml+xml;q=0.9,application/xml;q=0.8,*/*;q=0.7&quot;)]
    public string Text;

    [Benchmark]
    public int HashCode() =&gt; Text.GetHashCode();
}
</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Text</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashCode</td>
<td>text/(...)q=0.7 [86]</td>
</tr>
</tbody>
</table>
<h1 id="more-features">More features</h1>
<h2 id="generic-benchmarks">Generic benchmarks</h2>
<p>BenchmarkDotNet supports generic benchmarks, all you need to do is to tell it which types should be used as generic arguments (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/758">read more</a>).</p>
<pre><code class="lang-cs">[GenericTypeArguments(typeof(int))]
[GenericTypeArguments(typeof(char))]
public class IntroGenericTypeArguments&lt;T&gt;
{
    [Benchmark] public T Create() =&gt; Activator.CreateInstance&lt;T&gt;();
}
</code></pre>
<h2 id="arguments">Arguments</h2>
<p>We now support more scenarios for passing arguments to benchmarks:</p>
<ul>
<li>passing arguments to asynchronous benchmarks (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/818">more</a>)</li>
<li>passing generic types</li>
<li>passing arguments by reference</li>
<li>passing jagged arrays (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/769">more</a>)</li>
<li>types with implicit cast operator to stack only types can be passed as given stack-only types to Benchmarks (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/774">more</a>)</li>
</ul>
<p>Example:</p>
<pre><code class="lang-cs">public class WithStringToReadOnlySpan
{
    [Benchmark]
    [Arguments(&quot;some string&quot;)]
    public void AcceptsReadOnlySpan(ReadOnlySpan&lt;char&gt; notString)
}
</code></pre>
<h2 id="console-arguments">Console Arguments</h2>
<p><code>BenchmarkSwitcher</code> supports various console arguments (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/824">PR</a>), to make it work you need to pass the <code>args</code> to switcher:</p>
<pre><code class="lang-cs">class Program
{
    static void Main(string[] args) 
        =&gt; BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args);
}
</code></pre>
<p><strong>Note:</strong> to get the most up-to-date info about supported console arguments run the benchmarks with <code>--help</code>.</p>
<h3 id="filter">Filter</h3>
<p>The <code>--filter</code> or just <code>-f</code> allows you to filter the benchmarks by their full name (<code>namespace.typeName.methodName</code>) using glob patterns.</p>
<p>Examples:</p>
<ol>
<li>Run all benchmarks from System.Memory namespace: <code>-f System.Memory*</code></li>
<li>Run all benchmarks: <code>-f *</code></li>
<li>Run all benchmarks from ClassA and ClassB <code>-f *ClassA* *ClassB*</code></li>
</ol>
<p><strong>Note</strong>: If you would like to <strong>join</strong> all the results into a <strong>single summary</strong>, you need to use <code>--join</code>.</p>
<h3 id="categories">Categories</h3>
<p>You can also filter the benchmarks by categories:</p>
<ul>
<li><code>--anyCategories</code> - runs all benchmarks that belong to <strong>any</strong> of the provided categories</li>
<li><code>--allCategories</code>- runs all benchmarks that belong to <strong>all</strong> provided categories</li>
</ul>
<h3 id="diagnosers">Diagnosers</h3>
<ul>
<li><code>-m</code>, <code>--memory</code> - enables MemoryDiagnoser and prints memory statistics</li>
<li><code>-d</code>, <code>--disassm</code>- enables DisassemblyDiagnoser and exports diassembly of benchmarked code</li>
</ul>
<h3 id="runtimes">Runtimes</h3>
<p>The <code>--runtimes</code> or just <code>-r</code> allows you to run the benchmarks for selected Runtimes. Available options are: Clr, Mono, Core and CoreRT.</p>
<p>Example: run the benchmarks for .NET and .NET Core:</p>
<pre><code class="lang-log">dotnet run -c Release -- --runtimes clr core
</code></pre>
<h3 id="more-arguments">More arguments</h3>
<ul>
<li><code>-j</code>, <code>--job</code> (Default: Default) Dry/Short/Medium/Long or Default</li>
<li><code>-e</code>, <code>--exporters</code> GitHub/StackOverflow/RPlot/CSV/JSON/HTML/XML</li>
<li><code>-i</code>, <code>--inProcess</code> (Default: false) Run benchmarks in Process</li>
<li><code>-a</code>, <code>--artifacts</code> Valid path to accessible directory</li>
<li><code>--outliers</code> (Default: OnlyUpper) None/OnlyUpper/OnlyLower/All</li>
<li><code>--affinity</code> Affinity mask to set for the benchmark process</li>
<li><code>--allStats</code> (Default: false) Displays all statistics (min, max &amp; more)</li>
<li><code>--attribute</code> Run all methods with given attribute (applied to class or method)</li>
</ul>
<h2 id="other-small-improvements">Other small improvements</h2>
<ul>
<li><strong>Unicode support:</strong>
now you can enable support of Unicode symbols like <code>μ</code> or <code>±</code> with <code>[EncodingAttribute.Unicode]</code>,
an example: BenchmarkDotNet.Samples.IntroEncoding
(see <a href="https://github.com/dotnet/BenchmarkDotNet/pull/735">#735</a>)</li>
<li><strong>Better benchmark validation</strong>
(see <a href="https://github.com/dotnet/BenchmarkDotNet/pull/693">#693</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/737">#737</a>)</li>
<li><strong>Improve .NET Framework version detection</strong>: now we support .NET Framework 4.7.2
(see <a href="https://github.com/dotnet/BenchmarkDotNet/pull/743">#743</a>)</li>
<li><strong>OutlierModes:</strong>
now it's possible to control how to process outliers,
an example <a class="xref" href="../articles/samples/IntroOutliers.html">BenchmarkDotNet.Samples.IntroOutliers</a>
(see <a href="https://github.com/dotnet/BenchmarkDotNet/pull/766">#766</a>)</li>
<li><strong>LLVM support in MonoDisassembler</strong>
(see <a href="https://github.com/dotnet/BenchmarkDotNet/commit/a7426e84fde075503f489fdf096a95f694f77b85">a7426e</a>)</li>
<li><strong>Grand API renaming</strong>
we try not to change public API, but sometimes it's necessary because we want to get a consistent and understandable API in v1.0.0.
(see <a href="https://github.com/dotnet/BenchmarkDotNet/issues/787">#787</a>)</li>
<li><strong>Many-many small improvements and bug fixes</strong></li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: July 23, 2018</em></p>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.11.0">v0.11.0</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.10.14...v0.11.0">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.11.0">https://www.nuget.org/packages/BenchmarkDotNet/0.11.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.0">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.0</a></li>
</ul>

</article>


        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright &copy; 2013–2024 .NET Foundation and contributors
        </div>
      </div>
    </footer>
  </body>
</html>
