<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Full ChangeLog | BenchmarkDotNet </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Full ChangeLog | BenchmarkDotNet ">
      
      
      <link rel="icon" href="../logo/icon-32.png">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/dotnet/BenchmarkDotNet/blob/docs-stable/docs/changelog/full.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo/icon.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="changelog.full">
<h1 id="full-changelog">Full ChangeLog</h1>

<h1 id="benchmarkdotnet-v0151">BenchmarkDotNet v0.15.1</h1>
<h2 id="milestone-details">Milestone details</h2>
<p>In the <a href="https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone:v0.15.1">v0.15.1</a> scope,
6 issues were resolved and 12 pull requests were merged.
This release includes 17 commits by 6 contributors.</p>
<h2 id="resolved-issues-6">Resolved issues (6)</h2>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/2619">#2619</a> Added support to get exported file paths</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/2739">#2739</a> System.PlatformNotSupportedException thrown in DisposeAtProcessTermination with Android (assignee: <a href="https://github.com/BraedenLS">@BraedenLS</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/2740">#2740</a> System.NullReferenceException in thrown in ZeroMeasurementAnalyser with Android (assignee: <a href="https://github.com/BraedenLS">@BraedenLS</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/2744">#2744</a> Allow ArgumentsSource to reference methods in other types (assignee: <a href="https://github.com/JimmyCushnie">@JimmyCushnie</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/2745">#2745</a> Running benchmark with BenchmarkDotNet 15.0 fails with Fatal error. 0xC0000005, WakeLock (assignee: <a href="https://github.com/christiannagel">@christiannagel</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/2763">#2763</a> Unable to find Solution root directory if benchmark project uses .slnx</li>
</ul>
<h2 id="merged-pull-requests-12">Merged pull requests (12)</h2>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2738">#2738</a> chore: Update run-tests.yaml (by <a href="https://github.com/filzrev">@filzrev</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2741">#2741</a> Fix #2739: OS check for platform specific event (by <a href="https://github.com/BraedenLS">@BraedenLS</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2742">#2742</a> Fix #2740: Use CpuInfo.Unknown if CpuDetector.Detect() does not find supported OS (by <a href="https://github.com/BraedenLS">@BraedenLS</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2746">#2746</a> [build] Rework changelog generation (by <a href="https://github.com/AndreyAkinshin">@AndreyAkinshin</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2748">#2748</a> Allow ArgumentsSource to reference methods in other types (by <a href="https://github.com/JimmyCushnie">@JimmyCushnie</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2750">#2750</a> deps: Update package dependencies (by <a href="https://github.com/filzrev">@filzrev</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2752">#2752</a> chore: Fix the line endings in the files to LF. (by <a href="https://github.com/filzrev">@filzrev</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2755">#2755</a> chore: Update Microsoft.NET.Test.Sdk version (by <a href="https://github.com/filzrev">@filzrev</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2756">#2756</a> Refactor WakeLock.PInvoke for compatibility with the ARM CPU #2745 (by <a href="https://github.com/christiannagel">@christiannagel</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2759">#2759</a> chore: Change ExporterBase::GetArtifactFullName accessibility to public (by <a href="https://github.com/filzrev">@filzrev</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2762">#2762</a> Bump .NET SDK: 8.0.401-&gt;8.0.410 (by <a href="https://github.com/filzrev">@filzrev</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2764">#2764</a> Test for both .sln and .slnx when searching for solution file (by <a href="https://github.com/bstordrup">@bstordrup</a>)</li>
</ul>
<h2 id="commits-17">Commits (17)</h2>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/37b5ca505eb1783194c3f82b57c01b0aa149c489">37b5ca</a> Set next BenchmarkDotNet version: 0.15.1 (by <a href="https://github.com/AndreyAkinshin">@AndreyAkinshin</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/7306cdf5e9aed7aeeefc4a4361dbd9bb371ca80a">7306cd</a> [build] Bump actions/upload-artifact in generate-gh-pages: v1-&gt;v4 (by <a href="https://github.com/AndreyAkinshin">@AndreyAkinshin</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/a0ad259a72d31945d0dda19e1cd188c8506b52fe">a0ad25</a> [build] Bump actions/download-artifact in generate-gh-pages: v1-&gt;v4 (by <a href="https://github.com/AndreyAkinshin">@AndreyAkinshin</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/c21ac5a4e976aa38f91c5509cfa3231975768b93">c21ac5</a> [build] Improve generate-gh-pages.yaml (by <a href="https://github.com/AndreyAkinshin">@AndreyAkinshin</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/2b6d7c796b5ba667c4729aabc1baa1181c556ef7">2b6d7c</a> chore: update run-tests.yaml (by <a href="https://github.com/filzrev">@filzrev</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/7da69ade92ad898406229ff7d9ba931236804538">7da69a</a> Bump Perfolizer: 0.5.2-&gt;0.5.3 (by <a href="https://github.com/AndreyAkinshin">@AndreyAkinshin</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/c0bcfb965752d9d7ffe32e0a93e95bfec5c09b36">c0bcfb</a> Fix #2740: Use Cpu.Unknown if using unsupported OS (by <a href="https://github.com/BraedenLS">@BraedenLS</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/8bf4623c41201bc9877ea4976c24f6c8c0ebd969">8bf462</a> Fix #2739: OS check for platform exclusive event (#2741) (by <a href="https://github.com/BraedenLS">@BraedenLS</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/93d12c42c0adbc33702cdc42e1fc494d2c919208">93d12c</a> [build] Rework changelog generation (by <a href="https://github.com/AndreyAkinshin">@AndreyAkinshin</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/67664a313fba76cff2d8f53fe2b77f4bd08fefe5">67664a</a> deps: Update package dependencies (#2750) (by <a href="https://github.com/filzrev">@filzrev</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/ba1f9982bc920d95ee6b84d4d731cf3ada40df9e">ba1f99</a> Allow ArgumentsSource to reference methods in other types (#2748) (by <a href="https://github.com/JimmyCushnie">@JimmyCushnie</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/0134497366cb7276116fae416c1f5040123de466">013449</a> chore: fix line-endings to lf (by <a href="https://github.com/filzrev">@filzrev</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/68feeb4adb923c970074cb122426678438daa2df">68feeb</a> Refactor WakeLock.PInvoke for compatibility with the ARM CPU #2745 (#2756) (by <a href="https://github.com/christiannagel">@christiannagel</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/5c9d070671aa9d7cf93ee3b54c8ed52b15046108">5c9d07</a> chore: Update Microsoft.NET.Test.Sdk version (#2755) (by <a href="https://github.com/filzrev">@filzrev</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/d8eea0d0027f6e4dd061df67b016c6c15dd2b8dd">d8eea0</a> chore: modify ExporterBase::GetArtifactFullName accessibility (by <a href="https://github.com/filzrev">@filzrev</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/78a6b10690b058d0db8ac3b9e55f7d9aee5eb895">78a6b1</a> Test for both .sln and .slnx when searching for solution file (#2764) (by <a href="https://github.com/bstordrup">@bstordrup</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/0d909f3eacf64aa1a02f188142ff420845ec0b22">0d909f</a> deps: update dotnet sdk version to 8.0.410 (#2762) (by <a href="https://github.com/filzrev">@filzrev</a>)</li>
</ul>
<h2 id="contributors-6">Contributors (6)</h2>
<ul>
<li>Andrey Akinshin (<a href="https://github.com/AndreyAkinshin">@AndreyAkinshin</a>)</li>
<li>Benny Tordrup (<a href="https://github.com/bstordrup">@bstordrup</a>)</li>
<li>BraedenLS (<a href="https://github.com/BraedenLS">@BraedenLS</a>)</li>
<li>Christian Nagel (<a href="https://github.com/christiannagel">@christiannagel</a>)</li>
<li>filzrev (<a href="https://github.com/filzrev">@filzrev</a>)</li>
<li>Jimmy Cushnie (<a href="https://github.com/JimmyCushnie">@JimmyCushnie</a>)</li>
</ul>
<p>Thank you very much!</p>
<h1 id="benchmarkdotnet-v0150">BenchmarkDotNet v0.15.0</h1>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: May 22, 2025</em></p>
<p><em>Milestone: <a href="https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone%3Av0.15.0">v0.15.0</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.14.0...v0.15.0">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.15.0">https://www.nuget.org/packages/BenchmarkDotNet/0.15.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.15.0">https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.15.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotMemory/0.15.0">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotMemory/0.15.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.15.0">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.15.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.15.0">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.15.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Exporters.Plotting/0.15.0">https://www.nuget.org/packages/BenchmarkDotNet.Exporters.Plotting/0.15.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.15.0">https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.15.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.TestAdapter/0.15.0">https://www.nuget.org/packages/BenchmarkDotNet.TestAdapter/0.15.0</a></li>
</ul>
<h1 id="benchmarkdotnet-v0140">BenchmarkDotNet v0.14.0</h1>
<h2 id="highlights">Highlights</h2>
<ul>
<li>Introduce <code>BenchmarkDotNet.Diagnostics.dotMemory</code> <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2549">#2549</a>: memory allocation profile of your benchmarks using <a href="https://www.jetbrains.com/dotmemory/">dotMemory</a>, see <a class="xref" href="../articles/samples/IntroDotMemoryDiagnoser.html">BenchmarkDotNet.Samples.IntroDotMemoryDiagnoser</a></li>
<li>Introduce <code>BenchmarkDotNet.Exporters.Plotting</code> <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2560">#2560</a>: plotting via <a href="https://scottplot.net/">ScottPlot</a> (initial version)</li>
<li>Multiple bugfixes</li>
<li>The default build toolchains have been updated to pass <code>IntermediateOutputPath</code>, <code>OutputPath</code>, and <code>OutDir</code> properties to the <code>dotnet build</code> command. This change forces all build outputs to be placed in a new directory generated by BenchmarkDotNet, and fixes many issues that have been reported with builds. You can also access these paths in your own <code>.csproj</code> and <code>.props</code> from those properties if you need to copy custom files to the output.</li>
</ul>
<h2 id="bug-fixes">Bug fixes</h2>
<ul>
<li>Fixed multiple build-related bugs including passing MsBuildArguments and .Net 8's <code>UseArtifactsOutput</code>.</li>
</ul>
<h2 id="breaking-changes">Breaking Changes</h2>
<ul>
<li><code>DotNetCliBuilder</code> removed <code>retryFailedBuildWithNoDeps</code> constructor option.</li>
<li><code>DotNetCliCommand</code> removed <code>RetryFailedBuildWithNoDeps</code> property and <code>BuildNoRestoreNoDependencies()</code> and <code>PublishNoBuildAndNoRestore()</code> methods (replaced with <code>PublishNoRestore()</code>).</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: August 06, 2024</em></p>
<p><em>Milestone: <a href="https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone%3Av0.14.0">v0.14.0</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.13.12...v0.14.0">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.14.0">https://www.nuget.org/packages/BenchmarkDotNet/0.14.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.14.0">https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.14.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotMemory/0.14.0">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotMemory/0.14.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.14.0">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.14.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.14.0">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.14.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Exporters.Plotting/0.14.0">https://www.nuget.org/packages/BenchmarkDotNet.Exporters.Plotting/0.14.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.14.0">https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.14.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.TestAdapter/0.14.0">https://www.nuget.org/packages/BenchmarkDotNet.TestAdapter/0.14.0</a></li>
</ul>
<h1 id="benchmarkdotnet-v01312">BenchmarkDotNet v0.13.12</h1>
<h2 id="highlights">Highlights</h2>
<p>The biggest highlight of this release if our new VSTest Adapter,
which allows to run benchmarks as unit tests in your favorite IDE!
The detailed guide can be found <a class="xref" href="../articles/features/vstest.html">here</a>.</p>
<p>This release also includes to a minor bug fix that caused incorrect job id generation:
fixed job id generation (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2491">#2491</a>).</p>
<p>Also, the target framework in the BenchmarkDotNet templates was bumped to .NET 8.0.</p>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: January 05, 2024</em></p>
<p><em>Milestone: <a href="https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone%3Av0.13.12">v0.13.12</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.13.11...v0.13.12">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.13.12">https://www.nuget.org/packages/BenchmarkDotNet/0.13.12</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.12">https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.12</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.12">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.12</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.12">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.12</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.12">https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.12</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.TestAdapter/0.13.12">https://www.nuget.org/packages/BenchmarkDotNet.TestAdapter/0.13.12</a></li>
</ul>
<h1 id="benchmarkdotnet-v01311">BenchmarkDotNet v0.13.11</h1>
<h2 id="highlights">Highlights</h2>
<p>Small improvements.</p>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: December 06, 2023</em></p>
<p><em>Milestone: <a href="https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone%3Av0.13.11">v0.13.11</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.13.10...v0.13.11">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.13.11">https://www.nuget.org/packages/BenchmarkDotNet/0.13.11</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.11">https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.11</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.11">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.11</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.11">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.11</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.11">https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.11</a></li>
</ul>
<h1 id="benchmarkdotnet-v01310">BenchmarkDotNet v0.13.10</h1>
<h2 id="highlights">Highlights</h2>
<p>Initial support of .NET 9 and minor bug fixes.</p>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: November 01, 2023</em></p>
<p><em>Milestone: <a href="https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone%3Av0.13.10">v0.13.10</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.13.9...v0.13.10">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.13.10">https://www.nuget.org/packages/BenchmarkDotNet/0.13.10</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.10">https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.10</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.10">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.10</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.10">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.10</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.10">https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.10</a></li>
</ul>
<h1 id="benchmarkdotnet-v0139">BenchmarkDotNet v0.13.9</h1>
<h2 id="highlights">Highlights</h2>
<p>This release contains bug fixes.</p>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: October 05, 2023</em></p>
<p><em>Milestone: <a href="https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone%3Av0.13.9">v0.13.9</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.13.8...v0.13.9">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.13.9">https://www.nuget.org/packages/BenchmarkDotNet/0.13.9</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.9">https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.9</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.9">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.9</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.9">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.9</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.9">https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.9</a></li>
</ul>
<h1 id="benchmarkdotnet-v0138">BenchmarkDotNet v0.13.8</h1>
<h2 id="highlights">Highlights</h2>
<p>This release contains important bug fixes.</p>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: September 08, 2023</em></p>
<p><em>Milestone: <a href="https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone%3Av0.13.8">v0.13.8</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.13.7...v0.13.8">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.13.8">https://www.nuget.org/packages/BenchmarkDotNet/0.13.8</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.8">https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.8</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.8">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.8</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.8">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.8</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.8">https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.8</a></li>
</ul>
<h1 id="benchmarkdotnet-v0137">BenchmarkDotNet v0.13.7</h1>
<h2 id="highlights">Highlights</h2>
<p>This release contains important bug fixes listed below.</p>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: August 04, 2023</em></p>
<p><em>Milestone: <a href="https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone%3Av0.13.7">v0.13.7</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.13.6...v0.13.7">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.13.7">https://www.nuget.org/packages/BenchmarkDotNet/0.13.7</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.7">https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.7</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.7">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.7</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.7">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.7</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.7">https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.7</a></li>
</ul>
<h1 id="benchmarkdotnet-v0136">BenchmarkDotNet v0.13.6</h1>
<h2 id="highlights">Highlights</h2>
<ul>
<li>New <a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace">BenchmarkDotNet.Diagnostics.dotTrace</a> NuGet package.
Once this package is installed, you can annotate your benchmarks with the <code>[DotTraceDiagnoser]</code> and get a <a href="https://www.jetbrains.com/profiler/">dotTrace</a> performance snapshot at the end of the benchmark run.
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2328">#2328</a></li>
<li>Updated documentation website.
We migrated to <a href="https://dotnet.github.io/docfx/">docfx</a> 2.67 and got the refreshed modern template based on bootstrap 5 with dark/light theme switcher.</li>
<li>Updated <a href="https://www.nuget.org/packages/BenchmarkDotNet.Templates">BenchmarkDotNet.Templates</a>.
Multiple issues were resolved, now you can create new benchmark projects from terminal or your favorite IDE.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1658">#1658</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1881">#1881</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/2149">#2149</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2338">#2338</a></li>
<li>Response file support.
Now it's possible to pass additional arguments to BenchmarkDotNet using <code>@filename</code> syntax.
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2320">#2320</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2348">#2348</a></li>
<li>Custom runtime support.
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2285">#2285</a></li>
<li>Introduce CategoryDiscoverer, see <a class="xref" href="../articles/samples/IntroCategoryDiscoverer.html"><code>IntroCategoryDiscoverer</code></a>.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/2306">#2306</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2307">#2307</a></li>
<li>Multiple bug fixes.</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: July 11, 2023</em></p>
<p><em>Milestone: <a href="https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone%3Av0.13.6">v0.13.6</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.13.5...v0.13.6">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.13.6">https://www.nuget.org/packages/BenchmarkDotNet/0.13.6</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.6">https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.6</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.6">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.6</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.6">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.6</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.6">https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.6</a></li>
</ul>
<h1 id="benchmarkdotnet-v0135">BenchmarkDotNet v0.13.5</h1>
<h2 id="highlights">Highlights</h2>
<ul>
<li>Improved <code>JitStatsDiagnoser</code>.
This diagnoser was added in v0.13.4, it shows various stats from the JIT compiler that were collected during entire benchmark run
(amount of JITted methods,
amount of <a href="https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-core-3-0#tiered-compilation">tiered methods</a>,
how much memory JIT allocated during the benchmark).
In this release, we improved metric collection
(<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2246">#2246</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/e715d5bb63984fca65120d9a497f7d16395f9e5b">e715d5</a>)
and added the <code>[JitStatsDiagnoser]</code> attribute
(<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2250">#2250</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/512413ceb24077154bdf6d6306138accffe64c7a">512413</a>).</li>
<li>Enable strong-named assemblies in the released NuGet packages
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/2258">#2258</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2263">#2263</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/5cd288996ca13292fcf638be299c097a600aea7b">5cd288</a></li>
<li>Avoid keeping referenced values returned from a benchmark in memory
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1942">#1942</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2191">#2191</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/ff5dbe662478f547e4be8d734eaeb6a106f40875">ff5dbe</a></li>
<li>Keep generated files when MSBuild bin log is requested
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/2252">#2252</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2254">#2254</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/d3fbc03d6dabeb52f23c6b7e50287150e66957cc">d3fbc0</a></li>
<li>Add <code>Id</code> for <code>UnresolvedDiagnoser</code> (an exception fix)
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2251">#2251</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/a992b57490e844acf587bc2e01b08a7040dbc8e2">a992b5</a></li>
<li>Add brand names for Windows 22H2 and macOS 13
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/86f212b79e297d87d3942e4c50130fe6e214f3c8">86f212</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/0c26996ea685a99068aca71e7ae547b0851d3c64">0c2699</a></li>
<li>Remove deprecated <code>InProcessToolchain</code>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2248">#2248</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/615384d2553434d7f35c03ab3174d761f82c6c2d">615384</a></li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: February 17, 2023</em></p>
<p><em>Milestone: <a href="https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone%3Av0.13.5">v0.13.5</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.13.4...v0.13.5">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.13.5">https://www.nuget.org/packages/BenchmarkDotNet/0.13.5</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.5">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.5</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.5">https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.5</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.5">https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.5</a></li>
</ul>
<h1 id="benchmarkdotnet-v0134">BenchmarkDotNet v0.13.4</h1>
<h2 id="highlights">Highlights</h2>
<ul>
<li>Fixed LINQPad support
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/2237">#2237</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2238">#2238</a></li>
<li>New <code>JitStatsDiagnoser</code>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2243">#2243</a></li>
<li>Minor documentation improvements
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2206">#2206</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2218">#2218</a></li>
</ul>
<h2 id="jitstatsdiagnoser">JitStatsDiagnoser</h2>
<p>This new diagnoser introduced in (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2243">#2243</a>) allows getting advanced JIT statistics.</p>
<p>Sample usage:</p>
<pre><code class="lang-cmd">dotnet run -c Release -f net7.0 --filter *IntroBasic.Sleep --profiler jit
</code></pre>
<p>Result:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
<th style="text-align: right;">Methods JITted</th>
<th style="text-align: right;">Methods Tiered</th>
<th style="text-align: right;">JIT allocated memory</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sleep</td>
<td style="text-align: right;">15.53 ms</td>
<td style="text-align: right;">0.034 ms</td>
<td style="text-align: right;">0.032 ms</td>
<td style="text-align: right;">1,102</td>
<td style="text-align: right;">15</td>
<td style="text-align: right;">221,736 B</td>
</tr>
</tbody>
</table>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: January 13, 2023</em></p>
<p><em>Milestone: <a href="https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone%3Av0.13.4">v0.13.4</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.13.3...v0.13.4">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.13.4">https://www.nuget.org/packages/BenchmarkDotNet/0.13.4</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.4">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.4</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.4">https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.4</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.4">https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.4</a></li>
</ul>
<h1 id="benchmarkdotnet-v0133">BenchmarkDotNet v0.13.3</h1>
<h2 id="highlights">Highlights</h2>
<ul>
<li>New supported technologies
<ul>
<li>Add arm64 disassembler
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1422">#1422</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2127">#2127</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2107">#2107</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2123">#2123</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/2070">#2070</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2118">#2118</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2119">#2119</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2234">#2234</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2222">#2222</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2212">#2212</a>
<a href="https://github.com/9ee1/Capstone.NET/pull/37">9ee1/Capstone.NET#37</a></li>
<li>Initial .NET 8 support
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2192">#2192</a></li>
<li>.NET 6/7 MonoVM support
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/2064">#2064</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2142">#2142</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2227">#2227</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2230">#2230</a></li>
<li>Armv6 and Ppc64le architectures support
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/2216">#2216</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2219">#2219</a></li>
</ul>
</li>
<li>Improved support
<ul>
<li>Improved WASM support
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2201">#2201</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/2099">#2099</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2154">#2154</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2112">#2112</a></li>
<li>Improved NativeAOT support
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2095">#2095</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2221">#2221</a></li>
<li>Improved Android support
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2231">#2231</a></li>
<li>32-bit benchmarks can now handle addresses larger than 2GB with the help of <code>LargeAddressAware</code>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1469">#1469</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2145">#2145</a></li>
<li>Support 64bit affinity masks
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/2211">#2211</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2228">#2228</a></li>
</ul>
</li>
<li>New features
<ul>
<li>Add <code>ExceptionDiagnoser</code>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1736">#1736</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2169">#2169</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2182">#2182</a></li>
<li>Add <code>PerfCollectProfiler</code>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2117">#2117</a></li>
<li>Incremental benchmark execution with the help of <code>--resume</code>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1799">#1799</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2164">#2164</a></li>
<li>Taskbar progress
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/2102">#2102</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2158">#2158</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2140">#2140</a></li>
<li>Support <code>--noForcedGCs</code> to avoid forced GC between benchmark runs
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2101">#2101</a></li>
<li>Added apples to apples comparison mode
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2116">#2116</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2193">#2193</a></li>
<li>Communication between the host process and the benchmark process is now using pipes instead of output parsing
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2092">#2092</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1933">#1933</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/2189">#2189</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2207">#2207</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2200">#2200</a></li>
</ul>
</li>
<li>Dozens of bugfixes</li>
</ul>
<h2 id="special-thanks">Special Thanks</h2>
<p>We would like to highlight some important contributors who helped us with this release:</p>
<ol>
<li><a href="https://code.devexperts.com/event/openhack22">OpenHack'22 (devexperts.com)</a> hackathon sponsored by the DevExperts company.
As part of this hackathon we have received following PRs:</li>
</ol>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2132">#2132</a> fix: include argument and param names in --filter (by <a href="https://github.com/blouflashdb">@blouflashdb</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2140">#2140</a> Update console title with benchmark information (by <a href="https://github.com/franciscomoloureiro">@franciscomoloureiro</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2142">#2142</a> Issue 2064: Mono70 moniker (by <a href="https://github.com/Serg046">@Serg046</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2148">#2148</a> adding validation errors when the benchmarks are unsupported (by <a href="https://github.com/emanuel-v-r">@emanuel-v-r</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2160">#2160</a> Corrected logic to restore foreground color in ConsoleLogger.cs (by <a href="https://github.com/farQtech">@farQtech</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2164">#2164</a> 1799 adding resume arg (by <a href="https://github.com/melias">@melias</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2169">#2169</a> Issue #1736: Add ExceptionDiagnoser (by <a href="https://github.com/Serg046">@Serg046</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2161">#2161</a> add quiet logger (by <a href="https://github.com/franciscomoloureiro">@franciscomoloureiro</a>) <strong>(not merged yet)</strong></li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2171">#2171</a> Issue #1024: Calculate baseline by the fastest benchmark (by <a href="https://github.com/Serg046">@Serg046</a>) <strong>(not merged yet)</strong></li>
</ul>
<ol start="2">
<li>Jan Vorlicek helped to implement arm64 disassembler during an internal Microsoft Hackathon:</li>
</ol>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2107">#2107</a> Implement TryGetReferencedAddress for relative branches (by <a href="https://github.com/janvorli">@janvorli</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/2123">#2123</a> Added other arm64 constant form extraction plus other changes (by <a href="https://github.com/janvorli">@janvorli</a>)</li>
</ul>
<ol start="3">
<li>Ahmed Garhy (maintainer of Capstone.NET) helped to improve Capstone.NET, which was need to implement arm64 disassembler:</li>
</ol>
<ul>
<li><a href="https://github.com/9ee1/Capstone.NET/pull/37">9ee1/Capstone.NET#37</a> Sign Assembly with a Strong Name (by <a href="https://github.com/9ee1">@9ee1</a>)</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: December 26, 2022</em></p>
<p><em>Milestone: <a href="https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone%3Av0.13.3">v0.13.3</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.13.2...v0.13.3">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.13.3">https://www.nuget.org/packages/BenchmarkDotNet/0.13.3</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.3">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.3</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.3">https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.3</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.3">https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.3</a></li>
</ul>
<h1 id="benchmarkdotnet-v0132">BenchmarkDotNet v0.13.2</h1>
<h2 id="highlights">Highlights</h2>
<p>In BenchmarkDotNet v0.13.2, we have implemented support for:</p>
<ul>
<li>.NET 7</li>
<li>NativeAOT</li>
<li>.NET Framework 4.8.1</li>
</ul>
<p>We have also introduced new features and improvements including:</p>
<ul>
<li>Possibility to hide selected columns,</li>
<li>Allocation Ratio column,</li>
<li>Logging progress and estimated finish time,</li>
<li>ARM64 support for <code>BenchmarkDotNet.Diagnostics.Windows</code> package,</li>
<li>Printing Hardware Intrinsics information,</li>
<li>Glob filters support for DisassemblyDiagnoser.</li>
</ul>
<p>Of course, this release includes dozens of other improvements and bug fixes!</p>
<p>Our special thanks go to <a href="https://github.com/mawosoft">@mawosoft</a>, <a href="https://github.com/YegorStepanov">@YegorStepanov</a> and <a href="https://github.com/radical">@radical</a> who fixed a LOT of really nasty bugs.</p>
<h2 id="supported-technologies">Supported technologies</h2>
<h3 id="net-7-and-net-framework-481">.NET 7 and .NET Framework 4.8.1</h3>
<p>.NET 4.8.1 has been <a href="https://devblogs.microsoft.com/dotnet/announcing-dotnet-framework-481/">released</a> earlier this month, while .NET 7 should land in autumn this year. Now you can use BenchmarkDotNet to compare both!</p>
<pre><code class="lang-ini">BenchmarkDotNet=v0.13.1.1845-nightly, OS=Windows 11 (10.0.22622.575)
Microsoft SQ1 3.0 GHz, 1 CPU, 8 logical and 8 physical cores
.NET SDK=7.0.100-preview.6.22352.1
  [Host]     : .NET 7.0.0 (7.0.22.32404), Arm64 RyuJIT AdvSIMD
  Job-QJVIDT : .NET 7.0.0 (7.0.22.32404), Arm64 RyuJIT AdvSIMD
  Job-FNNXOY : .NET Framework 4.8.1 (4.8.9032.0), Arm64 RyuJIT
</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td>BinaryTrees_2</td>
<td>.NET 7.0</td>
<td style="text-align: right;">193.6 ms</td>
<td style="text-align: right;">227.33 MB</td>
</tr>
<tr>
<td>BinaryTrees_2</td>
<td>.NET Framework 4.8.1</td>
<td style="text-align: right;">192.8 ms</td>
<td style="text-align: right;">228.01 MB</td>
</tr>
</tbody>
</table>
<p>Credit for adding .NET 7 support in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1816">#1816</a> goes to <a href="https://github.com/am11">@am11</a>. <a href="https://github.com/adamsitnik">@adamsitnik</a> implemented .NET 4.8.1 support in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2044">#2044</a> and <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2067">#2067</a>. Big thanks to <a href="https://github.com/MichalPetryka">@MichalPetryka</a> who was using preview versions of BenchmarkDotNet and reported a bug related to .NET 4.8.1 support: <a href="https://github.com/dotnet/BenchmarkDotNet/issues/2059">#2059</a> that got fixed before we released a new version.</p>
<h3 id="nativeaot">NativeAOT</h3>
<p>We are really excited to see the experimental CoreRT project grow and become officially supported by Microsoft (under new name: NativeAOT)! You can read more about it <a href="https://devblogs.microsoft.com/dotnet/announcing-dotnet-7-preview-3/#what-is-native-aot">here</a>. Implementing and improving the support was a combined effort of multiple contributors that spawned across multiple repositories:</p>
<ul>
<li><a href="https://github.com/MichalStrehovsky">@MichalStrehovsky</a>: <a href="https://github.com/dotnet/runtime/pull/66290">#66290 in dotnet/runtime</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2020">#2020 in dotnet/BenchmarkDotNet</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2046">#2046 in dotnet/BenchmarkDotNet</a></li>
<li><a href="https://github.com/hez2010">@hez2010</a>: <a href="https://github.com/dotnet/runtime/pull/66650">#66650 in dotnet/runtime</a></li>
<li><a href="https://github.com/Beau-Gosse-dev">@Beau-Gosse-dev</a>: <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1955">#1955 in dotnet/BenchmarkDotNet</a></li>
<li><a href="https://github.com/adamsitnik">@adamsitnik</a>: <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1960">#1960 in dotnet/BenchmarkDotNet</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1965">#1965 in dotnet/BenchmarkDotNet</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1972">#1972 in dotnet/BenchmarkDotNet</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1973">#1973 in dotnet/BenchmarkDotNet</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1994">#1994 in dotnet/BenchmarkDotNet</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1997">#1997 in dotnet/BenchmarkDotNet</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2045">#2045 in dotnet/BenchmarkDotNet</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2068">#2068 in dotnet/BenchmarkDotNet</a></li>
<li><a href="https://github.com/kant2002">@kant2002</a>: <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1976">#1976 in dotnet/BenchmarkDotNet</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1979">#1979 in dotnet/BenchmarkDotNet</a></li>
<li><a href="https://github.com/jkotas">@jkotas</a>: <a href="https://github.com/dotnet/runtime/pull/68038">#68038 in dotnet/runtime</a>, <a href="https://github.com/dotnet/runtime/pull/68142">#68142 in dotnet/runtime</a>, <a href="https://github.com/dotnet/runtime/pull/68249">#68249 in dotnet/runtime</a>, <a href="https://github.com/dotnet/runtime/pull/68308">#68308 in dotnet/runtime</a>, <a href="https://github.com/dotnet/runtime/pull/68375">#68375 in dotnet/runtime</a></li>
<li><a href="https://github.com/MichalPetryka">@MichalPetryka</a>: <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2065">#2065 in dotnet/BenchmarkDotNet</a></li>
</ul>
<p>As every AOT solution, NativeAOT has some <a href="https://github.com/dotnet/runtime/blob/main/src/coreclr/nativeaot/docs/limitations.md">limitations</a> like limited reflection support or lack of dynamic assembly loading. Because of that, the host process (what you run from command line) is never an AOT process, but just a regular .NET process. This process (called Host process) uses reflection to read benchmarks metadata (find all <code>[Benchmark]</code> methods etc.), generates a new project that references the benchmarks and compiles it using ILCompiler. The boilerplate code is not using reflection, so the project is built with <code>TrimmerDefaultAction=link</code> (we have greatly reduced build time thanks to that). Such compilation produces a native executable, which is later started by the Host process. This process (called Benchmark or Child process) performs the actual benchmarking and reports the results back to the Host process. By default BenchmarkDotNet uses the latest version of <code>Microsoft.DotNet.ILCompiler</code> to build the NativeAOT benchmark according to <a href="https://github.com/dotnet/runtime/blob/main/src/coreclr/nativeaot/docs/compiling.md">this instructions</a>. Moreover, BenchmarkDotNet by default uses current machines CPU features (change: <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1994">#1994</a>, discussion: <a href="https://github.com/dotnet/BenchmarkDotNet/issues/2061">#2061</a>) and if you don't like this behavior, you can <a href="https://github.com/dotnet/BenchmarkDotNet/issues/2061#issuecomment-1203602177">disable it</a>.</p>
<p>This is why you need to:</p>
<ul>
<li>install <a href="https://learn.microsoft.com/dotnet/core/deploying/native-aot/#prerequisites">pre-requisites</a> required by NativeAOT compiler</li>
<li>target .NET to be able to run NativeAOT benchmarks (example: <code>&lt;TargetFramework&gt;net7.0&lt;/TargetFramework&gt;</code> in the .csproj file)</li>
<li>run the app as a .NET process (example: <code>dotnet run -c Release -f net7.0</code>).</li>
<li>specify the NativeAOT runtime in an explicit way, either by using console line arguments <code>--runtimes nativeaot7.0</code> (the recommended approach), or by using<code>[SimpleJob]</code> attribute or by using the fluent Job config API <code>Job.ShortRun.With(NativeAotRuntime.Net70)</code>:</li>
</ul>
<pre><code class="lang-cmd">dotnet run -c Release -f net7.0 --runtimes nativeaot7.0
</code></pre>
<p>For more examples please go to <a href="https://benchmarkdotnet.org/articles/configs/toolchains.html#nativeaot">docs</a>.</p>
<pre><code class="lang-ini">BenchmarkDotNet=v0.13.1.1845-nightly, OS=Windows 11 (10.0.22000.856/21H2)
AMD Ryzen Threadripper PRO 3945WX 12-Cores, 1 CPU, 24 logical and 12 physical cores
.NET SDK=7.0.100-rc.1.22423.16
  [Host]     : .NET 7.0.0 (7.0.22.42223), X64 RyuJIT AVX2
  Job-KDVXET : .NET 7.0.0 (7.0.22.42223), X64 RyuJIT AVX2
  Job-HFRAGK : .NET 7.0.0-rc.1.22424.9, X64 NativeAOT AVX2
</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Ratio</th>
<th style="text-align: right;">Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td>BinaryTrees_2</td>
<td>.NET 7.0</td>
<td style="text-align: right;">95.06 ms</td>
<td style="text-align: right;">1.00</td>
<td style="text-align: right;">227.33 MB</td>
</tr>
<tr>
<td>BinaryTrees_2</td>
<td>NativeAOT 7.0</td>
<td style="text-align: right;">90.32 ms</td>
<td style="text-align: right;">0.96</td>
<td style="text-align: right;">227.33 MB</td>
</tr>
</tbody>
</table>
<p>Some of .NET features are not supported by Native AOT, that is why you may want to filter them out using new <code>[AotFilter]</code> attribute:</p>
<pre><code class="lang-cs">[AotFilter(&quot;Currently not supported due to missing metadata.&quot;)]
public class Xml_FromStream&lt;T&gt;
</code></pre>
<h2 id="new-features-and-improvements">New features and improvements</h2>
<h3 id="hiding-columns">Hiding Columns</h3>
<p>In <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1621">#1621</a> <a href="https://github.com/marcnet80">@marcnet80</a> has reduced the number of columns displayed when multiple runtimes are being compared.</p>
<p><img src="https://user-images.githubusercontent.com/6011991/99952390-defab180-2d7f-11eb-851c-ffef6fbb0647.png#mid" alt=""></p>
<p>In <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1890">#1890</a> <a href="https://github.com/YegorStepanov">@YegorStepanov</a> has implemented a set of new APIs that allow for hiding columns. It's also exposed via <code>-h</code> and <code>--hide</code> command line arguments.</p>
<pre><code class="lang-cs">[MemoryDiagnoser] // adds Gen0, Gen1, Gen2 and Allocated Bytes columns
[HideColumns(Column.Gen0, Column.Gen1, Column.Gen2)] // dont display GenX columns
public class IntroHidingColumns
{
    [Benchmark]
    public byte[] AllocateArray() =&gt; new byte[100_000];
}
</code></pre>
<p>Sample results without <code>[HideColumns]</code>:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
<th style="text-align: right;">Gen0</th>
<th style="text-align: right;">Gen1</th>
<th style="text-align: right;">Gen2</th>
<th style="text-align: right;">Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td>AllocateArray</td>
<td style="text-align: right;">3.303 us</td>
<td style="text-align: right;">0.0465 us</td>
<td style="text-align: right;">0.0435 us</td>
<td style="text-align: right;">31.2462</td>
<td style="text-align: right;">31.2462</td>
<td style="text-align: right;">31.2462</td>
<td style="text-align: right;">97.69 KB</td>
</tr>
</tbody>
</table>
<p>With:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
<th style="text-align: right;">Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td>AllocateArray</td>
<td style="text-align: right;">3.489 us</td>
<td style="text-align: right;">0.0662 us</td>
<td style="text-align: right;">0.0763 us</td>
<td style="text-align: right;">97.69 KB</td>
</tr>
</tbody>
</table>
<p>Imagine how much time <a href="https://github.com/YegorStepanov">@YegorStepanov</a> has saved to all the people who so far were removing the columns manually from the results before publishing them on GitHub!</p>
<h3 id="allocation-ratio-column">Allocation Ratio Column</h3>
<p>In <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1859">#1859</a> <a href="https://github.com/YegorStepanov">@YegorStepanov</a> has added Allocation Ratio Column. It's enabled by default when <code>MemoryDiagnoser</code> is used and one of the benchmarks is marked as <code>[Benchmark(Baseline = true)]</code> or when there are multuple jobs defined and one of them is marked as baseline.</p>
<pre><code class="lang-cs">[MemoryDiagnoser]
public class AllocationColumnSample
{
    [Benchmark(Baseline = true)]
    [Arguments(&quot;test&quot;)]
    public string Builder(string value)
    {
        StringBuilder sb = new (value);

        for (int i = 0; i &lt; 10; i++)
            sb.Append(value);

        return sb.ToString();
    }

    [Benchmark]
    [Arguments(&quot;test&quot;)]
    public string Concatenation(string value)
    {
        string result = value;

        for (int i = 0; i &lt; 10; i++)
            result += value;

        return result;
    }
}
</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>value</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
<th style="text-align: right;">Ratio</th>
<th style="text-align: right;">Gen 0</th>
<th style="text-align: right;">Allocated</th>
<th style="text-align: right;">Alloc Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Builder</td>
<td>test</td>
<td style="text-align: right;">127.9 ns</td>
<td style="text-align: right;">0.49 ns</td>
<td style="text-align: right;">0.43 ns</td>
<td style="text-align: right;">1.00</td>
<td style="text-align: right;">0.0544</td>
<td style="text-align: right;">456 B</td>
<td style="text-align: right;">1.00</td>
</tr>
<tr>
<td>Concatenation</td>
<td>test</td>
<td style="text-align: right;">120.2 ns</td>
<td style="text-align: right;">0.94 ns</td>
<td style="text-align: right;">0.88 ns</td>
<td style="text-align: right;">0.94</td>
<td style="text-align: right;">0.0908</td>
<td style="text-align: right;">760 B</td>
<td style="text-align: right;">1.67</td>
</tr>
</tbody>
</table>
<h3 id="progress-and-estimated-finish-time">Progress and estimated finish time</h3>
<p>In <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1909">#1909</a> <a href="https://github.com/adamsitnik">@adamsitnik</a> has added logging of progress and estimated finish time.</p>
<pre><code class="lang-log">// ** Remained 5211 (99.9%) benchmark(s) to run. Estimated finish 2022-08-25 22:26 (9h 7m from now) **
</code></pre>
<h3 id="arm64-support-for-benchmarkdotnetdiagnosticswindows-package">arm64 support for BenchmarkDotNet.Diagnostics.Windows package</h3>
<p>Due to the <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2030">update</a> to <a href="https://www.nuget.org/packages/Microsoft.Diagnostics.Tracing.TraceEvent">TraceEvent 3.0</a> <code>BenchmarkDotNet.Diagnostics.Windows</code> package has now arm64 support. Which means that you can use <code>EtwProfiler</code> and other ETW-based diagnosers on Windows arm64.</p>
<p>It would not be possible without <a href="https://github.com/brianrob">@brianrob</a> who implemented arm64 support for TraceEvent in <a href="https://github.com/microsoft/perfview/pull/1533">#1533</a>!</p>
<h3 id="hardware-intrinsics-information">Hardware Intrinsics information</h3>
<p>In <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2051">#2051</a> <a href="https://github.com/adamsitnik">@adamsitnik</a> has extended the hardware information printed in the Summary table with Hardware Intrinsics information.</p>
<p><img src="https://user-images.githubusercontent.com/6011991/180951306-bf8c9f8f-469a-4d7c-8ee1-d7fa47acc0e1.png#mid" alt=""></p>
<p>Sine the space in Summary table is quite limited, we full information is printed only in the log:</p>
<p><img src="https://user-images.githubusercontent.com/6011991/180951531-38c6b6d0-ba6f-4766-a305-b2e306e8420b.png#mid" alt=""></p>
<p>Special thanks to <a href="https://github.com/tannergooding">@tannergooding</a> who provided a lot of <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2051#issuecomment-1194368152">very valuable feedback</a> and <a href="https://github.com/MichalPetryka">@MichalPetryka</a> who contributed an improvement <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2066">#2066</a> for older runtimes.</p>
<h3 id="other-improvements">Other improvements</h3>
<ul>
<li>WASM toolchain has received a lot of improvements from various .NET Team members: <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1769">#1769</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1936">#1936</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1938">#1938</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1982">#1982</a>.</li>
<li>Dependencies and TFMs updates: <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1805">#1805</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1978">#1978</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2012">#2012</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2019">#2019</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2035">#2035</a>.</li>
<li>Ensure proper SummaryStyle handling implemented by <a href="https://github.com/mawosoft">@mawosoft</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1828">#1828</a>.</li>
<li>Preserving <code>EnablePreviewFeatures</code> project setting which gives the possibility to benchmark preview .NET features. Implemented by <a href="https://github.com/kkokosa">@kkokosa</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1842">#1842</a>.</li>
<li>CI: Using non-deprecated macOS pool on Azure Pipelines, implemented by <a href="https://github.com/akoeplinger">@akoeplinger</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1847">#1847</a></li>
<li>CI: Updating Cake to 2.0.0, adopting frosting project style. Implemented by <a href="https://github.com/AndreyAkinshin">@AndreyAkinshin</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1865">#1865</a>.</li>
<li>Detecting ReSharper's Dynamic Program Analysis. Implemented by <a href="https://github.com/adamsitnik">@adamsitnik</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1874">#1874</a>.</li>
<li>Preventing benchmark failure when some of the exporters fail. Implemented by <a href="https://github.com/epeshk">@epeshk</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1902">#1902</a>.</li>
<li>Don't use the diagnosers when benchmarking has failed. Implemented by <a href="https://github.com/adamsitnik">@adamsitnik</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1903">#1903</a>.</li>
<li>Ensuring the default order of benchmarks is the same as declared in source code. Implemented by <a href="https://github.com/adamsitnik">@adamsitnik</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1907">#1907</a>.</li>
<li>Making <code>BuildTimeout</code> configurable. Implemented by <a href="https://github.com/adamsitnik">@adamsitnik</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1906">#1906</a>.</li>
<li>Notify users about private methods with Setup/Cleanup attributes. Implemented by <a href="https://github.com/epeshk">@epeshk</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1912">#1912</a>.</li>
<li>Don't run Roslyn Analyzers for the generated code. Implemented by <a href="https://github.com/adamsitnik">@adamsitnik</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1917">#1917</a>.</li>
<li>Ensure <code>WorkloadActionUnroll</code> and similar are optimized if possible. Implemented by <a href="https://github.com/AndyAyersMS">@AndyAyersMS</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1935">#1935</a>.</li>
<li>Don't use blocking acknowledgments when there is no need to. Implemented by <a href="https://github.com/adamsitnik">@adamsitnik</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1940">#1940</a>.</li>
<li>Executor: Don't use Process.ExitCode, unless the process has exited. Implemented by <a href="https://github.com/radical">@radical</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1947">#1947</a>.</li>
<li>Revise heuristic for initial jitting. Implemented by <a href="https://github.com/AndyAyersMS">@AndyAyersMS</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1949">#1949</a>.</li>
<li>Allow logging build commands output. Implemented by <a href="https://github.com/radical">@radical</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1950">#1950</a>.</li>
<li>Change Mono AOT mode to Normal AOT with LLVM JIT fall back. Implemented by <a href="https://github.com/fanyang-mono">@fanyang-mono</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1990">#1990</a>.</li>
</ul>
<h3 id="glob-filters-support-for-disassemblydiagnoser">Glob filters support for DisassemblyDiagnoser</h3>
<p>So far, the disassembler was always loading the type that was generated by BDN, searching for the benchmark method, disassembling it and when encountered direct method calls, disassembling the called methods as well (if their depth was lesser or equal to max configured depth).</p>
<p>This was working fine, but only for direct method calls. For indirect, the disassembly was incomplete.</p>
<p>In <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2072">#2072</a> <a href="https://github.com/adamsitnik">@adamsitnik</a> has added the possibility to filter methods disassembled by the <code>DisassemblyDiagnoser</code>.</p>
<p>The users can now pass <code>--disasmFilter $globPattern</code> and it's going to be applied to full signatures of all methods available for disassembling. Examples:</p>
<ul>
<li><code>--disasmFilter *System.Text*</code> - disassemble all <code>System.Text</code> methods.</li>
<li><code>--disasmFilter *</code> - disassemble all possible methods.</li>
</ul>
<p>Moreover, <a href="https://github.com/microsoft/clrmd">ClrMD</a> was updated to v2 (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2040">#2040</a>) and few disassembler bugs have been fixed (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/2075">#2075</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2078">#2078</a>). We are expecting that the disassembler will be more reliable now.</p>
<h3 id="docs-and-samples-improvements">Docs and Samples improvements</h3>
<p>Big thanks to <a href="https://github.com/SnakyBeaky">@SnakyBeaky</a>, <a href="https://github.com/Distinctlyminty">@Distinctlyminty</a>, <a href="https://github.com/asaf92">@asaf92</a>, <a href="https://github.com/adamsitnik">@adamsitnik</a> and <a href="https://github.com/eiriktsarpalis">@eiriktsarpalis</a> who have improved our docs, samples and error messages!</p>
<p><a href="https://github.com/dotnet/BenchmarkDotNet/pull/1776">#1776</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1797">#1797</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1850">#1850</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1861">#1861</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1939">#1939</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1974">#1974</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1997">#1997</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2042">#2042</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2050">#2050</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2068">#2068</a>.</p>
<h2 id="bug-fixes">Bug fixes</h2>
<ul>
<li>WASM: <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1811">#1811</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1846">#1846</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1916">#1916</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1926">#1926</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1932">#1932</a>.</li>
<li>Diagnoser-provided Analysers weren't automatically added to Config. Fixed by <a href="https://github.com/mawosoft">@mawosoft</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1790">#1790</a>.</li>
<li>Exportes could been duplicated. Fixed by <a href="https://github.com/workgroupengineering">@workgroupengineering</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1796">#1796</a>.</li>
<li>Small bug in SummaryStyle. Fixed by <a href="https://github.com/mawosoft">@mawosoft</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1801">#1801</a>.</li>
<li><code>InvalidOperationException/NullReferenceException</code> in <code>SmartParaemter</code>. Fixed by <a href="https://github.com/mawosoft">@mawosoft</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1810">#1810</a>.</li>
<li>Failures caused by colons in benchmark name. Fixed by <a href="https://github.com/ronbrogan">@ronbrogan</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1823">#1823</a>.</li>
<li>Some benchmark arugments were not properly escaped and were causing process launcher to crush. Fixed by <a href="https://github.com/adamsitnik">@adamsitnik</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1841">#1841</a></li>
<li>Invalid size specifiers for Memory and Disassembly diagnosers. Fixed by <a href="https://github.com/YegorStepanov">@YegorStepanov</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1854">#1854</a> and <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1855">#1855</a>.</li>
<li>Respect LogicalGroup order in DefaultOrderer. Fixed by <a href="https://github.com/AndreyAkinshin">@AndreyAkinshin</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1866">#1866</a>.</li>
<li>Endless loop in user interaction with redirected input. Fixed by <a href="https://github.com/tmds">@tmds</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1870">#</a>.</li>
<li>Broken power plan support. Fixed by <a href="https://github.com/YegorStepanov">@YegorStepanov</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1885">#1885</a>.</li>
<li><code>BytesAllocatedPerOperation</code> was not being output by the JSON and XML exporters. Fixed by <a href="https://github.com/martincostello">#martincostello</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1919">#1919</a>.</li>
<li>Incorrect default InvocationCount in the summary table. Fixed by <a href="https://github.com/AndreyAkinshin">@AndreyAkinshin</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/issues/1929">#1929</a>.</li>
<li>Failed build output was printed in reverse order. Fixed by <a href="https://github.com/radical">@radical</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1945">#1945</a>.</li>
<li>Build failures due to <code>NETSDK1150</code>. Fixed by <a href="https://github.com/OlegOLK">@OlegOLK</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1981">#1981</a>.</li>
<li><code>MetricCoumn</code> was not respecting provided units when formatting values. Fixed by <a href="https://github.com/mawosoft">@mawosoft</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2033">#2033</a>.</li>
<li>Generating invalid code that was causing benchmark failures. Fixed by <a href="https://github.com/mawosoft">@mawosoft</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2041">#2041</a>.</li>
<li>CI: non-master build branches were publishing artifacts to the CI feed. Fixed by <a href="https://github.com/mawosoft">@mawosoft</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2047">#2047</a>.</li>
<li>Comments in the project files were causing build failures. Fixed by <a href="https://github.com/mawosoft">@mawosoft</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/2056">#2056</a>.</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: August 26, 2022</em></p>
<p><em>Milestone: <a href="https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone%3Av0.13.2">v0.13.2</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.13.1...v0.13.2">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.13.2">https://www.nuget.org/packages/BenchmarkDotNet/0.13.2</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.2">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.2</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.2">https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.2</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.2">https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.2</a></li>
</ul>
<h1 id="benchmarkdotnet-v0131">BenchmarkDotNet v0.13.1</h1>
<p>BenchmarkDotNet v0.13.1 is a service update with various bug fixes and improvements.</p>
<h2 id="highlights">Highlights</h2>
<ul>
<li>S390x architecture support (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1712">#1712</a>)</li>
<li>Various WASM toolchain improvements (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1719">#1719</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1722">#1722</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1729">#1729</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1742">#1742</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1743">#1743</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1744">#1744</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1746">#1746</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1757">#1757</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1763">#1763</a>)</li>
<li>Support of CoreRT on 5.0.3XX SDK (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1725">#1725</a>)</li>
<li>Using Utf8 for reading from standard input (fixes a nasty encoding-related bug) (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1735">#1735</a>)</li>
<li>Adjusting WaitForExit timeouts (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1745">#1745</a>)</li>
<li>Support for returning unmanaged types from benchmarks with InProcessToolchain (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1750">#1750</a>)</li>
<li>Disabled Tiered JIT (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1751">#1751</a>)</li>
<li>A MemoryDiagnoser bug fix (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1762">#1762</a>)</li>
<li>Allow users to hide Gen X columns (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1764">#1764</a>)</li>
<li>Copy GC settings from host process to the benchmark process (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1765">#1765</a>)</li>
<li>Do not split surrogates in shortified parameter values (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1705">#1705</a>)</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: August 11, 2021</em></p>
<p><em>Milestone: <a href="https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone%3Av0.13.1">v0.13.1</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.13.0...v0.13.1">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.13.1">https://www.nuget.org/packages/BenchmarkDotNet/0.13.1</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.1">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.1</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.1">https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.1</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.1">https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.1</a></li>
</ul>
<h1 id="benchmarkdotnet-v0130">BenchmarkDotNet v0.13.0</h1>
<p>It's been a year since our last release. BenchmarkDotNet has been downloaded more than seven million times from <a href="https://www.nuget.org/packages/BenchmarkDotNet/">nuget.org</a>. It's more than we could have ever possibly imagined! Some could say, that it's also more than we can handle ;) That is why we wanted to once again thank <a href="https://github.com/dotnet/BenchmarkDotNet/graphs/contributors">all the contributors</a> who helped us with <code>0.13.0</code> release!</p>
<h2 id="highlights">Highlights</h2>
<p>In BenchmarkDotNet v0.13.0, we have supported various technologies:</p>
<ul>
<li>.NET 5 and .NET 6 target framework monikers</li>
<li>.NET SDK installed via snap</li>
<li>SingleFile deployment</li>
<li>Xamarin applications</li>
<li>WASM applications</li>
<li>Mono AOT</li>
</ul>
<p>We have also introduced new features and improvements including:</p>
<ul>
<li>Memory randomization</li>
<li>Method-specific job attributes</li>
<li>Sortable parameter columns</li>
<li>Customizable ratio column</li>
<li>Improved CoreRun and CoreRT support</li>
<li>Improved Hardware Counters support</li>
</ul>
<p>Of course, this release includes dozens of other improvements and bug fixes!</p>
<h2 id="supported-technologies">Supported technologies</h2>
<h3 id="net-5-net-6-singlefile-and-snap">.NET 5, .NET 6, SingleFile and snap</h3>
<p>At some point in time, <code>netcoreapp5.0</code> moniker was changed to <code>net5.0</code>, which required a fix on our side (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1479">#1479</a>, btw we love this kind of changes). Moreover, .NET 5 introduced platform-specific TMFs (example:  <code>net5.0-windows10.0.19041.0</code>) which also required some extra work: <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1560">#1560</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1691">#1691</a>.</p>
<p>In <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1523">#1523</a> support for .NET 6 was added.</p>
<pre><code class="lang-xml">&lt;TargetFrameworks&gt;net5.0;net5.0-windows10.0.19041.0;net6.0&lt;TargetFrameworks&gt;
</code></pre>
<p>In <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1686">#1686</a> <a href="https://github.com/am11">@am11</a> has implemented support for <strong>single file deployment</strong> (supported in .NET 5 onwards).</p>
<p>Last, but not least in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1652">#1652</a> <strong>snap</strong> support has been implemented.</p>
<pre><code class="lang-log">adam@adsitnik-ubuntu:~/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples$ dotnet50 run -c Release -f net5.0 --filter BenchmarkDotNet.Samples.IntroColdStart.Foo
// Validating benchmarks:
// ***** BenchmarkRunner: Start   *****
// ***** Found 1 benchmark(s) in total *****
// ***** Building 1 exe(s) in Parallel: Start   *****
// start /snap/dotnet-sdk/112/dotnet restore  /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in /home/adam/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples/bin/Release/net5.0/9a018ee4-0f33-46dd-9093-01d3bf31233b
// command took 1.49s and exited with 0
// start /snap/dotnet-sdk/112/dotnet build -c Release  --no-restore /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in /home/adam/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples/bin/Release/net5.0/9a018ee4-0f33-46dd-9093-01d3bf31233b
// command took 2.78s and exited with 0
// ***** Done, took 00:00:04 (4.37 sec)   *****
// Found 1 benchmarks:
//   IntroColdStart.Foo: Job-NECTOD(IterationCount=5, RunStrategy=ColdStart)

// **************************
// Benchmark: IntroColdStart.Foo: Job-NECTOD(IterationCount=5, RunStrategy=ColdStart)
// *** Execute ***
// Launch: 1 / 1
// Execute: /snap/dotnet-sdk/112/dotnet &quot;9a018ee4-0f33-46dd-9093-01d3bf31233b.dll&quot; --benchmarkName &quot;BenchmarkDotNet.Samples.IntroColdStart.Foo&quot; --job &quot;IterationCount=5, RunStrategy=ColdStart&quot; --benchmarkId 0 in /home/adam/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples/bin/Release/net5.0/9a018ee4-0f33-46dd-9093-01d3bf31233b/bin/Release/net5.0
</code></pre>
<h3 id="xamarin-support">Xamarin support</h3>
<p>Thanks to the contributions of the amazing <a href="https://github.com/jonathanpeppers">@jonathanpeppers</a> BenchmarkDotNet supports Xamarin! The examples can be found in our repo: <a href="https://github.com/dotnet/BenchmarkDotNet/tree/master/samples/BenchmarkDotNet.Samples.iOS">iOS</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/tree/master/samples/BenchmarkDotNet.Samples.Android">Android</a>.</p>
<p><img src="https://user-images.githubusercontent.com/840039/73184210-b105fb80-40e1-11ea-9efb-d29fe4d08c79.png#mid" alt=""></p>
<p><a href="https://github.com/dotnet/BenchmarkDotNet/pull/1360">#1360</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1429">#1429</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1434">#1434</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1509">#1509</a></p>
<h3 id="wasm-support">WASM support</h3>
<p>Thanks to the work of <a href="https://github.com/naricc">@naricc</a> you can now benchmark WASM using Mono Runtime! For more details, please refer to our <a href="https://benchmarkdotnet.org/articles/configs/toolchains.html#Wasm">docs</a>.</p>
<p><img src="https://user-images.githubusercontent.com/6011991/87671577-dd860080-c771-11ea-922f-e26a32a3f831.png#mid" alt=""></p>
<p><a href="https://github.com/dotnet/BenchmarkDotNet/pull/1483">#1483</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1498">#1498</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1500">#1500</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1501">#1501</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1507">#1507</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1592">#1592</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1689">#1689</a>.</p>
<h3 id="mono-aot-support">Mono AOT support</h3>
<p>In another awesome contribution (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1662">#1662</a>) <a href="https://github.com/naricc">@naricc</a> has implemented Mono AOT support. The new toolchain supports doing Mono AOT runs with both the Mono-Mini compiler and the Mono-LLVM compiler (which uses LLVM on the back end).</p>
<p>For more details, please go to our <a href="https://benchmarkdotnet.org/articles/configs/toolchains.html#MonoAotLLVM">docs</a>.</p>
<h2 id="new-features-and-improvements">New features and improvements</h2>
<h3 id="memory-randomization">Memory randomization</h3>
<p>In <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1587">#1587</a> <a href="https://github.com/adamsitnik">@adamsitnik</a> has introduced a new, <strong>experimental</strong> feature called &quot;Memory Randomization&quot;.</p>
<p>This feature allows you to ask BenchmarkDotNet to randomize the memory alignment by allocating random-sized byte arrays between iterations and <strong>call [GlobalSetup] before every benchmark iteration</strong> and <code>[GlobalCleanup]</code> after every benchmark iteration.</p>
<p>Sample benchmark:</p>
<pre><code class="lang-cs">public class IntroMemoryRandomization
{
    [Params(512 * 4)]
    public int Size;

    private int[] _array;
    private int[] _destination;

    [GlobalSetup]
    public void Setup()
    {
        _array = new int[Size];
        _destination = new int[Size];
    }

    [Benchmark]
    public void Array() =&gt; System.Array.Copy(_array, _destination, Size);
}
</code></pre>
<p>Without asking for the randomization, the objects are allocated in <code>[GlobalSetup]</code> and their unmodified addresses (and alignment) are used for all iterations (as long as they are not promoted to an older generation by the GC). This is typically the desired behavior, as it gives you very nice and flat distributions:</p>
<pre><code class="lang-cmd">dotnet run -c Release --filter IntroMemoryRandomization
</code></pre>
<pre><code class="lang-ini">-------------------- Histogram --------------------
[502.859 ns ; 508.045 ns) | @@@@@@@@@@@@@@@
---------------------------------------------------
</code></pre>
<p>But if for some reason you are interested in getting a distribution that is better reflecting the &quot;real-life&quot; performance you can enable the randomization:</p>
<pre><code class="lang-cmd">dotnet run -c Release --filter IntroMemoryRandomization --memoryRandomization true
</code></pre>
<pre><code class="lang-ini">-------------------- Histogram --------------------
[108.803 ns ; 213.537 ns) | @@@@@@@@@@@@@@@
[213.537 ns ; 315.458 ns) |
[315.458 ns ; 446.853 ns) | @@@@@@@@@@@@@@@@@@@@
[446.853 ns ; 559.259 ns) | @@@@@@@@@@@@@@@
---------------------------------------------------
</code></pre>
<h3 id="method-specific-job-attributes">Method-specific job attributes</h3>
<p>From now, all attributes that derive from <code>JobMutatorConfigBaseAttribute</code> (<a href="https://benchmarkdotnet.org/api/BenchmarkDotNet.Attributes.JobMutatorConfigBaseAttribute.html#BenchmarkDotNet_Attributes_JobMutatorConfigBaseAttribute">full list</a>) can be applied to methods. You no longer have to move a method to a separate type to customize config for it.</p>
<pre><code class="lang-cs">[Benchmark]
[WarmupCount(1)]
public void SingleWarmupIteration()

[Benchmark]
[WarmupCount(9)]
public void NineWarmupIterations()
</code></pre>
<h3 id="sortable-parameter-columns">Sortable parameter columns</h3>
<p>In order to sort columns of parameters in the results table, you can use the Property <code>Priority</code> inside the params attribute. The priority range is <code>[Int32.MinValue;Int32.MaxValue]</code>, lower priorities will appear earlier in the column order. The default priority is set to <code>0</code>.</p>
<pre><code class="lang-cs">public class IntroParamsPriority
{
    [Params(100)]
    public int A { get; set; }

    [Params(10, Priority = -100)]
    public int B { get; set; }

    [Benchmark]
    public void Benchmark() =&gt; Thread.Sleep(A + B + 5);
}
</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>B</th>
<th>A</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
</tr>
</thead>
<tbody>
<tr>
<td>Benchmark</td>
<td>10</td>
<td>100</td>
<td style="text-align: right;">115.4 ms</td>
<td style="text-align: right;">0.12 ms</td>
<td style="text-align: right;">0.11 ms</td>
</tr>
</tbody>
</table>
<p>This feature got implemented by <a href="https://github.com/JohannesDeml">@JohannesDeml</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1612">#1612</a>.</p>
<h3 id="customizable-ratio-column">Customizable ratio column</h3>
<p>Now it's possible to customize the format of the ratio column.</p>
<pre><code class="lang-cs">[Config(typeof(Config))]
public class IntroRatioStyle
{
    [Benchmark(Baseline = true)]
    public void Baseline() =&gt; Thread.Sleep(1000);

    [Benchmark]
    public void Bar() =&gt; Thread.Sleep(150);

    [Benchmark]
    public void Foo() =&gt; Thread.Sleep(1150);

    private class Config : ManualConfig
    {
        public Config()
        {
            SummaryStyle = SummaryStyle.Default.WithRatioStyle(RatioStyle.Trend);
        }
    }
}
</code></pre>
<pre><code>|   Method |       Mean |   Error |  StdDev |        Ratio | RatioSD |
|--------- |-----------:|--------:|--------:|-------------:|--------:|
| Baseline | 1,000.6 ms | 2.48 ms | 0.14 ms |     baseline |         |
|      Bar |   150.9 ms | 1.30 ms | 0.07 ms | 6.63x faster |   0.00x |
|      Foo | 1,150.4 ms | 5.17 ms | 0.28 ms | 1.15x slower |   0.00x |
</code></pre>
<p>This feature was implemented in <a href="https://github.com/dotnet/BenchmarkDotNet/issues/721">#731</a>.</p>
<h3 id="improved-corerun-support">Improved CoreRun support</h3>
<p>BenchmarkDotNet was reporting invalid .NET Core version number when comparing performance using CoreRuns built from <code>dotnet/corefx</code> and  <code>dotnet/runtime</code>. Fixed by <a href="https://github.com/adamsitnik">@adamsitnik</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1580">#1580</a></p>
<p>In <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1552">#1552</a> <a href="https://github.com/stanciuadrian">@stanciuadrian</a> has implemented support for all <code>GcMode</code> characteristics for <code>CoreRunToolchain</code>. Previously the settings were just ignored, now they are being translated to corresponding <code>COMPlus_*</code> env vars.</p>
<h3 id="improved-corert-support">Improved CoreRT support</h3>
<p>CoreRT has moved from <a href="https://github.com/dotnet/corert/">https://github.com/dotnet/corert/</a> to <a href="https://github.com/dotnet/runtimelab/tree/feature/NativeAOT">https://github.com/dotnet/runtimelab/tree/feature/NativeAOT</a> and we had to update the default compiler version and nuget feed address. Moreover, there was a bug in <code>CoreRtToolchain</code> which was causing any additional native dependencies to not work.</p>
<p>Big thanks to <a href="https://github.com/MichalStrehovsky">@MichalStrehovsky</a>, <a href="https://github.com/jkotas">@jkotas</a> and <a href="https://github.com/kant2002">@kant2002</a> for their help and support!</p>
<p><a href="https://github.com/dotnet/BenchmarkDotNet/pull/1606">#1606</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1643">#1643</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1679">#1679</a></p>
<h3 id="command-line-argument-support-in-benchmarkrunner">Command-line argument support in BenchmarkRunner</h3>
<p>So far only <code>BenchmarkSwitcher</code> was capable of handling console line arguments. Thanks to <a href="https://github.com/chan18">@chan18</a> <code>BenchmarkRunner</code> supports them as well (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1292">#1292</a>):</p>
<pre><code class="lang-cs">public class Program
{
    public static void Main(string[] args) =&gt; BenchmarkRunner.Run(typeof(Program).Assembly, args: args); 
}
</code></pre>
<h3 id="new-api-manualconfigcreateminimumviable">New API: ManualConfig.CreateMinimumViable</h3>
<p><code>ManualConfig.CreateEmpty</code> creates a completely empty config. Without adding a column provider and a logger to the config the users won't see any results being printed. In <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1582">#1582</a> <a href="https://github.com/adamsitnik">@adamsitnik</a> has introduced a new method that creates minimum viable config:</p>
<pre><code class="lang-cs">IConfig before = ManualConfig.CreateEmpty()
    .AddColumnProvider(DefaultColumnProviders.Instance)
    .AddLogger(ConsoleLogger.Default);

IConfig after = ManualConfig.CreateMinimumViable();
</code></pre>
<h3 id="benchmarking-nuget-packages-from-custom-feeds">Benchmarking NuGet packages from custom feeds</h3>
<p>In <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1659/">#1659</a> <a href="https://github.com/workgroupengineering">@workgroupengineering</a> added the possibility to indicate the source of the tested nuget package and whether it is a pre-release version.</p>
<h3 id="deterministic-benchmark-builds">Deterministic benchmark builds</h3>
<p>BenchmarkDotNet is now always enforcing Deterministic builds (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1489">#1489</a>) and Optimizations enabled (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1494">#1494</a>) which is a must-have if you are using custom build configurations. MSBuild enforces optimizations <strong>only</strong> for configurations that are named <code>Release</code> (the comparison is case-insensitive).</p>
<pre><code class="lang-xml">&lt;ItemGroup Condition=&quot; '$(Configuration)' == 'X' &quot;&gt;
   &lt;PackageReference Include=&quot;SomeLibThatYouWantToBenchmark&quot; Version=&quot;1.0.0&quot; /&gt;
&lt;/ItemGroup&gt;
&lt;ItemGroup Condition=&quot; '$(Configuration)' == 'Y' &quot;&gt;
   &lt;PackageReference Include=&quot;SomeLibThatYouWantToBenchmark&quot; Version=&quot;2.0.0&quot; /&gt;
&lt;/ItemGroup&gt;
</code></pre>
<pre><code class="lang-cs">var config = DefaultConfig.Instance
  .AddJob(Job.Default.WithCustomBuildConfiguration(&quot;X&quot;).WithId(&quot;X&quot;).AsBaseline())
  .AddJob(Job.Default.WithCustomBuildConfiguration(&quot;Y&quot;).WithId(&quot;Y&quot;));
</code></pre>
<p><a href="https://github.com/dotnet/BenchmarkDotNet/pull/1489">#1489</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1494">#1494</a></p>
<h3 id="improved-hardware-counters-support">Improved Hardware Counters support</h3>
<p>BenchmarkDotNet is being used by the .NET Team to ensure that .NET is not regressing. More than three thousand benchmarks (they can be found <a href="https://github.com/dotnet/performance/tree/main/src/benchmarks/micro">here</a>) are being executed multiple times a day on multiple hardware configs. Recently, .NET Team started to use <code>InstructionsRetired</code> to help to filter unstable benchmarks that report regressions despite not changing the number of instructions retired. This has exposed few bugs in Hardware Counters support in BenchmarkDotNet, which all got fixed by <a href="https://github.com/adamsitnik">@adamsitnik</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1547">#1547</a> and <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1550">#1550</a>. Moreover, we have <strong>removed</strong> the old <a href="https://adamsitnik.com/Hardware-Counters-Diagnoser/">PmcDiagnoser</a> and extended <a href="https://adamsitnik.com/ETW-Profiler/">EtwProfiler</a> with the hardware counters support. It's just much more accurate and futureproof. For details, please go to <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1548">#1548</a>.</p>
<p>How stable was <code>PmcDiagnoser</code> (same benchmarks run twice in a row on the same machine):</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th style="text-align: right;">InstructionRetired/Op</th>
</tr>
</thead>
<tbody>
<tr>
<td>Burgers_0</td>
<td>.NET 5.0</td>
<td style="text-align: right;">845,746</td>
</tr>
<tr>
<td>Burgers_0</td>
<td>.NET Core 2.1</td>
<td style="text-align: right;">30,154,151</td>
</tr>
<tr>
<td>Burgers_0</td>
<td>.NET Framework 4.6.1</td>
<td style="text-align: right;">4,230,848</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th style="text-align: right;">InstructionRetired/Op</th>
</tr>
</thead>
<tbody>
<tr>
<td>Burgers_0</td>
<td>.NET 5.0</td>
<td style="text-align: right;">34,154,524</td>
</tr>
<tr>
<td>Burgers_0</td>
<td>.NET Core 2.1</td>
<td style="text-align: right;">246,534,203</td>
</tr>
<tr>
<td>Burgers_0</td>
<td>.NET Framework 4.6.1</td>
<td style="text-align: right;">2,607,686</td>
</tr>
</tbody>
</table>
<p>How stable is <code>EtwProfiler</code>:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th style="text-align: right;">InstructionRetired/Op</th>
</tr>
</thead>
<tbody>
<tr>
<td>Burgers_0</td>
<td>.NET 5.0</td>
<td style="text-align: right;">3,069,978,261</td>
</tr>
<tr>
<td>Burgers_0</td>
<td>.NET Core 2.1</td>
<td style="text-align: right;">3,676,000,000</td>
</tr>
<tr>
<td>Burgers_0</td>
<td>.NET Framework 4.6.1</td>
<td style="text-align: right;">3,468,866,667</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th style="text-align: right;">InstructionRetired/Op</th>
</tr>
</thead>
<tbody>
<tr>
<td>Burgers_0</td>
<td>.NET 5.0</td>
<td style="text-align: right;">3,066,810,000</td>
</tr>
<tr>
<td>Burgers_0</td>
<td>.NET Core 2.1</td>
<td style="text-align: right;">3,674,666,667</td>
</tr>
<tr>
<td>Burgers_0</td>
<td>.NET Framework 4.6.1</td>
<td style="text-align: right;">3,468,600,000</td>
</tr>
</tbody>
</table>
<p>Moreover, in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1540">#1540</a> <a href="https://github.com/WojciechNagorski">@WojciechNagorski</a> has added the removal of temporary files created by <code>EtwProfiler</code>.</p>
<h3 id="improved-troubleshooting">Improved Troubleshooting</h3>
<p>We have the possibility to ask BDN to stop on the first error: <code>--stopOnFirstError true</code>.</p>
<p>The problem was when the users had not asked for that, tried to run <code>n</code> benchmarks, all of them failed to build, and BDN was printing the same build error <code>n</code> times.</p>
<p>In <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1672">#1672</a> <a href="https://github.com/adamsitnik">@adamsitnik</a> has changed that, so when all the build fails, BDN stops after printing the first error.</p>
<p>Moreover, we have also changed the default behavior for the failed builds of the boilerplate code. If the build fails, we don't remove the files. Previously we have required the users to pass <code>--keepFiles</code> to keep them. See <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1567">#1567</a> for more details and don't forget about the <a href="https://benchmarkdotnet.org/articles/guides/troubleshooting.html">Troubleshooting</a> docs!</p>
<h3 id="docs-and-samples-improvements">Docs and Samples improvements</h3>
<p>Big thanks to <a href="https://github.com/lukasz-pyrzyk">@lukasz-pyrzyk</a>, <a href="https://github.com/fleckert">@fleckert</a>, <a href="https://github.com/MarecekF">@MarecekF</a>, <a href="https://github.com/joostas">@joostas</a>, <a href="https://github.com/michalgalecki">@michalgalecki</a>, <a href="https://github.com/WojciechNagorski">@WojciechNagorski</a>, <a href="https://github.com/MendelMonteiro">@MendelMonteiro</a>, <a href="https://github.com/kevinsalimi">@kevinsalimi</a>, <a href="https://github.com/cedric-cf">@cedric-cf</a>, <a href="https://github.com/YohDeadfall">@YohDeadfall</a>,  <a href="https://github.com/jeffhandley">@jeffhandley</a> and <a href="https://github.com/JohannesDeml">@JohannesDeml</a> who have improved our docs and samples!</p>
<p><a href="https://github.com/dotnet/BenchmarkDotNet/pull/1463">#1463</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1465">#1465</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1508">#1508</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1518">#1518</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1554">#1554</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1568">#1568</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1601">#1601</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1633">#1633</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1645">#1645</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1647">#1647</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1657">#1657</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1675">#1675</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1676">#1676</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1690">#1690</a>.</p>
<h3 id="template-improvements">Template improvements</h3>
<ul>
<li>Projects created out of our official templates might have been unexpectedly packed when running <code>dotnet pack</code> on the entire solution. In <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1584">#1584</a> <a href="https://github.com/kendaleiv">@kendaleiv</a> has explicitly disabled packing for the template.</li>
<li>The template had <code>netcoreapp3.0</code> TFM hardcoded. This got fixed by <a href="https://github.com/ExceptionCaught">@https://github.com/ExceptionCaught</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1630">#1630</a> and <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1632">#1632</a>.</li>
<li>In <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1667">#1667</a> <a href="https://github.com/YohDeadfall">@YohDeadfall</a> has changed the default debug type from <code>portable</code> to <code>pdbonly</code> (required by <code>DisassemblyDiagnoser</code>).</li>
</ul>
<h2 id="bug-fixes">Bug fixes</h2>
<ul>
<li>Very long string <code>[Arguments]</code> and <code>[Params]</code> were causing BenchmarkDotNet to crash. Fixed by <a href="https://github.com/adamsitnik">@adamsitnik</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1248">#1248</a> and <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1545/">#1545</a>. So far trace file names were containing full benchmark names and arguments. Now if the name is too long, the trace file name is a hash (consistent for multiple runs of the same benchmark). The same goes for passing benchmark name by the host process to the benchmark process via command-line arguments.</li>
<li><code>LangVersion</code> set to a non-numeric value like <code>latest</code> was crashing the build. Fixed by <a href="https://github.com/martincostello">@martincostello</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1420">#1420</a>.</li>
<li>Windows 10 November 201<strong>9</strong> was being recognized as 201<strong>8</strong>. Fixed by <a href="https://github.com/kapsiR">@kapsiR</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1437">#1437</a>.</li>
<li>Assemblies loaded via streams were not supported. Fixed by <a href="https://github.com/jeremyosterhoudt">@jeremyosterhoudt</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1443">#1443</a>.</li>
<li><a href="https://wojciechnagorski.github.io/2019/08/analyzing-native-memory-allocation-with-benchmarkdotnet/">NativeMemoryProfiler</a> was detecting small leaks that were false positives. Fixed by <a href="https://github.com/WojciechNagorski">@WojciechNagorski</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1451">#1451</a> and <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1600">#1600</a>.</li>
<li><a href="https://adamsitnik.com/Disassembly-Diagnoser/">DisassemblyDiagnoser</a> was crashing on Linux. Fixed by <a href="https://github.com/damageboy">@damageboy</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1459">#1459</a>.</li>
<li>Target framework moniker was being printed as toolchain name for Full .NET Framework benchmarks. Fixed by <a href="https://github.com/svick">@svick</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1471">#1471</a>.</li>
<li><code>[ParamsSource]</code> returning <code>IEnumerable&lt;object[]&gt;</code> was not working properly when combined with <code>[Arguments]</code>. Fixed by <a href="https://github.com/adamsitnik">@adamsitnik</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1478">#1478</a>.</li>
<li><code>NullReferenceException</code> in <code>MultimodalDistributionAnalyzer</code>. Fixed by <a href="https://github.com/suslovk">@suslovk</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1488">#1488</a>.</li>
<li><code>NotSupportedException</code> was being thrown if there was an encoding mismatch between host and benchmark process. Diagnosed by <a href="https://github.com/ChristophLindemann">@ChristophLindemann</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/issues/1487">#1487</a>, fixed by <a href="https://github.com/lovettchris">@lovettchris</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1491">#1491</a>.</li>
<li><code>MissingMethodException</code> was being thrown in projects that referenced a newer version of <a href="https://github.com/icedland/iced">Iced</a>. Fixed by <a href="https://github.com/Symbai">@Symbai</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1497">#1497</a> and in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1502">#1502</a>.</li>
<li><code>AppendTargetFrameworkToOutputPath</code> set to <code>false</code> was not supported. Fixed by <a href="https://github.com/adamsitnik">@adamsitnik</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1563">#1563</a></li>
<li>A locking finalizer could have hanged benchmark process which would just print <code>// AfterAll</code> and never quit. Fixed by <a href="https://github.com/adamsitnik">@adamsitnik</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1571">#1571</a>. To prevent other hangs from happening, a timeout of <code>250ms</code> was added. If the process does not quit after running the benchmarks and waiting <code>250ms</code>, it's being force killed.</li>
<li>In some cases, <code>JsonExporter</code> was reporting <code>NaN</code> for some of the Statistics. This was breaking non-.NET JSON deserializers. Fixed by <a href="https://github.com/marcnet80">@marcnet80</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1581">#1581</a>.</li>
<li><code>UnitType.Size</code> metrics were not using the provided number format. Fixed by <a href="https://github.com/jodydonetti">@jodydonetti</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1569">#1569</a> and <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1618">#1618</a>.</li>
<li><code>MaxColumnWidth</code> setting was not used for type names. Fixed by <a href="https://github.com/JohannesDeml">@JohannesDeml</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1609">#1609</a>.</li>
<li>Current culture was not respected when formatting <code>Ratio</code> column values. Fixed by <a href="https://github.com/JohannesDeml">@JohannesDeml</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1610">#1610</a>.</li>
<li>BenchmarkDotNet was redirecting Standard Error of the benchmark process, which was causing deadlocks for benchmarks that were writing to it. Fixed by <a href="https://github.com/adamsitnik">@adamstinik</a> in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1631">#1631</a></li>
<li><code>DisassemblyDiagnoser</code> was failing to disassemble multiline source code. <a href="https://github.com/YohDeadfall">@YohDeadfall</a> fixed that in <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1674">#1674</a>.</li>
<li>In <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1644">#1644</a> <a href="https://github.com/adamsitnik">@adamstinik</a> has fixed the inconsistency between benchmark filter and hint.</li>
</ul>
<h2 id="removal-of-the-dotnet-global-tool">Removal of the dotnet global tool</h2>
<p>In <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1006">#1006</a> (0.11.4) we have introduced a new dotnet global tool.</p>
<p>By looking at the number of reported bugs we got to the conclusion that the tool has not passed the test of time.</p>
<p>Why? Because it was based entirely on dynamic assembly loading which is very hard to get right in .NET and the fact that we support all existing .NET Runtimes (.NET, .NET Core, Mono, CoreRT) made it even harder (if not impossible).</p>
<p><strong>We have removed it and the old versions are no longer supported</strong>. For more details, please refer to <a href="https://github.com/dotnet/BenchmarkDotNet/pull/1572">#1572</a>.</p>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: May 19, 2021</em></p>
<p><em>Milestone: <a href="https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone%3Av0.13.0">v0.13.0</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.12.1...v0.13.0">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.13.0">https://www.nuget.org/packages/BenchmarkDotNet/0.13.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.0">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.0">https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.0">https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.0</a></li>
</ul>
<h1 id="benchmarkdotnet-v0121">BenchmarkDotNet v0.12.1</h1>
<h2 id="highlights">Highlights</h2>
<ul>
<li><strong>.NET 5 support</strong><br>
As you probably know, .NET Core 5 was officially <a href="https://github.com/dotnet/runtime/pull/33694">rebranded</a> to .NET 5.
The new version of BenchmarkDotNet supports the new runtime after rebranding.<br>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1399">#1399</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/465ebf3fdbf20f0e9219c4c957fb33c13256fdcd">465ebf</a></li>
<li><strong>Perfolizer adoption</strong><br>
The internal statistical engine of BenchmarkDotNet became mature enough to be transformed into an independent project.
Meet <a href="https://github.com/AndreyAkinshin/perfolizer">perfolizer</a> — a toolkit for performance analysis!
While BenchmarkDotNet focuses on obtaining reliable measurements, perfolizer focuses on the decent analysis of measured data.
You still can use all the statistical algorithms from BenchmarkDotNet,
but you can also install perfolizer as a <a href="https://www.nuget.org/packages/Perfolizer/">standalone NuGet package</a>.
You can find more details in the <a href="https://aakinshin.net/posts/introducing-perfolizer/">official announcement</a>.<br>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1386">#1386</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/54a06102a6e0cc4169d23c6f9cd2779ee408d2bf">54a061</a></li>
<li><strong>Cross-platform disassembler</strong><br>
Now the <code>DisassemblyDiagnoser</code> is cross-platform!
The disassembling logic was also improved, now it handles runtime helper methods and references to method tables properly.
Internally, it uses the <a href="https://github.com/0xd4d/iced">Iced</a> library for formatting assembly code.<br>
Special thanks to <a href="https://github.com/adamsitnik">@adamsitnik</a> for the implementation and <a href="https://github.com/0xd4d">@0xd4d</a> for Iced!<br>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1332">#1332</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/899">#899</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1316">#1316</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1364">#1364</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/294320be9525b0ecfefd0351381756d3a3b77211">294320</a></li>
<li><strong>EventPipe-based cross-platform profiler</strong><br>
Now you can easily profiler your benchmarks on Windows, Linux, and macOS!
Just mark your class with the <code>[EventPipeProfiler(...)]</code> attribute and get a <code>.speedscope.json</code> file that you can browse in <a href="https://www.speedscope.app/">SpeedScope</a>.<br>
Special thanks to <a href="https://github.com/WojciechNagorski">@WojciechNagorski</a> for the implementation!<br>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1321">#1321</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1315">#1315</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/c648ff956662abae512c579ffa7f1dc12178f6c3">c648ff</a></li>
<li><strong>New fluent API</strong><br>
We continue to improve our API and make it easier for reading and writing.<br>
Special thanks to <a href="https://github.com/WojciechNagorski">@WojciechNagorski</a> for the implementation!<br>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1273">#1273</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1234">#1234</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/640d885ae0daddcee7c9ba9b5f1bf5790b9b5ae3">640d88</a></li>
<li><strong>Ref readonly support</strong><br>
Now you can use <code>ref readonly</code> in benchmark signatures.<br>
Special thanks to <a href="https://github.com/adamsitnik">@adamsitnik</a> for the implementation!<br>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1389">#1389</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1388">#1388</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/9ac7770682a45afb6cf4ec353f9fa3c69ece67ce">9ac777</a></li>
</ul>
<h2 id="cross-platform-disassembler">Cross-platform disassembler</h2>
<p>Just mark your benchmark class with the <code>[DisassemblyDiagnoser]</code> attribute
and you will get the disassembly listings for all the benchmarks.
The formatting looks pretty nice thanks to <a href="https://github.com/0xd4d/iced">Iced</a>.
It works like a charm on Windows, Linux, and macOS.</p>
<pre><code class="lang-cs">[DisassemblyDiagnoser]
public class IntroDisassembly
{
    private int[] field = Enumerable.Range(0, 100).ToArray();

    [Benchmark]
    public int SumLocal()
    {
        var local = field; // we use local variable that points to the field

        int sum = 0;
        for (int i = 0; i &lt; local.Length; i++)
            sum += local[i];

        return sum;
    }

    [Benchmark]
    public int SumField()
    {
        int sum = 0;
        for (int i = 0; i &lt; field.Length; i++)
            sum += field[i];

        return sum;
    }
}
</code></pre>
<p><strong>.NET Core 2.1.16 (CoreCLR 4.6.28516.03, CoreFX 4.6.28516.10), X64 RyuJIT</strong></p>
<pre><code class="lang-x86asm">; BenchmarkDotNet.Samples.IntroDisassembly.SumLocal()
       mov       rax,[rcx+8]
       xor       edx,edx
       xor       ecx,ecx
       mov       r8d,[rax+8]
       test      r8d,r8d
       jle       short M00_L01
M00_L00:
       movsxd    r9,ecx
       add       edx,[rax+r9*4+10]
       inc       ecx
       cmp       r8d,ecx
       jg        short M00_L00
M00_L01:
       mov       eax,edx
       ret
; Total bytes of code 35
</code></pre>
<p><strong>.NET Core 2.1.16 (CoreCLR 4.6.28516.03, CoreFX 4.6.28516.10), X64 RyuJIT</strong></p>
<pre><code class="lang-x86asm">; BenchmarkDotNet.Samples.IntroDisassembly.SumField()
       sub       rsp,28
       xor       eax,eax
       xor       edx,edx
       mov       rcx,[rcx+8]
       cmp       dword ptr [rcx+8],0
       jle       short M00_L01
M00_L00:
       mov       r8,rcx
       cmp       edx,[r8+8]
       jae       short M00_L02
       movsxd    r9,edx
       add       eax,[r8+r9*4+10]
       inc       edx
       cmp       [rcx+8],edx
       jg        short M00_L00
M00_L01:
       add       rsp,28
       ret
M00_L02:
       call      CORINFO_HELP_RNGCHKFAIL
       int       3
; Total bytes of code 53
</code></pre>
<p>Now we handle runtime helper methods and references to method tables properly. Example:</p>
<p>Before:</p>
<pre><code class="lang-x86asm">; MicroBenchmarks.WithCallsAfter.Benchmark(Int32)
       push    rsi
       sub     rsp,20h
       mov     rsi,rcx
       cmp     edx,7FFFFFFFh
       jne     M00_L00
       call    MicroBenchmarks.WithCallsAfter.Static()
       mov     rcx,rsi
       call    MicroBenchmarks.WithCallsAfter.Instance()
       mov     rcx,rsi
       call    MicroBenchmarks.WithCallsAfter.Recursive()
       mov     rcx,rsi
       mov     rax,qword ptr [rsi]
       mov     rax,qword ptr [rax+40h]
       call    qword ptr [rax+20h]
       mov     rcx,rsi
       mov     edx,1
       mov     rax,7FF8F4217050h
       add     rsp,20h
       pop     rsi
       jmp     rax
M00_L00:
       mov     rcx,offset System_Private_CoreLib+0xa31d48
       call    coreclr!MetaDataGetDispenser+0x322a0
       mov     rsi,rax
       mov     ecx,0ACFAh
       mov     rdx,7FF8F42F4680h
       call    coreclr!MetaDataGetDispenser+0x17140
       mov     rdx,rax
       mov     rcx,rsi
       call    System.InvalidOperationException..ctor(System.String)
       mov     rcx,rsi
       call    coreclr!coreclr_shutdown_2+0x39f0
       int     3
       add     byte ptr [rax],al
       sbb     dword ptr [00007ff9`26284e30],eax
       add     dword ptr [rax+40h],esp
       add     byte ptr [rax],al
       add     byte ptr [rax],al
       add     byte ptr [rax],al
       add     byte ptr [rax-70BC4CCh],ah
; Total bytes of code 157
</code></pre>
<p>After:</p>
<pre><code class="lang-x86asm">; BenchmarkDotNet.Samples.WithCallsAfter.Benchmark(Int32)
       push      rsi
       sub       rsp,20
       mov       rsi,rcx
       cmp       edx,7FFFFFFF
       jne       M00_L00 
       call      BenchmarkDotNet.Samples.WithCallsAfter.Static() 
       mov       rcx,rsi
       call      BenchmarkDotNet.Samples.WithCallsAfter.Instance() 
       mov       rcx,rsi
       call      BenchmarkDotNet.Samples.WithCallsAfter.Recursive() 
       mov       rcx,rsi
       mov       rax,[rsi]
       mov       rax,[rax+40]
       call      qword ptr [rax+20]
       mov       rcx,rsi
       mov       edx,1
       mov       rax BenchmarkDotNet.Samples.WithCallsAfter.Benchmark(Boolean) 
       add       rsp,20
       pop       rsi
       jmp       rax
M00_L00:
       mov       rcx MT_System.InvalidOperationException 
       call      CORINFO_HELP_NEWSFAST 
       mov       rsi,rax
       mov       ecx,12D
       mov       rdx,7FF954FF83F0
       call      CORINFO_HELP_STRCNS 
       mov       rdx,rax
       mov       rcx,rsi
       call      System.InvalidOperationException..ctor(System.String) 
       mov       rcx,rsi
       call      CORINFO_HELP_THROW 
       int       3
; Total bytes of code 134
</code></pre>
<p>See also: <a href="https://aakinshin.net/posts/dotnet-crossruntime-disasm/">Cross-runtime .NET disassembly with BenchmarkDotNet</a>.</p>
<p>Special thanks to <a href="https://github.com/adamsitnik">@adamsitnik</a> for the implementation and <a href="https://github.com/0xd4d">@0xd4d</a> for Iced!</p>
<h2 id="eventpipe-based-cross-platform-profiler">EventPipe-based cross-platform profiler</h2>
<p>Now you can easily profiler your benchmarks on Windows, Linux, and macOS!</p>
<p>If you want to use the new profiler, you should just mark your benchmark class with the <code>[EventPipeProfiler(...)]</code> attribute:</p>
<pre><code>[EventPipeProfiler(EventPipeProfile.CpuSampling)] // &lt;-- Enables new profiler
public class IntroEventPipeProfiler
{
    [Benchmark]
    public void Sleep() =&gt; Thread.Sleep(2000);
}
</code></pre>
<p>Once the benchmark run is finished, you get a <code>.speedscope.json</code> file that can be opened in <a href="https://www.speedscope.app/">SpeedScope</a>:</p>
<p><img src="https://wojciechnagorski.github.io/images/EventPipeProfiler/SpeedScope.png#mid" alt=""></p>
<p>The new profiler supports several modes:</p>
<ul>
<li><code>CpuSampling</code> - Useful for tracking CPU usage and general .NET runtime information. This is the default option.</li>
<li><code>GcVerbose</code> - Tracks GC collections and samples object allocations.</li>
<li><code>GcCollect</code> - Tracks GC collections only at very low overhead.</li>
<li><code>Jit</code> - Logging when Just in time (JIT) compilation occurs. Logging of the internal workings of the Just In Time compiler. This is fairly verbose. It details decisions about interesting optimization (like inlining and tail call)</li>
</ul>
<p>Please see Wojciech Nagórski's <a href="https://wojciechnagorski.github.io/2020/04/cross-platform-profiling-.net-code-with-benchmarkdotnet/">blog post</a> for all the details.</p>
<p>Special thanks to <a href="https://github.com/WojciechNagorski">@WojciechNagorski</a> for the implementation!</p>
<h2 id="new-fluent-api">New fluent API</h2>
<p>We continue to improve our API and make it easier for reading and writing.
The old API is still existing, but it is marked as obsolete and will be removed in the further library versions.
The most significant changes:</p>
<p><strong>Changes in Job configuration</strong></p>
<p><img src="https://user-images.githubusercontent.com/17333903/66208963-b49af000-e6b6-11e9-87b3-1e4bb5519273.PNG" alt=""></p>
<p><strong>Changes in IConfig/ManualConfig</strong></p>
<p><img src="https://user-images.githubusercontent.com/17333903/66208975-b6fd4a00-e6b6-11e9-94cd-85c73ae0ec27.PNG" alt=""></p>
<p><strong>Full fluent API</strong></p>
<p><img src="https://user-images.githubusercontent.com/17333903/66208977-b8c70d80-e6b6-11e9-8e43-6dac3921c121.PNG" alt=""></p>
<p>Special thanks to <a href="https://github.com/WojciechNagorski">@WojciechNagorski</a> for the implementation!</p>
<h2 id="ref-readonly-support">Ref readonly support</h2>
<p>Now you can use <code>ref readonly</code> in benchmark signatures.
Here is an example:</p>
<pre><code class="lang-cs">public class RefReadonlyBenchmark
{
    static readonly int[] array = { 1 };

    [Benchmark]
    public ref readonly int RefReadonly() =&gt; ref RefReadonlyMethod();

    static ref readonly int RefReadonlyMethod() =&gt; ref array[0];
}
</code></pre>
<p>Special thanks to <a href="https://github.com/adamsitnik">@adamsitnik</a> for the implementation!</p>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: April 6, 2020</em></p>
<p><em>Milestone: <a href="https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone%3Av0.12.1">v0.12.1</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.12.0...v0.12.1">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.12.1">https://www.nuget.org/packages/BenchmarkDotNet/0.12.1</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.12.1">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.12.1</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.12.1">https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.12.1</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.12.1">https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.12.1</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.12.1">https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.12.1</a></li>
</ul>
<h1 id="benchmarkdotnet-v0120">BenchmarkDotNet v0.12.0</h1>
<p>It's been several months since our last release, but we have been working hard and have some new features for you!</p>
<h2 id="highlights">Highlights</h2>
<ul>
<li><strong>Features and major improvements</strong>
<ul>
<li><strong>Advanced multiple target frameworks support</strong><br>
Now BenchmarkDotNet supports .NET Framework 4.8, .NET Core 3.1, and .NET Core 5.0.
Also, we reworked our API that allows targeting several runtimes from the same config:
the new API is more consistent, flexible, and powerful.
For example, if you want to execute your benchmarking using .NET Framework 4.8 and .NET Core 3.1,
you can use the <code>SimpleJob(RuntimeMoniker.Net48)</code>, <code>[SimpleJob(RuntimeMoniker.NetCoreApp31)]</code> attributes or
<code>Job.Default.With(ClrRuntime.Net48)</code>, <code>Job.Default.With(CoreRuntime.Core31)</code> jobs in a manual config.
You can find more details below.
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1188">#1188</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1186">#1186</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1236">#1236</a></li>
<li><strong>Official templates for BenchmarkDotNet-based projects</strong><br>
With the help of the <a href="https://www.nuget.org/packages/BenchmarkDotNet.Templates/">BenchmarkDotNet.Templates</a> NuGet package,
you can easily create new projects from the command line via <code>dotnet new benchmark</code>.
This command has a lot of useful options, so you can customize your new project as you want.
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1044">#1044</a></li>
<li><strong>New NativeMemoryProfiler</strong><br>
<code>NativeMemoryProfiler</code> measure the native memory traffic and adds the extra columns <code>Allocated native memory</code> and <code>Native memory leak</code> to the summary table.
Internally, it uses <code>EtwProfiler</code> to profile the code using ETW.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/457">#457</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1131">#1131</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1208">#1208</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1214">#1214</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1218">#1218</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1219">#1219</a></li>
<li><strong>New ThreadingDiagnoser</strong><br>
<code>ThreadingDiagnoser</code> also adds two extra columns to the summary table:
<code>Completed Work Items</code> (the number of work items that have been processed in ThreadPool per single operation) and
<code>Lock Contentions</code> (the number of times there <em>was contention</em> upon trying to take a Monitor's lock per single operation).
Internally, it uses <a href="https://github.com/dotnet/corefx/issues/35500">new APIs</a> exposed in .NET Core 3.0.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1154">#1154</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1227">#1227</a></li>
<li><strong>Improved MemoryDiagnoser</strong><br>
Now <code>MemoryDiagnoser</code> includes memory allocated by <em>all threads</em> that were live during benchmark execution: a new GC API was exposed in .NET Core 3.0 preview6+.
It allows to get the number of allocated bytes for all threads.
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1155">#1155</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1153">#1153</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/723">#723</a></li>
<li><strong>LINQPad 6 support</strong><br>
Now both LINQPad 5 and LINQPad 6 are supported!
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1241">#1241</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1245">#1245</a></li>
<li><strong>Fast documentation search</strong><br>
We continue to improve the usability of our documentation.
In this release, we improved the search experience in the documentation: now it works almost instantly with the help of <a href="https://www.algolia.com/">Algolia</a> engine!
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1148">#1148</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1158">#1158</a></li>
</ul>
</li>
<li><strong>Minor summary and exporter improvements</strong>
<ul>
<li><strong>Improved presentation of the current architecture in the environment information</strong><br>
In the previous version of BenchmarkDotNet, the reports always contained &quot;64bit&quot; or &quot;32bit&quot; which did not tell if it was ARM or not.
Now it prints the full architecture name (<code>x64</code>, <code>x86</code>, <code>ARM</code>, or <code>ARM64</code>).
For example, instead of <code>.NET Framework 4.8 (4.8.3815.0), 64bit RyuJIT</code> you will get <code>.NET Framework 4.8 (4.8.3815.0), X64 RyuJIT</code> or <code>.NET Framework 4.8 (4.8.3815.0), ARM64 RyuJIT</code>.
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1213">#1213</a></li>
<li><strong>Simplified reports for Full .NET Framework version</strong><br>
Previous version: <code>.NET Framework 4.7.2 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.3324.0</code>.
Current version: <code>.NET Framework 4.7.2 (4.7.3362.0), 64bit RyuJIT</code>.
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1114">#1114</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1111">#1111</a></li>
<li><strong>More reliable CPU info on Windows</strong><br>
We added a workaround to for a bug in wmic that uses <code>\r\r\n</code> as a line separator.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1144">#1144</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1145">#1145</a></li>
<li><strong>Better naming for generated plots</strong><br>
When <code>[RPlotExporter]</code> is used, BenchmarkDotNet generates a lot of useful plots in the <code>BenchmarkDotNet.Artifacts</code> folder.
The naming of the plot files was improved: benchmarks without <code>Params</code> doesn't include a double dash (<code>--</code>) in their names anymore.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1183">1183</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1212">1212</a></li>
<li><strong>Better density plot precision</strong>
The previous version of BenchmarkDotNet used the rule-of-thumb bandwidth selector in <code>RPlotExporter</code> density plots.
It was fine for unimodal distributions, but sometimes it produced misleading plots for multimodal distributions.
Now, RPlotExporter uses the Sheather&amp;Jones bandwidth selector that significantly improves the presentation of the density plots for complex distributions.
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/58fde64c809ceadb3fca9d677a7cec83071b833f">58fde64</a></li>
<li><strong>Better alignment in <code>HtmlExporter</code></strong><br>
Now BenchmarkDotNet aligns the content exported by <code>HtmlExporter</code> to the right.
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1189">#1189</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/dfa074b024cfa8bbe4fe175d3d65a3d9f85127ff">dfa074</a></li>
<li><strong>Better precision calculation in SummaryTable</strong><br>
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/4e9eb4335eee05a95a3766f2c81ae260508021af">4e9eb43</a></li>
<li><strong>Better summary analysis</strong><br>
BenchmarkDotNet warns the user when benchmark baseline value is too close to zero and the columns derived from BaselineCustomColumn cannot be computed.
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1161">#1161</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/600">#600</a></li>
<li><strong>Make log file datetime format 24-hour</strong><br>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1149">#1149</a></li>
<li><strong>Improve AskUser prompt message</strong><br>
The error messages will surround <code>*</code> by quotes on Linux and macOS.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1147">#1147</a></li>
</ul>
</li>
<li><strong>Minor API improvements</strong>
<ul>
<li><strong>ED-PELT algorithm for changepoint detection is now available</strong><br>
You can find details in <a href="https://aakinshin.net/posts/edpelt/">this blog post</a>.
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/f89091a2a9c1a4058dd8e32d5aa01271910dd7dc">f89091</a></li>
<li><strong>Improved OutlierMode API</strong><br>
BenchmarkDotNet performs measurement postprocessing that may remove some of the outlier values (it can be useful to remove upper outliers that we get because of the natural CPU noise).
In the previous version, naming for the <code>OutlierMode</code> values was pretty confusing: <code>None/OnlyUpper/OnlyLower/All</code>.
Now, these values were renamed to <code>DontRemove/RemoveUpper/RemoveLower/RemoveAll</code>.
For example, if you want to remove all the outliers, you can annotate your benchmark with the <code>[Outliers(OutlierMode.RemoveAll)]</code> attribute.
The old names still exist (to make sure that the changes are backward compatible), but they are marked as obsolete, and they will be removed in the future versions of the library.
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1199">#1199</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/0e4b8e69d10e73a83fce3ce3980497ee7798bc87">0e4b8e</a></li>
<li><strong>Add the possibility to pass <code>Config</code> to <code>BenchmarkSwitcher.RunAll</code> and <code>RunAllJoined</code></strong><br>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1194">#1194</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/ae23bddebe49cd66a9627790c073b7bc45ccbf5c">ae23bd</a></li>
<li><strong>Improved command line experience</strong><br>
When user uses <code>--packages $path</code>, the <code>$path</code> will be sent to the dotnet build command as well.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1187">1187</a></li>
<li><strong>Extend the list of supported power plans.</strong>
Now it supports &quot;ultimate&quot;, &quot;balanced&quot;, and &quot;power saver&quot; plans.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1132">#1132</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1139">#1139</a></li>
<li><strong>Make it possible to not enforce power plan on Windows.</strong>
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/1578c5c60c3f59f9128f680e35d1db219aa60d8d">1578c5c</a></li>
<li><strong><code>Guid</code> support in benchmark arguments</strong><br>
Now you can use <code>Guid</code> instances as benchmark arguments.
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/04ec20b5e0c0a514e8d158684864e4f9934ae8cc">04ec20b</a></li>
<li><strong>Make <code>ArgumentsSource</code> support <code>IEnumerable&lt;object[]&gt;</code> for benchmarks accepting a single argument to mimic <code>MemberData</code> behaviour.</strong><br>
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/ec296dc45de798f7407852d5ab7febe2b457eca4">ec296dc</a></li>
<li><strong>Make <code>FullNameProvider</code> public</strong><br>
So it can be reused by the <code>dotnet/performance</code> repository.
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/6d71308f4c1d96bcf8a526bfcc61bb23307b4041">6d71308</a></li>
<li><strong>Extend <code>Summary</code> with <code>LogFilePath</code></strong>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1135">#1135</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/6e6559499652c312369fd223d0cf4747f65512d6">6e6559</a></li>
<li><strong>Allow namespace filtering for <code>InliningDiagnoser</code></strong><br>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1106">#1106</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1130">#1130</a></li>
<li><strong>Option to configure <code>MaxParameterColumnWidth</code></strong><br>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1269">#1269</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/4ec88844547507474ccd0303b31f935b3463318c">4ec888</a></li>
</ul>
</li>
<li><strong>Other improvements</strong>
<ul>
<li><strong>Misc improvements in the documentation</strong><br>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1175">#1175</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1173">#1173</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1180">#1180</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1203">#1203</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1204">#1204</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1206">#1206</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1209">#1209</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1219">#1219</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1225">#1225</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1279">#1279</a></li>
<li><strong>Copy <code>PreserveCompilationContext</code> MSBuild setting from the project that defines benchmarks</strong><br>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1152">#1152</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/063d1a56152fd5812cb6e9dd5095dc6e647e6938">063d1a</a></li>
<li><strong>Add <code>System.Buffers.ArrayPoolEventSource</code> to the list of default .NET Providers of <code>EtwProfiler</code></strong><br>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1179">#1179</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/a106b114b1f04fa1024be84a8969f5a168fa1c8b">a106b1</a></li>
<li><strong>Consume CoreRT from the new NuGet feed</strong><br>
Because CoreRT no longer publishes to MyGet.
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1129">#1129</a></li>
</ul>
</li>
<li><strong>Breaking changes:</strong>
<ul>
<li>The <code>[ClrJob]</code>, <code>[CoreJob]</code> and <code>[CoreRtJob]</code> attributes got obsoleted and replaced by a <code>[SimpleJob]</code> which requires the user to provide target framework moniker in an explicit way.
(See the &quot;Advanced multiple target frameworks support&quot; section for details.)
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1188">#1188</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1182">#1182</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1115">#1115</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1056">#1056</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/993">#993</a>,</li>
<li>The old <code>InProcessToolchain</code> is now obsolete. It's recommended to use <code>InProcessEmitToolchain</code>. If you want to use the old one on purpose, you have to use <code>InProcessNoEmitToolchain</code>.
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1123">#1123</a></li>
</ul>
</li>
<li><strong>Bug fixes:</strong>
<ul>
<li>Invalid arg passing in StreamLogger constructor. The <code>append</code> arg was not passed to the <code>StreamWriter</code> .ctor.
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1185">#1185</a></li>
<li>Improve the output path of <code>.etl</code> files produced by <code>EtwProfiler</code>. <code>EtwProfiler</code> was throwing NRE for users who were using <code>[ClrJob]</code> and <code>[CoreJob]</code> attributes.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1156">#1156</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1072">#1072</a></li>
<li>Flush custom loggers at the end of benchmark session.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1134">#1134</a></li>
<li>Make ids for tag columns unique - when using multiple <code>TagColumns</code> only one <code>TagColumn</code> was printed in the results.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1146">#1146</a></li>
</ul>
</li>
</ul>
<h2 id="advanced-multiple-target-frameworks-support">Advanced multiple target frameworks support</h2>
<p>Now BenchmarkDotNet supports .NET Framework 4.8, .NET Core 3.1, and .NET Core 5.0.
Also, we reworked our API that allows targeting several runtimes from the same config:
the new API is more consistent, flexible, and powerful.
For example, if you want to execute your benchmarking using .NET Framework 4.8 and .NET Core 3.1,
you can use the <code>SimpleJob(RuntimeMoniker.Net48)</code>, <code>[SimpleJob(RuntimeMoniker.NetCoreApp31)]</code> attributes or
<code>Job.Default.With(ClrRuntime.Net48)</code>, <code>Job.Default.With(CoreRuntime.Core31)</code> jobs in a manual config.</p>
<p>Now let's discuss how to use it in detail.
If you want to test multiple frameworks, your project file <strong>MUST target all of them</strong> and you <strong>MUST install the corresponding SDKs</strong>:</p>
<pre><code class="lang-xml">&lt;TargetFrameworks&gt;netcoreapp3.0;netcoreapp2.1;net48&lt;/TargetFrameworks&gt;
</code></pre>
<p>If you run your benchmarks without specifying any custom settings, BenchmarkDotNet is going to run the benchmarks <strong>using the same framework as the host process</strong> (it corresponds to <code>RuntimeMoniker.HostProcess</code>):</p>
<pre><code class="lang-cmd">dotnet run -c Release -f netcoreapp2.1 # is going to run the benchmarks using .NET Core 2.1
dotnet run -c Release -f netcoreapp3.0 # is going to run the benchmarks using .NET Core 3.0
dotnet run -c Release -f net48         # is going to run the benchmarks using .NET 4.8
mono $pathToExe                        # is going to run the benchmarks using Mono from your PATH
</code></pre>
<p>To run the benchmarks for multiple runtimes with a single command from the command line, you need to specify the runtime moniker names via <code>--runtimes|-r</code> console argument:</p>
<pre><code class="lang-cmd">dotnet run -c Release -f netcoreapp2.1 --runtimes netcoreapp2.1 netcoreapp3.0 # is going to run the benchmarks using .NET Core 2.1 and .NET Core 3.0
dotnet run -c Release -f netcoreapp2.1 --runtimes netcoreapp2.1 net48         # is going to run the benchmarks using .NET Core 2.1 and .NET 4.8
</code></pre>
<p>What is going to happen if you provide multiple Full .NET Framework monikers?
Let's say:</p>
<pre><code class="lang-cmd">dotnet run -c Release -f net461 net472 net48
</code></pre>
<p>Full .NET Framework always runs every .NET executable using the latest .NET Framework available on a given machine.
If you try to run the benchmarks for a few .NET TFMs, they are all going to be executed using the latest .NET Framework from your machine.
The only difference is that they are all going to have different features enabled depending on the target version they were compiled for.
You can read more about this
<a href="https://learn.microsoft.com/dotnet/framework/migration-guide/version-compatibility">here</a> and
<a href="https://learn.microsoft.com/dotnet/framework/migration-guide/application-compatibility">here</a>.
This is <strong>.NET Framework behavior which can not be controlled by BenchmarkDotNet or any other tool</strong>.</p>
<p><strong>Note:</strong> Console arguments support works only if you pass the <code>args</code> to <code>BenchmarkSwitcher</code>:</p>
<pre><code class="lang-cs">class Program
{
    static void Main(string[] args) 
        =&gt; BenchmarkSwitcher
            .FromAssembly(typeof(Program).Assembly)
            .Run(args); // crucial to make it work
}
</code></pre>
<p>You can achieve the same thing using <code>[SimpleJobAttribute]</code>:</p>
<pre><code class="lang-cs">using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Jobs;

namespace BenchmarkDotNet.Samples
{
    [SimpleJob(RuntimeMoniker.Net48)]
    [SimpleJob(RuntimeMoniker.Mono)]
    [SimpleJob(RuntimeMoniker.NetCoreApp21)]
    [SimpleJob(RuntimeMoniker.NetCoreApp30)]
    public class TheClassWithBenchmarks
</code></pre>
<p>Or using a custom config:</p>
<pre><code class="lang-cs">using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;

namespace BenchmarkDotNet.Samples
{
    class Program
    {
        static void Main(string[] args)
        {
            var config = DefaultConfig.Instance
                .With(Job.Default.With(CoreRuntime.Core21))
                .With(Job.Default.With(CoreRuntime.Core30))
                .With(Job.Default.With(ClrRuntime.Net48))
                .With(Job.Default.With(MonoRuntime.Default));

            BenchmarkSwitcher
                .FromAssembly(typeof(Program).Assembly)
                .Run(args, config);
        }
    }
}
</code></pre>
<p>The recommended way of running the benchmarks for multiple runtimes is to use the <code>--runtimes</code> console line argument.
By using the console line argument, you don't need to edit the source code anytime you want to change the list of runtimes.
Moreover, if you share the source code of the benchmark, other people can run it even if they don't have the exact same framework version installed.</p>
<h2 id="official-templates-for-benchmarkdotnet-based-projects">Official templates for BenchmarkDotNet-based projects</h2>
<p>Since v0.12.0, BenchmarkDotNet provides project templates to setup your benchmarks easily.
The template exists for each major .NET language (<a href="https://learn.microsoft.com/dotnet/csharp/">C#</a>, <a href="https://learn.microsoft.com/dotnet/fsharp/">F#</a> and <a href="https://learn.microsoft.com/dotnet/visual-basic/">VB</a>) with equivalent features and structure.
The templates require the <a href="https://www.microsoft.com/net/download">.NET Core SDK</a>. Once installed, run the following command to install the templates:</p>
<pre><code class="lang-log">dotnet new -i BenchmarkDotNet.Templates
</code></pre>
<p>If you want to uninstall all BenchmarkDotNet templates:</p>
<pre><code class="lang-log">dotnet new -u BenchmarkDotNet.Templates
</code></pre>
<p>The template is a NuGet package distributed over nuget.org: <a href="https://www.nuget.org/packages/BenchmarkDotNet.Templates/">BenchmarkDotNet.Templates</a>.
To create a new C# benchmark library project from the template, run:</p>
<pre><code class="lang-log">dotnet new benchmark
</code></pre>
<p>If you'd like to create F# or VB project, you can specify project language with <code>-lang</code> option:</p>
<pre><code class="lang-log">dotnet new benchmark -lang F#
dotnet new benchmark -lang VB
</code></pre>
<p>The template projects have five additional options - all of them are optional.
By default, a class library project targeting netstandard2.0 is created.
You can specify <code>-f</code> or <code>--frameworks</code> to change target to one or more frameworks:</p>
<pre><code class="lang-log">dotnet new benchmark -f netstandard2.0;net472
</code></pre>
<p>The option <code>--console-app</code> creates a console app project targeting <code>netcoreapp3.0</code> with an entry point:</p>
<pre><code class="lang-log">dotnet new benchmark --console-app
</code></pre>
<p>This lets you run the benchmarks from a console (<code>dotnet run</code>) or from your favorite IDE.
The option <code>-f</code> or <code>--frameworks</code> will be ignored when <code>--console-app</code> is set.
The option <code>-b</code> or <code>--benchmarkName</code> sets the name of the benchmark class:</p>
<pre><code class="lang-log">dotnet new benchmark -b Md5VsSha256
</code></pre>
<p>BenchmarkDotNet lets you create a dedicated configuration class (see <a class="xref" href="../articles/configs/configs.html">Configs</a>) to customize the execution of your benchmarks.
To create a benchmark project with a configuration class, use the option <code>-c</code> or <code>--config</code>:</p>
<pre><code class="lang-log">dotnet new benchmark -c
</code></pre>
<p>The option <code>--no-restore</code> if specified, skips the automatic NuGet restore after the project is created:</p>
<pre><code class="lang-log">dotnet new benchmark --no-restore
</code></pre>
<p>Use the <code>-h</code> or <code>--help</code> option to display all possible arguments with a description and the default values:</p>
<pre><code class="lang-log">dotnet new benchmark --help
</code></pre>
<p>The version of the template NuGet package is synced with the <a href="https://www.nuget.org/packages/BenchmarkDotNet/">BenchmarkDotNet</a> package.
For instance, the template version <code>0.12.0</code> is referencing <a href="https://www.nuget.org/packages/BenchmarkDotNet/0.12.0">BenchmarkDotnet 0.12.0</a> - there is no floating version behavior.
For more info about the <code>dotnet new</code> CLI, please read <a href="https://learn.microsoft.com/dotnet/core/tools/dotnet">the documentation</a>.</p>
<h2 id="new-nativememoryprofiler">New NativeMemoryProfiler</h2>
<p><code>NativeMemoryProfiler</code> measure the native memory traffic and adds the extra columns <code>Allocated native memory</code> and <code>Native memory leak</code> to the summary table.
Internally, it uses <code>EtwProfiler</code> to profile the code using ETW.</p>
<p>Consider the following benchmark:</p>
<pre><code class="lang-cs">[ShortRunJob]
[NativeMemoryProfiler]
[MemoryDiagnoser]
public class IntroNativeMemory
{
    [Benchmark]
    public void BitmapWithLeaks()
    {
        var flag = new Bitmap(200, 100);
        var graphics = Graphics.FromImage(flag);
        var blackPen = new Pen(Color.Black, 3);
        graphics.DrawLine(blackPen, 100, 100, 500, 100);
    }

    [Benchmark]
    public void Bitmap()
    {
        using (var flag = new Bitmap(200, 100))
        {
            using (var graphics = Graphics.FromImage(flag))
            {
                using (var blackPen = new Pen(Color.Black, 3))
                {
                    graphics.DrawLine(blackPen, 100, 100, 500, 100);
                }
            }
        }
    }

    private const int Size = 20; // Greater value could cause System.OutOfMemoryException for test with memory leaks.
    private int ArraySize = Size * Marshal.SizeOf(typeof(int));

    [Benchmark]
    public unsafe void AllocHGlobal()
    {
        IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize);
        Span&lt;byte&gt; unmanaged = new Span&lt;byte&gt;(unmanagedHandle.ToPointer(), ArraySize);
        Marshal.FreeHGlobal(unmanagedHandle);
    }

    [Benchmark]
    public unsafe void AllocHGlobalWithLeaks()
    {
        IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize);
        Span&lt;byte&gt; unmanaged = new Span&lt;byte&gt;(unmanagedHandle.ToPointer(), ArraySize);
    }
}
</code></pre>
<p>It will produce the summary table like this one:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
<th style="text-align: right;">Gen 0</th>
<th style="text-align: right;">Gen 1</th>
<th style="text-align: right;">Gen 2</th>
<th style="text-align: right;">Allocated</th>
<th style="text-align: right;">Allocated native memory</th>
<th style="text-align: right;">Native memory leak</th>
</tr>
</thead>
<tbody>
<tr>
<td>BitmapWithLeaks</td>
<td style="text-align: right;">73,456.43 ns</td>
<td style="text-align: right;">22,498.10 ns</td>
<td style="text-align: right;">1,233.197 ns</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">177 B</td>
<td style="text-align: right;">13183 B</td>
<td style="text-align: right;">11615 B</td>
</tr>
<tr>
<td>Bitmap</td>
<td style="text-align: right;">91,590.08 ns</td>
<td style="text-align: right;">101,468.12 ns</td>
<td style="text-align: right;">5,561.810 ns</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">180 B</td>
<td style="text-align: right;">12624 B</td>
<td style="text-align: right;">-</td>
</tr>
<tr>
<td>AllocHGlobal</td>
<td style="text-align: right;">79.91 ns</td>
<td style="text-align: right;">43.93 ns</td>
<td style="text-align: right;">2.408 ns</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">80 B</td>
<td style="text-align: right;">-</td>
</tr>
<tr>
<td>AllocHGlobalWithLeaks</td>
<td style="text-align: right;">103.50 ns</td>
<td style="text-align: right;">153.21 ns</td>
<td style="text-align: right;">8.398 ns</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">80 B</td>
<td style="text-align: right;">80 B</td>
</tr>
</tbody>
</table>
<p>As you can see, we have two additional columns <code>Allocated native memory</code> and <code>Native memory leak</code> that contain some very useful numbers!</p>
<h2 id="new-threadingdiagnoser">New ThreadingDiagnoser</h2>
<p><code>ThreadingDiagnoser</code> also adds two extra columns to the summary table:</p>
<ul>
<li><code>Completed Work Items</code>: The number of work items that have been processed in ThreadPool (per single operation)</li>
<li><code>Lock Contentions</code>: The number of times there <strong>was contention</strong> upon trying to take a Monitor's lock (per single operation)</li>
</ul>
<p>Internally, it uses <a href="https://github.com/dotnet/corefx/issues/35500">new APIs</a> exposed in .NET Core 3.0.</p>
<p>It can be activated with the help of the <code>[ThreadingDiagnoser]</code> attribute:</p>
<pre><code class="lang-cs">[ThreadingDiagnoser]
public class IntroThreadingDiagnoser
{
    [Benchmark]
    public void CompleteOneWorkItem()
    {
        ManualResetEvent done = new ManualResetEvent(initialState: false);
        ThreadPool.QueueUserWorkItem(m =&gt; (m as ManualResetEvent).Set(), done);
        done.WaitOne();
    }
}
</code></pre>
<p>The above example will print a summary table like this one:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">StdDev</th>
<th style="text-align: right;">Median</th>
<th style="text-align: right;">Completed Work Items</th>
<th style="text-align: right;">Lock Contentions</th>
</tr>
</thead>
<tbody>
<tr>
<td>CompleteOneWorkItem</td>
<td style="text-align: right;">8,073.5519 ns</td>
<td style="text-align: right;">69.7261 ns</td>
<td style="text-align: right;">8,111.6074 ns</td>
<td style="text-align: right;">1.0000</td>
<td style="text-align: right;">-</td>
</tr>
</tbody>
</table>
<h2 id="linqpad-6-support">LINQPad 6 support</h2>
<p>Now both LINQPad 5 and LINQPad 6 are supported:</p>
<p><img src="https://user-images.githubusercontent.com/6011991/64907554-5d77b000-d6f4-11e9-9684-50ea678647eb.png" alt=""></p>
<h2 id="fast-documentation-search">Fast documentation search</h2>
<p>We continue to improve the usability of our documentation.
In this release, we improved the search experience in the documentation: now it works almost instantly with the help of <a href="https://www.algolia.com/">Algolia</a> engine!
That's how it looks:</p>
<p><img src="https://user-images.githubusercontent.com/2259237/67472874-701dc700-f65a-11e9-85f1-d4f3160f78cf.gif" alt=""></p>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: October 24, 2019</em></p>
<p><em>Milestone: <a href="https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone%3Av0.12.0">v0.12.0</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.11.5...v0.12.0">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.12.0">https://www.nuget.org/packages/BenchmarkDotNet/0.12.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.12.0">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.12.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.12.0">https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.12.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.12.0">https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.12.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.12.0">https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.12.0</a></li>
</ul>
<h1 id="benchmarkdotnet-v0115">BenchmarkDotNet v0.11.5</h1>
<h2 id="highlights">Highlights</h2>
<ul>
<li><strong>Features and noticeable improvements</strong>
<ul>
<li><strong>Power plan management</strong><br>
Now BenchmarkDotNet executes all benchmarks with enabled High-Performance power plan (configurable, Windows-only).
You can find some details below.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/68">#68</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/952">#952</a></li>
<li><strong>Better Environment Variables API</strong><br>
Now we have some additional extension methods which allow defining environment variables in user jobs.
In the previous version, users always had to set an array of environment variables like this:
<code>job.With(new[] { new EnvironmentVariable(&quot;a&quot;, &quot;b&quot;) })</code>.
Now it's possible to define an environment variable like
<code>job.With(new EnvironmentVariable(&quot;a&quot;, &quot;b&quot;))</code> or
<code>job.WithEnvironmentVariable(&quot;a&quot;, &quot;b&quot;)</code>.
Also, it's possible to clear the list of environment variables via
<code>job.WithoutEnvironmentVariables()</code>.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1069">#1069</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1080">#1080</a></li>
<li><strong>Better outlier messages</strong><br>
The previous version of BenchmarkDotNet printed information about detected or removed outliers like this:
&quot;3 outliers were detected&quot;.
It was nice, but it didn't provide additional information about these outliers
(users had to read the full log to find the outliers values).
Now BenchmarkDotNet prints additional information about outlier values like this:
&quot;3 outliers were detected (2.50 us..2.70 us)&quot;.
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/e983cd3126e64f82fe59bc1bc45d1a870a615e87">e983cd31</a></li>
<li><strong>Support modern CPU architecture names</strong><br>
In the environment information section, BenchmarkDotNet prints not only the processor brand string, but also its architecture
(e.g., &quot;Intel Core i7-4770K CPU 3.50GHz (Haswell)&quot;).
However, it failed to recognize some recent processors.
Now it's able to detect the architecture for modern Intel processors correctly
(Kaby Lake, Kaby Lake R, Kaby Lake G, Amber Lake Y, Coffee Lake, Cannon Lake, Whiskey Lake).
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/995e053d14a61cdadc417149480f23ebf679bcb7">995e053d</a></li>
<li><strong>Introduce BenchmarkDotNet.Annotations</strong><br>
Currently, BenchmarkDotNet targets .NET Standard 2.0.
It makes some users unhappy because they want to define benchmarks in projects with lower target framework.
We decided to start working on the <code>BenchmarkDotNet.Annotations</code> NuGet package which targets .NET Standard 1.0
and contains classes that users need to define their benchmarks.
However, it's not easy to refactor the full source code base and move all relevant public APIs to this package.
In v0.11.5, we did the first step and moved some of these APIs to <code>BenchmarkDotNet.Annotations</code>.
We want to continue moving classes to this package and get full-featured annotation package in the future.
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1084">#1084</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1096">#1096</a></li>
<li><strong>Use InProcessEmitToolchain by default in InProcess benchmarks</strong><br>
In BenchmarkDotNet 0.11.4, we introduced <code>InProcessEmitToolchain</code>.
It's a new, full-featured InProcess toolchain which allows executing benchmarks in the current process
without spawning additional process per benchmark.
It supports <code>[Arguments]</code>, <code>[ArgumentsSource]</code>, passing the arguments by <code>out</code>, <code>ref</code> and returning stack-only types like <code>Span&lt;T&gt;</code>.
However, in v0.11.4, it can be activated only if <code>InProcessEmitToolchain</code> is declared explicitly.
Now it's enabled by default when <code>[InProcessAttribute]</code> is used.
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1093">#1093</a></li>
<li><strong>Introduce an option which prevents overwriting results</strong><br>
Currently, BenchmarkDotNet overwrites results each time when the benchmarks are executed.
It allows avoiding tons of obsolete files in the <code>BenchmarkDotNet.Artifacts</code> folder.
However, the behavior doesn't fit all use cases:
sometimes users want to keep results for old benchmark runs.
Now we have a special option for it.
The option can be activated via <code>--noOverwrite</code> console line argument or
<code>DontOverwriteResults</code> extension method for <code>IConfig</code>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1074">#1074</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1083">#1083</a></li>
</ul>
</li>
<li><strong>Other improvements and bug fixes</strong>
<ul>
<li><strong>Diagnostics and validation</strong>
<ul>
<li><strong>Better benchmark declaration error processing</strong><br>
In the previous version, BenchmarkDotNet threw an exception when some benchmark methods had an invalid declaration
(e.g., invalid signature or invalid access modifiers).
Now it prints a nice error message without ugly stack traces.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1107">#1107</a></li>
<li><strong>Better error message for users who want to debug benchmarks</strong><br>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1073">#1073</a></li>
<li><strong>Don't show the same validation error multiple times</strong><br>
Now each error will be printed only once.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1079">#1079</a></li>
<li><strong>Restrict MemoryDiagnoserAttribute usage to class</strong><br>
Now it's impossible to accidentally mark a method with this attribute.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1119">#1119</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1122">#1122</a></li>
</ul>
</li>
<li><strong>Export</strong>
<ul>
<li><strong>Better indentation in disassembly listings</strong><br>
Now DissassemblyDiagnoser correctly process source code which contains tab as the indentation symbol
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1110">#1110</a></li>
<li><strong>Fix incorrect indentation for StackOverflow exporter</strong><br>
Previously, StackOverflow exporter doesn't have a proper indent for job runtimes in the environment information.
Now it's fixed.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/826">#826</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1104">#1104</a></li>
<li><strong>Fix StackOverflowException in XmlExporter.Full</strong><br>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1086">#1086</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1090">#1090</a></li>
<li><strong>Shortify MemoryDiagnoser column titles</strong><br>
Now we use the following column titles:
&quot;Allocated&quot; instead of &quot;Allocated Memory/Op&quot;,
&quot;Gen 0&quot; instead of &quot;Gen 0/1k Op&quot;.
The full description of each column can be found in the legend section below the summary table.
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1081">#1081</a></li>
</ul>
</li>
<li><strong>Benchmark generation and execution</strong>
<ul>
<li><strong>Fixed broken Orderers</strong><br>
The previous version has a nasty bug with custom orderers.
Now it's fixed.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1070">#1070</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1109">#1109</a></li>
<li><strong>Better overhead evaluation</strong><br>
In the previous version, BenchmarkDotNet evaluated the benchmark overhead as a mean value of all overhead iteration.
It was fine in most cases, but in some cases, the mean value can be spoiled by outliers.
Now BenchmarkDotNet uses the median value.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1116">#1116</a></li>
<li><strong>Respect CopyLocalLockFileAssemblies</strong><br>
Now BenchmarkDotNet respect the <code>CopyLocalLockFileAssemblies</code> value and copies it
to the generated benchmark project.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1068">#1068</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1108">#1108</a></li>
<li><strong>Disable CodeAnalysisRuleSet for generated benchmarks</strong><br>
Previously, generated benchmarks may fail if the <code>CodeAnalysisRuleSet</code> is defined in <code>Directory.Build.Props</code>.
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1082">#1082</a></li>
<li><strong>Supported undefined enum values</strong><br>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1020">#1020</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1071">#1071</a></li>
</ul>
</li>
<li><strong>Other minor improvements and bug fixes</strong></li>
</ul>
</li>
</ul>
<h2 id="power-plans">Power plans</h2>
<p>In <a href="https://github.com/dotnet/BenchmarkDotNet/pull/952">#952</a>, power plan management was implemented.
It resolves a pretty old issue <a href="https://github.com/dotnet/BenchmarkDotNet/issues/68">#68</a> which was created more than three years ago.
Now BenchmarkDotNet forces OS to execute a benchmark on the High-Performance power plan.
You can disable this feature by modifying PowerPlanMode property.
Here is an example where we are playing with this value:</p>
<pre><code class="lang-cs">[Config(typeof(Config))]
public class IntroPowerPlan
{
    private class Config : ManualConfig
    {
        public Config()
        {
            Add(Job.MediumRun.WithPowerPlan(PowerPlan.HighPerformance));
            Add(Job.MediumRun.WithPowerPlan(PowerPlan.UserPowerPlan));
        }
    }

    [Benchmark]
    public int IterationTest()
    {
        int j = 0;
        for (int i = 0; i &lt; short.MaxValue; ++i)
            j = i;
        return j;
    }

    [Benchmark]
    public int SplitJoin()
        =&gt; string.Join(&quot;,&quot;, new string[1000]).Split(',').Length;
}
</code></pre>
<p>And here is an example of the summary table on plugged-off laptop:</p>
<pre><code class="lang-md">        Method |       PowerPlan |     Mean |     Error |    StdDev |
-------------- |---------------- |---------:|----------:|----------:|
 IterationTest | HighPerformance | 40.80 us | 0.4168 us | 0.6109 us |
     SplitJoin | HighPerformance | 13.24 us | 0.2514 us | 0.3763 us |
 IterationTest |   UserPowerPlan | 79.72 us | 2.5623 us | 3.8352 us |
     SplitJoin |   UserPowerPlan | 24.54 us | 2.1062 us | 3.1525 us |
</code></pre>
<p>As you can see, the power plan produces a noticeable effect on the benchmark results.</p>
<p>This feature is available on Windows only.</p>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: April 2, 2019</em></p>
<p><em>Milestone: <a href="https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone%3Av0.11.5">v0.11.5</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.11.4...v0.11.5">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.11.5">https://www.nuget.org/packages/BenchmarkDotNet/0.11.5</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.5">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.5</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.11.5">https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.11.5</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.11.5">https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.11.5</a></li>
</ul>
<h1 id="benchmarkdotnet-v0114">BenchmarkDotNet v0.11.4</h1>
<p>It's been few months since our last release, but we have been working hard and have some new features for you!</p>
<h2 id="highlights">Highlights</h2>
<ul>
<li><strong>Features</strong>
<ul>
<li><strong>BenchmarkDotNet as a global tool</strong>: a new global tool which allows you to run benchmarks from given library.
Now you can run benchmarks from the command line via <code>dotnet benchmark</code>.
You can find more information about it in the documentation
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1006">#1006</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/213">#213</a></li>
<li><strong>InProcessEmitToolchain</strong>: new, full-featured InProcess toolchain which allows executing benchmarks in the current process
without spawning additional process per benchmark.
It supports <code>[Arguments]</code>, <code>[ArgumentsSource]</code>, passing the arguments by <code>out</code>, <code>ref</code> and returning stack-only types like <code>Span&lt;T&gt;</code>.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/919">#919</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/921">#921</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/843">#843</a></li>
<li><strong>ARM support</strong>: BenchmarkDotNet supports now ARM and ARM64.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/780">#780</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/979">#979</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/385">#385</a></li>
<li><strong>Mono AOT support</strong>: a new toolchain which allows running benchmarks using AOT version of Mono
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/940">#940</a></li>
<li><strong>NuGet symbol server support</strong>: BenchmarkDotNet publishes now the symbols to NuGet.org symbol server and you can easily debug it.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/967">#967</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/968">#968</a></li>
<li><strong>Experimental support for .NET Core 3.0 WPF benchmarks</strong>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1066">#1066</a>
For a working example please go to <a href="https://github.com/dotMorten/WPFBenchmarkTests">https://github.com/dotMorten/WPFBenchmarkTests</a></li>
</ul>
</li>
<li><strong>Improvements:</strong>
<ul>
<li>CoreRT Toolchain improvements - thanks to help from CoreRT Team we were able to make
the CoreRT Toolchain work with the latest version of CoreRT
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1001">#1001</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1057">#1057</a></li>
<li>Display the number of benchmarks to run: we now display how many benchmarks are going to be executed
before running them and how many remained after running each of them
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1048">#1048</a></li>
<li>Better list of suggested benchmarks for wrong filter
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/834">#834</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/957">#957</a></li>
<li>Invalid assembly binding redirects generated by VS were a pain to many of our users,
we have now implemented an approach that tries to work around this issue.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/895">#895</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/667">#667</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/896">#896</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/942">#942</a></li>
<li>Handling duplicates in IConfig
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/912">#912</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/938">#938</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/360">#360</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/463">#463</a></li>
<li>Disassembly diagnoser should be kept in a separate directory to avoid dependency conflicts
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1059">#1059</a></li>
<li>Give a warning when the <code>[Benchmark]</code> method is static - we now produce an error when users fail into this common issue
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/983">#983</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/985">#985</a></li>
<li>C# keywords are prohibited as benchmark names
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/849">#849</a></li>
<li>File names should be consistent across all OSes - <code>&lt;</code> and <code>&gt;</code> are valid on Unix, but not on Windows.
We have unified that and now files produced on Unix and Windows have the same names.
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/981">#981</a></li>
<li>Improve restore, build and publish projects
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1002">#1002</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1013">#1013</a></li>
<li>Make it possible to disable OptimizationsValidator
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/988">#988</a></li>
<li>Sort enum parameters by value instead of name
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/977">#977</a></li>
<li>Detect .NET Core benchmark failures from LINQPad
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/980">#980</a></li>
<li>Improved error logging
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1008">#1008</a></li>
<li>Improved disassembly diff
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1022">#1022</a></li>
<li>Using invariant culture for Roslyn Toolchain error messages
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1042">#1042</a></li>
<li>Use only full names in the auto-generated code to avoid any possible conflicts with user code
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1007">#1007</a>,
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1009">#1009</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1010">#1010</a></li>
<li>Write the GitHub table format to the console by default
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1062">#1062</a></li>
<li>Proper cleanup on Ctrl+C/console Window exit
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1061">#1061</a></li>
<li>Introduce StoppingCriteria - the first step to writing your own heuristic that determines when benchmarking should be stopped
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/984">#984</a></li>
</ul>
</li>
<li><strong>Breaking changes:</strong>
<ul>
<li>.NET Standard 2.0 only - BenchmarkDotNet has a single target now, which should help with some assembly resolving issues.
We had to drop .NET 4.6 support because of that and .NET 4.6.1 is now the oldest supported .NET Framework.
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1032">#1032</a></li>
<li>CustomCoreClrToolchain has been removed, it's recommended to use CoreRunToolchain instead
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/928">#928</a></li>
</ul>
</li>
<li><strong>Bug fixes:</strong>
<ul>
<li>NRE in <code>Summary</code> ctor
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/986">#986</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/987">#987</a></li>
<li>ArgumentNullException when running benchmarks from published .NET Core app
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1018">#1018</a></li>
<li>Dry jobs can eat iteration failures
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1045">#1045</a></li>
<li>NullReferenceException in BenchmarkDotNet.Reports.SummaryTable after iteration failure
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1046">#1046</a></li>
<li>Running the example throws NullReference
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1049">#1049</a></li>
<li>Fix race condition in process output reader
<a href="https://github.com/dotnet/BenchmarkDotNet/issues/1051">#1051</a>
<a href="https://github.com/dotnet/BenchmarkDotNet/pull/1053">#1053</a></li>
<li>Fix a rare but really annoying bug where for some reason we were sometimes setting ForegroundColor
to the same color as BackgroundColor and some parts of the logged output were invisible
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/ea3036810ef60b483d766a097e6f3edfde28a834">commit</a></li>
<li>StopOnFirstError must be respected
<a href="https://github.com/dotnet/BenchmarkDotNet/commit/87d281d7dbf52036819efff52e6661e436648b73">commit</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: February 15, 2019</em></p>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.11.4">v0.11.4</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.11.3...v0.11.4">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.11.4">https://www.nuget.org/packages/BenchmarkDotNet/0.11.4</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.4">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.4</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.11.4">https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.11.4</a></li>
</ul>
<h1 id="benchmarkdotnet-v0113">BenchmarkDotNet v0.11.3</h1>
<h2 id="highlights">Highlights</h2>
<p>This release is focused mainly on bug fixes that were affecting user experience. But don't worry, we have some new features too!</p>
<ul>
<li><strong>Diagnosers</strong>
<ul>
<li>ConcurrencyVisualizerProfiler (allows profiling benchmarks on Windows and exporting the data to a trace file which can be opened with Concurrency Visualizer)</li>
</ul>
</li>
<li><strong>Command-line:</strong>
<ul>
<li><code>--stopOnFirstError</code>: Stops the benchmarks execution on first error. <a href="https://github.com/dotnet/BenchmarkDotNet/pull/947">#947</a></li>
<li><code>--statisticalTest</code>: Performs a Mann–Whitney Statistical Test for identifying regressions and improvements. <a href="https://github.com/dotnet/BenchmarkDotNet/pull/960">#960</a></li>
</ul>
</li>
<li><strong>Bug fixes:</strong>
<ul>
<li>Dry mode doesn't work because of the ZeroMeasurementHelper <a href="https://github.com/dotnet/BenchmarkDotNet/issues/943">#943</a></li>
<li>MannWhitneyTest fails when comparing statistics of different sample size <a href="https://github.com/dotnet/BenchmarkDotNet/issues/948">#948</a> and <a href="https://github.com/dotnet/BenchmarkDotNet/issues/950">#950</a></li>
<li>Improve the dynamic loading of Diagnostics package <a href="https://github.com/dotnet/BenchmarkDotNet/issues/955">#955</a></li>
<li>BenchmarkRunner.RunUrl throws NRE when Config is not provided <a href="https://github.com/dotnet/BenchmarkDotNet/issues/961">#961</a></li>
<li>Don't require the users to do manual installation of TraceEvent when using Diagnostics package <a href="https://github.com/dotnet/BenchmarkDotNet/issues/962">#962</a></li>
<li>Stop benchmark after closing application + Flush log after stopping benchmark <a href="https://github.com/dotnet/BenchmarkDotNet/issues/963">#963</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="diagnosers">Diagnosers</h2>
<h3 id="concurrencyvisualizerprofiler">ConcurrencyVisualizerProfiler</h3>
<p><code>ConcurrencyVisualizerProfiler</code> allows to profile the benchmarked .NET code on Windows and exports the data to a CVTrace file which can be opened with <a href="https://learn.microsoft.com/visualstudio/profiling/concurrency-visualizer">Concurrency Visualizer</a>.</p>
<p><code>ConcurrencyVisualizerProfiler</code> uses <code>EtwProfiler</code> to get a <code>.etl</code> file which still can be opened with <a href="https://github.com/Microsoft/perfview">PerfView</a> or <a href="https://learn.microsoft.com/windows-hardware/test/wpt/windows-performance-analyzer">Windows Performance Analyzer</a>. The difference is that it also enables all Task and Thread related ETW Providers and exports a simple <code>xml</code> which can be opened with Visual Studio if you install <a href="https://marketplace.visualstudio.com/items?itemName=Diagnostics.ConcurrencyVisualizer2017">Concurrency Visualizer plugin</a></p>
<p><img src="https://user-images.githubusercontent.com/6011991/48638184-2b13fe00-e9d0-11e8-8a94-0e951e4606ae.png" alt="open trace"></p>
<p><img src="https://user-images.githubusercontent.com/6011991/48638108-f6a04200-e9cf-11e8-8f7c-feda0a99138c.png" alt="Utilization"></p>
<p><img src="https://user-images.githubusercontent.com/6011991/48638120-fb64f600-e9cf-11e8-9e2d-53b615bfe9a8.png" alt="Threads"></p>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/964">#964</a> Concurrency Visualizer Profiler Diagnoser (by <a href="https://github.com/adamsitnik">@adamsitnik</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/dfb3c8912505799a76b0eb5ae0c082bb44599fa7">dfb3c89</a> ConcurrencyVisualizerProfiler diagnoser! (by <a href="https://github.com/adamsitnik">@adamsitnik</a>)</li>
</ul>
<hr>
<h2 id="command-line">Command-line</h2>
<p>In this release, we have some new command-line arguments!</p>
<h3 id="--stoponfirsterror--stops-the-benchmarks-execution-on-first-error"><code>--stopOnFirstError</code>:  Stops the benchmarks execution on first error</h3>
<p>When provided, BenchmarkDotNet is going to stop the benchmarks execution on first error.</p>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/947">#947</a> Add option to stop running when the first benchmark fails (by <a href="https://github.com/wojtpl2">@wojtpl2</a>)</li>
</ul>
<h3 id="--statisticaltest-statistical-test"><code>--statisticalTest</code>: Statistical Test</h3>
<p>To perform a Mann–Whitney U Test and display the results in a dedicated column you need to provide the Threshold via
<code>--statisticalTest</code>. Examples: 5%, 10ms, 100ns, 1s.</p>
<p>Example: run Mann–Whitney U test with relative ratio of 1% for all benchmarks for .NET 4.6 (base), .NET Core 2.0  and .NET Core 2.1.</p>
<pre><code class="lang-cs">class Program
{
    static void Main(string[] args) =&gt; BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args);
}

public class MySample
{
    [Benchmark]
    public void Sleep()
    {
#if NETFRAMEWORK
        Thread.Sleep(50);
#elif NETCOREAPP2_0
        Thread.Sleep(45);
#elif NETCOREAPP2_1
        Thread.Sleep(55);
#endif
    }
    
    [Benchmark]
    public void Same() =&gt; Thread.Sleep(50);
}
</code></pre>
<pre><code class="lang-log">dotnet run -c Release -f netcoreapp2.1 --filter * --runtimes net46 netcoreapp2.0 netcoreapp2.1 --statisticalTest 1%
</code></pre>
<p><strong>Note:</strong> .NET 4.6 will be our baseline because it was provided as first on the runtimes list.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Runtime</th>
<th>Toolchain</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
<th style="text-align: right;">Ratio</th>
<th>MannWhitney(1%)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sleep</td>
<td>Clr</td>
<td>net46</td>
<td style="text-align: right;">50.51 ms</td>
<td style="text-align: right;">0.1833 ms</td>
<td style="text-align: right;">0.1714 ms</td>
<td style="text-align: right;">1.00</td>
<td>Base</td>
</tr>
<tr>
<td>Sleep</td>
<td>Core</td>
<td>netcoreapp2.0</td>
<td style="text-align: right;">45.53 ms</td>
<td style="text-align: right;">0.1262 ms</td>
<td style="text-align: right;">0.1181 ms</td>
<td style="text-align: right;">0.90</td>
<td>Faster</td>
</tr>
<tr>
<td>Sleep</td>
<td>Core</td>
<td>netcoreapp2.1</td>
<td style="text-align: right;">55.50 ms</td>
<td style="text-align: right;">0.1217 ms</td>
<td style="text-align: right;">0.1138 ms</td>
<td style="text-align: right;">1.10</td>
<td>Slower</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td style="text-align: right;"></td>
<td></td>
</tr>
<tr>
<td>Same</td>
<td>Clr</td>
<td>net46</td>
<td style="text-align: right;">50.47 ms</td>
<td style="text-align: right;">0.1795 ms</td>
<td style="text-align: right;">0.1679 ms</td>
<td style="text-align: right;">1.00</td>
<td>Base</td>
</tr>
<tr>
<td>Same</td>
<td>Core</td>
<td>netcoreapp2.0</td>
<td style="text-align: right;">50.55 ms</td>
<td style="text-align: right;">0.1873 ms</td>
<td style="text-align: right;">0.1752 ms</td>
<td style="text-align: right;">1.00</td>
<td>Same</td>
</tr>
<tr>
<td>Same</td>
<td>Core</td>
<td>netcoreapp2.1</td>
<td style="text-align: right;">50.55 ms</td>
<td style="text-align: right;">0.2162 ms</td>
<td style="text-align: right;">0.2022 ms</td>
<td style="text-align: right;">1.00</td>
<td>Same</td>
</tr>
</tbody>
</table>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: November 20, 2018</em></p>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.11.3">v0.11.3</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.11.2...v0.11.3">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.11.3">https://www.nuget.org/packages/BenchmarkDotNet/0.11.3</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.3">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.3</a></li>
</ul>
<h1 id="benchmarkdotnet-v0112">BenchmarkDotNet v0.11.2</h1>
<p>This release includes many PRs from the Hacktoberfest.
We are very grateful to all the contributors who spent their time to help us make BenchmarkDotNet even better!</p>
<h2 id="highlights">Highlights</h2>
<p>In this release, we have many improvements in different areas:</p>
<ul>
<li><strong>Diagnosers</strong>
<ul>
<li>EtwProfiler (allows profiling benchmarks on Windows and exporting the data to a trace file)</li>
</ul>
</li>
<li><strong>Execution:</strong>
<ul>
<li>Comparing NuGet packages (now it's possible to compare different versions of the same package)</li>
<li>.NET Core 3.0 support</li>
<li>Deferred Execution Validator</li>
</ul>
</li>
<li><strong>Command-line:</strong>
<ul>
<li><code>--list</code>: List of benchmarks</li>
<li><code>--info</code>: Print environment info</li>
<li><code>--runtimes</code>: Choosing execution runtimes (<code>--runtimes net472 netcoreapp2.1</code> will executed a benchmark on .NET 4.7.2 and .NET Core 2.1)</li>
<li>Options for number of invocations and iterations</li>
<li>Custom default settings for console argument parser</li>
<li>Case-insensitive filter</li>
<li>Benchmarking with different CoreRun instances</li>
<li>Hardware counters command-line support</li>
</ul>
</li>
<li><strong>Exporters:</strong>
<ul>
<li>Markdown output for DisassemblyDiagnoser</li>
<li>Diff view for disassembler output</li>
<li>Improved LINQPad support (colored monospaced logs)</li>
<li>Better CPU brand strings</li>
</ul>
</li>
<li><strong>Attributes:</strong>
<ul>
<li>Async <code>[GlobalSetup]</code> and <code>[GlobalCleanup]</code> support</li>
<li>Introduced <code>[ParamsAllValues]</code></li>
<li>Selecting Baseline across Methods and Jobs</li>
</ul>
</li>
<li><strong>Statistics:</strong>
<ul>
<li>Better statistical tests (Welch's t-test and Mann-Whitney U-test)</li>
<li>ZeroMeasurementAnalyser</li>
<li>RatioColumn</li>
</ul>
</li>
<li><strong>Other:</strong>
<ul>
<li>Azure Pipelines support for internal builds</li>
<li>Many minor bug fixes</li>
<li>Improved documentation</li>
<li>New tests</li>
</ul>
</li>
</ul>
<hr>
<h2 id="diagnosers">Diagnosers</h2>
<h3 id="etwprofiler">EtwProfiler</h3>
<p><code>EtwProfiler</code> allows to profile the benchmarked .NET code on Windows and exports the data to a trace file which can be opened with <a href="https://github.com/Microsoft/perfview">PerfView</a> or <a href="https://learn.microsoft.com/windows-hardware/test/wpt/windows-performance-analyzer">Windows Performance Analyzer</a>.</p>
<p><code>EtwProfiler</code> uses <code>TraceEvent</code> library which internally uses Event Tracing for Windows (ETW) to capture stack traces and important .NET Runtime events.
Before the process with benchmarked code is started, EtwProfiler starts User and Kernel ETW sessions. Every session writes data to it's own file and captures different data. User session listens for the .NET Runtime events (GC, JIT etc) while the Kernel session gets CPU stacks and Hardware Counter events. After this, the process with benchmarked code is started. During the benchmark execution all the data is captured and written to a trace file. Moreover, BenchmarkDotNet Engine emits it's own events to be able to differentiate jitting, warmup, pilot and actual workload when analyzing the trace file. When the benchmarking is over, both sessions are closed and the two trace files are merged into one.</p>
<p><img src="https://adamsitnik.com/images/etwprofiler/flamegraph.png" alt=""></p>
<p>You can find more details
in the <a class="xref" href="../articles/features/etwprofiler.html">documentation</a> and
in the <a href="https://adamsitnik.com/ETW-Profiler/">blog post</a> by Adam Sitnik.</p>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/878">#878</a> EtwProfiler Diagnoser (by <a href="https://github.com/adamsitnik">@adamsitnik</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/04a71586206a822bca56f0abdacefdc2e5fc1b01">04a715</a> EtwProfiler Diagnoser (#878) (by <a href="https://github.com/adamsitnik">@adamsitnik</a>)</li>
</ul>
<hr>
<h2 id="execution">Execution</h2>
<h3 id="comparing-nuget-packages">Comparing NuGet packages</h3>
<p>Now it's possible to compare performance of several versions of the same NuGet package.
An example:</p>
<pre><code class="lang-cs">[Config(typeof(Config))]
public class IntroNuGet
{
  // Specify jobs with different versions of the same NuGet package to benchmark.
  // The NuGet versions referenced on these jobs must be greater or equal to the
  // same NuGet version referenced in this benchmark project.
  // Example: This benchmark project references Newtonsoft.Json 9.0.1
  private class Config : ManualConfig
  {
    public Config()
    {
      var baseJob = Job.MediumRun.With(CsProjCoreToolchain.Current.Value);
      Add(baseJob.WithNuGet(&quot;Newtonsoft.Json&quot;, &quot;11.0.2&quot;).WithId(&quot;11.0.2&quot;));
      Add(baseJob.WithNuGet(&quot;Newtonsoft.Json&quot;, &quot;11.0.1&quot;).WithId(&quot;11.0.1&quot;));
      Add(baseJob.WithNuGet(&quot;Newtonsoft.Json&quot;, &quot;10.0.3&quot;).WithId(&quot;10.0.3&quot;));
      Add(baseJob.WithNuGet(&quot;Newtonsoft.Json&quot;, &quot;10.0.2&quot;).WithId(&quot;10.0.2&quot;));
      Add(baseJob.WithNuGet(&quot;Newtonsoft.Json&quot;, &quot;10.0.1&quot;).WithId(&quot;10.0.1&quot;));
      Add(baseJob.WithNuGet(&quot;Newtonsoft.Json&quot;, &quot;9.0.1&quot;).WithId(&quot;9.0.1&quot;));
    }
  }
  
  [Benchmark]
  public void SerializeAnonymousObject()
    =&gt; JsonConvert.SerializeObject(
      new { hello = &quot;world&quot;, price = 1.99, now = DateTime.UtcNow });
}
</code></pre>
<p>See also: <a class="xref" href="../articles/samples/IntroNuGet.html">BenchmarkDotNet.Samples.IntroNuGet</a></p>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/290">#290</a> Question: Any official way to benchmark same method between different assembly versions?</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/931">#931</a> Same NuGet version used when benchmarking different packages</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/922">#922</a> Enables benchmarking betweeen different Nuget packages (by <a href="https://github.com/Shazwazza">@Shazwazza</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/932">#932</a> Partition benchmark run info based on added nuget packages (by <a href="https://github.com/blairconrad">@blairconrad</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/92a7869aaa30aeacaf1da2dcc45bc65c8333ae73">92a786</a> Enables benchmarking betweeen different Nuget packages (#922) fixes #290 (by <a href="https://github.com/Shazwazza">@Shazwazza</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/510685f48ce2baf57682aa82e18c6486989e9625">510685</a> Partition benchmark run info based on added nuget packages (#932) (by <a href="https://github.com/blairconrad">@blairconrad</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/cf84a44d108d5bf3860129e0a2a78cace9c95626">cf84a4</a> NuGet casing fix (by <a href="https://github.com/AndreyAkinshin">@AndreyAkinshin</a>)</li>
</ul>
<h3 id="net-core-30-support">.NET Core 3.0 support</h3>
<p>Now it's possible to run benchmarks on preview versions of .NET Core 3.0.</p>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/874">#874</a> .NET Core 3.0 support (assignee: <a href="https://github.com/adamsitnik">@adamsitnik</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/2e398c89561b3b1c89ec64b94f656ae20236efd1">2e398c</a> detect .NET Core 3.0 and use the appropriate target framework moniker, fixes ... (by <a href="https://github.com/adamsitnik">@adamsitnik</a>)</li>
</ul>
<h3 id="deferred-execution-validator">Deferred Execution Validator</h3>
<p>In LINQ, execution of a query is usually <a href="https://learn.microsoft.com/dotnet/standard/linq/deferred-execution-example">deferred</a> until the moment when you actually request the data. If your benchmark just returns <code>IEnumerable</code> or <code>IQueryable</code> it's not measuring the execution of the query, just the creation.</p>
<p>This is why we decided to warn you about this issue whenever it happens:</p>
<pre><code class="lang-log">Benchmark IntroDeferredExecution.Wrong returns a deferred execution result (IEnumerable&lt;Int32&gt;). You need to either change the method declaration to return a materialized result or consume it on your own. You can use .Consume() extension method to do that.
</code></pre>
<p>Don't worry! We are also providing you with a <code>Consume</code> extension method which can execute given <code>IEnumerable</code> or <code>IQueryable</code> and consume its results. All you need to do is to create a <a class="xref" href="../api/BenchmarkDotNet.Engines.Consumer.html"><code>Consumer</code></a> instance, preferably store it in a field (to exclude the cost of creating Consumer from the benchmark itself) and pass it to <code>Consume</code> extension method.</p>
<p><strong>Do not call <code>.ToArray()</code> because it's an expensive operation and it might dominate given benchmark!</strong></p>
<p>See also: <a class="xref" href="../articles/samples/IntroDeferredExecution.html">BenchmarkDotNet.Samples.IntroDeferredExecution</a></p>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/858">#858</a> Should the Engine iterate over and consume IEnumerable and IQueryable results? (assignee: <a href="https://github.com/adamsitnik">@adamsitnik</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/cebe2a0f84fa21acb6db9613fe3a4326d635f129">cebe2a</a> Deferred Execution Validator, fixes #858 (by <a href="https://github.com/adamsitnik">@adamsitnik</a>)</li>
</ul>
<hr>
<h2 id="command-line">Command-line</h2>
<p>In this release, we have tons of improvements for command-line experience.</p>
<h3 id="--list-list-of-benchmarks"><code>--list</code>: List of benchmarks</h3>
<p>The <code>--list</code> allows you to print all of the available benchmark names. Available options are:</p>
<ul>
<li><code>flat</code> - prints list of the available benchmarks: <code>--list flat</code></li>
</ul>
<pre><code class="lang-ini">BenchmarkDotNet.Samples.Algo_Md5VsSha256.Md5
BenchmarkDotNet.Samples.Algo_Md5VsSha256.Sha256
BenchmarkDotNet.Samples.IntroArguments.Benchmark
BenchmarkDotNet.Samples.IntroArgumentsSource.SingleArgument
BenchmarkDotNet.Samples.IntroArgumentsSource.ManyArguments
BenchmarkDotNet.Samples.IntroArrayParam.ArrayIndexOf
BenchmarkDotNet.Samples.IntroArrayParam.ManualIndexOf
BenchmarkDotNet.Samples.IntroBasic.Sleep
[...]
</code></pre>
<ul>
<li><code>tree</code> - prints tree of the available benchmarks: <code>--list tree</code></li>
</ul>
<pre><code class="lang-ini">BenchmarkDotNet
 └─Samples
    ├─Algo_Md5VsSha256
    │  ├─Md5
    │  └─Sha256
    ├─IntroArguments
    │  └─Benchmark
    ├─IntroArgumentsSource
    │  ├─SingleArgument
    │  └─ManyArguments
    ├─IntroArrayParam
    │  ├─ArrayIndexOf
    │  └─ManualIndexOf
    ├─IntroBasic
    │  ├─Sleep
[...]
</code></pre>
<p>The <code>--list</code> option works with the <code>--filter</code> option. Examples:</p>
<ul>
<li><code>--list flat --filter *IntroSetupCleanup*</code> prints:</li>
</ul>
<pre><code class="lang-ini">BenchmarkDotNet.Samples.IntroSetupCleanupGlobal.Logic
BenchmarkDotNet.Samples.IntroSetupCleanupIteration.Benchmark
BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkA
BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkB
BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkC
BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkD
</code></pre>
<ul>
<li><code>--list tree --filter *IntroSetupCleanup*</code> prints:</li>
</ul>
<pre><code class="lang-ini">BenchmarkDotNet
 └─Samples
    ├─IntroSetupCleanupGlobal
    │  └─Logic
    ├─IntroSetupCleanupIteration
    │  └─Benchmark
    └─IntroSetupCleanupTarget
       ├─BenchmarkA
       ├─BenchmarkB
       ├─BenchmarkC
       └─BenchmarkD
</code></pre>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/905">#905</a> Implement <code>--list</code></li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/914">#914</a> Implement <code>--list</code> - fixes #905 (by <a href="https://github.com/wojtpl2">@wojtpl2</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/916">#916</a> Update console-args.md - add information about <code>--list</code> option (by <a href="https://github.com/wojtpl2">@wojtpl2</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/330f66c3a3d94d1369d5c0b629bbb0085d5db8eb">330f66</a> Implement <code>--list</code> - fixes #905 (#914) (by <a href="https://github.com/wojtpl2">@wojtpl2</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/6c7521d4fd6776098667944321c8a65848382ae5">6c7521</a> Update console-args.md - add information about <code>--list</code> option (#916) (by <a href="https://github.com/wojtpl2">@wojtpl2</a>)</li>
</ul>
<h3 id="--info-print-environment-info"><code>--info</code>: Print environment info</h3>
<p>Some of our users really like the info we print about hardware and OS.
Now we have the <code>--info</code> console line argument which does not run the benchmarks, but simply prints the info.</p>
<pre><code class="lang-ini">BenchmarkDotNet=v0.11.1.786-nightly, OS=Windows 10.0.17134.285 (1803/April2018Update/Redstone4)
Intel Xeon CPU E5-1650 v4 3.60GHz, 1 CPU, 12 logical and 6 physical cores
Frequency=3507500 Hz, Resolution=285.1033 ns, Timer=TSC
.NET Core SDK=3.0.100-alpha1-009642
  [Host] : .NET Core 3.0.0-preview1-27004-04 (CoreCLR 4.6.27003.04, CoreFX 4.6.27003.02), 64bit RyuJIT
</code></pre>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/904">#904</a> Implement <code>--info</code></li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/907">#907</a> fixes #904 Implement <code>--info</code> (by <a href="https://github.com/lahma">@lahma</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/4be28d25fa9ab79ca194c615783148042738bdad">4be28d</a> fixes #904 Implement <code>--info</code> (#907) (by <a href="https://github.com/lahma">@lahma</a>)</li>
</ul>
<h3 id="--runtimes-choosing-execution-runtimes"><code>--runtimes</code>: Choosing execution runtimes</h3>
<p>The <code>--runtimes</code> or just <code>-r</code> allows you to run the benchmarks for selected Runtimes. Available options are: Mono, CoreRT, Core, Clr net46, net461, net462, net47, net471, net472, netcoreapp2.0, netcoreapp2.1, netcoreapp2.2, netcoreapp3.0.</p>
<p>Example: run the benchmarks for .NET 4.7.2 and .NET Core 2.1:</p>
<pre><code class="lang-log">dotnet run -c Release -- --runtimes net472 netcoreapp2.1
</code></pre>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/913">#913</a> .NET Core Toolchains improvements (by <a href="https://github.com/adamsitnik">@adamsitnik</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/0f721c8e0e100fc951a54b6045eb7b58c55c2a1f">0f721c</a> make it possible to specify runtimes using explicit tfms like net472 or netco... (by <a href="https://github.com/adamsitnik">@adamsitnik</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/1c581e5bf5b4ba9f40d113ae09e0731a60523a60">1c581e</a> .NET Core Toolchains improvements (#913) (by <a href="https://github.com/adamsitnik">@adamsitnik</a>)</li>
</ul>
<h3 id="options-for-number-of-invocations-and-iterations">Options for number of invocations and iterations</h3>
<ul>
<li><code>--launchCount</code> - how many times we should launch process with target benchmark. The default is 1.</li>
<li><code>--warmupCount</code> - how many warmup iterations should be performed. If you set it, the minWarmupCount and maxWarmupCount are ignored. By default calculated by the heuristic.</li>
<li><code>--minWarmupCount</code> - minimum count of warmup iterations that should be performed. The default is 6.</li>
<li><code>--maxWarmupCount</code> - maximum count of warmup iterations that should be performed. The default is 50.</li>
<li><code>--iterationTime</code> - desired time of execution of an iteration. Used by Pilot stage to estimate the number of invocations per iteration. 500ms by default.</li>
<li><code>--iterationCount</code> - how many target iterations should be performed. By default calculated by the heuristic.</li>
<li><code>--minIterationCount</code> - minimum number of iterations to run. The default is 15.</li>
<li><code>--maxIterationCount</code> - maximum number of iterations to run. The default is 100.</li>
<li><code>--invocationCount</code> - invocation count in a single iteration. By default calculated by the heuristic.</li>
<li><code>--unrollFactor</code> - how many times the benchmark method will be invoked per one iteration of a generated loop. 16 by default</li>
<li><code>--runOncePerIteration</code> - run the benchmark exactly once per iteration. False by default.</li>
</ul>
<p>Example: run single warmup iteration, from 9 to 12 actual workload iterations.</p>
<pre><code class="lang-log">dotnet run -c Release -- --warmupCount 1 --minIterationCount 9 --maxIterationCount 12
</code></pre>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/902">#902</a> More command line args (by <a href="https://github.com/adamsitnik">@adamsitnik</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/ba0d22b41fd25022e3a945fe5ef1ae8aea697cf7">ba0d22</a> allow to configure the number of invocations and iterations from command line (by <a href="https://github.com/adamsitnik">@adamsitnik</a>)</li>
</ul>
<h3 id="custom-default-settings-for-console-argument-parser">Custom default settings for console argument parser</h3>
<p>If you want to have a possibility to specify custom default Job settings programmatically and optionally overwrite it with console line arguments, then you should create a global config with single job marked as <code>.AsDefault</code> and pass it to <code>BenchmarkSwitcher</code> together with the console line arguments.</p>
<p>Example: run single warmup iteration by default.</p>
<pre><code class="lang-cs">static void Main(string[] args)
    =&gt; BenchmarkSwitcher
        .FromAssembly(typeof(Program).Assembly)
        .Run(args, GetGlobalConfig());

static IConfig GetGlobalConfig()
    =&gt; DefaultConfig.Instance
        .With(Job.Default
            .WithWarmupCount(1)
            .AsDefault()); // the KEY to get it working
</code></pre>
<p>Now, the default settings are: <code>WarmupCount=1</code> but you might still overwrite it from console args like in the example below:</p>
<pre><code class="lang-log">dotnet run -c Release -- --warmupCount 2
</code></pre>
<h3 id="case-insensitive-filter">Case-insensitive filter</h3>
<p>The <code>--filter</code> or just <code>-f</code> allows you to filter the benchmarks by their full name (<code>namespace.typeName.methodName</code>) using glob patterns.</p>
<p>Examples:</p>
<ol>
<li>Run all benchmarks from System.Memory namespace: <code>-f System.Memory*</code></li>
<li>Run all benchmarks: <code>-f *</code></li>
<li>Run all benchmarks from ClassA and ClassB <code>-f *ClassA* *ClassB*</code></li>
</ol>
<p>Now this filter expression is case-insensitive.</p>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/864">#864</a> Make the filter case insensitive (assignee: <a href="https://github.com/adamsitnik">@adamsitnik</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/106777f7f575a8535f16292f1de80e8ffba2853a">106777</a> make the filter case insensitive invariant culture, fixes #864 (by <a href="https://github.com/adamsitnik">@adamsitnik</a>)</li>
</ul>
<h3 id="benchmarking-with-different-corerun-instances">Benchmarking with different CoreRun instances</h3>
<p>CoreRun is a simpler version of <code>dotnet run</code>, used for developing CoreCLR and CoreFX.</p>
<p>Typically when working on the performance of .NET Core a developer has more than 1 copy of CoreRun.
Example: CoreRun before my changes, and after my changes.
This change allows to simply run same benchmark for few different CoreRuns to compare the perf in easy way.</p>
<p>Sample usage:</p>
<pre><code class="lang-log">dotnet run -c Release -f netcoreapp2.1 -- -f *Empty.method --job dry --coreRun
C:\Projects\coreclr_upstream\bin\tests\Windows_NT.x64.Release\Tests\Core_Root\CoreRun.exe
C:\Projects\coreclr_upstream\bin\tests\Windows_NT.x64.Release\Tests\Core_Root_beforeMyChanges\CoreRun.exe
</code></pre>
<p>Sample output:</p>
<p><img src="https://user-images.githubusercontent.com/6011991/47417561-860f5800-d778-11e8-8dc6-b4e3586a9c90.png" alt="image"></p>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/925">#925</a> Make it possible to run the benchmark with multiple CoreRun.exe (assignee: <a href="https://github.com/adamsitnik">@adamsitnik</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/90161654725efd5639e0190638a3383d6a49e34c">901616</a> when user provides CoreRun path and runtime in explicit way, we should use th... (by <a href="https://github.com/adamsitnik">@adamsitnik</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/46bebf1497d4e9314c6dfd2d4e10df81332aa4fa">46bebf</a> allow the users to run the same benchmarks using few different CoreRun.exe, f... (by <a href="https://github.com/adamsitnik">@adamsitnik</a>)</li>
</ul>
<h3 id="hardware-counters-command-line-support">Hardware counters command-line support</h3>
<pre><code class="lang-log">--counters CacheMisses+InstructionRetired
</code></pre>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/1e3df74b2f927f541bed723f65c2d571fa850c53">1e3df7</a> make it possible to specify hardware counters from command line (by <a href="https://github.com/adamsitnik">@adamsitnik</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/a4f91a392675e4851a785095af162b977d249ba3">a4f91a</a> better handling of edge cases for parsing hardware counters from the console ... (by <a href="https://github.com/adamsitnik">@adamsitnik</a>)</li>
</ul>
<hr>
<h2 id="exporters">Exporters</h2>
<h3 id="markdown-output-for-disassemblydiagnoser">Markdown output for DisassemblyDiagnoser</h3>
<p>Now <code>DisassemblyDiagnoser</code> generates markdown version of the assembly listing.</p>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/560">#560</a> Suggestion: markdown output for DisassemblyDiagnoser (assignee: <a href="https://github.com/adamsitnik">@adamsitnik</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/1e62355f209a25c7a33f9ab7e7e03b0afe7d851f">1e6235</a> github markdown exporter for Disassembler, fixes #560 (by <a href="https://github.com/adamsitnik">@adamsitnik</a>)</li>
</ul>
<h3 id="diff-view-for-disassembler-output">Diff view for disassembler output</h3>
<p>Now we have <code>PrettyGithubMarkdownDiffDisassemblyExporter</code> which can generates
nice diffs between assembly listings.
This mode can be activated via the <code>--disasmDiff</code> command line argument or
the <code>printDiff: true</code> argument of <code>DisassemblyDiagnoserConfig</code>.
An output example (Diff between SumLocal and SumField on .NET Core 2.1.4 (CoreCLR 4.6.26814.03, CoreFX 4.6.26814.02), 64bit RyuJIT)</p>
<pre><code class="lang-diff">-; BenchmarkDotNet.Samples.IntroDisassemblyRyuJit.SumLocal()
-                   var local = field; // we use local variable that points to the field
-            ^^^^^^^^^^^^^^^^^^
-       mov     rax,qword ptr [rcx+8]
+; BenchmarkDotNet.Samples.IntroDisassemblyRyuJit.SumField()
                    int sum = 0;
             ^^^^^^^^^^^^
-       xor     edx,edx
-                   for (int i = 0; i &lt; local.Length; i++)
+       xor     eax,eax
+                   for (int i = 0; i &lt; field.Length; i++)
                  ^^^^^^^^^
-       xor     ecx,ecx
-                   for (int i = 0; i &lt; local.Length; i++)
+       xor     edx,edx
+                   for (int i = 0; i &lt; field.Length; i++)
                             ^^^^^^^^^^^^^^^^
-       mov     r8d,dword ptr [rax+8]
-       test    r8d,r8d
+       mov     rcx,qword ptr [rcx+8]
+       cmp     dword ptr [rcx+8],0
        jle     M00_L01
-                       sum += local[i];
+                       sum += field[i];
                 ^^^^^^^^^^^^^^^^
 M00_L00:
-       movsxd  r9,ecx
-       add     edx,dword ptr [rax+r9*4+10h]
-                   for (int i = 0; i &lt; local.Length; i++)
+       mov     r8,rcx
+       cmp     edx,dword ptr [r8+8]
+       jae     00007ff9`0c412c1f
+       movsxd  r9,edx
+       add     eax,dword ptr [r8+r9*4+10h]
+                   for (int i = 0; i &lt; field.Length; i++)
                                               ^^^
-       inc     ecx
-       cmp     r8d,ecx
+       inc     edx
+       cmp     dword ptr [rcx+8],edx
        jg      M00_L00
                    return sum;
             ^^^^^^^^^^^
 M00_L01:
-       mov     eax,edx
-; Total bytes of code 34
+       add     rsp,28h
+; Total bytes of code 42
</code></pre>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/544">#544</a> Diff view for disassembler output (assignee: <a href="https://github.com/wojtpl2">@wojtpl2</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/927">#927</a> Improve Disassembly exporters and add PrettyGithubMarkdownDiffDisassemblyExporter (by <a href="https://github.com/wojtpl2">@wojtpl2</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/936">#936</a> Producing the asm diff reports on demand</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/937">#937</a> Producing the asm diff reports on demand - fix for #936 (by <a href="https://github.com/wojtpl2">@wojtpl2</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/1903a1bd96d207ed51611d1dc546920f5bfb0d86">1903a1</a> Improve Disassembly exporters and add PrettyGithubMarkdownDiffDisassemblyExpo... (by <a href="https://github.com/wojtpl2">@wojtpl2</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/dd103b60a4af0d3b9e7efb523c0923e7cbd8b62d">dd103b</a> Producing the asm diff reports on demand - fixes #936 (#937) (by <a href="https://github.com/wojtpl2">@wojtpl2</a>)</li>
</ul>
<h3 id="improved-linqpad-support">Improved LINQPad support</h3>
<p>If you run BenchmarkDotNet v0.11.2+ in LINQPad, your logs will be colored and monospaced:</p>
<p><img src="https://user-images.githubusercontent.com/2259237/47839043-4ec92880-ddc2-11e8-838d-960f6d5449e5.png" alt="linqpad"></p>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/447">#447</a> Implement ColoredLogger for LinqPad</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/903">#903</a> Add LINQPad logging (by <a href="https://github.com/bgrainger">@bgrainger</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/915">#915</a> Use a monospaced font for LINQPad logging output (by <a href="https://github.com/bgrainger">@bgrainger</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/c3b6095b933b132c1773ced3af126f282465b980">c3b609</a> Add LINQPad logging (#903) (by <a href="https://github.com/bgrainger">@bgrainger</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/10fdd0998b46c4358f6fa38aacc21e57a7730724">10fdd0</a> Use a monospaced font for LINQPad logging output. (#915) (by <a href="https://github.com/bgrainger">@bgrainger</a>)</li>
</ul>
<h3 id="better-cpu-brand-strings">Better CPU brand strings</h3>
<p>We did a lot of changes which improve the presentation form of the CPU brand string.
Here is an example of such string in the previous version of BenchmarkDotNet:</p>
<pre><code class="lang-log">AMD Ryzen 7 2700X Eight-Core Processor (Max: 4.10GHz), 1 CPU, 16 logical and 8 physical cores
</code></pre>
<p>Now it becomes:</p>
<pre><code class="lang-log">AMD Ryzen 7 2700X 4.10GHz, 1 CPU, 16 logical and 8 physical cores
</code></pre>
<p>As you can see, &quot;Eight-Core Processor&quot; was removed (because we already have &quot;8 physical cores&quot;);
&quot;(Max: 4.10GHz)&quot; was replaced by 4.10GHz (because the original CPU brand string doesn't contain the nominal frequency).</p>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/859">#859</a> Strange max frequency values on Windows (assignee: <a href="https://github.com/Rizzen">@Rizzen</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/909">#909</a> Improve CPU Brand Strings without frequency</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/860">#860</a> Fix strange CPU Frequency values (by <a href="https://github.com/Rizzen">@Rizzen</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/910">#910</a> Simplify AMD Ryzen CPU brand info (by <a href="https://github.com/lahma">@lahma</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/a78b38b0e89d04ad3fe8934162c7adb42f81eabe">a78b38</a> Fix strange CPU Frequency values (#860) (by <a href="https://github.com/Rizzen">@Rizzen</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/5df1e6434b791eb5da6f6ef42505fc6a94ebd008">5df1e6</a> Simplify AMD Ryzen CPU brand info (#910) (by <a href="https://github.com/lahma">@lahma</a>)</li>
</ul>
<hr>
<h2 id="attributes">Attributes</h2>
<h3 id="async-globalsetup-and-globalcleanup">Async GlobalSetup and GlobalCleanup</h3>
<p>Now GlobalSetup and GlobalCleanup methods can be async.</p>
<p>See also: docs.setup-and-cleanup</p>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/521">#521</a> Support async Setup/Cleanup</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/892">#892</a> Added support for async GlobalSetup. (by <a href="https://github.com/dlemstra">@dlemstra</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/923">#923</a> async GlobalCleanup support (by <a href="https://github.com/dlemstra">@dlemstra</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/926">#926</a> Added support for async GlobalCleanup. (by <a href="https://github.com/dlemstra">@dlemstra</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/e0f7a67681860ead87cef76fa0db349460b34eb0">e0f7a6</a> Added support for async GlobalSetup. (#892) (by <a href="https://github.com/dlemstra">@dlemstra</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/a971a435ce6e6ca25d246e5e2cd56c5b2cf4739d">a971a4</a> async GlobalCleanup support (#923) (by <a href="https://github.com/dlemstra">@dlemstra</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/e4c7b852e5593bb280881e28ece51d26687c5ba9">e4c7b8</a> Added support for async GlobalCleanup. (#926), fixes #521 (by <a href="https://github.com/dlemstra">@dlemstra</a>)</li>
</ul>
<h3 id="introduced-paramsallvalues">Introduced ParamsAllValues</h3>
<p>If you want to use all possible values of an <code>enum</code> or another type with a small number of values, you can use the <a class="xref" href="../api/BenchmarkDotNet.Attributes.ParamsAllValuesAttribute.html"><code>[ParamsAllValues]</code></a> attribute, instead of listing all the values by hand. The types supported by the attribute are:</p>
<ul>
<li><code>bool</code></li>
<li>any <code>enum</code> that is not marked with <code>[Flags]</code></li>
<li><code>Nullable&lt;T&gt;</code>, where <code>T</code> is an enum or boolean</li>
</ul>
<p>An example:</p>
<pre><code class="lang-cs">public class IntroParamsAllValues
{
    public enum CustomEnum
    {
        A,
        BB,
        CCC
    }

    [ParamsAllValues]
    public CustomEnum E { get; set; }

    [ParamsAllValues]
    public bool? B { get; set; }

    [Benchmark]
    public void Benchmark()
    {
        Thread.Sleep(
            E.ToString().Length * 100 +
            (B == true ? 20 : B == false ? 10 : 0));
    }
}
</code></pre>
<p>Output:</p>
<pre><code class="lang-markdown">    Method |   E |     B |     Mean | Error |
---------- |---- |------ |---------:|------:|
 Benchmark |   A |     ? | 101.9 ms |    NA |
 Benchmark |   A | False | 111.9 ms |    NA |
 Benchmark |   A |  True | 122.3 ms |    NA |
 Benchmark |  BB |     ? | 201.5 ms |    NA |
 Benchmark |  BB | False | 211.8 ms |    NA |
 Benchmark |  BB |  True | 221.4 ms |    NA |
 Benchmark | CCC |     ? | 301.8 ms |    NA |
 Benchmark | CCC | False | 312.3 ms |    NA |
 Benchmark | CCC |  True | 322.2 ms |    NA |

// * Legends *
  E     : Value of the 'E' parameter
  B     : Value of the 'B' parameter
</code></pre>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/658">#658</a> [Params] for enums should include all values by default</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/908">#908</a> Added [ParamsAllValues] (by <a href="https://github.com/gsomix">@gsomix</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/922dfff62d6cf6fd808865e705a09eee63690a2e">922dff</a> Added [ParamsAllValues] (#908), fixes #658 (by <a href="https://github.com/gsomix">@gsomix</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/846d0863b6456d3e1e6ccab06d8e61c5cd064194">846d08</a> ParamsAllValuesValidator fixes (by <a href="https://github.com/AndreyAkinshin">@AndreyAkinshin</a>)</li>
</ul>
<h3 id="selecting-baseline-across-methods-and-jobs">Selecting Baseline across Methods and Jobs</h3>
<p>Now it's possible to mark a method and a job as baselines at the same time:</p>
<pre><code class="lang-cs">public class TheBaselines
{
    [Benchmark(Baseline = true)]
    public void Sleep100ms() =&gt; Thread.Sleep(TimeSpan.FromMilliseconds(100));
    
    [Benchmark]
    public void Sleep50ms() =&gt; Thread.Sleep(TimeSpan.FromMilliseconds(50));
}

static void Main(string[] args)
    =&gt; BenchmarkSwitcher
        .FromTypes(new[] { typeof(TheBaselines) })
        .Run(args,
                DefaultConfig.Instance
                    .With(Job.Core.AsBaseline())
                    .With(Job.Clr.WithId(&quot;CLR 4.7.2&quot;)));
</code></pre>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/issues/880">#880</a> Select Baseline across Methods and Jobs (assignee: <a href="https://github.com/AndreyAkinshin">@AndreyAkinshin</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/21a0073cc8b486f41b2e84deafacd00a1303013a">21a007</a> Support method-job baseline pairs, fixes #880 (by <a href="https://github.com/AndreyAkinshin">@AndreyAkinshin</a>)</li>
</ul>
<hr>
<h2 id="statistics">Statistics</h2>
<h3 id="statistical-tests">Statistical tests</h3>
<p>In this release, statistical testing was significantly improved.
Now it's possible to compare all benchmarks against baseline with the help
of Welch's t-test or Mann–Whitney U test.</p>
<p>An example:</p>
<pre><code class="lang-cs">[StatisticalTestColumn(
    StatisticalTestKind.Welch, ThresholdUnit.Microseconds, 1, true)]
[StatisticalTestColumn(
    StatisticalTestKind.MannWhitney, ThresholdUnit.Microseconds, 1, true)]
[StatisticalTestColumn(
    StatisticalTestKind.Welch, ThresholdUnit.Ratio, 0.03, true)]
[StatisticalTestColumn(
    StatisticalTestKind.MannWhitney, ThresholdUnit.Ratio, 0.03, true)]
[SimpleJob(warmupCount: 0, targetCount: 5)]
public class IntroStatisticalTesting
{
    [Benchmark] public void Sleep50() =&gt; Thread.Sleep(50);
    [Benchmark] public void Sleep97() =&gt; Thread.Sleep(97);
    [Benchmark] public void Sleep99() =&gt; Thread.Sleep(99);
    [Benchmark(Baseline = true)] public void Sleep100() =&gt; Thread.Sleep(100);
    [Benchmark] public void Sleep101() =&gt; Thread.Sleep(101);
    [Benchmark] public void Sleep103() =&gt; Thread.Sleep(103);
    [Benchmark] public void Sleep150() =&gt; Thread.Sleep(150);
}
</code></pre>
<p>Output:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
<th style="text-align: right;">Ratio</th>
<th>Welch(1us)/p-values</th>
<th>Welch(3%)/p-values</th>
<th>MannWhitney(1us)/p-values</th>
<th>MannWhitney(3%)/p-values</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sleep50</td>
<td style="text-align: right;">53.13 ms</td>
<td style="text-align: right;">0.5901 ms</td>
<td style="text-align: right;">0.1532 ms</td>
<td style="text-align: right;">0.51</td>
<td>Faster: 1.0000/0.0000</td>
<td>Faster: 1.0000/0.0000</td>
<td>Faster: 1.0000/0.0040</td>
<td>Faster: 1.0000/0.0040</td>
</tr>
<tr>
<td>Sleep97</td>
<td style="text-align: right;">100.07 ms</td>
<td style="text-align: right;">0.9093 ms</td>
<td style="text-align: right;">0.2361 ms</td>
<td style="text-align: right;">0.97</td>
<td>Faster: 1.0000/0.0000</td>
<td>Same: 1.0000/0.1290</td>
<td>Faster: 1.0000/0.0040</td>
<td>Same: 1.0000/0.1111</td>
</tr>
<tr>
<td>Sleep99</td>
<td style="text-align: right;">102.23 ms</td>
<td style="text-align: right;">2.4462 ms</td>
<td style="text-align: right;">0.6353 ms</td>
<td style="text-align: right;">0.99</td>
<td>Faster: 0.9928/0.0072</td>
<td>Same: 1.0000/0.9994</td>
<td>Faster: 0.9960/0.0079</td>
<td>Same: 1.0000/1.0000</td>
</tr>
<tr>
<td>Sleep100</td>
<td style="text-align: right;">103.34 ms</td>
<td style="text-align: right;">0.8180 ms</td>
<td style="text-align: right;">0.2124 ms</td>
<td style="text-align: right;">1.00</td>
<td>Base: 0.5029/0.5029</td>
<td>Base: 1.0000/1.0000</td>
<td>Base: 0.7262/0.7262</td>
<td>Base: 1.0000/1.0000</td>
</tr>
<tr>
<td>Sleep101</td>
<td style="text-align: right;">103.73 ms</td>
<td style="text-align: right;">2.1591 ms</td>
<td style="text-align: right;">0.5607 ms</td>
<td style="text-align: right;">1.00</td>
<td>Same: 0.1041/0.8969</td>
<td>Same: 0.9999/1.0000</td>
<td>Same: 0.1111/0.9246</td>
<td>Same: 1.0000/1.0000</td>
</tr>
<tr>
<td>Sleep103</td>
<td style="text-align: right;">106.21 ms</td>
<td style="text-align: right;">1.2511 ms</td>
<td style="text-align: right;">0.3249 ms</td>
<td style="text-align: right;">1.03</td>
<td>Slower: 0.0000/1.0000</td>
<td>Same: 0.9447/1.0000</td>
<td>Slower: 0.0040/1.0000</td>
<td>Same: 0.9246/1.0000</td>
</tr>
<tr>
<td>Sleep150</td>
<td style="text-align: right;">153.16 ms</td>
<td style="text-align: right;">3.4929 ms</td>
<td style="text-align: right;">0.9071 ms</td>
<td style="text-align: right;">1.48</td>
<td>Slower: 0.0000/1.0000</td>
<td>Slower: 0.0000/1.0000</td>
<td>Slower: 0.0040/1.0000</td>
<td>Slower: 0.0040/1.0000</td>
</tr>
</tbody>
</table>
<pre><code class="lang-log">// * Legends *
  Mean                      : Arithmetic mean of all measurements
  Error                     : Half of 99.9% confidence interval
  StdDev                    : Standard deviation of all measurements
  Ratio                     : Mean of the ratio distribution ([Current]/[Baseline])
  Welch(1us)/p-values       : Welch-based TOST equivalence test with 1 us threshold. Format: 'Result: p-value(Slower)|p-value(Faster)'
  Welch(3%)/p-values        : Welch-based TOST equivalence test with 3% threshold. Format: 'Result: p-value(Slower)|p-value(Faster)'
  MannWhitney(1us)/p-values : MannWhitney-based TOST equivalence test with 1 us threshold. Format: 'Result: p-value(Slower)|p-value(Faster)'
  MannWhitney(3%)/p-values  : MannWhitney-based TOST equivalence test with 3% threshold. Format: 'Result: p-value(Slower)|p-value(Faster)'
  1 ms                      : 1 Millisecond (0.001 sec)
</code></pre>
<p>The statistical testing is a work-in-progress feature.
In future versions of BenchmarkDotNet, we are planning to improve API, fill missed docs, and introduce more parameters for customization.</p>
<p>See also: <a class="xref" href="../articles/samples/IntroStatisticalTesting.html">BenchmarkDotNet.Samples.IntroStatisticalTesting</a></p>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/60eca005326970202a33891e5aecd2ef6b7e4cd0">60eca0</a> Threshold API for WelchTTest; Improve Student accuracy for small n (by <a href="https://github.com/AndreyAkinshin">@AndreyAkinshin</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/05cc8d15ef88e382bbb1827d766d7275c3e42abd">05cc8d</a> Statistical testing improvements (by <a href="https://github.com/AndreyAkinshin">@AndreyAkinshin</a>)</li>
</ul>
<h3 id="zeromeasurementanalyser">ZeroMeasurementAnalyser</h3>
<p>When you have an empty benchmark like this</p>
<pre><code class="lang-cs">[Benchmark]
public void Empty() { }
</code></pre>
<p>The expected duration of this method is zero.
However, you can get the mean value like <code>0.0023ns</code> because of the natural noise.
It's a pretty confusing result for many developers.
Since v0.11.2, we have <code>ZeroMeasurementAnalyser</code> which warn you about such methods.
By default, BenchmarkDotNet automatically evaluate overhead.
In this case, <code>ZeroMeasurementAnalyser</code> runs Welch's t-test and compare actual and overhead measurements.
If the overhead evaluation is disabled, it runs one-sample Student's t-test against a half of CPU cycle.</p>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/pull/906">#906</a> Zero measurement analyser (by <a href="https://github.com/Rizzen">@Rizzen</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/48d193e30c780eb43e65b21f892c48db5dab6f6b">48d193</a> Zero measurement analyser (#906) (by <a href="https://github.com/Rizzen">@Rizzen</a>)</li>
</ul>
<h3 id="ratiocolumn">RatioColumn</h3>
<p>The <code>Ratio</code> column was formerly known as <code>Scaled</code>.
The old title was a source of misunderstanding and confusion because
many developers interpreted it as the ratio of means (e.g., <code>50.46</code>/<code>100.39</code> for <code>Time50</code>).
The ratio of distribution means and the mean of the ratio distribution are pretty close to each other in most cases,
but they are not equal.</p>
<p>See also:
<a class="xref" href="../articles/samples/IntroBenchmarkBaseline.html">BenchmarkDotNet.Samples.IntroBenchmarkBaseline</a>,
<a class="xref" href="../articles/samples/IntroRatioSD.html">BenchmarkDotNet.Samples.IntroRatioSD</a>,
<a class="xref" href="../articles/features/baselines.html">Benchmark and Job Baselines</a>.</p>
<ul>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/4e64c94cfe7b49bbdc06aabb6ee1f262bd370862">4e64c9</a> Ratio/RatioSD columns (by <a href="https://github.com/AndreyAkinshin">@AndreyAkinshin</a>)</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: November 1, 2018</em></p>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.11.2">v0.11.2</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.11.1...v0.11.2">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.11.2">https://www.nuget.org/packages/BenchmarkDotNet/0.11.2</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.2">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.2</a></li>
</ul>
<h1 id="benchmarkdotnet-v0111">BenchmarkDotNet v0.11.1</h1>
<p>This release includes some minor improvements and bug fixes:</p>
<ul>
<li>Fixed <code>RPlotExporter</code> (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/852">#852</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/issues/855">#855</a>).
In v0.11.0, the plot generation was broken because of the huge renaming in <a href="https://github.com/dotnet/BenchmarkDotNet/issues/787">#787</a>.</li>
<li><a class="xref" href="../articles/samples/IntroArgumentsSource.html">ArgumentsSource</a> now supports additional types like
<code>Type</code> (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/840">#840</a>),
<code>BigInteger</code> (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/850">#850</a>),
<code>DateTime</code> (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/853">#853</a>),
and special double values like <code>double.NaN</code>  (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/851">#851</a>)</li>
<li>Generated projects ignore Directory.Build.props and Directory.Build.targets files <a href="https://github.com/dotnet/BenchmarkDotNet/pull/854">#854</a></li>
<li>Now it's possible to run benchmarks with CoreRun (<a href="https://github.com/dotnet/BenchmarkDotNet/commit/de152c7acc71eddeaa304c846cc67e6a54ca7a0f">de152c</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/857">#857</a>)</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: August 22, 2018</em></p>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.11.1">v0.11.1</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.11.0...v0.11.1">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.11.1">https://www.nuget.org/packages/BenchmarkDotNet/0.11.1</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.1">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.1</a></li>
</ul>
<h1 id="benchmarkdotnet-v0110">BenchmarkDotNet v0.11.0</h1>
<p>This is one of the biggest releases of BenchmarkDotNet ever.
There are so many improvements.
We have
new documentation,
many performance improvements,
Job Mutators,
better user experience,
correct Ctrl+C handling,
better generic benchmarks support,
more scenarios for passing arguments to benchmarks,
awesome support of console arguments,
unicode support,
LLVM support in MonoDisassembler,
and many-many other improvements and bug fixes!</p>
<p>A big part of the features and bug fixes were implemented to meet the enterprise requirements of Microsoft to make it possible to port CoreCLR, CoreFX, and CoreFXLab to BenchmarkDotNet.</p>
<p>The release would not be possible without many contributions from amazing community members. This release is a combined effort. We build BenchmarkDotNet together to make benchmarking .NET code easy and available to everyone for free!</p>
<h1 id="new-documentation">New documentation</h1>
<p>We have many improvements in our documentation!
The new docs include:</p>
<ul>
<li><a href="https://dotnet.github.io/docfx/">DocFX</a> under the hood</li>
<li>Detailed changelogs which includes all commits, merged pull requests and resolved issues</li>
<li>API references</li>
<li>Code samples for main features:
we generate it automatically based on the <code>BenchmarkDotNet.Samples</code> project;
it means that all samples can always be compiled
(no more samples with outdated API)</li>
<li>Better UI</li>
<li>Documentation versioning: now it's possible to look at the documentation for recent BenchmarkDotNet versions</li>
</ul>
<h1 id="performance-improvements">Performance improvements</h1>
<p>BenchmarkDotNet needs to be capable of running few thousands of CoreFX and CoreCLR benchmarks in an acceptable amount of time. The code itself was already optimized so we needed architectural and design changes to meet this requirement.</p>
<h2 id="generate-one-executable-per-runtime-settings">Generate one executable per runtime settings</h2>
<p>To ensure that the side effects of one benchmark run does not affect another benchmark run BenchmarkDotNet generates, builds and runs every benchmark in a dedicated process. So far we were generating and building one executable per benchmark, now we generate and build one executable per runtime settings. So if you want to run ten thousands of benchmarks for .NET Core 2.1 we are going to generate and build single executable, not ten thousand. If you target multiple runtimes the build is going to be executed in parallel. Moreover, if one of the parallel builds fail it's going to be repeated in a sequential way.</p>
<p>Previously the time to generate and build 650 benchmarks from our Samples project was <strong>one hour</strong>. Now it's something around <strong>13 seconds</strong> which means <strong>276 X</strong> improvement for this particular scenario. You can see the changes <a href="https://github.com/dotnet/BenchmarkDotNet/issues/699">here</a>.</p>
<h2 id="dont-execute-long-operations-more-than-once-per-iteration">Don't execute long operations more than once per iteration</h2>
<p>BenchmarkDotNet was designed to allow for very accurate and stable micro-benchmarking. One of the techniques that we use is manual loop unrolling. In practice, it meant that for every iteration we were executing the benchmark at least 16 times (the default <code>UnrollFactor</code> value). It was of course not desired for the very time-consuming benchmarks.</p>
<p>So far this feature was always enabled by default and users would need to configure <code>UnrollFactor=1</code> to disable it. Now BenchmarkDotNet is going to discover such scenario and don't perform manual loop unrolling for the very time-consuming benchmarks. BenchmarkDotNet uses <code>Job.IterationTime</code> setting (the default is 0.5s) in the Pilot Experiment stage to determine how many times given benchmark should be executed per iteration.</p>
<p>Example:</p>
<pre><code class="lang-cs">public class Program
{
    static void Main() =&gt; BenchmarkRunner.Run&lt;Program&gt;();

    [Benchmark]
    public void Sleep1s() =&gt; Thread.Sleep(TimeSpan.FromSeconds(1));
}
</code></pre>
<p>Time to run with the previous version: <strong>374 seconds</strong>. With <code>0.11.0</code> it's <strong>27 seconds</strong> which gives us almost <strong>14 X</strong> improvement. A good example of benchmarks that are going to benefit from this change are computer game benchmarks and ML.NET benchmarks. You can see the changes <a href="https://github.com/dotnet/BenchmarkDotNet/pull/760">here</a> and <a href="https://github.com/dotnet/BenchmarkDotNet/pull/771">here</a>.</p>
<h2 id="exposing-more-configuration-settings">Exposing more configuration settings</h2>
<p>The default settings were configured to work well with every scenario. Before running the benchmark, BenchmarkDotNet does not know anything about it. This is why it performs many warmup iterations before running the benchmarks.</p>
<p>When you author benchmarks and run them many times you can come up with custom settings that produce similar results but in a shorter manner of time. To allow you to do that we have exposed:</p>
<ul>
<li><code>Job.MinIterationCount</code> (default value is 15)</li>
<li><code>Job.MaxIterationCount</code> (default value is 100)</li>
<li><code>Job.MinWarmupIterationCount</code> (default value is 6)</li>
<li><code>Job.MaxWarmupIterationCount</code> (default value is 50)</li>
</ul>
<h1 id="user-experience">User Experience</h1>
<p>One of the biggest success factors of BenchmarkDotNet is a great user experience. The tool just works as expected and makes your life easy. We want to make it even better!</p>
<h2 id="net-standard-20">.NET Standard 2.0</h2>
<p>We have ported BenchmarkDotNet to .NET Standard 2.0 and thanks to that we were able to not only simplify our code and build process but also merge <code>BenchmarkDotNet.Core.dll</code> and <code>BenchmarkDotNet.Toolchains.Roslyn.dll</code> into <code>BenchmarkDotNet.dll</code>. We still support .NET 4.6 but we have dropped .NET Core 1.1 support. More information and full discussion can be found <a href="https://github.com/dotnet/BenchmarkDotNet/pull/688">here</a>.</p>
<p><strong>Note:</strong> Our <code>BenchmarkDotNet.Diagnostics.Windows</code> package which uses <code>EventTrace</code> to implement ETW-based diagnosers was also ported to .NET Standard 2.0 and you can now use all the ETW diagnosers with .NET Core on Windows. We plan to add EventPipe support and make this page fully cross-platform and Unix compatible soon.</p>
<h2 id="using-complex-types-as-benchmark-arguments">Using complex types as benchmark arguments</h2>
<p>So far we have required the users to implement <code>IParam</code> interface to make the custom complex types work as benchmark arguments/parameters. This has changed, now the users can use any complex types as arguments and it will just work (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/754">more</a>).</p>
<pre><code class="lang-cs">public class Program
{
    static void Main(string[] args) =&gt; BenchmarkRunner.Run&lt;Program&gt;();

    public IEnumerable&lt;object&gt; Arguments()
    {
        yield return new Point2D(10, 200);
    }

    [Benchmark]
    [ArgumentsSource(nameof(Arguments))]
    public int WithArgument(Point2D point) =&gt; point.X + point.Y;
}

public class Point2D
{
    public int X, Y;

    public Point2D(int x, int y)
    {
        X = x;
        Y = y;
    }

    public override string ToString() =&gt; $&quot;[{X},{Y}]&quot;;
}
</code></pre>
<p><strong>Note</strong>: If you want to control what will be displayed in the summary you should override <code>ToString</code>.</p>
<h2 id="if-iterationsetup-is-provided-run-benchmark-once-per-iteration">If IterationSetup is provided run benchmark once per iteration</h2>
<p>When Stephen Toub says that something is <a href="https://github.com/dotnet/BenchmarkDotNet/issues/730">buggy</a>, it most probably is. BenchmarkDotNet performs multiple invocations of benchmark per every iteration. When we have exposed the <code>[IterationSetup]</code> attribute many users were expecting that the <code>IterationSetup</code> is going to be invoked before every benchmark execution.</p>
<p>It was invoked before every iteration, and iteration was more than one benchmark call if the user did not configure that explicitly. We have changed that and now if you provide an <code>[IterationSetup]</code> method it is going to be executed before every iteration and iteration will invoke the benchmark just once.</p>
<pre><code class="lang-cs">public class Test
{
    public static void Main() =&gt; BenchmarkRunner.Run&lt;Test&gt;();

    [IterationSetup]
    public void MySetup() =&gt; Console.WriteLine(&quot;MySetup&quot;);

    [Benchmark]
    public void MyBenchmark() =&gt; Console.WriteLine(&quot;MyBenchmark&quot;);
}
</code></pre>
<p>Before:</p>
<pre><code class="lang-log">MySetup
MyBenchmark
MyBenchmark
MyBenchmark
MyBenchmark
(...)
</code></pre>
<p>After:</p>
<pre><code class="lang-log">MySetup
MyBenchmark
MySetup
MyBenchmark
MySetup
MyBenchmark
(...)
</code></pre>
<p><strong>Note:</strong> If you want to configure how many times benchmark should be invoked per iteration you can use the new <code>[InvocationCountAttribute]</code>.</p>
<h2 id="job-mutators">Job Mutators</h2>
<p><code>Job</code> represents a set of settings to run the benchmarks. We run every benchmark for every job defined by the user. The problem was that so far many jobs were just added to the config instead of being merged with other jobs.</p>
<p>An example:</p>
<pre><code class="lang-cs">[ClrJob, CoreJob]
[GcServer(true)]
public class MyBenchmarkClass
</code></pre>
<p>Resulted in 3 jobs and 3 benchmark executions: <code>ClrJob</code>,  <code>CoreJob</code> and <code>GcServer(true)</code> for current runtime.</p>
<p>Now all Jobs and their corresponding attributes marked as mutators are going to be applied to other jobs, not just added to the config. So in this particular scenario, the benchmarks from <code>MyBenchmarkClass</code> are going to be executed for .NET with Server GC enabled and .NET Core with Server GC enabled.</p>
<p>Mutators are great when you want to have a single, global config for all benchmarks and apply given settings only to selected types. You can find out more about mutators <a href="https://github.com/dotnet/BenchmarkDotNet/pull/800">here</a>.</p>
<h2 id="ctrlc">Ctrl+C</h2>
<p>When the user:</p>
<ul>
<li>presses <code>Ctrl+C</code></li>
<li>presses <code>Ctrl+Break</code></li>
<li>logs off</li>
<li>closes console window</li>
</ul>
<p>We are now going to close any existing ETW session created by BenchmarkDotNet and <strong>restore console colors</strong> (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/761">read more</a>).</p>
<h2 id="handle-outofmemoryexception-more-gracefully">Handle OutOfMemoryException more gracefully</h2>
<p>When our benchmark hits <code>OutOfMemoryException</code> we print some nice explanation:</p>
<pre><code class="lang-cs">public class Program
{
    static void Main(string[] args) =&gt; BenchmarkRunner.Run&lt;Program&gt;();

    private List&lt;object&gt; list = new List&lt;object&gt;();

    [Benchmark]
    public void AntiPattern() =&gt; list.Add(new int[int.MaxValue / 2]);
}
</code></pre>
<pre><code class="lang-log">OutOfMemoryException!
BenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects.
If your benchmark allocates memory and keeps it alive, you are creating a memory leak.
You should redesign your benchmark and remove the side-effects. You can use `OperationsPerInvoke`, `IterationSetup` and `IterationCleanup` to do that.
</code></pre>
<h2 id="trimming-long-strings">Trimming long strings</h2>
<p>We used to display the values &quot;as is&quot; which was bad for long strings. Now the values are trimmed (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/748">more</a>).</p>
<pre><code class="lang-cs">public class Long
{
    [Params(&quot;text/plain,text/html;q=0.9,application/xhtml+xml;q=0.9,application/xml;q=0.8,*/*;q=0.7&quot;)]
    public string Text;

    [Benchmark]
    public int HashCode() =&gt; Text.GetHashCode();
}
</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th>Text</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashCode</td>
<td>text/(...)q=0.7 [86]</td>
</tr>
</tbody>
</table>
<h1 id="more-features">More features</h1>
<h2 id="generic-benchmarks">Generic benchmarks</h2>
<p>BenchmarkDotNet supports generic benchmarks, all you need to do is to tell it which types should be used as generic arguments (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/758">read more</a>).</p>
<pre><code class="lang-cs">[GenericTypeArguments(typeof(int))]
[GenericTypeArguments(typeof(char))]
public class IntroGenericTypeArguments&lt;T&gt;
{
    [Benchmark] public T Create() =&gt; Activator.CreateInstance&lt;T&gt;();
}
</code></pre>
<h2 id="arguments">Arguments</h2>
<p>We now support more scenarios for passing arguments to benchmarks:</p>
<ul>
<li>passing arguments to asynchronous benchmarks (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/818">more</a>)</li>
<li>passing generic types</li>
<li>passing arguments by reference</li>
<li>passing jagged arrays (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/769">more</a>)</li>
<li>types with implicit cast operator to stack only types can be passed as given stack-only types to Benchmarks (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/774">more</a>)</li>
</ul>
<p>Example:</p>
<pre><code class="lang-cs">public class WithStringToReadOnlySpan
{
    [Benchmark]
    [Arguments(&quot;some string&quot;)]
    public void AcceptsReadOnlySpan(ReadOnlySpan&lt;char&gt; notString)
}
</code></pre>
<h2 id="console-arguments">Console Arguments</h2>
<p><code>BenchmarkSwitcher</code> supports various console arguments (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/824">PR</a>), to make it work you need to pass the <code>args</code> to switcher:</p>
<pre><code class="lang-cs">class Program
{
    static void Main(string[] args) 
        =&gt; BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args);
}
</code></pre>
<p><strong>Note:</strong> to get the most up-to-date info about supported console arguments run the benchmarks with <code>--help</code>.</p>
<h3 id="filter">Filter</h3>
<p>The <code>--filter</code> or just <code>-f</code> allows you to filter the benchmarks by their full name (<code>namespace.typeName.methodName</code>) using glob patterns.</p>
<p>Examples:</p>
<ol>
<li>Run all benchmarks from System.Memory namespace: <code>-f System.Memory*</code></li>
<li>Run all benchmarks: <code>-f *</code></li>
<li>Run all benchmarks from ClassA and ClassB <code>-f *ClassA* *ClassB*</code></li>
</ol>
<p><strong>Note</strong>: If you would like to <strong>join</strong> all the results into a <strong>single summary</strong>, you need to use <code>--join</code>.</p>
<h3 id="categories">Categories</h3>
<p>You can also filter the benchmarks by categories:</p>
<ul>
<li><code>--anyCategories</code> - runs all benchmarks that belong to <strong>any</strong> of the provided categories</li>
<li><code>--allCategories</code>- runs all benchmarks that belong to <strong>all</strong> provided categories</li>
</ul>
<h3 id="diagnosers">Diagnosers</h3>
<ul>
<li><code>-m</code>, <code>--memory</code> - enables MemoryDiagnoser and prints memory statistics</li>
<li><code>-d</code>, <code>--disassm</code>- enables DisassemblyDiagnoser and exports diassembly of benchmarked code</li>
</ul>
<h3 id="runtimes">Runtimes</h3>
<p>The <code>--runtimes</code> or just <code>-r</code> allows you to run the benchmarks for selected Runtimes. Available options are: Clr, Mono, Core and CoreRT.</p>
<p>Example: run the benchmarks for .NET and .NET Core:</p>
<pre><code class="lang-log">dotnet run -c Release -- --runtimes clr core
</code></pre>
<h3 id="more-arguments">More arguments</h3>
<ul>
<li><code>-j</code>, <code>--job</code> (Default: Default) Dry/Short/Medium/Long or Default</li>
<li><code>-e</code>, <code>--exporters</code> GitHub/StackOverflow/RPlot/CSV/JSON/HTML/XML</li>
<li><code>-i</code>, <code>--inProcess</code> (Default: false) Run benchmarks in Process</li>
<li><code>-a</code>, <code>--artifacts</code> Valid path to accessible directory</li>
<li><code>--outliers</code> (Default: OnlyUpper) None/OnlyUpper/OnlyLower/All</li>
<li><code>--affinity</code> Affinity mask to set for the benchmark process</li>
<li><code>--allStats</code> (Default: false) Displays all statistics (min, max &amp; more)</li>
<li><code>--attribute</code> Run all methods with given attribute (applied to class or method)</li>
</ul>
<h2 id="other-small-improvements">Other small improvements</h2>
<ul>
<li><strong>Unicode support:</strong>
now you can enable support of Unicode symbols like <code>μ</code> or <code>±</code> with <code>[EncodingAttribute.Unicode]</code>,
an example: BenchmarkDotNet.Samples.IntroEncoding
(see <a href="https://github.com/dotnet/BenchmarkDotNet/pull/735">#735</a>)</li>
<li><strong>Better benchmark validation</strong>
(see <a href="https://github.com/dotnet/BenchmarkDotNet/pull/693">#693</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/737">#737</a>)</li>
<li><strong>Improve .NET Framework version detection</strong>: now we support .NET Framework 4.7.2
(see <a href="https://github.com/dotnet/BenchmarkDotNet/pull/743">#743</a>)</li>
<li><strong>OutlierModes:</strong>
now it's possible to control how to process outliers,
an example <a class="xref" href="../articles/samples/IntroOutliers.html">BenchmarkDotNet.Samples.IntroOutliers</a>
(see <a href="https://github.com/dotnet/BenchmarkDotNet/pull/766">#766</a>)</li>
<li><strong>LLVM support in MonoDisassembler</strong>
(see <a href="https://github.com/dotnet/BenchmarkDotNet/commit/a7426e84fde075503f489fdf096a95f694f77b85">a7426e</a>)</li>
<li><strong>Grand API renaming</strong>
we try not to change public API, but sometimes it's necessary because we want to get a consistent and understandable API in v1.0.0.
(see <a href="https://github.com/dotnet/BenchmarkDotNet/issues/787">#787</a>)</li>
<li><strong>Many-many small improvements and bug fixes</strong></li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: July 23, 2018</em></p>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.11.0">v0.11.0</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.10.14...v0.11.0">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.11.0">https://www.nuget.org/packages/BenchmarkDotNet/0.11.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.0">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.0</a></li>
</ul>
<h1 id="benchmarkdotnet-v01014">BenchmarkDotNet v0.10.14</h1>
<ul>
<li>Per-method parameterization (<a href="https://benchmarkdotnet.org/articles/features/parameterization.html">Read more</a>)</li>
<li>Console histograms and multimodal disribution detection</li>
<li>Many improvements for Mono disassembly support on Windows (<a href="https://aakinshin.net/posts/dotnet-crossruntime-disasm/">Read more</a>)</li>
<li>Many bugfixes</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: April 09, 2018</em></p>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.10.14">v0.10.14</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.10.13...v0.10.14">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.10.14">https://www.nuget.org/packages/BenchmarkDotNet/0.10.14</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.14">https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.14</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.14">https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.14</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.14">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.14</a></li>
</ul>
<h1 id="benchmarkdotnet-v01013">BenchmarkDotNet v0.10.13</h1>
<p>Overview post: <a href="https://aakinshin.net/posts/bdn-v0_10_13/">BenchmarkDotNet v0.10.13</a></p>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: March 02, 2018</em></p>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.10.13">v0.10.13</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.10.12...v0.10.13">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.10.13">https://www.nuget.org/packages/BenchmarkDotNet/0.10.13</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.13">https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.13</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.13">https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.13</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.13">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.13</a></li>
</ul>
<h1 id="benchmarkdotnet-v01012">BenchmarkDotNet v0.10.12</h1>
<p>Overview post: <a href="https://aakinshin.net/posts/bdn-v0_10_12/">BenchmarkDotNet v0.10.12</a></p>
<h3 id="highlights">Highlights</h3>
<ul>
<li><strong>Improved DisassemblyDiagnoser:</strong>
BenchmarkDotNet contains an embedded disassembler so that it can print assembly code for all benchmarks;
it's not easy, but the disassembler evolves in every release.</li>
<li><strong>Improved MemoryDiagnoser:</strong>
it has a better precision level, and it takes less time to evaluate memory allocations in a benchmark.</li>
<li><strong>New TailCallDiagnoser:</strong>
now you get notifications when JIT applies the tail call optimizations to your methods.</li>
<li><strong>Better environment info:</strong>
when your share performance results, it's very important to share information about your environment.
The library generates the environment summary for you by default.
Now it contains information about the amount of physical CPU, physical cores, and logic cores.
If you run a benchmark on a virtual machine, you will get the name of the hypervisor
(e.g., Hyper-V, VMware, or VirtualBox).</li>
<li><strong>Better summary table:</strong>
one of the greatest features of BenchmarkDotNet is the summary table.
It shows all important information about results in a compact and understandable form.
Now it has better customization options: you can display relative performance of different environments
(e.g., compare .NET Framework and .NET Core) and group benchmarks by categories.</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: January 15, 2018</em></p>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.10.12">v0.10.12</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.10.11...v0.10.12">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.10.12">https://www.nuget.org/packages/BenchmarkDotNet/0.10.12</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.12">https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.12</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.12">https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.12</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.12">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.12</a></li>
</ul>
<h1 id="benchmarkdotnet-v01011">BenchmarkDotNet v0.10.11</h1>
<h2 id="highlights">Highlights</h2>
<ul>
<li>ByRef and Stack-only support (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/492">#492</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/blob/edf20758871ec621fdbfd93d862769da46c4bf15/samples/BenchmarkDotNet.Samples/IL/IL_RefReturns.cs">sample</a>)</li>
<li>.NET Core 2.1 support (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/587">#587</a>)</li>
<li>Improved LINQPad support</li>
<li>Smart logic for precision in ScaledColumn (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/509">#509</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/issues/590">#590</a>)</li>
<li>Better macOS version detection (<a href="https://github.com/dotnet/BenchmarkDotNet/commit/15d72388436c1060e87662b5f4519b9e7e071627">15d72388</a>)</li>
<li>Minor fixes and improvements</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: December 01, 2017</em></p>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.10.11">v0.10.11</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.10.10...v0.10.11">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.10.11">https://www.nuget.org/packages/BenchmarkDotNet/0.10.11</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.11">https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.11</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.11">https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.11</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.11">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.11</a></li>
</ul>
<h1 id="benchmarkdotnet-v01010">BenchmarkDotNet v0.10.10</h1>
<p>Highlights:</p>
<ul>
<li>Disassembly Diagnoser (read more here: <a href="https://adamsitnik.com/Disassembly-Diagnoser/">Disassembling .NET Code with BenchmarkDotNet</a>)</li>
<li>ParamsSources</li>
<li>.NET Core x86 support</li>
<li>Environment variables and Mono args support</li>
<li>Better environment description</li>
<li>More: additional sections in the documentation, bug fixes, build script improvements, internal refactoring.</li>
</ul>
<p>Overview post: <a href="https://aakinshin.net/posts/bdn-v0_10_10/">BenchmarkDotNet v0.10.10</a></p>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: November 03, 2017</em></p>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.10.10">v0.10.10</a></em>
(<a href="https://github.com/dotnet/BenchmarkDotNet/compare/v0.10.9...v0.10.10">List of commits</a>)</p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.10.10">https://www.nuget.org/packages/BenchmarkDotNet/0.10.10</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.10">https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.10</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.10">https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.10</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.10">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.10</a></li>
</ul>
<h1 id="benchmarkdotnet-v0109">BenchmarkDotNet v0.10.9</h1>
<ul>
<li>Migrate from custom build scripts to Cake (C# Make) (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/426">#426</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/475">#475</a>, thanks <a href="https://github.com/Ky7m">@Ky7m</a>)</li>
<li>Target Setup methods for specific Benchmarks (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/469">#469</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/501">#501</a>, thanks <a href="https://github.com/ipjohnson">@ipjohnson</a>)</li>
<li>Many improvements in XmlExporter (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/476">#476</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/488">#488</a>, thanks <a href="https://github.com/Teknikaali">@Teknikaali</a>)</li>
<li>Add MemoryDiagnoser results to JsonExporter output (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/453">#453</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/478">#478</a>, thanks <a href="https://github.com/Teknikaali">@Teknikaali</a>)</li>
<li>Detect correct version of .NET Core (+ improved presentation for information about runtime) (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/448">#448</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/compare/dc6dc411b4d8703d0a1abafe64fb1e0b0a83af1f...cea199f74923c99f88f4bb4d53e37f86b10269b7">ed586585...ed586585</a>)</li>
<li>Fix UnauthorizedAccessException (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/380">#380</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/issues/390">#390</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/issues/490">#490</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/issues/491">#491</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/commit/8505abb5416bad90cda03f4972b067f9ac44b304">8505abb5</a>)</li>
<li>Fix app.config generation (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/499">#499</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/commit/dc6dc411b4d8703d0a1abafe64fb1e0b0a83af1f">dc6dc411</a>)</li>
<li>Fix incorrect order of IterationCleanup and Benchmark jitting (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/481">#481</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/503">#503</a>)</li>
<li>Fix test scripts for MacOS+zsh (<a href="https://github.com/dotnet/BenchmarkDotNet/commit/1177c80e2dbe931439e44bb0ce2ce25cad8b9ba2">1177c8</a>)</li>
<li>Unix-related ProcessorAffinity fixes (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/474">#474</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/commit/26d44411ea47f28a9cc7df84b2df0ef89b2bbcf7">26d44411</a>)</li>
<li>Minor fixes in docs (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/465">#465</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/467">#467</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/473">#473</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/480">#480</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/483">#483</a>, thanks <a href="https://github.com/mtschneiders">@mtschneiders</a>, <a href="https://github.com/davkean">@davkean</a>, <a href="https://github.com/aarondandy">@aarondandy</a>, <a href="https://github.com/AmadeusW">@AmadeusW</a>)</li>
<li>Temporary hacks for <a href="https://appveyor.statuspage.io/incidents/m2vdvw39kdk8">appveyor connectivity incident</a> (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/497">#497</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/506">#506</a>)</li>
<li>Additional warnings for incorrect Configs (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/482">#482</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/commit/eb84825ff08aa5d23d2d512d4d4bde3e95ca0815">eb84825f</a>)</li>
<li>Additional warnings for F# methods with spaces (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/479">#479</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/commit/3c2c8dec28d6c570f2901001058cd9c6000e6ca2">3c2c8dec</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/commit/7ba1c809004e0b75eaa87724155480eaf623f8a9">7ba1c809</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/commit/3ca39afe9f0d25359f9b092181beb02d57c5ad32">3ca39afe</a>)</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: July 28, 2017</em></p>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.10.9">v0.10.9</a></em></p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.10.9">https://www.nuget.org/packages/BenchmarkDotNet/0.10.9</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.9">https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.9</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.9">https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.9</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.9">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.9</a></li>
</ul>
<h1 id="benchmarkdotnet-v0108">BenchmarkDotNet v0.10.8</h1>
<ul>
<li>Legend for time units (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/349">#349</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/issues/459">#459</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/commit/f14e508e44b510a26cc3ec5aed30ee7843a92baf">f14e508e</a>)</li>
<li>XML exporter (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/157">#157</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/452">#452</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/commit/a0148db80c518a9d255f496534a8d1666be52c69">a0148db8</a>)</li>
<li>.NET Framework 4.7 support (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/461">#461</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/commit/3f2b5c3c134c62f34f0ecf1a9c90d91ad37f2c6a">3f2b5c3c</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/commit/5513873ac40d07583d6136e431e3b7c8cdf6c851">5513873a</a>)</li>
<li>Public API for AllocationQuantum (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/450">#450</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/462">#462</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/commit/a0148db80c518a9d255f496534a8d1666be52c69">a0148db8</a>)</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: June 09, 2017</em></p>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.10.8">v0.10.8</a></em></p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.10.8">https://www.nuget.org/packages/BenchmarkDotNet/0.10.8</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.8">https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.8</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.8">https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.8</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.8">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.8</a></li>
</ul>
<h1 id="benchmarkdotnet-v0107">BenchmarkDotNet v0.10.7</h1>
<ul>
<li>LINQPad support (5.22.05+) (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/66">#66</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/issues/445">#445</a>)</li>
<li>Benchmark filters and categories (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/248">#248</a>)</li>
<li>Updated setup/cleanup attributes: <code>[GlobalSetup]</code>, <code>[GlobalCleanup]</code>, <code>[IterationSetup]</code>, <code>[IterationCleanup]</code> (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/270">#270</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/issues/274">#274</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/issues/325">#325</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/issues/456">#456</a>)</li>
<li>Better Value Types support (<a href="https://github.com/dotnet/BenchmarkDotNet/commit/afa803d0e38c0e11864b2e4394d4a85d3801d944">afa803d0</a>)</li>
<li>Building Sources on Linux: it's possible to build the solution (with unloaded F#/VB projects), run samples (for both net46/netcoreapp1.1), run unit tests (for netcoreapp1.1 only)</li>
<li>Fix minor bugs in <code>JsonExporter</code> (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/451">#451</a>)</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: June 05, 2017</em></p>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.10.7">v0.10.7</a></em></p>
<p><em>Overview post: <a href="https://aakinshin.net/posts/bdn-v0_10_7/">https://aakinshin.net/posts/bdn-v0_10_7/</a></em></p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.10.7">https://www.nuget.org/packages/BenchmarkDotNet/0.10.7</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.7">https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.7</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.7">https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.7</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.7">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.7</a></li>
</ul>
<h1 id="benchmarkdotnet-v0106">BenchmarkDotNet v0.10.6</h1>
<ul>
<li>Removed buggy allocation from Engine which was spoiling the results of MemoryDiagnoser for micro benchmarks. This part of the code is now guarded with very strict integration tests, it should never happen again. We now also exclude the side effects of the Allocation Quantum. <strong>This bug was serious, you must update to <code>0.10.6</code></strong> (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/439">#439</a>)</li>
<li>Support of the <code>PackageTargetFallback</code> setting which allows to reference components that target old framework monikers (like <code>dotnet5.4</code> or <code>portable-net45+win8</code>) (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/438">#438</a>)</li>
<li>Added <code>InstructionRetiredPerCycleColumn</code> which shows up automatically when <code>HardwareCounter.InstructionRetired</code> and <code>HardwareCounter.TotalCycles</code> are used.</li>
<li>Support benchmark classes without namespace (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/446">#446</a>)</li>
<li>Fix problem with RPlotExporter and quoted directories in %PATH% (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/446">#446</a>)</li>
<li>Show Windows brand version in summary</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: May 12, 2017</em></p>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.10.6">v0.10.6</a></em></p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.10.6">https://www.nuget.org/packages/BenchmarkDotNet/0.10.6</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.6">https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.6</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.6">https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.6</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.6">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.6</a></li>
</ul>
<h1 id="benchmarkdotnet-v0105">BenchmarkDotNet v0.10.5</h1>
<ul>
<li>Fixed SizeUnit presentation in the summary table (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/434">#434</a>)</li>
<li>In MemoryDiagnoser, now 1kB = 1024B (instead of 1000 in v0.10.4) (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/434">#434</a>)</li>
<li>Fix false allocations detection (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/436">#436</a> <a href="https://github.com/dotnet/BenchmarkDotNet/commit/9b44de704b96e2333d762b14daa152d859b1917d">9b44de70</a>)</li>
<li>Hide ScaledSD column for small values (<a href="https://github.com/dotnet/BenchmarkDotNet/commit/da857ad7eda77db813692d3c3678f8ad04f5af78">da857ad7</a>)</li>
<li>Autoselecting amount of digits after the decimal point (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/404">#404</a>)</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: April 26, 2017</em></p>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.10.5">v0.10.5</a></em></p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.10.5">https://www.nuget.org/packages/BenchmarkDotNet/0.10.5</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.5">https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.5</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.5">https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.5</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.5">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.5</a></li>
</ul>
<h1 id="benchmarkdotnet-v0104">BenchmarkDotNet v0.10.4</h1>
<ul>
<li>New logo</li>
<li>Update to Roslyn 2.0, drop .NET 4.5 support (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/303">#303</a>)</li>
<li>Initial support of HardwareCounters (Windows only)</li>
<li>Initial experimental support of in-process benchmarks</li>
<li>Optional configs for <code>BenchmarkSwitcher</code> (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/391">#391</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/392">#392</a>)</li>
<li>Host API interface (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/356">#356</a>)</li>
<li>Improved measurements for async benchmarks (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/415">#415</a>)</li>
<li>Improved precision level (MinIterationTimes is 500ms instead of 200ms; introduced <code>AccuracyMode.MaxAbsoluteError</code> and <code>AccuracyMode.MaxRelativeError</code> instead of <code>AccuracyMode.MaxStdErrRelative</code>; logic which select amount of iterations uses confidence intervals instead of standard errors; the Error column (half of CI99.9%) is shown by default instead of StdErr)</li>
<li>Introduced <code>ISummaryStyle</code>, raw data in CSV reports (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/118">#118</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/issues/146">#146</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/396">#396</a>)</li>
<li>Handle cases when report files are existed and locked (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/414">#414</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/416">#416</a>)</li>
<li>MarkdownExporter right-justifies numeric columns (<a href="https://github.com/dotnet/BenchmarkDotNet/pull/421">#421</a>)</li>
<li>Better colors for console output (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/376">#376</a>)</li>
<li>Column legends</li>
<li>Add information about CPU microarchitecture for well-known processors to summary</li>
<li>Fix AssemblyInformationalVersionAttribute (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/382">#382</a>)</li>
<li>Fix incorrect method filtering in BenchmarkSwitcher (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/365">#365</a>)</li>
<li>Fix OS Version in Summary for Windows 10 (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/351">#351</a>)</li>
<li>Fix OS Version on Mono</li>
<li>Fix --class and --method filtering  (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/249">#249</a>)</li>
<li>Fix --exporters option (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/189">#189</a>)</li>
<li>Fix escaping logic in CsvExporter (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/294">#294</a>, <a href="https://github.com/dotnet/BenchmarkDotNet/pull/409">#409</a>)</li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/0a251b81b826876179740cc8b79c994a73a5cd51">Fix</a> MacOS detection</li>
<li>Minor bugfixes and API improvements</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: April 21, 2017</em></p>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.10.4">v0.10.4</a></em></p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.10.4">https://www.nuget.org/packages/BenchmarkDotNet/0.10.4</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.4">https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.4</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.4">https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.4</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.4">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.4</a></li>
</ul>
<h1 id="benchmarkdotnet-v0103">BenchmarkDotNet v0.10.3</h1>
<ul>
<li><strong>New .csprojs</strong> support for .NET Core. Also for F# (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/366">#366</a>)!</li>
<li>New plots and RPlotExporter (density plots for each job; cumulative mean plots)</li>
<li>Fixed exporter order (now RPlotExporer uses the actual measurements instead of previous version)</li>
<li>Xplat improvments in RuntimeInformation</li>
<li>Introduced <code>RunStrategy.Monitoring</code></li>
<li>Possibility to set custom path for Mono (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/306">#306</a>)</li>
<li>Possibility to set any .NET Core version &gt;= 1.1 (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/336">#336</a>)</li>
<li><strong>MemoryDiagnoser is now disabled by default (Breaking changes!!)</strong> (<a href="https://github.com/dotnet/BenchmarkDotNet/issues/369">#369</a>)</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: March 01, 2017</em></p>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.10.3">v0.10.3</a></em></p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.10.3">https://www.nuget.org/packages/BenchmarkDotNet/0.10.3</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.3">https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.3</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.3">https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.3</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.3">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.3</a></li>
</ul>
<h1 id="benchmarkdotnet-v0102">BenchmarkDotNet v0.10.2</h1>
<ul>
<li>Closed <a href="https://github.com/dotnet/BenchmarkDotNet/issues/307">#307</a>: culture invariant statistics output</li>
<li>Closed <a href="https://github.com/dotnet/BenchmarkDotNet/issues/321">#321</a>: persist optimized, auto-generated dll compiled from url/plain code</li>
<li>Closed <a href="https://github.com/dotnet/BenchmarkDotNet/issues/332">#322</a>: always restore the console foreground color</li>
<li>Closed <a href="https://github.com/dotnet/BenchmarkDotNet/issues/337">#337</a>: Better detection of Rscript.exe in RPlotExporter</li>
<li>Closed <a href="https://github.com/dotnet/BenchmarkDotNet/issues/345">#345</a>: fix bug in WelchTTestPValueColumn for DryJob</li>
<li>VS 2017 <a href="https://github.com/dotnet/BenchmarkDotNet/commit/f4bdae5b7e203e0f0a7d283db5faa78107674f31">compatibility fix</a></li>
<li><a href="https://github.com/dotnet/BenchmarkDotNet/commit/24dea483b8312efba669d82a6fac3603e60050f5">fix</a> bold markup for Atlassian exporter</li>
<li>Improved precision of nanobenchmarks</li>
<li>Minor infrastructure changes and misc fixes</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: January 21, 2017</em></p>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.10.2">v0.10.2</a></em></p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.10.2">https://www.nuget.org/packages/BenchmarkDotNet/0.10.2</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.2">https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.2</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.2">https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.2</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.2">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.2</a></li>
</ul>
<h1 id="benchmarkdotnet-v0101">BenchmarkDotNet v0.10.1</h1>
<ul>
<li>MemoryDiagnoser got improved. The changes:
<ul>
<li>Memory Diagnoser is now part of BenchmarkDotNet.Core.dll, and it's <strong>enabled by default</strong></li>
<li>MemoryDiagnoser is <strong>100% accurate</strong> about allocated memory when using default settings or Job.ShortRun or any longer job. (see <a href="https://github.com/dotnet/BenchmarkDotNet/pull/284">#284</a>)</li>
<li>Memory Diagnoser no longer includes allocations from Cleanup/Setup methods (see <a href="https://github.com/dotnet/BenchmarkDotNet/issues/186">#186</a>)</li>
<li>the results are now scaled so they are stable across the runs. (see <a href="https://github.com/dotnet/BenchmarkDotNet/issues/133">#133</a>)</li>
</ul>
</li>
<li>.NET Core 1.1+ support, we no longer support 1.0, we target netcoreapp1.1 now. Reason: we wanted to use <code>GC.GetAllocatedBytesForCurrentThread</code> in MemoryDiagnoser which is available only in 1.1+</li>
<li>Improved information about environment in summary</li>
<li>Minor bugfixes</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: December 04, 2016</em></p>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.10.1">v0.10.1</a></em></p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.10.1">https://www.nuget.org/packages/BenchmarkDotNet/0.10.1</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.1">https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.1</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.1">https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.1</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.1">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.1</a></li>
</ul>
<h1 id="benchmarkdotnet-v0100">BenchmarkDotNet v0.10.0</h1>
<ul>
<li>Now BenchmarkDotNet is a part of .NET Foundation</li>
<li>Job and Column API refactoring (see new documentation)</li>
<li>Measurement engine improvements</li>
<li>Horology enhancement (see <code>TimeInterval</code> and <code>Frequency</code>)</li>
<li>Introduced <code>RankColumn</code> which is based on <code>WelchTTest</code> (see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/commit/cf839a0d7ecfdf93da709b63fe324fd2157aabc3">157aabc3</a>)</li>
<li>JsonExporters refactoring (see the Exporters/Json section in the documentation)
<ul>
<li>Renamed JsonExporters classed and attributes</li>
<li>JsonExporters with custom settings</li>
<li>JsonExporters now includes information about the target type namespace (see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/246">#246</a>).</li>
</ul>
</li>
<li>Add <code>JetBrains.Annotations</code> (see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/pull/253">#253</a>)</li>
<li>RFC 4180 support in CSV exporters (see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/241">#241</a>)</li>
<li>Many bugfixes</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: November 10, 2016</em></p>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.10.0">v0.10.0</a></em></p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.10.0">https://www.nuget.org/packages/BenchmarkDotNet/0.10.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.0">https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.0">https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.0</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.0">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.0</a></li>
</ul>
<p><em>Online Documentation:</em> <a href="https://dotnet.github.io/BenchmarkDotNet/">https://dotnet.github.io/BenchmarkDotNet/</a></p>
<h1 id="benchmarkdotnet-v099">BenchmarkDotNet v0.9.9</h1>
<ul>
<li>Attribute config style (see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/166">#166</a>)</li>
<li><a href="https://perfdotnet.github.io/BenchmarkDotNet/index.htm">Online documentation</a> (see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/219">#219</a>)</li>
<li>Mono LLVM support (see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/226">#226</a>)</li>
<li>Async method support (see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/236">#236</a>)</li>
<li>NuGet packages and repo layout restructuring (see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/225">#225</a>, <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/228">#228</a>)</li>
<li><code>[Cleanup]</code> attribute (see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/215">#215</a>)</li>
<li>New statistics columns: <code>Skewness</code>, <code>Kurtosis</code>, <code>WelchTTestPValue</code>, Improved math for the <code>Scaled</code> column</li>
<li>Now current default branch is <code>master</code></li>
<li>Minor improvements and bug fixes</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: August 18, 2016</em></p>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.9.9">v0.9.9</a></em></p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.9.9">https://www.nuget.org/packages/BenchmarkDotNet/0.9.9</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Core/0.9.9">https://www.nuget.org/packages/BenchmarkDotNet.Core/0.9.9</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.9.9">https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.9.9</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.9">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.9</a></li>
</ul>
<p><em>Online Documentation:</em> <a href="https://perfdotnet.github.io/BenchmarkDotNet/">https://perfdotnet.github.io/BenchmarkDotNet/</a></p>
<h1 id="benchmarkdotnet-v098">BenchmarkDotNet v0.9.8</h1>
<ul>
<li>CoreCLR RTM support (see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/216">#216</a>). <strong>Breaking change:</strong> we have dropped dnx451 and dnxcore50 support.</li>
<li>Migration from MSBuild to Roslyn, which supports Mono on Linux and MacOS (see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/149">#149</a>).  <strong>Breaking change:</strong> we have dropped .NET 4.0 support.</li>
<li>Ability to manage GC mode: turn on/off the Server/Concurrent GC modes, extend to CPU groups, set gcAllowVeryLargeObjects and avoid BenchmarkDotNet from forcing GC.Collect (see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/188">#188</a>,  <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/76">#76</a> and <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/211">#211</a>)</li>
<li>Support CopyToOutput (see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/212">#212</a>). Now you can use native dependencies as well as custom files.</li>
<li>Copying custom settings from app.config (see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/108">#108</a>). It means we support assembly binding redirects as well as custom connection strings etc.</li>
<li>AsciiDocExporter (see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/pull/169">#169</a>)</li>
<li>Framework setting in Job has been removed (see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/194">#194</a>)</li>
<li>Minor bugfixes and improvements</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.9.8">v0.9.8</a></em></p>
<p><em>Date: July 07, 2016</em></p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.9.8">https://www.nuget.org/packages/BenchmarkDotNet/0.9.8</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.8">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.8</a></li>
</ul>
<h1 id="benchmarkdotnet-v097">BenchmarkDotNet v0.9.7</h1>
<ul>
<li>.NET Core RC2 support (see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/pull/187">#187</a>)</li>
<li>Bugfixes</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.9.7">v0.9.7</a></em></p>
<p><em>Date: May 29, 2016</em></p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.9.7">https://www.nuget.org/packages/BenchmarkDotNet/0.9.7</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.9.7-beta">https://www.nuget.org/packages/BenchmarkDotNet/0.9.7-beta</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.7">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.7</a></li>
</ul>
<h1 id="benchmarkdotnet-v096">BenchmarkDotNet v0.9.6</h1>
<ul>
<li>Added Percentiles (see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/pull/164">#164</a>)</li>
<li>Added support for Json export (see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/84">#84</a>)</li>
<li>Bugfixes</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.9.6">v0.9.6</a></em></p>
<p><em>Date: May 11, 2016</em></p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.9.6">https://www.nuget.org/packages/BenchmarkDotNet/0.9.6</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.9.6-beta">https://www.nuget.org/packages/BenchmarkDotNet/0.9.6-beta</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.6">https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.6</a></li>
</ul>
<h1 id="benchmarkdotnet-v095">BenchmarkDotNet v0.9.5</h1>
<ul>
<li>Added validators, JitOptimizationsValidator detects all non-optimzied dlls that were referenced <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/134">#134</a></li>
<li><strong>Strong naming</strong> <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/101">#101</a></li>
<li>Add <code>IOrderProvider</code> <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/107">#107</a></li>
<li><strong>Putting all the generated artifacts in a separate folder: ./BenchmarkDotNet.Artifacts/results</strong> and ./BenchmarkDotNet.Artifacts/bin <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/94">#94</a></li>
<li>Printing dotnet cli version for .NET Core and Dnx451, informing user when not installed. Closed <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/128">#128</a></li>
<li>Supporting assembly redirects <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/67">#67</a></li>
<li>Changed used msbuild version: 12 for .NET 4.5 (VS 2013), 14 for .NET 4.6 (VS 2015). Closed <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/132">#132</a> and <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/137">#137</a></li>
<li>Switched to new ‘dotnet’ target framework monikers (dotnet5.4 instead of dnxcore50), <a href="https://github.com/aspnet/Announcements/issues/98">why</a></li>
<li>dnx452, dnx46, net462 support added</li>
<li>Executing single Benchmark for multiple Runtimes also with Diagnoser attached (see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/pull/117">#117</a>)</li>
<li>Misc minor changes</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.9.5">v0.9.5</a></em></p>
<p><em>Date: May 02, 2016</em></p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.9.5">https://www.nuget.org/packages/BenchmarkDotNet/0.9.5</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.9.5-beta">https://www.nuget.org/packages/BenchmarkDotNet/0.9.5-beta</a></li>
</ul>
<h1 id="benchmarkdotnet-v094">BenchmarkDotNet v0.9.4</h1>
<ul>
<li>Improved messages about error in benchmarks, see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/104">#104</a></li>
<li>Natural sort order, see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/92">#92</a>, <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/95">#95</a>, <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/97">#97</a></li>
<li>Improved <code>double</code>/<code>float</code>/<code>decimal</code>/<code>enum</code> support for Params, see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/96">#96</a>, <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/105">#105</a>, <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/116">#116</a></li>
<li>Now environment info includes information about <code>HardwareTimerKind</code> and <code>JitModules</code></li>
<li>Added <code>DryConfig</code></li>
<li>Improved export performance, closed <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/119">#119</a>, merged <a href="https://github.com/PerfDotNet/BenchmarkDotNet/pull/124">#124</a></li>
<li>Better cmd-line discoverability (see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/78">#78</a>), e.g. run <code>Benchmark.exe --help</code> and some useful information will be printed</li>
<li>Supporting all kinds of references for generated project (exact version, custom paths, GAC, sub-folders, dependent assemblies not copied), closed <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/41">#41</a>, <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/49">#49</a>, <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/72">#72</a>, <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/123">#123</a>, merged <a href="https://github.com/PerfDotNet/BenchmarkDotNet/pull/125">#125</a></li>
<li>Friendliness to LinqPad restored, closed <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/66">#66</a>, merged <a href="https://github.com/PerfDotNet/BenchmarkDotNet/pull/125">#125</a></li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.9.4">v0.9.4</a></em></p>
<p><em>Date: March 24, 2016</em></p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.9.4">https://www.nuget.org/packages/BenchmarkDotNet/0.9.4</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.9.4-beta">https://www.nuget.org/packages/BenchmarkDotNet/0.9.4-beta</a></li>
</ul>
<h1 id="benchmarkdotnet-v093">BenchmarkDotNet v0.9.3</h1>
<ul>
<li>CoreCLR support (Closed <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/52">#52</a>, Merged <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/113">#113</a>)</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.9.3">v0.9.3</a></em></p>
<p><em>Date: March 13, 2016</em></p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.9.3">https://www.nuget.org/packages/BenchmarkDotNet/0.9.3</a></li>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.9.3-beta">https://www.nuget.org/packages/BenchmarkDotNet/0.9.3-beta</a></li>
</ul>
<h1 id="benchmarkdotnet-v092">BenchmarkDotNet v0.9.2</h1>
<ul>
<li>Dnx451 support (Closed <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/51">#51</a>, Merged <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/87">#87</a>)</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Milestone: <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues?q=milestone%3Av0.9.2">v0.9.2</a></em></p>
<p><em>Date: March 5, 2016</em></p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.9.2">https://www.nuget.org/packages/BenchmarkDotNet/0.9.2</a></li>
</ul>
<h1 id="benchmarkdotnet-v091">BenchmarkDotNet v0.9.1</h1>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: February 10, 2016</em></p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.9.1">https://www.nuget.org/packages/BenchmarkDotNet/0.9.1</a></li>
</ul>
<h1 id="benchmarkdotnet-v090">BenchmarkDotNet v0.9.0</h1>
<ul>
<li>New API</li>
<li>Autodetermination of amount iteration for warmup/target idle/main iterations, duration of iteration, amount of CLR launches.</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: February 9, 2016</em></p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.9.0">https://www.nuget.org/packages/BenchmarkDotNet/0.9.0</a></li>
</ul>
<h1 id="benchmarkdotnet-v082">BenchmarkDotNet v0.8.2</h1>
<ul>
<li>Changes in the Summary table
<ul>
<li>Summary table now supports ResultExtenders that can add new column to the table</li>
<li>Now we use <a href="https://en.wikipedia.org/wiki/Standard_error">StandardError</a> (aka <code>Error</code>) as the main accuracy metric</li>
<li>Columns <code>op/s</code>, <code>StdDev</code> are disabled by default (you can add it via ResultExtenders)</li>
</ul>
</li>
<li>Statistic improvements, now you have detailed statistic in the console log like follows:</li>
</ul>
<pre><code>Mean = 118.5298 us, StdError = 1.2863 us (N = 30, StdDev = 7.0454 us)
Min = 109.1602 us, Median = 117.1794 us, Max = 132.5764 us
IQR = 10.1244 us, LowerFence = 98.0834 us, UpperFence = 138.5810 us
ConfidenceInterval = [116.0086 us; 121.0510 us] (CI 95%)
</code></pre>
<ul>
<li>Added the <code>Baseline</code> feature, see <a href="https://github.com/PerfDotNet/BenchmarkDotNet/issues/64">#64</a></li>
<li>Export improvements, now you have files <code>&lt;BenchmarkName&gt;-report-github.md</code>, <code>&lt;BenchmarkName&gt;-report-stackoverflow.md</code> for easy publishing results on GitHub and StackOverflow.</li>
<li>Basic plotting. Added new <code>BenchmarkRPlotExporter</code> that creates <code>BuildPlots.R</code> in the bin directory. It is an R script that generates boxplot and barplot for your benchmarks (you should have installed R with defined <code>R_HOME</code> environment variable)</li>
<li>Updated environment info
<ul>
<li>Added Stopwatch <code>Frequency</code> and <code>Resolution</code></li>
<li>Split common benchmark properties (like <code>Mode</code>, <code>Platform</code>, <code>Runtime</code>) in several lines (3 properties per line)</li>
</ul>
</li>
<li>Log improvements: add total time, statistics, list of exported files</li>
<li>Bug fixes</li>
</ul>
<h2 id="additional-details">Additional details</h2>
<p><em>Date: January 19, 2016</em></p>
<p><em>NuGet Packages:</em></p>
<ul>
<li><a href="https://www.nuget.org/packages/BenchmarkDotNet/0.8.2">https://www.nuget.org/packages/BenchmarkDotNet/0.8.2</a></li>
</ul>
<h1 id="benchmarkdotnet-v081">BenchmarkDotNet v0.8.1</h1>
<h1 id="benchmarkdotnet-v080">BenchmarkDotNet v0.8.0</h1>
<h1 id="benchmarkdotnet-v078">BenchmarkDotNet v0.7.8</h1>
<h1 id="benchmarkdotnet-v077">BenchmarkDotNet v0.7.7</h1>
<h1 id="benchmarkdotnet-v076">BenchmarkDotNet v0.7.6</h1>
<h1 id="benchmarkdotnet-v075">BenchmarkDotNet v0.7.5</h1>
<h1 id="benchmarkdotnet-v074">BenchmarkDotNet v0.7.4</h1>
<h1 id="benchmarkdotnet-v073">BenchmarkDotNet v0.7.3</h1>
<h1 id="benchmarkdotnet-v072">BenchmarkDotNet v0.7.2</h1>
<h1 id="benchmarkdotnet-v071">BenchmarkDotNet v0.7.1</h1>
<h1 id="benchmarkdotnet-v070">BenchmarkDotNet v0.7.0</h1>

</article>


        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright &copy; 2013–2024 .NET Foundation and contributors
        </div>
      </div>
    </footer>
  </body>
</html>
