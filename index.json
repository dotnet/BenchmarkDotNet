{
  "api/BenchmarkDotNet.Analysers.AnalyserBase.html": {
    "href": "api/BenchmarkDotNet.Analysers.AnalyserBase.html",
    "title": "Class AnalyserBase | BenchmarkDotNet",
    "summary": "Class AnalyserBase Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public abstract class AnalyserBase : IAnalyser Inheritance object AnalyserBase Implements IAnalyser Derived BaselineCustomAnalyzer EnvironmentAnalyser HideColumnsAnalyser MinIterationTimeAnalyser MultimodalDistributionAnalyzer OutliersAnalyser RuntimeErrorAnalyser ZeroMeasurementAnalyser Constructors AnalyserBase() protected AnalyserBase() Properties Id public abstract string Id { get; } Property Value string Methods Analyse(Summary) public IEnumerable<Conclusion> Analyse(Summary summary) Parameters summary Summary Returns IEnumerable<Conclusion> AnalyseReport(BenchmarkReport, Summary) protected virtual IEnumerable<Conclusion> AnalyseReport(BenchmarkReport report, Summary summary) Parameters report BenchmarkReport summary Summary Returns IEnumerable<Conclusion> AnalyseSummary(Summary) protected virtual IEnumerable<Conclusion> AnalyseSummary(Summary summary) Parameters summary Summary Returns IEnumerable<Conclusion> CreateError(string, BenchmarkReport?, bool) protected Conclusion CreateError(string message, BenchmarkReport? report = null, bool mergeable = true) Parameters message string report BenchmarkReport mergeable bool Returns Conclusion CreateHint(string, BenchmarkReport?, bool) protected Conclusion CreateHint(string message, BenchmarkReport? report = null, bool mergeable = true) Parameters message string report BenchmarkReport mergeable bool Returns Conclusion CreateWarning(string, BenchmarkReport?, bool) protected Conclusion CreateWarning(string message, BenchmarkReport? report = null, bool mergeable = true) Parameters message string report BenchmarkReport mergeable bool Returns Conclusion"
  },
  "api/BenchmarkDotNet.Analysers.BaselineCustomAnalyzer.html": {
    "href": "api/BenchmarkDotNet.Analysers.BaselineCustomAnalyzer.html",
    "title": "Class BaselineCustomAnalyzer | BenchmarkDotNet",
    "summary": "Class BaselineCustomAnalyzer Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public class BaselineCustomAnalyzer : AnalyserBase, IAnalyser Inheritance object AnalyserBase BaselineCustomAnalyzer Implements IAnalyser Inherited Members AnalyserBase.Analyse(Summary) AnalyserBase.AnalyseReport(BenchmarkReport, Summary) AnalyserBase.CreateHint(string, BenchmarkReport, bool) AnalyserBase.CreateWarning(string, BenchmarkReport, bool) AnalyserBase.CreateError(string, BenchmarkReport, bool) Constructors BaselineCustomAnalyzer() public BaselineCustomAnalyzer() Fields Default public static readonly IAnalyser Default Field Value IAnalyser Properties Id public override string Id { get; } Property Value string Methods AnalyseSummary(Summary) protected override IEnumerable<Conclusion> AnalyseSummary(Summary summary) Parameters summary Summary Returns IEnumerable<Conclusion>"
  },
  "api/BenchmarkDotNet.Analysers.CompositeAnalyser.html": {
    "href": "api/BenchmarkDotNet.Analysers.CompositeAnalyser.html",
    "title": "Class CompositeAnalyser | BenchmarkDotNet",
    "summary": "Class CompositeAnalyser Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public class CompositeAnalyser : IAnalyser Inheritance object CompositeAnalyser Implements IAnalyser Constructors CompositeAnalyser(ImmutableHashSet<IAnalyser>) public CompositeAnalyser(ImmutableHashSet<IAnalyser> analysers) Parameters analysers ImmutableHashSet<IAnalyser> Properties Id public string Id { get; } Property Value string Methods Analyse(Summary) public IEnumerable<Conclusion> Analyse(Summary summary) Parameters summary Summary Returns IEnumerable<Conclusion>"
  },
  "api/BenchmarkDotNet.Analysers.Conclusion.html": {
    "href": "api/BenchmarkDotNet.Analysers.Conclusion.html",
    "title": "Class Conclusion | BenchmarkDotNet",
    "summary": "Class Conclusion Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public sealed class Conclusion : IEquatable<Conclusion> Inheritance object Conclusion Implements IEquatable<Conclusion> Properties AnalyserId public string AnalyserId { get; } Property Value string Kind public ConclusionKind Kind { get; } Property Value ConclusionKind Mergeable public bool Mergeable { get; } Property Value bool Message public string Message { get; } Property Value string Report public BenchmarkReport? Report { get; } Property Value BenchmarkReport Methods CreateError(string, string, BenchmarkReport?, bool) public static Conclusion CreateError(string analyserId, string message, BenchmarkReport? report = null, bool mergeable = true) Parameters analyserId string message string report BenchmarkReport mergeable bool Returns Conclusion CreateHint(string, string, BenchmarkReport?, bool) public static Conclusion CreateHint(string analyserId, string message, BenchmarkReport? report = null, bool mergeable = true) Parameters analyserId string message string report BenchmarkReport mergeable bool Returns Conclusion CreateWarning(string, string, BenchmarkReport?, bool) public static Conclusion CreateWarning(string analyserId, string message, BenchmarkReport? report = null, bool mergeable = true) Parameters analyserId string message string report BenchmarkReport mergeable bool Returns Conclusion Equals(Conclusion?) public bool Equals(Conclusion? other) Parameters other Conclusion Returns bool Equals(object?) public override bool Equals(object? obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/BenchmarkDotNet.Analysers.ConclusionHelper.html": {
    "href": "api/BenchmarkDotNet.Analysers.ConclusionHelper.html",
    "title": "Class ConclusionHelper | BenchmarkDotNet",
    "summary": "Class ConclusionHelper Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public static class ConclusionHelper Inheritance object ConclusionHelper Methods Print(ILogger, IEnumerable<Conclusion>) public static void Print(ILogger logger, IEnumerable<Conclusion> conclusions) Parameters logger ILogger conclusions IEnumerable<Conclusion>"
  },
  "api/BenchmarkDotNet.Analysers.ConclusionKind.html": {
    "href": "api/BenchmarkDotNet.Analysers.ConclusionKind.html",
    "title": "Enum ConclusionKind | BenchmarkDotNet",
    "summary": "Enum ConclusionKind Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public enum ConclusionKind Fields Error = 0 Hint = 2 Warning = 1"
  },
  "api/BenchmarkDotNet.Analysers.EnvironmentAnalyser.html": {
    "href": "api/BenchmarkDotNet.Analysers.EnvironmentAnalyser.html",
    "title": "Class EnvironmentAnalyser | BenchmarkDotNet",
    "summary": "Class EnvironmentAnalyser Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public class EnvironmentAnalyser : AnalyserBase, IAnalyser Inheritance object AnalyserBase EnvironmentAnalyser Implements IAnalyser Inherited Members AnalyserBase.Analyse(Summary) AnalyserBase.CreateHint(string, BenchmarkReport, bool) AnalyserBase.CreateWarning(string, BenchmarkReport, bool) AnalyserBase.CreateError(string, BenchmarkReport, bool) Fields Default public static readonly IAnalyser Default Field Value IAnalyser Properties Id public override string Id { get; } Property Value string Methods AnalyseReport(BenchmarkReport, Summary) protected override IEnumerable<Conclusion> AnalyseReport(BenchmarkReport report, Summary summary) Parameters report BenchmarkReport summary Summary Returns IEnumerable<Conclusion> AnalyseSummary(Summary) protected override IEnumerable<Conclusion> AnalyseSummary(Summary summary) Parameters summary Summary Returns IEnumerable<Conclusion>"
  },
  "api/BenchmarkDotNet.Analysers.HideColumnsAnalyser.html": {
    "href": "api/BenchmarkDotNet.Analysers.HideColumnsAnalyser.html",
    "title": "Class HideColumnsAnalyser | BenchmarkDotNet",
    "summary": "Class HideColumnsAnalyser Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public class HideColumnsAnalyser : AnalyserBase, IAnalyser Inheritance object AnalyserBase HideColumnsAnalyser Implements IAnalyser Inherited Members AnalyserBase.Analyse(Summary) AnalyserBase.AnalyseReport(BenchmarkReport, Summary) AnalyserBase.CreateHint(string, BenchmarkReport, bool) AnalyserBase.CreateWarning(string, BenchmarkReport, bool) AnalyserBase.CreateError(string, BenchmarkReport, bool) Constructors HideColumnsAnalyser() public HideColumnsAnalyser() Fields Default public static readonly IAnalyser Default Field Value IAnalyser Properties Id public override string Id { get; } Property Value string Methods AnalyseSummary(Summary) protected override IEnumerable<Conclusion> AnalyseSummary(Summary summary) Parameters summary Summary Returns IEnumerable<Conclusion>"
  },
  "api/BenchmarkDotNet.Analysers.html": {
    "href": "api/BenchmarkDotNet.Analysers.html",
    "title": "Namespace BenchmarkDotNet.Analysers | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Analysers Classes AnalyserBase BaselineCustomAnalyzer CompositeAnalyser Conclusion ConclusionHelper EnvironmentAnalyser HideColumnsAnalyser MinIterationTimeAnalyser MultimodalDistributionAnalyzer OutliersAnalyser RuntimeErrorAnalyser ZeroMeasurementAnalyser Interfaces IAnalyser Enums ConclusionKind"
  },
  "api/BenchmarkDotNet.Analysers.IAnalyser.html": {
    "href": "api/BenchmarkDotNet.Analysers.IAnalyser.html",
    "title": "Interface IAnalyser | BenchmarkDotNet",
    "summary": "Interface IAnalyser Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public interface IAnalyser Properties Id string Id { get; } Property Value string Methods Analyse(Summary) IEnumerable<Conclusion> Analyse(Summary summary) Parameters summary Summary Returns IEnumerable<Conclusion>"
  },
  "api/BenchmarkDotNet.Analysers.MinIterationTimeAnalyser.html": {
    "href": "api/BenchmarkDotNet.Analysers.MinIterationTimeAnalyser.html",
    "title": "Class MinIterationTimeAnalyser | BenchmarkDotNet",
    "summary": "Class MinIterationTimeAnalyser Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public class MinIterationTimeAnalyser : AnalyserBase, IAnalyser Inheritance object AnalyserBase MinIterationTimeAnalyser Implements IAnalyser Inherited Members AnalyserBase.Analyse(Summary) AnalyserBase.AnalyseSummary(Summary) AnalyserBase.CreateHint(string, BenchmarkReport, bool) AnalyserBase.CreateWarning(string, BenchmarkReport, bool) AnalyserBase.CreateError(string, BenchmarkReport, bool) Fields Default public static readonly IAnalyser Default Field Value IAnalyser Properties Id public override string Id { get; } Property Value string Methods AnalyseReport(BenchmarkReport, Summary) protected override IEnumerable<Conclusion> AnalyseReport(BenchmarkReport report, Summary summary) Parameters report BenchmarkReport summary Summary Returns IEnumerable<Conclusion>"
  },
  "api/BenchmarkDotNet.Analysers.MultimodalDistributionAnalyzer.html": {
    "href": "api/BenchmarkDotNet.Analysers.MultimodalDistributionAnalyzer.html",
    "title": "Class MultimodalDistributionAnalyzer | BenchmarkDotNet",
    "summary": "Class MultimodalDistributionAnalyzer Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public class MultimodalDistributionAnalyzer : AnalyserBase, IAnalyser Inheritance object AnalyserBase MultimodalDistributionAnalyzer Implements IAnalyser Inherited Members AnalyserBase.Analyse(Summary) AnalyserBase.AnalyseSummary(Summary) AnalyserBase.CreateHint(string, BenchmarkReport, bool) AnalyserBase.CreateWarning(string, BenchmarkReport, bool) AnalyserBase.CreateError(string, BenchmarkReport, bool) Fields Default public static readonly IAnalyser Default Field Value IAnalyser Properties Id public override string Id { get; } Property Value string Methods AnalyseReport(BenchmarkReport, Summary) protected override IEnumerable<Conclusion> AnalyseReport(BenchmarkReport report, Summary summary) Parameters report BenchmarkReport summary Summary Returns IEnumerable<Conclusion>"
  },
  "api/BenchmarkDotNet.Analysers.OutliersAnalyser.html": {
    "href": "api/BenchmarkDotNet.Analysers.OutliersAnalyser.html",
    "title": "Class OutliersAnalyser | BenchmarkDotNet",
    "summary": "Class OutliersAnalyser Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public class OutliersAnalyser : AnalyserBase, IAnalyser Inheritance object AnalyserBase OutliersAnalyser Implements IAnalyser Inherited Members AnalyserBase.Analyse(Summary) AnalyserBase.AnalyseSummary(Summary) AnalyserBase.CreateHint(string, BenchmarkReport, bool) AnalyserBase.CreateWarning(string, BenchmarkReport, bool) AnalyserBase.CreateError(string, BenchmarkReport, bool) Fields Default public static readonly IAnalyser Default Field Value IAnalyser Properties Id public override string Id { get; } Property Value string Methods AnalyseReport(BenchmarkReport, Summary) protected override IEnumerable<Conclusion> AnalyseReport(BenchmarkReport report, Summary summary) Parameters report BenchmarkReport summary Summary Returns IEnumerable<Conclusion> GetMessage(double[], double[], double[], double[], CultureInfo) Returns a nice message which can be displayed in the summary. public static string GetMessage(double[] actualOutliers, double[] allOutliers, double[] lowerOutliers, double[] upperOutliers, CultureInfo cultureInfo) Parameters actualOutliers double[] Actual outliers which were removed from the statistics allOutliers double[] All outliers which present in the distribution (lower and upper) lowerOutliers double[] All lower outliers upperOutliers double[] All upper outliers cultureInfo CultureInfo CultureInfo Returns string The message"
  },
  "api/BenchmarkDotNet.Analysers.RuntimeErrorAnalyser.html": {
    "href": "api/BenchmarkDotNet.Analysers.RuntimeErrorAnalyser.html",
    "title": "Class RuntimeErrorAnalyser | BenchmarkDotNet",
    "summary": "Class RuntimeErrorAnalyser Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public class RuntimeErrorAnalyser : AnalyserBase, IAnalyser Inheritance object AnalyserBase RuntimeErrorAnalyser Implements IAnalyser Inherited Members AnalyserBase.Analyse(Summary) AnalyserBase.AnalyseSummary(Summary) AnalyserBase.CreateHint(string, BenchmarkReport, bool) AnalyserBase.CreateWarning(string, BenchmarkReport, bool) AnalyserBase.CreateError(string, BenchmarkReport, bool) Fields Default public static readonly IAnalyser Default Field Value IAnalyser Properties Id public override string Id { get; } Property Value string Methods AnalyseReport(BenchmarkReport, Summary) protected override IEnumerable<Conclusion> AnalyseReport(BenchmarkReport report, Summary summary) Parameters report BenchmarkReport summary Summary Returns IEnumerable<Conclusion>"
  },
  "api/BenchmarkDotNet.Analysers.ZeroMeasurementAnalyser.html": {
    "href": "api/BenchmarkDotNet.Analysers.ZeroMeasurementAnalyser.html",
    "title": "Class ZeroMeasurementAnalyser | BenchmarkDotNet",
    "summary": "Class ZeroMeasurementAnalyser Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public class ZeroMeasurementAnalyser : AnalyserBase, IAnalyser Inheritance object AnalyserBase ZeroMeasurementAnalyser Implements IAnalyser Inherited Members AnalyserBase.Analyse(Summary) AnalyserBase.AnalyseSummary(Summary) AnalyserBase.CreateHint(string, BenchmarkReport, bool) AnalyserBase.CreateWarning(string, BenchmarkReport, bool) AnalyserBase.CreateError(string, BenchmarkReport, bool) Fields Default public static readonly IAnalyser Default Field Value IAnalyser Properties Id public override string Id { get; } Property Value string Methods AnalyseReport(BenchmarkReport, Summary) protected override IEnumerable<Conclusion> AnalyseReport(BenchmarkReport report, Summary summary) Parameters report BenchmarkReport summary Summary Returns IEnumerable<Conclusion>"
  },
  "api/BenchmarkDotNet.Attributes.AllCategoriesFilterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.AllCategoriesFilterAttribute.html",
    "title": "Class AllCategoriesFilterAttribute | BenchmarkDotNet",
    "summary": "Class AllCategoriesFilterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class AllCategoriesFilterAttribute : FilterConfigBaseAttribute, IConfigSource Inheritance object Attribute FilterConfigBaseAttribute AllCategoriesFilterAttribute Implements IConfigSource Inherited Members FilterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors AllCategoriesFilterAttribute() public AllCategoriesFilterAttribute() AllCategoriesFilterAttribute(params string[]) public AllCategoriesFilterAttribute(params string[] targetCategories) Parameters targetCategories string[]"
  },
  "api/BenchmarkDotNet.Attributes.AllStatisticsColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.AllStatisticsColumnAttribute.html",
    "title": "Class AllStatisticsColumnAttribute | BenchmarkDotNet",
    "summary": "Class AllStatisticsColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class AllStatisticsColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute AllStatisticsColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors AllStatisticsColumnAttribute() public AllStatisticsColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.AnyCategoriesFilterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.AnyCategoriesFilterAttribute.html",
    "title": "Class AnyCategoriesFilterAttribute | BenchmarkDotNet",
    "summary": "Class AnyCategoriesFilterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class AnyCategoriesFilterAttribute : FilterConfigBaseAttribute, IConfigSource Inheritance object Attribute FilterConfigBaseAttribute AnyCategoriesFilterAttribute Implements IConfigSource Inherited Members FilterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors AnyCategoriesFilterAttribute() public AnyCategoriesFilterAttribute() AnyCategoriesFilterAttribute(params string[]) public AnyCategoriesFilterAttribute(params string[] targetCategories) Parameters targetCategories string[]"
  },
  "api/BenchmarkDotNet.Attributes.ArgumentsAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ArgumentsAttribute.html",
    "title": "Class ArgumentsAttribute | BenchmarkDotNet",
    "summary": "Class ArgumentsAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)] public class ArgumentsAttribute : PriorityAttribute Inheritance object Attribute PriorityAttribute ArgumentsAttribute Inherited Members PriorityAttribute.Priority Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ArgumentsAttribute() public ArgumentsAttribute() ArgumentsAttribute(params object?[]?) public ArgumentsAttribute(params object?[]? values) Parameters values object[] Properties Values public object?[] Values { get; } Property Value object[]"
  },
  "api/BenchmarkDotNet.Attributes.ArgumentsSourceAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ArgumentsSourceAttribute.html",
    "title": "Class ArgumentsSourceAttribute | BenchmarkDotNet",
    "summary": "Class ArgumentsSourceAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)] public class ArgumentsSourceAttribute : PriorityAttribute Inheritance object Attribute PriorityAttribute ArgumentsSourceAttribute Inherited Members PriorityAttribute.Priority Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ArgumentsSourceAttribute(string) public ArgumentsSourceAttribute(string name) Parameters name string ArgumentsSourceAttribute(Type, string) public ArgumentsSourceAttribute(Type type, string name) Parameters type Type name string Properties Name public string Name { get; } Property Value string Type public Type? Type { get; } Property Value Type"
  },
  "api/BenchmarkDotNet.Attributes.ArtifactsPathAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ArtifactsPathAttribute.html",
    "title": "Class ArtifactsPathAttribute | BenchmarkDotNet",
    "summary": "Class ArtifactsPathAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Class)] public class ArtifactsPathAttribute : Attribute, IConfigSource Inheritance object Attribute ArtifactsPathAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ArtifactsPathAttribute(string) public ArtifactsPathAttribute(string value) Parameters value string Properties Config public IConfig Config { get; } Property Value IConfig Value public string Value { get; } Property Value string"
  },
  "api/BenchmarkDotNet.Attributes.AsciiDocExporterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.AsciiDocExporterAttribute.html",
    "title": "Class AsciiDocExporterAttribute | BenchmarkDotNet",
    "summary": "Class AsciiDocExporterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class AsciiDocExporterAttribute : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute AsciiDocExporterAttribute Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors AsciiDocExporterAttribute() public AsciiDocExporterAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.BaselineColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.BaselineColumnAttribute.html",
    "title": "Class BaselineColumnAttribute | BenchmarkDotNet",
    "summary": "Class BaselineColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class BaselineColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute BaselineColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors BaselineColumnAttribute() public BaselineColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.BenchmarkAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.BenchmarkAttribute.html",
    "title": "Class BenchmarkAttribute | BenchmarkDotNet",
    "summary": "Class BenchmarkAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll [AttributeUsage(AttributeTargets.Method)] public class BenchmarkAttribute : Attribute Inheritance object Attribute BenchmarkAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors BenchmarkAttribute(int, string) public BenchmarkAttribute(int sourceCodeLineNumber = 0, string sourceCodeFile = \"\") Parameters sourceCodeLineNumber int sourceCodeFile string Properties Baseline public bool Baseline { get; set; } Property Value bool Description public string? Description { get; set; } Property Value string OperationsPerInvoke public int OperationsPerInvoke { get; set; } Property Value int SourceCodeFile public string SourceCodeFile { get; } Property Value string SourceCodeLineNumber public int SourceCodeLineNumber { get; } Property Value int"
  },
  "api/BenchmarkDotNet.Attributes.BenchmarkCategoryAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.BenchmarkCategoryAttribute.html",
    "title": "Class BenchmarkCategoryAttribute | BenchmarkDotNet",
    "summary": "Class BenchmarkCategoryAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = true)] public class BenchmarkCategoryAttribute : Attribute Inheritance object Attribute BenchmarkCategoryAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors BenchmarkCategoryAttribute() protected BenchmarkCategoryAttribute() BenchmarkCategoryAttribute(params string[]) public BenchmarkCategoryAttribute(params string[] categories) Parameters categories string[] Properties Categories public string[] Categories { get; } Property Value string[]"
  },
  "api/BenchmarkDotNet.Attributes.CategoriesColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.CategoriesColumnAttribute.html",
    "title": "Class CategoriesColumnAttribute | BenchmarkDotNet",
    "summary": "Class CategoriesColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class CategoriesColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute CategoriesColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors CategoriesColumnAttribute() public CategoriesColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.CategoryDiscovererAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.CategoryDiscovererAttribute.html",
    "title": "Class CategoryDiscovererAttribute | BenchmarkDotNet",
    "summary": "Class CategoryDiscovererAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Class)] public class CategoryDiscovererAttribute : Attribute, IConfigSource Inheritance object Attribute CategoryDiscovererAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors CategoryDiscovererAttribute(bool) public CategoryDiscovererAttribute(bool inherit = true) Parameters inherit bool Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.ClrJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ClrJobAttribute.html",
    "title": "Class ClrJobAttribute | BenchmarkDotNet",
    "summary": "Class ClrJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [Obsolete(\"Please use [SimpleJob(RuntimeMoniker.Net$)] instead.\", false)] public class ClrJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute ClrJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ClrJobAttribute() public ClrJobAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.ColumnConfigBaseAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ColumnConfigBaseAttribute.html",
    "title": "Class ColumnConfigBaseAttribute | BenchmarkDotNet",
    "summary": "Class ColumnConfigBaseAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public abstract class ColumnConfigBaseAttribute : Attribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute Implements IConfigSource Derived AllStatisticsColumnAttribute BaselineColumnAttribute CategoriesColumnAttribute ConfidenceIntervalErrorColumnAttribute IterationsColumnAttribute KurtosisColumnAttribute LogicalGroupColumnAttribute MaxColumnAttribute MeanColumnAttribute MedianColumnAttribute MinColumnAttribute MValueColumnAttribute NamespaceColumnAttribute OperationsPerSecondAttribute Q1ColumnAttribute Q3ColumnAttribute RankColumnAttribute SkewnessColumnAttribute StatisticalTestColumnAttribute StdDevColumnAttribute StdErrorColumnAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ColumnConfigBaseAttribute() protected ColumnConfigBaseAttribute() ColumnConfigBaseAttribute(params IColumn[]) protected ColumnConfigBaseAttribute(params IColumn[] columns) Parameters columns IColumn[] Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.ConfidenceIntervalErrorColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ConfidenceIntervalErrorColumnAttribute.html",
    "title": "Class ConfidenceIntervalErrorColumnAttribute | BenchmarkDotNet",
    "summary": "Class ConfidenceIntervalErrorColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class ConfidenceIntervalErrorColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute ConfidenceIntervalErrorColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ConfidenceIntervalErrorColumnAttribute() public ConfidenceIntervalErrorColumnAttribute() ConfidenceIntervalErrorColumnAttribute(ConfidenceLevel) public ConfidenceIntervalErrorColumnAttribute(ConfidenceLevel level) Parameters level ConfidenceLevel"
  },
  "api/BenchmarkDotNet.Attributes.ConfigAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ConfigAttribute.html",
    "title": "Class ConfigAttribute | BenchmarkDotNet",
    "summary": "Class ConfigAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class ConfigAttribute : Attribute, IConfigSource Inheritance object Attribute ConfigAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ConfigAttribute(Type) public ConfigAttribute(Type type) Parameters type Type Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.CoreJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.CoreJobAttribute.html",
    "title": "Class CoreJobAttribute | BenchmarkDotNet",
    "summary": "Class CoreJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [Obsolete(\"Please use [SimpleJob(RuntimeMoniker.NetCoreApp$)] instead.\", false)] public class CoreJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute CoreJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors CoreJobAttribute() public CoreJobAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.CsvExporterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.CsvExporterAttribute.html",
    "title": "Class CsvExporterAttribute | BenchmarkDotNet",
    "summary": "Class CsvExporterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class CsvExporterAttribute : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute CsvExporterAttribute Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors CsvExporterAttribute(CsvSeparator) public CsvExporterAttribute(CsvSeparator separator = CsvSeparator.CurrentCulture) Parameters separator CsvSeparator"
  },
  "api/BenchmarkDotNet.Attributes.CsvMeasurementsExporterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.CsvMeasurementsExporterAttribute.html",
    "title": "Class CsvMeasurementsExporterAttribute | BenchmarkDotNet",
    "summary": "Class CsvMeasurementsExporterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class CsvMeasurementsExporterAttribute : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute CsvMeasurementsExporterAttribute Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors CsvMeasurementsExporterAttribute(CsvSeparator) public CsvMeasurementsExporterAttribute(CsvSeparator separator = CsvSeparator.CurrentCulture) Parameters separator CsvSeparator"
  },
  "api/BenchmarkDotNet.Attributes.DisassemblyDiagnoserAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.DisassemblyDiagnoserAttribute.html",
    "title": "Class DisassemblyDiagnoserAttribute | BenchmarkDotNet",
    "summary": "Class DisassemblyDiagnoserAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Class)] public class DisassemblyDiagnoserAttribute : Attribute, IConfigSource Inheritance object Attribute DisassemblyDiagnoserAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors DisassemblyDiagnoserAttribute() protected DisassemblyDiagnoserAttribute() DisassemblyDiagnoserAttribute(int, DisassemblySyntax, bool, bool, bool, bool, bool, bool, params string[]) public DisassemblyDiagnoserAttribute(int maxDepth = 1, DisassemblySyntax syntax = DisassemblySyntax.Masm, bool printSource = false, bool printInstructionAddresses = false, bool exportGithubMarkdown = true, bool exportHtml = false, bool exportCombinedDisassemblyReport = false, bool exportDiff = false, params string[] filters) Parameters maxDepth int Includes called methods to given level. 1 by default, indexed from 1. To print just the benchmark set it to 0. syntax DisassemblySyntax The disassembly syntax. MASM is the default. printSource bool C#|F#|VB source code will be printed. False by default. printInstructionAddresses bool Print instruction addresses. False by default exportGithubMarkdown bool Exports to GitHub markdown. True by default. exportHtml bool Exports to HTML with clickable links. False by default. exportCombinedDisassemblyReport bool Exports all benchmarks to a single HTML report. Makes it easy to compare different runtimes or methods (each becomes a column in HTML table). exportDiff bool Exports a diff of the assembly code to the Github markdown format. False by default. filters string[] Glob patterns applied to full method signatures by the the disassembler. Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.DryClrJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.DryClrJobAttribute.html",
    "title": "Class DryClrJobAttribute | BenchmarkDotNet",
    "summary": "Class DryClrJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [Obsolete(\"Please use [DryJob(RuntimeMoniker.Net$)] instead.\", false)] public class DryClrJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute DryClrJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors DryClrJobAttribute() public DryClrJobAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.DryCoreJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.DryCoreJobAttribute.html",
    "title": "Class DryCoreJobAttribute | BenchmarkDotNet",
    "summary": "Class DryCoreJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [Obsolete(\"Please use [DryJob(RuntimeMoniker.NetCoreApp$)] instead.\", false)] public class DryCoreJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute DryCoreJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors DryCoreJobAttribute() public DryCoreJobAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.DryJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.DryJobAttribute.html",
    "title": "Class DryJobAttribute | BenchmarkDotNet",
    "summary": "Class DryJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class DryJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute DryJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors DryJobAttribute() public DryJobAttribute() DryJobAttribute(RuntimeMoniker) defines a new Dry Job that targets specified Framework public DryJobAttribute(RuntimeMoniker runtimeMoniker) Parameters runtimeMoniker RuntimeMoniker Target Framework to test. DryJobAttribute(RuntimeMoniker, Jit, Platform) defines a new Dry Job that targets specified Framework, JIT and Platform public DryJobAttribute(RuntimeMoniker runtimeMoniker, Jit jit, Platform platform) Parameters runtimeMoniker RuntimeMoniker Target Framework to test. jit Jit Jit to test. platform Platform Platform to test."
  },
  "api/BenchmarkDotNet.Attributes.DryMonoJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.DryMonoJobAttribute.html",
    "title": "Class DryMonoJobAttribute | BenchmarkDotNet",
    "summary": "Class DryMonoJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [Obsolete(\"Please use [DryJob(RuntimeMoniker.Mono)] instead.\", false)] public class DryMonoJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute DryMonoJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors DryMonoJobAttribute() public DryMonoJobAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.EncodingAttribute.ASCII.html": {
    "href": "api/BenchmarkDotNet.Attributes.EncodingAttribute.ASCII.html",
    "title": "Class EncodingAttribute.ASCII | BenchmarkDotNet",
    "summary": "Class EncodingAttribute.ASCII Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class EncodingAttribute.ASCII : EncodingAttribute, IConfigSource Inheritance object Attribute EncodingAttribute EncodingAttribute.ASCII Implements IConfigSource Inherited Members EncodingAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ASCII() public ASCII()"
  },
  "api/BenchmarkDotNet.Attributes.EncodingAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.EncodingAttribute.html",
    "title": "Class EncodingAttribute | BenchmarkDotNet",
    "summary": "Class EncodingAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] [Obsolete(\"Don't use it\")] public class EncodingAttribute : Attribute, IConfigSource Inheritance object Attribute EncodingAttribute Implements IConfigSource Derived EncodingAttribute.ASCII EncodingAttribute.Unicode Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.EncodingAttribute.Unicode.html": {
    "href": "api/BenchmarkDotNet.Attributes.EncodingAttribute.Unicode.html",
    "title": "Class EncodingAttribute.Unicode | BenchmarkDotNet",
    "summary": "Class EncodingAttribute.Unicode Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class EncodingAttribute.Unicode : EncodingAttribute, IConfigSource Inheritance object Attribute EncodingAttribute EncodingAttribute.Unicode Implements IConfigSource Inherited Members EncodingAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors Unicode() public Unicode()"
  },
  "api/BenchmarkDotNet.Attributes.EvaluateOverheadAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.EvaluateOverheadAttribute.html",
    "title": "Class EvaluateOverheadAttribute | BenchmarkDotNet",
    "summary": "Class EvaluateOverheadAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Specifies if the overhead should be evaluated (Idle runs) and it's average value subtracted from every result. True by default, very important for nano-benchmarks. public class EvaluateOverheadAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute EvaluateOverheadAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors EvaluateOverheadAttribute(bool) public EvaluateOverheadAttribute(bool value = true) Parameters value bool"
  },
  "api/BenchmarkDotNet.Attributes.EventPipeProfilerAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.EventPipeProfilerAttribute.html",
    "title": "Class EventPipeProfilerAttribute | BenchmarkDotNet",
    "summary": "Class EventPipeProfilerAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Class)] public class EventPipeProfilerAttribute : Attribute, IConfigSource Inheritance object Attribute EventPipeProfilerAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors EventPipeProfilerAttribute(EventPipeProfile) public EventPipeProfilerAttribute(EventPipeProfile profile) Parameters profile EventPipeProfile Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.ExceptionDiagnoserAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ExceptionDiagnoserAttribute.html",
    "title": "Class ExceptionDiagnoserAttribute | BenchmarkDotNet",
    "summary": "Class ExceptionDiagnoserAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Class)] public class ExceptionDiagnoserAttribute : Attribute, IConfigSource Inheritance object Attribute ExceptionDiagnoserAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ExceptionDiagnoserAttribute(bool) public ExceptionDiagnoserAttribute(bool displayExceptionsIfZeroValue = true) Parameters displayExceptionsIfZeroValue bool Display Exceptions column. True by default. Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.ExceptionDiagnoserConfig.html": {
    "href": "api/BenchmarkDotNet.Attributes.ExceptionDiagnoserConfig.html",
    "title": "Class ExceptionDiagnoserConfig | BenchmarkDotNet",
    "summary": "Class ExceptionDiagnoserConfig Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class ExceptionDiagnoserConfig Inheritance object ExceptionDiagnoserConfig Constructors ExceptionDiagnoserConfig(bool) public ExceptionDiagnoserConfig(bool displayExceptionsIfZeroValue = true) Parameters displayExceptionsIfZeroValue bool Determines whether the Exceptions column is displayed when its value is not calculated. True by default. Properties DisplayExceptionsIfZeroValue public bool DisplayExceptionsIfZeroValue { get; } Property Value bool"
  },
  "api/BenchmarkDotNet.Attributes.ExecutionValidatorAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ExecutionValidatorAttribute.html",
    "title": "Class ExecutionValidatorAttribute | BenchmarkDotNet",
    "summary": "Class ExecutionValidatorAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class ExecutionValidatorAttribute : ValidatorConfigBaseAttribute, IConfigSource Inheritance object Attribute ValidatorConfigBaseAttribute ExecutionValidatorAttribute Implements IConfigSource Inherited Members ValidatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ExecutionValidatorAttribute() public ExecutionValidatorAttribute() ExecutionValidatorAttribute(bool) public ExecutionValidatorAttribute(bool failOnError) Parameters failOnError bool"
  },
  "api/BenchmarkDotNet.Attributes.ExporterConfigBaseAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ExporterConfigBaseAttribute.html",
    "title": "Class ExporterConfigBaseAttribute | BenchmarkDotNet",
    "summary": "Class ExporterConfigBaseAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class ExporterConfigBaseAttribute : Attribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute Implements IConfigSource Derived AsciiDocExporterAttribute CsvExporterAttribute CsvMeasurementsExporterAttribute HtmlExporterAttribute JsonExporterAttribute MarkdownExporterAttribute MarkdownExporterAttribute.Atlassian MarkdownExporterAttribute.Default MarkdownExporterAttribute.GitHub MarkdownExporterAttribute.StackOverflow PlainExporterAttribute RPlotExporterAttribute XmlExporterAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ExporterConfigBaseAttribute() protected ExporterConfigBaseAttribute() ExporterConfigBaseAttribute(params IExporter[]) protected ExporterConfigBaseAttribute(params IExporter[] exporters) Parameters exporters IExporter[] Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.FilterConfigBaseAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.FilterConfigBaseAttribute.html",
    "title": "Class FilterConfigBaseAttribute | BenchmarkDotNet",
    "summary": "Class FilterConfigBaseAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class|AttributeTargets.Method)] public abstract class FilterConfigBaseAttribute : Attribute, IConfigSource Inheritance object Attribute FilterConfigBaseAttribute Implements IConfigSource Derived AllCategoriesFilterAttribute AnyCategoriesFilterAttribute AotFilterAttribute OperatingSystemsArchitectureFilterAttribute OperatingSystemsFilterAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors FilterConfigBaseAttribute() protected FilterConfigBaseAttribute() FilterConfigBaseAttribute(params IFilter[]) protected FilterConfigBaseAttribute(params IFilter[] filters) Parameters filters IFilter[] Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.Filters.AotFilterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.Filters.AotFilterAttribute.html",
    "title": "Class AotFilterAttribute | BenchmarkDotNet",
    "summary": "Class AotFilterAttribute Namespace BenchmarkDotNet.Attributes.Filters Assembly BenchmarkDotNet.dll public class AotFilterAttribute : FilterConfigBaseAttribute, IConfigSource Inheritance object Attribute FilterConfigBaseAttribute AotFilterAttribute Implements IConfigSource Inherited Members FilterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors AotFilterAttribute(string?) public AotFilterAttribute(string? reason = null) Parameters reason string"
  },
  "api/BenchmarkDotNet.Attributes.Filters.html": {
    "href": "api/BenchmarkDotNet.Attributes.Filters.html",
    "title": "Namespace BenchmarkDotNet.Attributes.Filters | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Attributes.Filters Classes AotFilterAttribute"
  },
  "api/BenchmarkDotNet.Attributes.GcConcurrentAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.GcConcurrentAttribute.html",
    "title": "Class GcConcurrentAttribute | BenchmarkDotNet",
    "summary": "Class GcConcurrentAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Specifies whether the common language runtime runs garbage collection on a separate thread. false: Does not run garbage collection concurrently. true: Runs garbage collection concurrently. This is the default. public class GcConcurrentAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute GcConcurrentAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors GcConcurrentAttribute(bool) public GcConcurrentAttribute(bool value = true) Parameters value bool"
  },
  "api/BenchmarkDotNet.Attributes.GcForceAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.GcForceAttribute.html",
    "title": "Class GcForceAttribute | BenchmarkDotNet",
    "summary": "Class GcForceAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Specifies whether the BenchmarkDotNet's benchmark runner forces full garbage collection after each benchmark invocation false: Does not force garbage collection. true: Forces full garbage collection after each benchmark invocation. This is the default. public class GcForceAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute GcForceAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors GcForceAttribute(bool) public GcForceAttribute(bool value = true) Parameters value bool"
  },
  "api/BenchmarkDotNet.Attributes.GcServerAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.GcServerAttribute.html",
    "title": "Class GcServerAttribute | BenchmarkDotNet",
    "summary": "Class GcServerAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Specifies whether the common language runtime runs server garbage collection. false: Does not run server garbage collection. This is the default. true: Runs server garbage collection. public class GcServerAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute GcServerAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors GcServerAttribute(bool) public GcServerAttribute(bool value = false) Parameters value bool"
  },
  "api/BenchmarkDotNet.Attributes.GenericTypeArgumentsAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.GenericTypeArgumentsAttribute.html",
    "title": "Class GenericTypeArgumentsAttribute | BenchmarkDotNet",
    "summary": "Class GenericTypeArgumentsAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public class GenericTypeArgumentsAttribute : Attribute Inheritance object Attribute GenericTypeArgumentsAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors GenericTypeArgumentsAttribute(Type) public GenericTypeArgumentsAttribute(Type type) Parameters type Type GenericTypeArgumentsAttribute(Type, Type) public GenericTypeArgumentsAttribute(Type type1, Type type2) Parameters type1 Type type2 Type GenericTypeArgumentsAttribute(Type, Type, Type) public GenericTypeArgumentsAttribute(Type type1, Type type2, Type type3) Parameters type1 Type type2 Type type3 Type Properties GenericTypeArguments public Type[] GenericTypeArguments { get; } Property Value Type[]"
  },
  "api/BenchmarkDotNet.Attributes.GlobalCleanupAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.GlobalCleanupAttribute.html",
    "title": "Class GlobalCleanupAttribute | BenchmarkDotNet",
    "summary": "Class GlobalCleanupAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll Marks method to be executed after all benchmark iterations. It's going to be executed only once, after all benchmark runs. [AttributeUsage(AttributeTargets.Method)] public class GlobalCleanupAttribute : TargetedAttribute Inheritance object Attribute TargetedAttribute GlobalCleanupAttribute Inherited Members TargetedAttribute.Match(MethodInfo) TargetedAttribute.Targets TargetedAttribute.Target Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors GlobalCleanupAttribute() public GlobalCleanupAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.GlobalSetupAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.GlobalSetupAttribute.html",
    "title": "Class GlobalSetupAttribute | BenchmarkDotNet",
    "summary": "Class GlobalSetupAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll Marks method to be executed before all benchmark iterations. It's going to be executed only once, just before warm up. [AttributeUsage(AttributeTargets.Method)] public class GlobalSetupAttribute : TargetedAttribute Inheritance object Attribute TargetedAttribute GlobalSetupAttribute Inherited Members TargetedAttribute.Match(MethodInfo) TargetedAttribute.Targets TargetedAttribute.Target Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors GlobalSetupAttribute() public GlobalSetupAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.GroupBenchmarksByAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.GroupBenchmarksByAttribute.html",
    "title": "Class GroupBenchmarksByAttribute | BenchmarkDotNet",
    "summary": "Class GroupBenchmarksByAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Class)] public class GroupBenchmarksByAttribute : Attribute, IConfigSource Inheritance object Attribute GroupBenchmarksByAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors GroupBenchmarksByAttribute() protected GroupBenchmarksByAttribute() GroupBenchmarksByAttribute(params BenchmarkLogicalGroupRule[]) public GroupBenchmarksByAttribute(params BenchmarkLogicalGroupRule[] rules) Parameters rules BenchmarkLogicalGroupRule[] Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.HardwareCountersAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.HardwareCountersAttribute.html",
    "title": "Class HardwareCountersAttribute | BenchmarkDotNet",
    "summary": "Class HardwareCountersAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class HardwareCountersAttribute : Attribute, IConfigSource Inheritance object Attribute HardwareCountersAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors HardwareCountersAttribute() protected HardwareCountersAttribute() HardwareCountersAttribute(params HardwareCounter[]) public HardwareCountersAttribute(params HardwareCounter[] counters) Parameters counters HardwareCounter[] Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.HideColumnsAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.HideColumnsAttribute.html",
    "title": "Class HideColumnsAttribute | BenchmarkDotNet",
    "summary": "Class HideColumnsAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class HideColumnsAttribute : Attribute, IConfigSource Inheritance object Attribute HideColumnsAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors HideColumnsAttribute() protected HideColumnsAttribute() HideColumnsAttribute(params string[]) public HideColumnsAttribute(params string[] names) Parameters names string[] Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.html": {
    "href": "api/BenchmarkDotNet.Attributes.html",
    "title": "Namespace BenchmarkDotNet.Attributes | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Attributes Classes AllCategoriesFilterAttribute AllStatisticsColumnAttribute AnyCategoriesFilterAttribute ArgumentsAttribute ArgumentsSourceAttribute ArtifactsPathAttribute AsciiDocExporterAttribute BaselineColumnAttribute BenchmarkAttribute BenchmarkCategoryAttribute CategoriesColumnAttribute CategoryDiscovererAttribute ClrJobAttribute ColumnConfigBaseAttribute ConfidenceIntervalErrorColumnAttribute ConfigAttribute CoreJobAttribute CsvExporterAttribute CsvMeasurementsExporterAttribute DisassemblyDiagnoserAttribute DryClrJobAttribute DryCoreJobAttribute DryJobAttribute DryMonoJobAttribute EncodingAttribute EncodingAttribute.ASCII EncodingAttribute.Unicode EvaluateOverheadAttribute Specifies if the overhead should be evaluated (Idle runs) and it's average value subtracted from every result. True by default, very important for nano-benchmarks. EventPipeProfilerAttribute ExceptionDiagnoserAttribute ExceptionDiagnoserConfig ExecutionValidatorAttribute ExporterConfigBaseAttribute FilterConfigBaseAttribute GcConcurrentAttribute Specifies whether the common language runtime runs garbage collection on a separate thread. false: Does not run garbage collection concurrently. true: Runs garbage collection concurrently. This is the default. GcForceAttribute Specifies whether the BenchmarkDotNet's benchmark runner forces full garbage collection after each benchmark invocation false: Does not force garbage collection. true: Forces full garbage collection after each benchmark invocation. This is the default. GcServerAttribute Specifies whether the common language runtime runs server garbage collection. false: Does not run server garbage collection. This is the default. true: Runs server garbage collection. GenericTypeArgumentsAttribute GlobalCleanupAttribute Marks method to be executed after all benchmark iterations. It's going to be executed only once, after all benchmark runs. GlobalSetupAttribute Marks method to be executed before all benchmark iterations. It's going to be executed only once, just before warm up. GroupBenchmarksByAttribute HardwareCountersAttribute HideColumnsAttribute HtmlExporterAttribute InProcessAttribute InnerIterationCountAttribute Invocation count in a single iteration. Does exactly the same as InvocationCountAttribute, added to make porting from xunit-performance to BenchmarkDotNet easier InvocationCountAttribute Invocation count in a single iteration. If specified, IterationTime will be ignored. If specified, it must be a multiple of UnrollFactor. IterationCleanupAttribute Marks method to be executed after each benchmark iteration. This should NOT be used for microbenchmarks - please see the docs. IterationCountAttribute How many target iterations should be performed If specified, MinIterationCount will be ignored. If specified, MaxIterationCount will be ignored. IterationSetupAttribute Marks method to be executed before each benchmark iteration. This should NOT be used for microbenchmarks - please see the docs. IterationTimeAttribute Desired time of execution of an iteration. Used by Pilot stage to estimate the number of invocations per iteration. The default value is 500 milliseconds. IterationsColumnAttribute JobConfigBaseAttribute JobMutatorConfigBaseAttribute JsonExporterAttribute JsonExporterAttribute.BriefAttribute JsonExporterAttribute.BriefCompressed JsonExporterAttribute.Full JsonExporterAttribute.FullCompressed KeepBenchmarkFilesAttribute determines if all auto-generated files should be kept or removed after running the benchmarks KurtosisColumnAttribute LegacyJitX64JobAttribute LegacyJitX86JobAttribute LogicalGroupColumnAttribute LongRunJobAttribute MValueColumnAttribute Prints mvalue. See http://www.brendangregg.com/FrequencyTrails/modes.html MarkdownExporterAttribute MarkdownExporterAttribute.Atlassian MarkdownExporterAttribute.Default MarkdownExporterAttribute.GitHub MarkdownExporterAttribute.StackOverflow MaxAbsoluteErrorAttribute Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error). Doesn't have a default value. If MaxRelativeError is also provided, the smallest value is used as stop criteria. MaxColumnAttribute MaxIterationCountAttribute Maximum count of target iterations that should be performed The default value is 100 If you set this value to below 15, then MultimodalDistributionAnalyzer is not going to work MaxRelativeErrorAttribute Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error). The default value is 0.02. If MaxAbsoluteError is also provided, the smallest value is used as stop criteria. MaxWarmupCountAttribute Maximum count of warmup iterations that should be performed The default value is 50 MeanColumnAttribute MedianColumnAttribute MediumRunJobAttribute MemoryDiagnoserAttribute MemoryRandomizationAttribute specifies whether Engine should allocate some random-sized memory between iterations it makes [GlobalCleanup] and [GlobalSetup] methods to be executed after every iteration MinColumnAttribute MinInvokeCountAttribute Minimum count of benchmark invocations per iteration. The default value is 4. MinIterationCountAttribute Minimum count of target iterations that should be performed. The default value is 15. If you set this value to below 15, then MultimodalDistributionAnalyzer is not going to work. MinIterationTimeAttribute Minimum time of a single iteration. Unlike Run.IterationTime, this characteristic specifies only the lower limit. In case of need, BenchmarkDotNet can increase this value. The default value is 500 milliseconds. MinWarmupCountAttribute Minimum count of warmup iterations that should be performed The default value is 6 MonoJobAttribute NamespaceColumnAttribute Add a column with the target method namespace. OperatingSystemsArchitectureFilterAttribute OperatingSystemsFilterAttribute OperationsPerSecondAttribute OrdererAttribute OutliersAttribute Specifies which outliers should be removed from the distribution ParamsAllValuesAttribute ParamsAttribute ParamsSourceAttribute PerfCollectProfilerAttribute PlainExporterAttribute PriorityAttribute ProcessCountAttribute How many times we should launch process with target benchmark. Q1ColumnAttribute Q3ColumnAttribute RPlotExporterAttribute RankColumnAttribute ReturnValueValidatorAttribute RunOncePerIterationAttribute Run the benchmark exactly once per iteration. RyuJitX64JobAttribute RyuJitX86JobAttribute ShortRunJobAttribute SimpleJobAttribute SkewnessColumnAttribute StatisticalTestColumnAttribute StdDevColumnAttribute StdErrorColumnAttribute StopOnFirstErrorAttribute determines if running should be stop after first error TargetedAttribute Base class for attributes that are targeted at one or more method(s) ThreadingDiagnoserAttribute UnicodeConsoleLoggerAttribute Enable unicode support in console logger ValidatorConfigBaseAttribute VeryLongRunJobAttribute WakeLockAttribute Placing a WakeLockAttribute on your assembly or class controls whether the Windows system enters sleep or turns off the display while benchmarks run. WarmupCountAttribute How many warmup iterations should be performed. XmlExporterAttribute XmlExporterAttribute.Brief XmlExporterAttribute.BriefCompressed XmlExporterAttribute.Full XmlExporterAttribute.FullCompressed Enums OS"
  },
  "api/BenchmarkDotNet.Attributes.HtmlExporterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.HtmlExporterAttribute.html",
    "title": "Class HtmlExporterAttribute | BenchmarkDotNet",
    "summary": "Class HtmlExporterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class HtmlExporterAttribute : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute HtmlExporterAttribute Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors HtmlExporterAttribute() public HtmlExporterAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.InnerIterationCountAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.InnerIterationCountAttribute.html",
    "title": "Class InnerIterationCountAttribute | BenchmarkDotNet",
    "summary": "Class InnerIterationCountAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Invocation count in a single iteration. Does exactly the same as InvocationCountAttribute, added to make porting from xunit-performance to BenchmarkDotNet easier public class InnerIterationCountAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute InnerIterationCountAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors InnerIterationCountAttribute(int) public InnerIterationCountAttribute(int invocationCount) Parameters invocationCount int"
  },
  "api/BenchmarkDotNet.Attributes.InProcessAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.InProcessAttribute.html",
    "title": "Class InProcessAttribute | BenchmarkDotNet",
    "summary": "Class InProcessAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class InProcessAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute InProcessAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors InProcessAttribute(bool) public InProcessAttribute(bool dontLogOutput = false) Parameters dontLogOutput bool"
  },
  "api/BenchmarkDotNet.Attributes.InvocationCountAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.InvocationCountAttribute.html",
    "title": "Class InvocationCountAttribute | BenchmarkDotNet",
    "summary": "Class InvocationCountAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Invocation count in a single iteration. If specified, IterationTime will be ignored. If specified, it must be a multiple of UnrollFactor. public class InvocationCountAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute InvocationCountAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors InvocationCountAttribute(int, int) public InvocationCountAttribute(int invocationCount, int unrollFactor = 1) Parameters invocationCount int unrollFactor int"
  },
  "api/BenchmarkDotNet.Attributes.IterationCleanupAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.IterationCleanupAttribute.html",
    "title": "Class IterationCleanupAttribute | BenchmarkDotNet",
    "summary": "Class IterationCleanupAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll Marks method to be executed after each benchmark iteration. This should NOT be used for microbenchmarks - please see the docs. [AttributeUsage(AttributeTargets.Method)] public class IterationCleanupAttribute : TargetedAttribute Inheritance object Attribute TargetedAttribute IterationCleanupAttribute Inherited Members TargetedAttribute.Match(MethodInfo) TargetedAttribute.Targets TargetedAttribute.Target Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors IterationCleanupAttribute() public IterationCleanupAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.IterationCountAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.IterationCountAttribute.html",
    "title": "Class IterationCountAttribute | BenchmarkDotNet",
    "summary": "Class IterationCountAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll How many target iterations should be performed If specified, MinIterationCount will be ignored. If specified, MaxIterationCount will be ignored. public class IterationCountAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute IterationCountAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors IterationCountAttribute(int) public IterationCountAttribute(int targetIterationCount) Parameters targetIterationCount int"
  },
  "api/BenchmarkDotNet.Attributes.IterationsColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.IterationsColumnAttribute.html",
    "title": "Class IterationsColumnAttribute | BenchmarkDotNet",
    "summary": "Class IterationsColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class IterationsColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute IterationsColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors IterationsColumnAttribute() public IterationsColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.IterationSetupAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.IterationSetupAttribute.html",
    "title": "Class IterationSetupAttribute | BenchmarkDotNet",
    "summary": "Class IterationSetupAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll Marks method to be executed before each benchmark iteration. This should NOT be used for microbenchmarks - please see the docs. [AttributeUsage(AttributeTargets.Method)] public class IterationSetupAttribute : TargetedAttribute Inheritance object Attribute TargetedAttribute IterationSetupAttribute Inherited Members TargetedAttribute.Match(MethodInfo) TargetedAttribute.Targets TargetedAttribute.Target Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors IterationSetupAttribute() public IterationSetupAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.IterationTimeAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.IterationTimeAttribute.html",
    "title": "Class IterationTimeAttribute | BenchmarkDotNet",
    "summary": "Class IterationTimeAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Desired time of execution of an iteration. Used by Pilot stage to estimate the number of invocations per iteration. The default value is 500 milliseconds. public class IterationTimeAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute IterationTimeAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors IterationTimeAttribute(double) public IterationTimeAttribute(double milliseconds) Parameters milliseconds double"
  },
  "api/BenchmarkDotNet.Attributes.JobConfigBaseAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.JobConfigBaseAttribute.html",
    "title": "Class JobConfigBaseAttribute | BenchmarkDotNet",
    "summary": "Class JobConfigBaseAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class JobConfigBaseAttribute : Attribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute Implements IConfigSource Derived ClrJobAttribute CoreJobAttribute DryClrJobAttribute DryCoreJobAttribute DryJobAttribute DryMonoJobAttribute InProcessAttribute LegacyJitX64JobAttribute LegacyJitX86JobAttribute LongRunJobAttribute MediumRunJobAttribute MonoJobAttribute RyuJitX64JobAttribute RyuJitX86JobAttribute ShortRunJobAttribute SimpleJobAttribute VeryLongRunJobAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors JobConfigBaseAttribute() public JobConfigBaseAttribute() JobConfigBaseAttribute(Job) protected JobConfigBaseAttribute(Job job) Parameters job Job Properties Config public IConfig Config { get; } Property Value IConfig Methods GetJob(Job, RuntimeMoniker, Jit?, Platform?) protected static Job GetJob(Job sourceJob, RuntimeMoniker runtimeMoniker, Jit? jit, Platform? platform) Parameters sourceJob Job runtimeMoniker RuntimeMoniker jit Jit? platform Platform? Returns Job"
  },
  "api/BenchmarkDotNet.Attributes.JobMutatorConfigBaseAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.JobMutatorConfigBaseAttribute.html",
    "title": "Class JobMutatorConfigBaseAttribute | BenchmarkDotNet",
    "summary": "Class JobMutatorConfigBaseAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = false)] public class JobMutatorConfigBaseAttribute : Attribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute Implements IConfigSource Derived EvaluateOverheadAttribute GcConcurrentAttribute GcForceAttribute GcServerAttribute InnerIterationCountAttribute InvocationCountAttribute IterationCountAttribute IterationTimeAttribute MaxAbsoluteErrorAttribute MaxIterationCountAttribute MaxRelativeErrorAttribute MaxWarmupCountAttribute MemoryRandomizationAttribute MinInvokeCountAttribute MinIterationCountAttribute MinIterationTimeAttribute MinWarmupCountAttribute OutliersAttribute ProcessCountAttribute RunOncePerIterationAttribute WarmupCountAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors JobMutatorConfigBaseAttribute() public JobMutatorConfigBaseAttribute() JobMutatorConfigBaseAttribute(Job) protected JobMutatorConfigBaseAttribute(Job job) Parameters job Job Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.JsonExporterAttribute.BriefAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.JsonExporterAttribute.BriefAttribute.html",
    "title": "Class JsonExporterAttribute.BriefAttribute | BenchmarkDotNet",
    "summary": "Class JsonExporterAttribute.BriefAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class JsonExporterAttribute.BriefAttribute : JsonExporterAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute JsonExporterAttribute JsonExporterAttribute.BriefAttribute Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors BriefAttribute() public BriefAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.JsonExporterAttribute.BriefCompressed.html": {
    "href": "api/BenchmarkDotNet.Attributes.JsonExporterAttribute.BriefCompressed.html",
    "title": "Class JsonExporterAttribute.BriefCompressed | BenchmarkDotNet",
    "summary": "Class JsonExporterAttribute.BriefCompressed Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class JsonExporterAttribute.BriefCompressed : JsonExporterAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute JsonExporterAttribute JsonExporterAttribute.BriefCompressed Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors BriefCompressed() public BriefCompressed()"
  },
  "api/BenchmarkDotNet.Attributes.JsonExporterAttribute.Full.html": {
    "href": "api/BenchmarkDotNet.Attributes.JsonExporterAttribute.Full.html",
    "title": "Class JsonExporterAttribute.Full | BenchmarkDotNet",
    "summary": "Class JsonExporterAttribute.Full Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class JsonExporterAttribute.Full : JsonExporterAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute JsonExporterAttribute JsonExporterAttribute.Full Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors Full() public Full()"
  },
  "api/BenchmarkDotNet.Attributes.JsonExporterAttribute.FullCompressed.html": {
    "href": "api/BenchmarkDotNet.Attributes.JsonExporterAttribute.FullCompressed.html",
    "title": "Class JsonExporterAttribute.FullCompressed | BenchmarkDotNet",
    "summary": "Class JsonExporterAttribute.FullCompressed Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class JsonExporterAttribute.FullCompressed : JsonExporterAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute JsonExporterAttribute JsonExporterAttribute.FullCompressed Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors FullCompressed() public FullCompressed()"
  },
  "api/BenchmarkDotNet.Attributes.JsonExporterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.JsonExporterAttribute.html",
    "title": "Class JsonExporterAttribute | BenchmarkDotNet",
    "summary": "Class JsonExporterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class JsonExporterAttribute : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute JsonExporterAttribute Implements IConfigSource Derived JsonExporterAttribute.BriefAttribute JsonExporterAttribute.BriefCompressed JsonExporterAttribute.Full JsonExporterAttribute.FullCompressed Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors JsonExporterAttribute(string, bool, bool) public JsonExporterAttribute(string fileNameSuffix = \"\", bool indentJson = false, bool excludeMeasurements = false) Parameters fileNameSuffix string indentJson bool excludeMeasurements bool"
  },
  "api/BenchmarkDotNet.Attributes.KeepBenchmarkFilesAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.KeepBenchmarkFilesAttribute.html",
    "title": "Class KeepBenchmarkFilesAttribute | BenchmarkDotNet",
    "summary": "Class KeepBenchmarkFilesAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll determines if all auto-generated files should be kept or removed after running the benchmarks [AttributeUsage(AttributeTargets.Class)] public class KeepBenchmarkFilesAttribute : Attribute, IConfigSource Inheritance object Attribute KeepBenchmarkFilesAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors KeepBenchmarkFilesAttribute(bool) public KeepBenchmarkFilesAttribute(bool value = true) Parameters value bool Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.KurtosisColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.KurtosisColumnAttribute.html",
    "title": "Class KurtosisColumnAttribute | BenchmarkDotNet",
    "summary": "Class KurtosisColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class KurtosisColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute KurtosisColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors KurtosisColumnAttribute() public KurtosisColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.LegacyJitX64JobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.LegacyJitX64JobAttribute.html",
    "title": "Class LegacyJitX64JobAttribute | BenchmarkDotNet",
    "summary": "Class LegacyJitX64JobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class LegacyJitX64JobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute LegacyJitX64JobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors LegacyJitX64JobAttribute() public LegacyJitX64JobAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.LegacyJitX86JobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.LegacyJitX86JobAttribute.html",
    "title": "Class LegacyJitX86JobAttribute | BenchmarkDotNet",
    "summary": "Class LegacyJitX86JobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class LegacyJitX86JobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute LegacyJitX86JobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors LegacyJitX86JobAttribute() public LegacyJitX86JobAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.LogicalGroupColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.LogicalGroupColumnAttribute.html",
    "title": "Class LogicalGroupColumnAttribute | BenchmarkDotNet",
    "summary": "Class LogicalGroupColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class LogicalGroupColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute LogicalGroupColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors LogicalGroupColumnAttribute() public LogicalGroupColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.LongRunJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.LongRunJobAttribute.html",
    "title": "Class LongRunJobAttribute | BenchmarkDotNet",
    "summary": "Class LongRunJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class LongRunJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute LongRunJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors LongRunJobAttribute() public LongRunJobAttribute() LongRunJobAttribute(RuntimeMoniker) defines a new LongRun Job that targets specified Framework public LongRunJobAttribute(RuntimeMoniker runtimeMoniker) Parameters runtimeMoniker RuntimeMoniker Target Framework to test. LongRunJobAttribute(RuntimeMoniker, Jit, Platform) defines a new LongRun Job that targets specified Framework, JIT and Platform public LongRunJobAttribute(RuntimeMoniker runtimeMoniker, Jit jit, Platform platform) Parameters runtimeMoniker RuntimeMoniker Target Framework to test. jit Jit Jit to test. platform Platform Platform to test."
  },
  "api/BenchmarkDotNet.Attributes.MarkdownExporterAttribute.Atlassian.html": {
    "href": "api/BenchmarkDotNet.Attributes.MarkdownExporterAttribute.Atlassian.html",
    "title": "Class MarkdownExporterAttribute.Atlassian | BenchmarkDotNet",
    "summary": "Class MarkdownExporterAttribute.Atlassian Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class MarkdownExporterAttribute.Atlassian : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute MarkdownExporterAttribute.Atlassian Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors Atlassian() public Atlassian()"
  },
  "api/BenchmarkDotNet.Attributes.MarkdownExporterAttribute.Default.html": {
    "href": "api/BenchmarkDotNet.Attributes.MarkdownExporterAttribute.Default.html",
    "title": "Class MarkdownExporterAttribute.Default | BenchmarkDotNet",
    "summary": "Class MarkdownExporterAttribute.Default Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class MarkdownExporterAttribute.Default : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute MarkdownExporterAttribute.Default Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors Default() public Default()"
  },
  "api/BenchmarkDotNet.Attributes.MarkdownExporterAttribute.GitHub.html": {
    "href": "api/BenchmarkDotNet.Attributes.MarkdownExporterAttribute.GitHub.html",
    "title": "Class MarkdownExporterAttribute.GitHub | BenchmarkDotNet",
    "summary": "Class MarkdownExporterAttribute.GitHub Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class MarkdownExporterAttribute.GitHub : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute MarkdownExporterAttribute.GitHub Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors GitHub() public GitHub()"
  },
  "api/BenchmarkDotNet.Attributes.MarkdownExporterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MarkdownExporterAttribute.html",
    "title": "Class MarkdownExporterAttribute | BenchmarkDotNet",
    "summary": "Class MarkdownExporterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class MarkdownExporterAttribute : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute MarkdownExporterAttribute Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MarkdownExporterAttribute() public MarkdownExporterAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.MarkdownExporterAttribute.StackOverflow.html": {
    "href": "api/BenchmarkDotNet.Attributes.MarkdownExporterAttribute.StackOverflow.html",
    "title": "Class MarkdownExporterAttribute.StackOverflow | BenchmarkDotNet",
    "summary": "Class MarkdownExporterAttribute.StackOverflow Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class MarkdownExporterAttribute.StackOverflow : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute MarkdownExporterAttribute.StackOverflow Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors StackOverflow() public StackOverflow()"
  },
  "api/BenchmarkDotNet.Attributes.MaxAbsoluteErrorAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MaxAbsoluteErrorAttribute.html",
    "title": "Class MaxAbsoluteErrorAttribute | BenchmarkDotNet",
    "summary": "Class MaxAbsoluteErrorAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error). Doesn't have a default value. If MaxRelativeError is also provided, the smallest value is used as stop criteria. public class MaxAbsoluteErrorAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute MaxAbsoluteErrorAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MaxAbsoluteErrorAttribute(double) public MaxAbsoluteErrorAttribute(double nanoseconds) Parameters nanoseconds double"
  },
  "api/BenchmarkDotNet.Attributes.MaxColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MaxColumnAttribute.html",
    "title": "Class MaxColumnAttribute | BenchmarkDotNet",
    "summary": "Class MaxColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class MaxColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute MaxColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MaxColumnAttribute() public MaxColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.MaxIterationCountAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MaxIterationCountAttribute.html",
    "title": "Class MaxIterationCountAttribute | BenchmarkDotNet",
    "summary": "Class MaxIterationCountAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Maximum count of target iterations that should be performed The default value is 100 If you set this value to below 15, then MultimodalDistributionAnalyzer is not going to work public class MaxIterationCountAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute MaxIterationCountAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MaxIterationCountAttribute(int) public MaxIterationCountAttribute(int maxTargetIterationCount) Parameters maxTargetIterationCount int"
  },
  "api/BenchmarkDotNet.Attributes.MaxRelativeErrorAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MaxRelativeErrorAttribute.html",
    "title": "Class MaxRelativeErrorAttribute | BenchmarkDotNet",
    "summary": "Class MaxRelativeErrorAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error). The default value is 0.02. If MaxAbsoluteError is also provided, the smallest value is used as stop criteria. public class MaxRelativeErrorAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute MaxRelativeErrorAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MaxRelativeErrorAttribute(double) public MaxRelativeErrorAttribute(double maxRelativeError) Parameters maxRelativeError double"
  },
  "api/BenchmarkDotNet.Attributes.MaxWarmupCountAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MaxWarmupCountAttribute.html",
    "title": "Class MaxWarmupCountAttribute | BenchmarkDotNet",
    "summary": "Class MaxWarmupCountAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Maximum count of warmup iterations that should be performed The default value is 50 public class MaxWarmupCountAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute MaxWarmupCountAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MaxWarmupCountAttribute(int, bool) public MaxWarmupCountAttribute(int maxWarmupCount, bool forceAutoWarmup = false) Parameters maxWarmupCount int Maximum count of warmup iterations that should be performed. The default value is 50 forceAutoWarmup bool if set to true, will overwrite WarmupCount of the global config"
  },
  "api/BenchmarkDotNet.Attributes.MeanColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MeanColumnAttribute.html",
    "title": "Class MeanColumnAttribute | BenchmarkDotNet",
    "summary": "Class MeanColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class MeanColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute MeanColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MeanColumnAttribute() public MeanColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.MedianColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MedianColumnAttribute.html",
    "title": "Class MedianColumnAttribute | BenchmarkDotNet",
    "summary": "Class MedianColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class MedianColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute MedianColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MedianColumnAttribute() public MedianColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.MediumRunJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MediumRunJobAttribute.html",
    "title": "Class MediumRunJobAttribute | BenchmarkDotNet",
    "summary": "Class MediumRunJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class MediumRunJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute MediumRunJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MediumRunJobAttribute() public MediumRunJobAttribute() MediumRunJobAttribute(RuntimeMoniker) defines a new MediumRun Job that targets specified Framework public MediumRunJobAttribute(RuntimeMoniker runtimeMoniker) Parameters runtimeMoniker RuntimeMoniker Target Framework to test. MediumRunJobAttribute(RuntimeMoniker, Jit, Platform) defines a new MediumRun Job that targets specified Framework, JIT and Platform public MediumRunJobAttribute(RuntimeMoniker runtimeMoniker, Jit jit, Platform platform) Parameters runtimeMoniker RuntimeMoniker Target Framework to test. jit Jit Jit to test. platform Platform Platform to test."
  },
  "api/BenchmarkDotNet.Attributes.MemoryDiagnoserAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MemoryDiagnoserAttribute.html",
    "title": "Class MemoryDiagnoserAttribute | BenchmarkDotNet",
    "summary": "Class MemoryDiagnoserAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Class)] public class MemoryDiagnoserAttribute : Attribute, IConfigSource Inheritance object Attribute MemoryDiagnoserAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MemoryDiagnoserAttribute(bool) public MemoryDiagnoserAttribute(bool displayGenColumns = true) Parameters displayGenColumns bool Display Garbage Collections per Generation columns (Gen 0, Gen 1, Gen 2). True by default. Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.MemoryRandomizationAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MemoryRandomizationAttribute.html",
    "title": "Class MemoryRandomizationAttribute | BenchmarkDotNet",
    "summary": "Class MemoryRandomizationAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll specifies whether Engine should allocate some random-sized memory between iterations it makes [GlobalCleanup] and [GlobalSetup] methods to be executed after every iteration public class MemoryRandomizationAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute MemoryRandomizationAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MemoryRandomizationAttribute(bool, OutlierMode) public MemoryRandomizationAttribute(bool enable = true, OutlierMode outlierMode = 0) Parameters enable bool outlierMode OutlierMode"
  },
  "api/BenchmarkDotNet.Attributes.MinColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MinColumnAttribute.html",
    "title": "Class MinColumnAttribute | BenchmarkDotNet",
    "summary": "Class MinColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class MinColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute MinColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MinColumnAttribute() public MinColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.MinInvokeCountAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MinInvokeCountAttribute.html",
    "title": "Class MinInvokeCountAttribute | BenchmarkDotNet",
    "summary": "Class MinInvokeCountAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Minimum count of benchmark invocations per iteration. The default value is 4. public class MinInvokeCountAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute MinInvokeCountAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MinInvokeCountAttribute(int) public MinInvokeCountAttribute(int minInvokeCount) Parameters minInvokeCount int"
  },
  "api/BenchmarkDotNet.Attributes.MinIterationCountAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MinIterationCountAttribute.html",
    "title": "Class MinIterationCountAttribute | BenchmarkDotNet",
    "summary": "Class MinIterationCountAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Minimum count of target iterations that should be performed. The default value is 15. If you set this value to below 15, then MultimodalDistributionAnalyzer is not going to work. public class MinIterationCountAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute MinIterationCountAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MinIterationCountAttribute(int) public MinIterationCountAttribute(int minTargetIterationCount) Parameters minTargetIterationCount int"
  },
  "api/BenchmarkDotNet.Attributes.MinIterationTimeAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MinIterationTimeAttribute.html",
    "title": "Class MinIterationTimeAttribute | BenchmarkDotNet",
    "summary": "Class MinIterationTimeAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Minimum time of a single iteration. Unlike Run.IterationTime, this characteristic specifies only the lower limit. In case of need, BenchmarkDotNet can increase this value. The default value is 500 milliseconds. public class MinIterationTimeAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute MinIterationTimeAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MinIterationTimeAttribute(double) public MinIterationTimeAttribute(double milliseconds) Parameters milliseconds double"
  },
  "api/BenchmarkDotNet.Attributes.MinWarmupCountAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MinWarmupCountAttribute.html",
    "title": "Class MinWarmupCountAttribute | BenchmarkDotNet",
    "summary": "Class MinWarmupCountAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Minimum count of warmup iterations that should be performed The default value is 6 public class MinWarmupCountAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute MinWarmupCountAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MinWarmupCountAttribute(int, bool) public MinWarmupCountAttribute(int minWarmupCount, bool forceAutoWarmup = false) Parameters minWarmupCount int Minimum count of warmup iterations that should be performed. The default value is 6 forceAutoWarmup bool if set to true, will overwrite WarmupCount in the global config"
  },
  "api/BenchmarkDotNet.Attributes.MonoJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MonoJobAttribute.html",
    "title": "Class MonoJobAttribute | BenchmarkDotNet",
    "summary": "Class MonoJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class MonoJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute MonoJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MonoJobAttribute(RuntimeMoniker, bool) public MonoJobAttribute(RuntimeMoniker runtimeMoniker, bool baseline = false) Parameters runtimeMoniker RuntimeMoniker baseline bool MonoJobAttribute(bool) public MonoJobAttribute(bool baseline = false) Parameters baseline bool MonoJobAttribute(string, string, bool) public MonoJobAttribute(string name, string path, bool baseline = false) Parameters name string path string baseline bool"
  },
  "api/BenchmarkDotNet.Attributes.MValueColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MValueColumnAttribute.html",
    "title": "Class MValueColumnAttribute | BenchmarkDotNet",
    "summary": "Class MValueColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Prints mvalue. See http://www.brendangregg.com/FrequencyTrails/modes.html public class MValueColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute MValueColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MValueColumnAttribute() public MValueColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.NamespaceColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.NamespaceColumnAttribute.html",
    "title": "Class NamespaceColumnAttribute | BenchmarkDotNet",
    "summary": "Class NamespaceColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Add a column with the target method namespace. public class NamespaceColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute NamespaceColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors NamespaceColumnAttribute() public NamespaceColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.OperatingSystemsArchitectureFilterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.OperatingSystemsArchitectureFilterAttribute.html",
    "title": "Class OperatingSystemsArchitectureFilterAttribute | BenchmarkDotNet",
    "summary": "Class OperatingSystemsArchitectureFilterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class OperatingSystemsArchitectureFilterAttribute : FilterConfigBaseAttribute, IConfigSource Inheritance object Attribute FilterConfigBaseAttribute OperatingSystemsArchitectureFilterAttribute Implements IConfigSource Inherited Members FilterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors OperatingSystemsArchitectureFilterAttribute() public OperatingSystemsArchitectureFilterAttribute() OperatingSystemsArchitectureFilterAttribute(bool, params Architecture[]) public OperatingSystemsArchitectureFilterAttribute(bool allowed, params Architecture[] architectures) Parameters allowed bool if set to true, the architectures are enabled, if set to false, disabled architectures Architecture[] the architecture(s) for which the filter should be applied"
  },
  "api/BenchmarkDotNet.Attributes.OperatingSystemsFilterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.OperatingSystemsFilterAttribute.html",
    "title": "Class OperatingSystemsFilterAttribute | BenchmarkDotNet",
    "summary": "Class OperatingSystemsFilterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class OperatingSystemsFilterAttribute : FilterConfigBaseAttribute, IConfigSource Inheritance object Attribute FilterConfigBaseAttribute OperatingSystemsFilterAttribute Implements IConfigSource Inherited Members FilterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors OperatingSystemsFilterAttribute() public OperatingSystemsFilterAttribute() OperatingSystemsFilterAttribute(bool, params OS[]) public OperatingSystemsFilterAttribute(bool allowed, params OS[] platforms) Parameters allowed bool if set to true, the OSes belonging to platforms are enabled, if set to false, disabled platforms OS[] the platform(s) for which the filter should be applied"
  },
  "api/BenchmarkDotNet.Attributes.OperationsPerSecondAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.OperationsPerSecondAttribute.html",
    "title": "Class OperationsPerSecondAttribute | BenchmarkDotNet",
    "summary": "Class OperationsPerSecondAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class OperationsPerSecondAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute OperationsPerSecondAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors OperationsPerSecondAttribute() public OperationsPerSecondAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.OrdererAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.OrdererAttribute.html",
    "title": "Class OrdererAttribute | BenchmarkDotNet",
    "summary": "Class OrdererAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class OrdererAttribute : Attribute, IConfigSource Inheritance object Attribute OrdererAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors OrdererAttribute(SummaryOrderPolicy, MethodOrderPolicy, JobOrderPolicy) public OrdererAttribute(SummaryOrderPolicy summaryOrderPolicy = SummaryOrderPolicy.Default, MethodOrderPolicy methodOrderPolicy = MethodOrderPolicy.Declared, JobOrderPolicy jobOrderPolicy = JobOrderPolicy.Default) Parameters summaryOrderPolicy SummaryOrderPolicy methodOrderPolicy MethodOrderPolicy jobOrderPolicy JobOrderPolicy Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.OS.html": {
    "href": "api/BenchmarkDotNet.Attributes.OS.html",
    "title": "Enum OS | BenchmarkDotNet",
    "summary": "Enum OS Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public enum OS : byte Fields Browser = 3 WebAssembly Linux = 1 Windows = 0 macOS = 2"
  },
  "api/BenchmarkDotNet.Attributes.OutliersAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.OutliersAttribute.html",
    "title": "Class OutliersAttribute | BenchmarkDotNet",
    "summary": "Class OutliersAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Specifies which outliers should be removed from the distribution public class OutliersAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute OutliersAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors OutliersAttribute(OutlierMode) public OutliersAttribute(OutlierMode outlierMode) Parameters outlierMode OutlierMode"
  },
  "api/BenchmarkDotNet.Attributes.ParamsAllValuesAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ParamsAllValuesAttribute.html",
    "title": "Class ParamsAllValuesAttribute | BenchmarkDotNet",
    "summary": "Class ParamsAllValuesAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll [AttributeUsage(AttributeTargets.Property|AttributeTargets.Field)] public class ParamsAllValuesAttribute : PriorityAttribute Inheritance object Attribute PriorityAttribute ParamsAllValuesAttribute Inherited Members PriorityAttribute.Priority Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ParamsAllValuesAttribute() public ParamsAllValuesAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.ParamsAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ParamsAttribute.html",
    "title": "Class ParamsAttribute | BenchmarkDotNet",
    "summary": "Class ParamsAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll [AttributeUsage(AttributeTargets.Property|AttributeTargets.Field)] public class ParamsAttribute : PriorityAttribute Inheritance object Attribute PriorityAttribute ParamsAttribute Inherited Members PriorityAttribute.Priority Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ParamsAttribute() public ParamsAttribute() ParamsAttribute(params object?[]?) public ParamsAttribute(params object?[]? values) Parameters values object[] Properties Values public object?[] Values { get; protected set; } Property Value object[]"
  },
  "api/BenchmarkDotNet.Attributes.ParamsSourceAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ParamsSourceAttribute.html",
    "title": "Class ParamsSourceAttribute | BenchmarkDotNet",
    "summary": "Class ParamsSourceAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll [AttributeUsage(AttributeTargets.Property|AttributeTargets.Field)] public class ParamsSourceAttribute : PriorityAttribute Inheritance object Attribute PriorityAttribute ParamsSourceAttribute Inherited Members PriorityAttribute.Priority Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ParamsSourceAttribute(string) public ParamsSourceAttribute(string name) Parameters name string ParamsSourceAttribute(Type, string) public ParamsSourceAttribute(Type type, string name) Parameters type Type name string Properties Name public string Name { get; } Property Value string Type public Type? Type { get; } Property Value Type"
  },
  "api/BenchmarkDotNet.Attributes.PerfCollectProfilerAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.PerfCollectProfilerAttribute.html",
    "title": "Class PerfCollectProfilerAttribute | BenchmarkDotNet",
    "summary": "Class PerfCollectProfilerAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class PerfCollectProfilerAttribute : Attribute, IConfigSource Inheritance object Attribute PerfCollectProfilerAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors PerfCollectProfilerAttribute(bool, int) public PerfCollectProfilerAttribute(bool performExtraBenchmarksRun = false, int timeoutInSeconds = 300) Parameters performExtraBenchmarksRun bool When set to true, benchmarks will be executed one more time with the profiler attached. If set to false, there will be no extra run but the results will contain overhead. False by default. timeoutInSeconds int How long should we wait for the perfcollect script to finish processing the trace. 300s by default. Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.PlainExporterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.PlainExporterAttribute.html",
    "title": "Class PlainExporterAttribute | BenchmarkDotNet",
    "summary": "Class PlainExporterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class PlainExporterAttribute : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute PlainExporterAttribute Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors PlainExporterAttribute() public PlainExporterAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.PriorityAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.PriorityAttribute.html",
    "title": "Class PriorityAttribute | BenchmarkDotNet",
    "summary": "Class PriorityAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll public abstract class PriorityAttribute : Attribute Inheritance object Attribute PriorityAttribute Derived ArgumentsAttribute ArgumentsSourceAttribute ParamsAllValuesAttribute ParamsAttribute ParamsSourceAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors PriorityAttribute() protected PriorityAttribute() Properties Priority Defines display order of column in the same category. public int Priority { get; set; } Property Value int"
  },
  "api/BenchmarkDotNet.Attributes.ProcessCountAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ProcessCountAttribute.html",
    "title": "Class ProcessCountAttribute | BenchmarkDotNet",
    "summary": "Class ProcessCountAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll How many times we should launch process with target benchmark. public class ProcessCountAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute ProcessCountAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ProcessCountAttribute(int) public ProcessCountAttribute(int processLaunchCount) Parameters processLaunchCount int"
  },
  "api/BenchmarkDotNet.Attributes.Q1ColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.Q1ColumnAttribute.html",
    "title": "Class Q1ColumnAttribute | BenchmarkDotNet",
    "summary": "Class Q1ColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class Q1ColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute Q1ColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors Q1ColumnAttribute() public Q1ColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.Q3ColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.Q3ColumnAttribute.html",
    "title": "Class Q3ColumnAttribute | BenchmarkDotNet",
    "summary": "Class Q3ColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class Q3ColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute Q3ColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors Q3ColumnAttribute() public Q3ColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.RankColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.RankColumnAttribute.html",
    "title": "Class RankColumnAttribute | BenchmarkDotNet",
    "summary": "Class RankColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class RankColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute RankColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors RankColumnAttribute(NumeralSystem) public RankColumnAttribute(NumeralSystem system = NumeralSystem.Arabic) Parameters system NumeralSystem"
  },
  "api/BenchmarkDotNet.Attributes.ReturnValueValidatorAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ReturnValueValidatorAttribute.html",
    "title": "Class ReturnValueValidatorAttribute | BenchmarkDotNet",
    "summary": "Class ReturnValueValidatorAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class ReturnValueValidatorAttribute : ValidatorConfigBaseAttribute, IConfigSource Inheritance object Attribute ValidatorConfigBaseAttribute ReturnValueValidatorAttribute Implements IConfigSource Inherited Members ValidatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ReturnValueValidatorAttribute() public ReturnValueValidatorAttribute() ReturnValueValidatorAttribute(bool) public ReturnValueValidatorAttribute(bool failOnError) Parameters failOnError bool"
  },
  "api/BenchmarkDotNet.Attributes.RPlotExporterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.RPlotExporterAttribute.html",
    "title": "Class RPlotExporterAttribute | BenchmarkDotNet",
    "summary": "Class RPlotExporterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class RPlotExporterAttribute : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute RPlotExporterAttribute Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors RPlotExporterAttribute() public RPlotExporterAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.RunOncePerIterationAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.RunOncePerIterationAttribute.html",
    "title": "Class RunOncePerIterationAttribute | BenchmarkDotNet",
    "summary": "Class RunOncePerIterationAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Run the benchmark exactly once per iteration. public class RunOncePerIterationAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute RunOncePerIterationAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors RunOncePerIterationAttribute() public RunOncePerIterationAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.RyuJitX64JobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.RyuJitX64JobAttribute.html",
    "title": "Class RyuJitX64JobAttribute | BenchmarkDotNet",
    "summary": "Class RyuJitX64JobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class RyuJitX64JobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute RyuJitX64JobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors RyuJitX64JobAttribute() public RyuJitX64JobAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.RyuJitX86JobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.RyuJitX86JobAttribute.html",
    "title": "Class RyuJitX86JobAttribute | BenchmarkDotNet",
    "summary": "Class RyuJitX86JobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class RyuJitX86JobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute RyuJitX86JobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors RyuJitX86JobAttribute() public RyuJitX86JobAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.ShortRunJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ShortRunJobAttribute.html",
    "title": "Class ShortRunJobAttribute | BenchmarkDotNet",
    "summary": "Class ShortRunJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class ShortRunJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute ShortRunJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ShortRunJobAttribute() public ShortRunJobAttribute() ShortRunJobAttribute(RuntimeMoniker) defines a new ShortRun Job that targets specified Framework public ShortRunJobAttribute(RuntimeMoniker runtimeMoniker) Parameters runtimeMoniker RuntimeMoniker Target Framework to test. ShortRunJobAttribute(RuntimeMoniker, Jit, Platform) defines a new ShortRun Job that targets specified Framework, JIT and Platform public ShortRunJobAttribute(RuntimeMoniker runtimeMoniker, Jit jit, Platform platform) Parameters runtimeMoniker RuntimeMoniker Target Framework to test. jit Jit Jit to test. platform Platform Platform to test."
  },
  "api/BenchmarkDotNet.Attributes.SimpleJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.SimpleJobAttribute.html",
    "title": "Class SimpleJobAttribute | BenchmarkDotNet",
    "summary": "Class SimpleJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class SimpleJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute SimpleJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors SimpleJobAttribute(RunStrategy, RuntimeMoniker, int, int, int, int, string?, bool) public SimpleJobAttribute(RunStrategy runStrategy, RuntimeMoniker runtimeMoniker, int launchCount = -1, int warmupCount = -1, int iterationCount = -1, int invocationCount = -1, string? id = null, bool baseline = false) Parameters runStrategy RunStrategy runtimeMoniker RuntimeMoniker launchCount int warmupCount int iterationCount int invocationCount int id string baseline bool SimpleJobAttribute(RunStrategy, int, int, int, int, string?, bool) public SimpleJobAttribute(RunStrategy runStrategy, int launchCount = -1, int warmupCount = -1, int iterationCount = -1, int invocationCount = -1, string? id = null, bool baseline = false) Parameters runStrategy RunStrategy launchCount int warmupCount int iterationCount int invocationCount int id string baseline bool SimpleJobAttribute(RuntimeMoniker, int, int, int, int, string?, bool) public SimpleJobAttribute(RuntimeMoniker runtimeMoniker, int launchCount = -1, int warmupCount = -1, int iterationCount = -1, int invocationCount = -1, string? id = null, bool baseline = false) Parameters runtimeMoniker RuntimeMoniker launchCount int warmupCount int iterationCount int invocationCount int id string baseline bool SimpleJobAttribute(int, int, int, int, string?, bool) public SimpleJobAttribute(int launchCount = -1, int warmupCount = -1, int iterationCount = -1, int invocationCount = -1, string? id = null, bool baseline = false) Parameters launchCount int warmupCount int iterationCount int invocationCount int id string baseline bool"
  },
  "api/BenchmarkDotNet.Attributes.SkewnessColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.SkewnessColumnAttribute.html",
    "title": "Class SkewnessColumnAttribute | BenchmarkDotNet",
    "summary": "Class SkewnessColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class SkewnessColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute SkewnessColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors SkewnessColumnAttribute() public SkewnessColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.StatisticalTestColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.StatisticalTestColumnAttribute.html",
    "title": "Class StatisticalTestColumnAttribute | BenchmarkDotNet",
    "summary": "Class StatisticalTestColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class StatisticalTestColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute StatisticalTestColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors StatisticalTestColumnAttribute() public StatisticalTestColumnAttribute() StatisticalTestColumnAttribute(string) public StatisticalTestColumnAttribute(string threshold) Parameters threshold string StatisticalTestColumnAttribute(string, SignificanceLevel) public StatisticalTestColumnAttribute(string threshold, SignificanceLevel significanceLevel) Parameters threshold string significanceLevel SignificanceLevel"
  },
  "api/BenchmarkDotNet.Attributes.StdDevColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.StdDevColumnAttribute.html",
    "title": "Class StdDevColumnAttribute | BenchmarkDotNet",
    "summary": "Class StdDevColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class StdDevColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute StdDevColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors StdDevColumnAttribute() public StdDevColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.StdErrorColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.StdErrorColumnAttribute.html",
    "title": "Class StdErrorColumnAttribute | BenchmarkDotNet",
    "summary": "Class StdErrorColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class StdErrorColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute StdErrorColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors StdErrorColumnAttribute() public StdErrorColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.StopOnFirstErrorAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.StopOnFirstErrorAttribute.html",
    "title": "Class StopOnFirstErrorAttribute | BenchmarkDotNet",
    "summary": "Class StopOnFirstErrorAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll determines if running should be stop after first error [AttributeUsage(AttributeTargets.Class)] public class StopOnFirstErrorAttribute : Attribute, IConfigSource Inheritance object Attribute StopOnFirstErrorAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors StopOnFirstErrorAttribute(bool) public StopOnFirstErrorAttribute(bool value = true) Parameters value bool Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.TargetedAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.TargetedAttribute.html",
    "title": "Class TargetedAttribute | BenchmarkDotNet",
    "summary": "Class TargetedAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll Base class for attributes that are targeted at one or more method(s) public abstract class TargetedAttribute : Attribute Inheritance object Attribute TargetedAttribute Derived GlobalCleanupAttribute GlobalSetupAttribute IterationCleanupAttribute IterationSetupAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors TargetedAttribute() protected TargetedAttribute() Properties Target Target method for attribute public string Target { get; set; } Property Value string Targets public string[] Targets { get; set; } Property Value string[] Methods Match(MethodInfo) public bool Match(MethodInfo method) Parameters method MethodInfo Returns bool"
  },
  "api/BenchmarkDotNet.Attributes.ThreadingDiagnoserAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ThreadingDiagnoserAttribute.html",
    "title": "Class ThreadingDiagnoserAttribute | BenchmarkDotNet",
    "summary": "Class ThreadingDiagnoserAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Class)] public class ThreadingDiagnoserAttribute : Attribute, IConfigSource Inheritance object Attribute ThreadingDiagnoserAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ThreadingDiagnoserAttribute(bool, bool) public ThreadingDiagnoserAttribute(bool displayLockContentionWhenZero = true, bool displayCompletedWorkItemCountWhenZero = true) Parameters displayLockContentionWhenZero bool Display configuration for 'LockContentionCount' when it is empty. True (displayed) by default. displayCompletedWorkItemCountWhenZero bool Display configuration for 'CompletedWorkItemCount' when it is empty. True (displayed) by default. Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.UnicodeConsoleLoggerAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.UnicodeConsoleLoggerAttribute.html",
    "title": "Class UnicodeConsoleLoggerAttribute | BenchmarkDotNet",
    "summary": "Class UnicodeConsoleLoggerAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Enable unicode support in console logger [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class UnicodeConsoleLoggerAttribute : Attribute, IConfigSource Inheritance object Attribute UnicodeConsoleLoggerAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors UnicodeConsoleLoggerAttribute() public UnicodeConsoleLoggerAttribute() Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.ValidatorConfigBaseAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ValidatorConfigBaseAttribute.html",
    "title": "Class ValidatorConfigBaseAttribute | BenchmarkDotNet",
    "summary": "Class ValidatorConfigBaseAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public abstract class ValidatorConfigBaseAttribute : Attribute, IConfigSource Inheritance object Attribute ValidatorConfigBaseAttribute Implements IConfigSource Derived ExecutionValidatorAttribute ReturnValueValidatorAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ValidatorConfigBaseAttribute() protected ValidatorConfigBaseAttribute() ValidatorConfigBaseAttribute(params IValidator[]) protected ValidatorConfigBaseAttribute(params IValidator[] validators) Parameters validators IValidator[] Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.VeryLongRunJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.VeryLongRunJobAttribute.html",
    "title": "Class VeryLongRunJobAttribute | BenchmarkDotNet",
    "summary": "Class VeryLongRunJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class VeryLongRunJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute VeryLongRunJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors VeryLongRunJobAttribute() public VeryLongRunJobAttribute() VeryLongRunJobAttribute(RuntimeMoniker) defines a new VeryLongRun Job that targets specified Framework public VeryLongRunJobAttribute(RuntimeMoniker runtimeMoniker) Parameters runtimeMoniker RuntimeMoniker Target Framework to test. VeryLongRunJobAttribute(RuntimeMoniker, Jit, Platform) defines a new VeryLongRun Job that targets specified Framework, JIT and Platform public VeryLongRunJobAttribute(RuntimeMoniker runtimeMoniker, Jit jit, Platform platform) Parameters runtimeMoniker RuntimeMoniker Target Framework to test. jit Jit Jit to test. platform Platform Platform to test."
  },
  "api/BenchmarkDotNet.Attributes.WakeLockAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.WakeLockAttribute.html",
    "title": "Class WakeLockAttribute | BenchmarkDotNet",
    "summary": "Class WakeLockAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Placing a WakeLockAttribute on your assembly or class controls whether the Windows system enters sleep or turns off the display while benchmarks run. [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public sealed class WakeLockAttribute : Attribute, IConfigSource Inheritance object Attribute WakeLockAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors WakeLockAttribute(WakeLockType) public WakeLockAttribute(WakeLockType wakeLockType) Parameters wakeLockType WakeLockType Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.WarmupCountAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.WarmupCountAttribute.html",
    "title": "Class WarmupCountAttribute | BenchmarkDotNet",
    "summary": "Class WarmupCountAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll How many warmup iterations should be performed. public class WarmupCountAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute WarmupCountAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors WarmupCountAttribute(int) public WarmupCountAttribute(int warmupCount) Parameters warmupCount int"
  },
  "api/BenchmarkDotNet.Attributes.XmlExporterAttribute.Brief.html": {
    "href": "api/BenchmarkDotNet.Attributes.XmlExporterAttribute.Brief.html",
    "title": "Class XmlExporterAttribute.Brief | BenchmarkDotNet",
    "summary": "Class XmlExporterAttribute.Brief Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class XmlExporterAttribute.Brief : XmlExporterAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute XmlExporterAttribute XmlExporterAttribute.Brief Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors Brief() public Brief()"
  },
  "api/BenchmarkDotNet.Attributes.XmlExporterAttribute.BriefCompressed.html": {
    "href": "api/BenchmarkDotNet.Attributes.XmlExporterAttribute.BriefCompressed.html",
    "title": "Class XmlExporterAttribute.BriefCompressed | BenchmarkDotNet",
    "summary": "Class XmlExporterAttribute.BriefCompressed Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class XmlExporterAttribute.BriefCompressed : XmlExporterAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute XmlExporterAttribute XmlExporterAttribute.BriefCompressed Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors BriefCompressed() public BriefCompressed()"
  },
  "api/BenchmarkDotNet.Attributes.XmlExporterAttribute.Full.html": {
    "href": "api/BenchmarkDotNet.Attributes.XmlExporterAttribute.Full.html",
    "title": "Class XmlExporterAttribute.Full | BenchmarkDotNet",
    "summary": "Class XmlExporterAttribute.Full Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class XmlExporterAttribute.Full : XmlExporterAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute XmlExporterAttribute XmlExporterAttribute.Full Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors Full() public Full()"
  },
  "api/BenchmarkDotNet.Attributes.XmlExporterAttribute.FullCompressed.html": {
    "href": "api/BenchmarkDotNet.Attributes.XmlExporterAttribute.FullCompressed.html",
    "title": "Class XmlExporterAttribute.FullCompressed | BenchmarkDotNet",
    "summary": "Class XmlExporterAttribute.FullCompressed Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class XmlExporterAttribute.FullCompressed : XmlExporterAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute XmlExporterAttribute XmlExporterAttribute.FullCompressed Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors FullCompressed() public FullCompressed()"
  },
  "api/BenchmarkDotNet.Attributes.XmlExporterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.XmlExporterAttribute.html",
    "title": "Class XmlExporterAttribute | BenchmarkDotNet",
    "summary": "Class XmlExporterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class XmlExporterAttribute : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute XmlExporterAttribute Implements IConfigSource Derived XmlExporterAttribute.Brief XmlExporterAttribute.BriefCompressed XmlExporterAttribute.Full XmlExporterAttribute.FullCompressed Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors XmlExporterAttribute(string, bool, bool) public XmlExporterAttribute(string fileNameSuffix = \"\", bool indentXml = false, bool excludeMeasurements = false) Parameters fileNameSuffix string indentXml bool excludeMeasurements bool"
  },
  "api/BenchmarkDotNet.Characteristics.Characteristic-1.html": {
    "href": "api/BenchmarkDotNet.Characteristics.Characteristic-1.html",
    "title": "Class Characteristic<T> | BenchmarkDotNet",
    "summary": "Class Characteristic<T> Namespace BenchmarkDotNet.Characteristics Assembly BenchmarkDotNet.dll public class Characteristic<T> : Characteristic Type Parameters T Inheritance object Characteristic Characteristic<T> Inherited Members Characteristic.EmptyValue Characteristic.Create<TOwner, T>(string) Characteristic.Create<TOwner, T>(string, T) Characteristic.Create<TOwner, T>(string, Func<CharacteristicObject, T, T>, T, bool) Characteristic.CreateHidden<TOwner, T>(string) Characteristic.CreateIgnoreOnApply<TOwner, T>(string) Characteristic.ToString() Characteristic.Id Characteristic.FullId Characteristic.IgnoreOnApply Characteristic.DontShowInSummary Characteristic.CharacteristicType Characteristic.DeclaringType Characteristic.HasChildCharacteristics Extension Methods CharacteristicHelper.IsPresentableCharacteristic(Characteristic, bool) Properties FallbackValue public T FallbackValue { get; } Property Value T this[CharacteristicObject] public T this[CharacteristicObject obj] { get; set; } Parameters obj CharacteristicObject Property Value T"
  },
  "api/BenchmarkDotNet.Characteristics.Characteristic.html": {
    "href": "api/BenchmarkDotNet.Characteristics.Characteristic.html",
    "title": "Class Characteristic | BenchmarkDotNet",
    "summary": "Class Characteristic Namespace BenchmarkDotNet.Characteristics Assembly BenchmarkDotNet.dll public abstract class Characteristic Inheritance object Characteristic Derived Characteristic<T> Extension Methods CharacteristicHelper.IsPresentableCharacteristic(Characteristic, bool) Constructors Characteristic(string, Type, Type, object, bool, bool) protected Characteristic(string id, Type characteristicType, Type declaringType, object fallbackValue, bool ignoreOnApply, bool dontShowInSummary = false) Parameters id string characteristicType Type declaringType Type fallbackValue object ignoreOnApply bool dontShowInSummary bool Fields EmptyValue public static readonly object EmptyValue Field Value object Properties CharacteristicType public Type CharacteristicType { get; } Property Value Type DeclaringType public Type DeclaringType { get; } Property Value Type DontShowInSummary public bool DontShowInSummary { get; } Property Value bool FullId public string FullId { get; } Property Value string HasChildCharacteristics public bool HasChildCharacteristics { get; } Property Value bool Id public string Id { get; } Property Value string IgnoreOnApply public bool IgnoreOnApply { get; } Property Value bool this[CharacteristicObject] public object? this[CharacteristicObject obj] { get; set; } Parameters obj CharacteristicObject Property Value object Methods CreateHidden<TOwner, T>(string) public static Characteristic<T> CreateHidden<TOwner, T>(string memberName) where TOwner : CharacteristicObject Parameters memberName string Returns Characteristic<T> Type Parameters TOwner T CreateIgnoreOnApply<TOwner, T>(string) public static Characteristic<T> CreateIgnoreOnApply<TOwner, T>(string memberName) where TOwner : CharacteristicObject Parameters memberName string Returns Characteristic<T> Type Parameters TOwner T Create<TOwner, T>(string) public static Characteristic<T> Create<TOwner, T>(string memberName) where TOwner : CharacteristicObject Parameters memberName string Returns Characteristic<T> Type Parameters TOwner T Create<TOwner, T>(string, Func<CharacteristicObject, T, T>, T, bool) public static Characteristic<T> Create<TOwner, T>(string memberName, Func<CharacteristicObject, T, T> resolver, T fallbackValue, bool ignoreOnApply) where TOwner : CharacteristicObject Parameters memberName string resolver Func<CharacteristicObject, T, T> fallbackValue T ignoreOnApply bool Returns Characteristic<T> Type Parameters TOwner T Create<TOwner, T>(string, T) public static Characteristic<T> Create<TOwner, T>(string memberName, T fallbackValue) where TOwner : CharacteristicObject Parameters memberName string fallbackValue T Returns Characteristic<T> Type Parameters TOwner T ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Characteristics.CharacteristicHelper.html": {
    "href": "api/BenchmarkDotNet.Characteristics.CharacteristicHelper.html",
    "title": "Class CharacteristicHelper | BenchmarkDotNet",
    "summary": "Class CharacteristicHelper Namespace BenchmarkDotNet.Characteristics Assembly BenchmarkDotNet.dll public static class CharacteristicHelper Inheritance object CharacteristicHelper Methods GetAllCharacteristics(CharacteristicObject) public static IReadOnlyList<Characteristic> GetAllCharacteristics(this CharacteristicObject obj) Parameters obj CharacteristicObject Returns IReadOnlyList<Characteristic> GetAllCharacteristics(Type) public static IReadOnlyList<Characteristic> GetAllCharacteristics(Type characteristicObjectType) Parameters characteristicObjectType Type Returns IReadOnlyList<Characteristic> GetAllPresentableCharacteristics(Type, bool) public static IReadOnlyList<Characteristic> GetAllPresentableCharacteristics(Type characteristicObjectType, bool includeIgnoreOnApply = false) Parameters characteristicObjectType Type includeIgnoreOnApply bool Returns IReadOnlyList<Characteristic> GetThisTypeCharacteristics(CharacteristicObject) public static IReadOnlyList<Characteristic> GetThisTypeCharacteristics(this CharacteristicObject obj) Parameters obj CharacteristicObject Returns IReadOnlyList<Characteristic> GetThisTypeCharacteristics(Type) public static IReadOnlyList<Characteristic> GetThisTypeCharacteristics(Type characteristicObjectType) Parameters characteristicObjectType Type Returns IReadOnlyList<Characteristic> IsPresentableCharacteristic(Characteristic, bool) public static bool IsPresentableCharacteristic(this Characteristic c, bool includeIgnoreOnApply = false) Parameters c Characteristic includeIgnoreOnApply bool Returns bool"
  },
  "api/BenchmarkDotNet.Characteristics.CharacteristicObject-1.html": {
    "href": "api/BenchmarkDotNet.Characteristics.CharacteristicObject-1.html",
    "title": "Class CharacteristicObject<T> | BenchmarkDotNet",
    "summary": "Class CharacteristicObject<T> Namespace BenchmarkDotNet.Characteristics Assembly BenchmarkDotNet.dll public abstract class CharacteristicObject<T> : CharacteristicObject where T : CharacteristicObject<T>, new() Type Parameters T Inheritance object CharacteristicObject CharacteristicObject<T> Derived CharacteristicSet JobMode<T> Inherited Members CharacteristicObject.IdCharacteristic CharacteristicObject.ResolveId(CharacteristicObject, string) CharacteristicObject.GetCharacteristicsWithValues() CharacteristicObject.HasValue(Characteristic) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver, T) CharacteristicObject.ResolveValue(Characteristic, IResolver) CharacteristicObject.ResolveValue(Characteristic, IResolver, object) CharacteristicObject.ResolveValue<T>(Characteristic<T>, T) CharacteristicObject.ResolveValue(Characteristic, object) CharacteristicObject.ResolveValueAsNullable<T>(Characteristic<T>) CharacteristicObject.ApplyCore(CharacteristicObject) CharacteristicObject.FreezeCore() CharacteristicObject.UnfreezeCopyCore() CharacteristicObject.ToString() CharacteristicObject.OwnerOrSelf CharacteristicObject.Frozen CharacteristicObject.IsPropertyBag CharacteristicObject.HasChanges CharacteristicObject.Id Extension Methods CharacteristicHelper.GetAllCharacteristics(CharacteristicObject) CharacteristicHelper.GetThisTypeCharacteristics(CharacteristicObject) Constructors CharacteristicObject() protected CharacteristicObject() CharacteristicObject(string?) protected CharacteristicObject(string? id) Parameters id string Methods Apply(CharacteristicObject) public T Apply(CharacteristicObject other) Parameters other CharacteristicObject Returns T Apply(params CharacteristicObject[]) public T Apply(params CharacteristicObject[] others) Parameters others CharacteristicObject[] Returns T ApplyAndFreeze(CharacteristicObject) public T ApplyAndFreeze(CharacteristicObject other) Parameters other CharacteristicObject Returns T ApplyAndFreeze(params CharacteristicObject[]) public T ApplyAndFreeze(params CharacteristicObject[] others) Parameters others CharacteristicObject[] Returns T CreateCharacteristic<TC>(string) protected static Characteristic<TC> CreateCharacteristic<TC>(string memberName) Parameters memberName string Returns Characteristic<TC> Type Parameters TC CreateHiddenCharacteristic<TC>(string) protected static Characteristic<TC> CreateHiddenCharacteristic<TC>(string memberName) Parameters memberName string Returns Characteristic<TC> Type Parameters TC CreateIgnoreOnApplyCharacteristic<TC>(string) protected static Characteristic<TC> CreateIgnoreOnApplyCharacteristic<TC>(string memberName) Parameters memberName string Returns Characteristic<TC> Type Parameters TC Freeze() public T Freeze() Returns T UnfreezeCopy() public T UnfreezeCopy() Returns T"
  },
  "api/BenchmarkDotNet.Characteristics.CharacteristicObject.html": {
    "href": "api/BenchmarkDotNet.Characteristics.CharacteristicObject.html",
    "title": "Class CharacteristicObject | BenchmarkDotNet",
    "summary": "Class CharacteristicObject Namespace BenchmarkDotNet.Characteristics Assembly BenchmarkDotNet.dll public abstract class CharacteristicObject Inheritance object CharacteristicObject Derived CharacteristicObject<T> Extension Methods CharacteristicHelper.GetAllCharacteristics(CharacteristicObject) CharacteristicHelper.GetThisTypeCharacteristics(CharacteristicObject) Constructors CharacteristicObject() protected CharacteristicObject() CharacteristicObject(string?) protected CharacteristicObject(string? id) Parameters id string Fields IdCharacteristic public static readonly Characteristic<string> IdCharacteristic Field Value Characteristic<string> Properties Frozen public bool Frozen { get; } Property Value bool HasChanges public bool HasChanges { get; } Property Value bool Id public string Id { get; } Property Value string IsPropertyBag protected virtual bool IsPropertyBag { get; } Property Value bool OwnerOrSelf protected CharacteristicObject OwnerOrSelf { get; } Property Value CharacteristicObject Methods Apply(CharacteristicObject) public void Apply(CharacteristicObject other) Parameters other CharacteristicObject ApplyCore(CharacteristicObject) protected CharacteristicObject ApplyCore(CharacteristicObject other) Parameters other CharacteristicObject Returns CharacteristicObject Freeze() public void Freeze() FreezeCore() protected CharacteristicObject FreezeCore() Returns CharacteristicObject GetCharacteristicsWithValues() public IEnumerable<Characteristic> GetCharacteristicsWithValues() Returns IEnumerable<Characteristic> HasValue(Characteristic) public bool HasValue(Characteristic characteristic) Parameters characteristic Characteristic Returns bool ResolveId(CharacteristicObject, string) protected static string ResolveId(CharacteristicObject obj, string actual) Parameters obj CharacteristicObject actual string Returns string ResolveValue(Characteristic, IResolver) public object ResolveValue(Characteristic characteristic, IResolver resolver) Parameters characteristic Characteristic resolver IResolver Returns object ResolveValue(Characteristic, IResolver, object) public object ResolveValue(Characteristic characteristic, IResolver resolver, object defaultValue) Parameters characteristic Characteristic resolver IResolver defaultValue object Returns object ResolveValue(Characteristic, object) public object ResolveValue(Characteristic characteristic, object defaultValue) Parameters characteristic Characteristic defaultValue object Returns object ResolveValueAsNullable<T>(Characteristic<T>) public T? ResolveValueAsNullable<T>(Characteristic<T> characteristic) where T : struct Parameters characteristic Characteristic<T> Returns T? Type Parameters T ResolveValue<T>(Characteristic<T>, IResolver) public T ResolveValue<T>(Characteristic<T> characteristic, IResolver resolver) Parameters characteristic Characteristic<T> resolver IResolver Returns T Type Parameters T ResolveValue<T>(Characteristic<T>, IResolver, T) public T ResolveValue<T>(Characteristic<T> characteristic, IResolver resolver, T defaultValue) Parameters characteristic Characteristic<T> resolver IResolver defaultValue T Returns T Type Parameters T ResolveValue<T>(Characteristic<T>, T) public T ResolveValue<T>(Characteristic<T> characteristic, T defaultValue) Parameters characteristic Characteristic<T> defaultValue T Returns T Type Parameters T ToString() public override string ToString() Returns string UnfreezeCopy() public CharacteristicObject UnfreezeCopy() Returns CharacteristicObject UnfreezeCopyCore() protected CharacteristicObject UnfreezeCopyCore() Returns CharacteristicObject"
  },
  "api/BenchmarkDotNet.Characteristics.CharacteristicPresenter.html": {
    "href": "api/BenchmarkDotNet.Characteristics.CharacteristicPresenter.html",
    "title": "Class CharacteristicPresenter | BenchmarkDotNet",
    "summary": "Class CharacteristicPresenter Namespace BenchmarkDotNet.Characteristics Assembly BenchmarkDotNet.dll public abstract class CharacteristicPresenter Inheritance object CharacteristicPresenter Constructors CharacteristicPresenter() protected CharacteristicPresenter() Fields DefaultPresenter public static readonly CharacteristicPresenter DefaultPresenter Field Value CharacteristicPresenter FolderPresenter public static readonly CharacteristicPresenter FolderPresenter Field Value CharacteristicPresenter SourceCodePresenter public static readonly CharacteristicPresenter SourceCodePresenter Field Value CharacteristicPresenter SummaryPresenter public static readonly CharacteristicPresenter SummaryPresenter Field Value CharacteristicPresenter Methods ToPresentation(CharacteristicObject, Characteristic) public abstract string ToPresentation(CharacteristicObject obj, Characteristic characteristic) Parameters obj CharacteristicObject characteristic Characteristic Returns string ToPresentation(object, Characteristic) public abstract string ToPresentation(object characteristicValue, Characteristic characteristic) Parameters characteristicValue object characteristic Characteristic Returns string"
  },
  "api/BenchmarkDotNet.Characteristics.CharacteristicSet.html": {
    "href": "api/BenchmarkDotNet.Characteristics.CharacteristicSet.html",
    "title": "Class CharacteristicSet | BenchmarkDotNet",
    "summary": "Class CharacteristicSet Namespace BenchmarkDotNet.Characteristics Assembly BenchmarkDotNet.dll public sealed class CharacteristicSet : CharacteristicObject<CharacteristicSet> Inheritance object CharacteristicObject CharacteristicObject<CharacteristicSet> CharacteristicSet Inherited Members CharacteristicObject<CharacteristicSet>.Apply(CharacteristicObject) CharacteristicObject<CharacteristicSet>.Apply(params CharacteristicObject[]) CharacteristicObject<CharacteristicSet>.ApplyAndFreeze(CharacteristicObject) CharacteristicObject<CharacteristicSet>.ApplyAndFreeze(params CharacteristicObject[]) CharacteristicObject<CharacteristicSet>.Freeze() CharacteristicObject<CharacteristicSet>.UnfreezeCopy() CharacteristicObject.IdCharacteristic CharacteristicObject.GetCharacteristicsWithValues() CharacteristicObject.HasValue(Characteristic) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver, T) CharacteristicObject.ResolveValue(Characteristic, IResolver) CharacteristicObject.ResolveValue(Characteristic, IResolver, object) CharacteristicObject.ResolveValue<T>(Characteristic<T>, T) CharacteristicObject.ResolveValue(Characteristic, object) CharacteristicObject.ResolveValueAsNullable<T>(Characteristic<T>) CharacteristicObject.ToString() CharacteristicObject.Frozen CharacteristicObject.HasChanges CharacteristicObject.Id Extension Methods CharacteristicHelper.GetAllCharacteristics(CharacteristicObject) CharacteristicHelper.GetThisTypeCharacteristics(CharacteristicObject) Constructors CharacteristicSet() public CharacteristicSet() CharacteristicSet(CharacteristicObject) public CharacteristicSet(CharacteristicObject other) Parameters other CharacteristicObject CharacteristicSet(params CharacteristicObject[]) public CharacteristicSet(params CharacteristicObject[] others) Parameters others CharacteristicObject[] Properties IsPropertyBag protected override bool IsPropertyBag { get; } Property Value bool"
  },
  "api/BenchmarkDotNet.Characteristics.CharacteristicSetPresenter.html": {
    "href": "api/BenchmarkDotNet.Characteristics.CharacteristicSetPresenter.html",
    "title": "Class CharacteristicSetPresenter | BenchmarkDotNet",
    "summary": "Class CharacteristicSetPresenter Namespace BenchmarkDotNet.Characteristics Assembly BenchmarkDotNet.dll public abstract class CharacteristicSetPresenter Inheritance object CharacteristicSetPresenter Constructors CharacteristicSetPresenter() protected CharacteristicSetPresenter() Fields Default public static readonly CharacteristicSetPresenter Default Field Value CharacteristicSetPresenter Display public static readonly CharacteristicSetPresenter Display Field Value CharacteristicSetPresenter Folder public static readonly CharacteristicSetPresenter Folder Field Value CharacteristicSetPresenter SourceCode public static readonly CharacteristicSetPresenter SourceCode Field Value CharacteristicSetPresenter Methods GetPresentableCharacteristics(CharacteristicObject, bool) protected virtual IEnumerable<Characteristic> GetPresentableCharacteristics(CharacteristicObject obj, bool includeIgnoreOnApply = false) Parameters obj CharacteristicObject includeIgnoreOnApply bool Returns IEnumerable<Characteristic> ToPresentation(CharacteristicObject) public abstract string ToPresentation(CharacteristicObject obj) Parameters obj CharacteristicObject Returns string"
  },
  "api/BenchmarkDotNet.Characteristics.CompositeResolver.html": {
    "href": "api/BenchmarkDotNet.Characteristics.CompositeResolver.html",
    "title": "Class CompositeResolver | BenchmarkDotNet",
    "summary": "Class CompositeResolver Namespace BenchmarkDotNet.Characteristics Assembly BenchmarkDotNet.dll public class CompositeResolver : IResolver Inheritance object CompositeResolver Implements IResolver Constructors CompositeResolver(params IResolver[]) public CompositeResolver(params IResolver[] resolvers) Parameters resolvers IResolver[] Methods CanResolve(Characteristic) public bool CanResolve(Characteristic characteristic) Parameters characteristic Characteristic Returns bool Resolve(CharacteristicObject, Characteristic) public object Resolve(CharacteristicObject obj, Characteristic characteristic) Parameters obj CharacteristicObject characteristic Characteristic Returns object Resolve(CharacteristicObject, Characteristic, object) public object Resolve(CharacteristicObject obj, Characteristic characteristic, object defaultValue) Parameters obj CharacteristicObject characteristic Characteristic defaultValue object Returns object Resolve<T>(CharacteristicObject, Characteristic<T>) public T Resolve<T>(CharacteristicObject obj, Characteristic<T> characteristic) Parameters obj CharacteristicObject characteristic Characteristic<T> Returns T Type Parameters T Resolve<T>(CharacteristicObject, Characteristic<T>, T) public T Resolve<T>(CharacteristicObject obj, Characteristic<T> characteristic, T defaultValue) Parameters obj CharacteristicObject characteristic Characteristic<T> defaultValue T Returns T Type Parameters T"
  },
  "api/BenchmarkDotNet.Characteristics.html": {
    "href": "api/BenchmarkDotNet.Characteristics.html",
    "title": "Namespace BenchmarkDotNet.Characteristics | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Characteristics Classes Characteristic CharacteristicHelper CharacteristicObject CharacteristicObject<T> CharacteristicPresenter CharacteristicSet CharacteristicSetPresenter Characteristic<T> CompositeResolver Resolver Interfaces IResolver An entity which can resolve default values of Characteristic<T>."
  },
  "api/BenchmarkDotNet.Characteristics.IResolver.html": {
    "href": "api/BenchmarkDotNet.Characteristics.IResolver.html",
    "title": "Interface IResolver | BenchmarkDotNet",
    "summary": "Interface IResolver Namespace BenchmarkDotNet.Characteristics Assembly BenchmarkDotNet.dll An entity which can resolve default values of Characteristic<T>. public interface IResolver Methods CanResolve(Characteristic) bool CanResolve(Characteristic characteristic) Parameters characteristic Characteristic Returns bool Resolve(CharacteristicObject, Characteristic) object Resolve(CharacteristicObject obj, Characteristic characteristic) Parameters obj CharacteristicObject characteristic Characteristic Returns object Resolve(CharacteristicObject, Characteristic, object) object Resolve(CharacteristicObject obj, Characteristic characteristic, object defaultValue) Parameters obj CharacteristicObject characteristic Characteristic defaultValue object Returns object Resolve<T>(CharacteristicObject, Characteristic<T>) T Resolve<T>(CharacteristicObject obj, Characteristic<T> characteristic) Parameters obj CharacteristicObject characteristic Characteristic<T> Returns T Type Parameters T Resolve<T>(CharacteristicObject, Characteristic<T>, T) T Resolve<T>(CharacteristicObject obj, Characteristic<T> characteristic, T defaultValue) Parameters obj CharacteristicObject characteristic Characteristic<T> defaultValue T Returns T Type Parameters T"
  },
  "api/BenchmarkDotNet.Characteristics.Resolver.html": {
    "href": "api/BenchmarkDotNet.Characteristics.Resolver.html",
    "title": "Class Resolver | BenchmarkDotNet",
    "summary": "Class Resolver Namespace BenchmarkDotNet.Characteristics Assembly BenchmarkDotNet.dll public class Resolver : IResolver Inheritance object Resolver Implements IResolver Derived EngineResolver EnvironmentResolver GcResolver InfrastructureResolver Constructors Resolver() public Resolver() Methods CanResolve(Characteristic) public bool CanResolve(Characteristic characteristic) Parameters characteristic Characteristic Returns bool Register<T>(Characteristic<T>, Func<CharacteristicObject, T>) protected void Register<T>(Characteristic<T> characteristic, Func<CharacteristicObject, T> resolver) Parameters characteristic Characteristic<T> resolver Func<CharacteristicObject, T> Type Parameters T Register<T>(Characteristic<T>, Func<T>) protected void Register<T>(Characteristic<T> characteristic, Func<T> resolver) Parameters characteristic Characteristic<T> resolver Func<T> Type Parameters T Resolve(CharacteristicObject, Characteristic) public object Resolve(CharacteristicObject obj, Characteristic characteristic) Parameters obj CharacteristicObject characteristic Characteristic Returns object Resolve(CharacteristicObject, Characteristic, object) public object Resolve(CharacteristicObject obj, Characteristic characteristic, object defaultValue) Parameters obj CharacteristicObject characteristic Characteristic defaultValue object Returns object Resolve<T>(CharacteristicObject, Characteristic<T>) public T Resolve<T>(CharacteristicObject obj, Characteristic<T> characteristic) Parameters obj CharacteristicObject characteristic Characteristic<T> Returns T Type Parameters T Resolve<T>(CharacteristicObject, Characteristic<T>, T) public T Resolve<T>(CharacteristicObject obj, Characteristic<T> characteristic, T defaultValue) Parameters obj CharacteristicObject characteristic Characteristic<T> defaultValue T Returns T Type Parameters T"
  },
  "api/BenchmarkDotNet.Code.ArrayParam-1.html": {
    "href": "api/BenchmarkDotNet.Code.ArrayParam-1.html",
    "title": "Class ArrayParam<T> | BenchmarkDotNet",
    "summary": "Class ArrayParam<T> Namespace BenchmarkDotNet.Code Assembly BenchmarkDotNet.dll public class ArrayParam<T> : IParam Type Parameters T Inheritance object ArrayParam<T> Implements IParam Properties DisplayText used to display the value (e.g. in summary in Params column) public string DisplayText { get; } Property Value string Value value of the parameter object for benchmark used internally (e.g. by the InProcessToolchain) public object Value { get; } Property Value object Methods ForComplexTypes(T[], Func<T, string>) for types where calling .ToString() will be NOT enough to re-create them in auto-generated source code file public static ArrayParam<T> ForComplexTypes(T[] array, Func<T, string> toSourceCode) Parameters array T[] the array toSourceCode Func<T, string> method which transforms an item of type T to it's C# representation example: point => $\"new Point2d({point.X}, {point.Y})\" Returns ArrayParam<T> ForPrimitives(T[]) for types where calling .ToString() will be enough to re-create them in auto-generated source code file (integers, strings and other primitives) public static ArrayParam<T> ForPrimitives(T[] array) Parameters array T[] Returns ArrayParam<T> ToSourceCode() this source code is used to create parameter for benchmark in C# source code file example: $\"new Point2D({Value.X}, {Value.Y})\" public string ToSourceCode() Returns string"
  },
  "api/BenchmarkDotNet.Code.EnumParam.html": {
    "href": "api/BenchmarkDotNet.Code.EnumParam.html",
    "title": "Class EnumParam | BenchmarkDotNet",
    "summary": "Class EnumParam Namespace BenchmarkDotNet.Code Assembly BenchmarkDotNet.dll public class EnumParam : IParam Inheritance object EnumParam Implements IParam Properties DisplayText used to display the value (e.g. in summary in Params column) public string DisplayText { get; } Property Value string Value value of the parameter object for benchmark used internally (e.g. by the InProcessToolchain) public object Value { get; } Property Value object Methods ToSourceCode() this source code is used to create parameter for benchmark in C# source code file example: $\"new Point2D({Value.X}, {Value.Y})\" public string ToSourceCode() Returns string"
  },
  "api/BenchmarkDotNet.Code.html": {
    "href": "api/BenchmarkDotNet.Code.html",
    "title": "Namespace BenchmarkDotNet.Code | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Code Classes ArrayParam<T> EnumParam Interfaces IParam"
  },
  "api/BenchmarkDotNet.Code.IParam.html": {
    "href": "api/BenchmarkDotNet.Code.IParam.html",
    "title": "Interface IParam | BenchmarkDotNet",
    "summary": "Interface IParam Namespace BenchmarkDotNet.Code Assembly BenchmarkDotNet.dll public interface IParam Properties DisplayText used to display the value (e.g. in summary in Params column) string DisplayText { get; } Property Value string Value value of the parameter object for benchmark used internally (e.g. by the InProcessToolchain) object Value { get; } Property Value object Methods ToSourceCode() this source code is used to create parameter for benchmark in C# source code file example: $\"new Point2D({Value.X}, {Value.Y})\" string ToSourceCode() Returns string"
  },
  "api/BenchmarkDotNet.Columns.BaselineAllocationRatioColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.BaselineAllocationRatioColumn.html",
    "title": "Class BaselineAllocationRatioColumn | BenchmarkDotNet",
    "summary": "Class BaselineAllocationRatioColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class BaselineAllocationRatioColumn : BaselineCustomColumn, IColumn Inheritance object BaselineCustomColumn BaselineAllocationRatioColumn Implements IColumn Inherited Members BaselineCustomColumn.GetValue(Summary, BenchmarkCase) BaselineCustomColumn.IsAvailable(Summary) BaselineCustomColumn.GetValue(Summary, BenchmarkCase, SummaryStyle) BaselineCustomColumn.ToString() BaselineCustomColumn.IsDefault(Summary, BenchmarkCase) BaselineCustomColumn.AlwaysShow Extension Methods ColumnExtensions.ToProvider(IColumn) Fields RatioMean public static readonly IColumn RatioMean Field Value IColumn Properties Category public override ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public override string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public override string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public override bool IsNumeric { get; } Property Value bool Legend Column description. public override string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public override int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public override UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase, Statistics, IReadOnlyDictionary<string, Metric>, Statistics, IReadOnlyDictionary<string, Metric>, bool) public override string GetValue(Summary summary, BenchmarkCase benchmarkCase, Statistics baseline, IReadOnlyDictionary<string, Metric> baselineMetrics, Statistics current, IReadOnlyDictionary<string, Metric> currentMetrics, bool isBaseline) Parameters summary Summary benchmarkCase BenchmarkCase baseline Statistics baselineMetrics IReadOnlyDictionary<string, Metric> current Statistics currentMetrics IReadOnlyDictionary<string, Metric> isBaseline bool Returns string"
  },
  "api/BenchmarkDotNet.Columns.BaselineColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.BaselineColumn.html",
    "title": "Class BaselineColumn | BenchmarkDotNet",
    "summary": "Class BaselineColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class BaselineColumn : IColumn Inheritance object BaselineColumn Implements IColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Constructors BaselineColumn() public BaselineColumn() Fields Default public static readonly IColumn Default Field Value IColumn Properties AlwaysShow public bool AlwaysShow { get; } Property Value bool Category public ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public bool IsNumeric { get; } Property Value bool Legend Column description. public string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) public bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Columns.BaselineCustomColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.BaselineCustomColumn.html",
    "title": "Class BaselineCustomColumn | BenchmarkDotNet",
    "summary": "Class BaselineCustomColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public abstract class BaselineCustomColumn : IColumn Inheritance object BaselineCustomColumn Implements IColumn Derived BaselineAllocationRatioColumn BaselineRatioColumn BaselineScaledColumn StatisticalTestColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Constructors BaselineCustomColumn() protected BaselineCustomColumn() Properties AlwaysShow public bool AlwaysShow { get; } Property Value bool Category public virtual ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public abstract string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public abstract string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public abstract bool IsNumeric { get; } Property Value bool Legend Column description. public abstract string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public abstract int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public abstract UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, Statistics, IReadOnlyDictionary<string, Metric>, Statistics, IReadOnlyDictionary<string, Metric>, bool) public abstract string GetValue(Summary summary, BenchmarkCase benchmarkCase, Statistics baseline, IReadOnlyDictionary<string, Metric> baselineMetrics, Statistics current, IReadOnlyDictionary<string, Metric> currentMetrics, bool isBaseline) Parameters summary Summary benchmarkCase BenchmarkCase baseline Statistics baselineMetrics IReadOnlyDictionary<string, Metric> current Statistics currentMetrics IReadOnlyDictionary<string, Metric> isBaseline bool Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) public bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Columns.BaselineRatioColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.BaselineRatioColumn.html",
    "title": "Class BaselineRatioColumn | BenchmarkDotNet",
    "summary": "Class BaselineRatioColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class BaselineRatioColumn : BaselineCustomColumn, IColumn Inheritance object BaselineCustomColumn BaselineRatioColumn Implements IColumn Inherited Members BaselineCustomColumn.GetValue(Summary, BenchmarkCase) BaselineCustomColumn.IsAvailable(Summary) BaselineCustomColumn.GetValue(Summary, BenchmarkCase, SummaryStyle) BaselineCustomColumn.ToString() BaselineCustomColumn.IsDefault(Summary, BenchmarkCase) BaselineCustomColumn.AlwaysShow BaselineCustomColumn.Category Extension Methods ColumnExtensions.ToProvider(IColumn) Fields RatioMean public static readonly IColumn RatioMean Field Value IColumn RatioStdDev public static readonly IColumn RatioStdDev Field Value IColumn Properties ColumnName Display column title in the summary. public override string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public override string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public override bool IsNumeric { get; } Property Value bool Legend Column description. public override string Legend { get; } Property Value string Metric public BaselineRatioColumn.RatioMetric Metric { get; } Property Value BaselineRatioColumn.RatioMetric PriorityInCategory Defines order of column in the same category. public override int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public override UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase, Statistics, IReadOnlyDictionary<string, Metric>, Statistics, IReadOnlyDictionary<string, Metric>, bool) public override string GetValue(Summary summary, BenchmarkCase benchmarkCase, Statistics baseline, IReadOnlyDictionary<string, Metric> baselineMetrics, Statistics current, IReadOnlyDictionary<string, Metric> currentMetrics, bool isBaseline) Parameters summary Summary benchmarkCase BenchmarkCase baseline Statistics baselineMetrics IReadOnlyDictionary<string, Metric> current Statistics currentMetrics IReadOnlyDictionary<string, Metric> isBaseline bool Returns string"
  },
  "api/BenchmarkDotNet.Columns.BaselineRatioColumn.RatioMetric.html": {
    "href": "api/BenchmarkDotNet.Columns.BaselineRatioColumn.RatioMetric.html",
    "title": "Enum BaselineRatioColumn.RatioMetric | BenchmarkDotNet",
    "summary": "Enum BaselineRatioColumn.RatioMetric Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public enum BaselineRatioColumn.RatioMetric Fields Mean = 0 StdDev = 1"
  },
  "api/BenchmarkDotNet.Columns.BaselineScaledColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.BaselineScaledColumn.html",
    "title": "Class BaselineScaledColumn | BenchmarkDotNet",
    "summary": "Class BaselineScaledColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll [Obsolete(\"Use BaselineRatioColumn\")] public class BaselineScaledColumn : BaselineCustomColumn, IColumn Inheritance object BaselineCustomColumn BaselineScaledColumn Implements IColumn Inherited Members BaselineCustomColumn.GetValue(Summary, BenchmarkCase) BaselineCustomColumn.IsAvailable(Summary) BaselineCustomColumn.GetValue(Summary, BenchmarkCase, SummaryStyle) BaselineCustomColumn.ToString() BaselineCustomColumn.IsDefault(Summary, BenchmarkCase) BaselineCustomColumn.AlwaysShow BaselineCustomColumn.Category Extension Methods ColumnExtensions.ToProvider(IColumn) Fields Scaled public static readonly IColumn Scaled Field Value IColumn Properties ColumnName Display column title in the summary. public override string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public override string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public override bool IsNumeric { get; } Property Value bool Kind public BaselineScaledColumn.ScaledKind Kind { get; } Property Value BaselineScaledColumn.ScaledKind Legend Column description. public override string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public override int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public override UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase, Statistics, IReadOnlyDictionary<string, Metric>, Statistics, IReadOnlyDictionary<string, Metric>, bool) public override string GetValue(Summary summary, BenchmarkCase benchmarkCase, Statistics baseline, IReadOnlyDictionary<string, Metric> baselineMetrics, Statistics current, IReadOnlyDictionary<string, Metric> currentMetrics, bool isBaseline) Parameters summary Summary benchmarkCase BenchmarkCase baseline Statistics baselineMetrics IReadOnlyDictionary<string, Metric> current Statistics currentMetrics IReadOnlyDictionary<string, Metric> isBaseline bool Returns string"
  },
  "api/BenchmarkDotNet.Columns.BaselineScaledColumn.ScaledKind.html": {
    "href": "api/BenchmarkDotNet.Columns.BaselineScaledColumn.ScaledKind.html",
    "title": "Enum BaselineScaledColumn.ScaledKind | BenchmarkDotNet",
    "summary": "Enum BaselineScaledColumn.ScaledKind Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public enum BaselineScaledColumn.ScaledKind Fields Mean = 0"
  },
  "api/BenchmarkDotNet.Columns.CategoriesColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.CategoriesColumn.html",
    "title": "Class CategoriesColumn | BenchmarkDotNet",
    "summary": "Class CategoriesColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class CategoriesColumn : IColumn Inheritance object CategoriesColumn Implements IColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Constructors CategoriesColumn() public CategoriesColumn() Fields Default public static readonly IColumn Default Field Value IColumn Properties AlwaysShow public bool AlwaysShow { get; } Property Value bool Category public ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public bool IsNumeric { get; } Property Value bool Legend Column description. public string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) public bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Columns.Column.html": {
    "href": "api/BenchmarkDotNet.Columns.Column.html",
    "title": "Class Column | BenchmarkDotNet",
    "summary": "Class Column Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public static class Column Inheritance object Column Fields Accuracy public const string Accuracy = \"Accuracy\" Field Value string Affinity public const string Affinity = \"Affinity\" Field Value string AllocRatio public const string AllocRatio = \"Alloc Ratio\" Field Value string Allocated public const string Allocated = \"Allocated\" Field Value string AllocatedNativeMemory public const string AllocatedNativeMemory = \"Allocated native memory\" Field Value string AllowVeryLargeObjects public const string AllowVeryLargeObjects = \"AllowVeryLargeObjects\" Field Value string AnalyzeLaunchVariance public const string AnalyzeLaunchVariance = \"AnalyzeLaunchVariance\" Field Value string Arguments public const string Arguments = \"Arguments\" Field Value string Baseline public const string Baseline = \"Baseline\" Field Value string BuildConfiguration public const string BuildConfiguration = \"BuildConfiguration\" Field Value string Categories public const string Categories = \"Categories\" Field Value string Clock public const string Clock = \"Clock\" Field Value string CodeSize public const string CodeSize = \"Code Size\" Field Value string CompletedWorkItems public const string CompletedWorkItems = \"Completed Work Items\" Field Value string Concurrent public const string Concurrent = \"Concurrent\" Field Value string CpuGroups public const string CpuGroups = \"CpuGroups\" Field Value string EngineFactory public const string EngineFactory = \"EngineFactory\" Field Value string Environment public const string Environment = \"Environment\" Field Value string EnvironmentVariables public const string EnvironmentVariables = \"EnvironmentVariables\" Field Value string Error public const string Error = \"Error\" Field Value string EvaluateOverhead public const string EvaluateOverhead = \"EvaluateOverhead\" Field Value string Exceptions public const string Exceptions = \"Exceptions\" Field Value string Force public const string Force = \"Force\" Field Value string Gc public const string Gc = \"Gc\" Field Value string Gen0 public const string Gen0 = \"Gen0\" Field Value string Gen1 public const string Gen1 = \"Gen1\" Field Value string Gen2 public const string Gen2 = \"Gen2\" Field Value string HeapAffinitizeMask public const string HeapAffinitizeMask = \"HeapAffinitizeMask\" Field Value string HeapCount public const string HeapCount = \"HeapCount\" Field Value string Id public const string Id = \"Id\" Field Value string Infrastructure public const string Infrastructure = \"Infrastructure\" Field Value string InvocationCount public const string InvocationCount = \"InvocationCount\" Field Value string IsDefault public const string IsDefault = \"IsDefault\" Field Value string IsMutator public const string IsMutator = \"IsMutator\" Field Value string IterationCount public const string IterationCount = \"IterationCount\" Field Value string IterationTime public const string IterationTime = \"IterationTime\" Field Value string Iterations public const string Iterations = \"Iterations\" Field Value string Jit public const string Jit = \"Jit\" Field Value string Job public const string Job = \"Job\" Field Value string Kurtosis public const string Kurtosis = \"Kurtosis\" Field Value string LaunchCount public const string LaunchCount = \"LaunchCount\" Field Value string LockContentions public const string LockContentions = \"Lock Contentions\" Field Value string LogicalGroup public const string LogicalGroup = \"LogicalGroup\" Field Value string MValue public const string MValue = \"MValue\" Field Value string Max public const string Max = \"Max\" Field Value string MaxAbsoluteError public const string MaxAbsoluteError = \"MaxAbsoluteError\" Field Value string MaxIterationCount public const string MaxIterationCount = \"MaxIterationCount\" Field Value string MaxRelativeError public const string MaxRelativeError = \"MaxRelativeError\" Field Value string MaxWarmupIterationCount public const string MaxWarmupIterationCount = \"MaxWarmupIterationCount\" Field Value string Mean public const string Mean = \"Mean\" Field Value string Median public const string Median = \"Median\" Field Value string MemoryRandomization public const string MemoryRandomization = \"MemoryRandomization\" Field Value string Meta public const string Meta = \"Meta\" Field Value string Method public const string Method = \"Method\" Field Value string Min public const string Min = \"Min\" Field Value string MinInvokeCount public const string MinInvokeCount = \"MinInvokeCount\" Field Value string MinIterationCount public const string MinIterationCount = \"MinIterationCount\" Field Value string MinIterationTime public const string MinIterationTime = \"MinIterationTime\" Field Value string MinWarmupIterationCount public const string MinWarmupIterationCount = \"MinWarmupIterationCount\" Field Value string Namespace public const string Namespace = \"Namespace\" Field Value string NativeMemoryLeak public const string NativeMemoryLeak = \"Native memory leak\" Field Value string NoAffinitize public const string NoAffinitize = \"NoAffinitize\" Field Value string NuGetReferences public const string NuGetReferences = \"NuGetReferences\" Field Value string OperationPerSecond public const string OperationPerSecond = \"Op/s\" Field Value string OutlierMode public const string OutlierMode = \"OutlierMode\" Field Value string P0 public const string P0 = \"P0\" Field Value string P100 public const string P100 = \"P100\" Field Value string P25 public const string P25 = \"P25\" Field Value string P50 public const string P50 = \"P50\" Field Value string P67 public const string P67 = \"P67\" Field Value string P80 public const string P80 = \"P80\" Field Value string P85 public const string P85 = \"P85\" Field Value string P90 public const string P90 = \"P90\" Field Value string P95 public const string P95 = \"P95\" Field Value string Platform public const string Platform = \"Platform\" Field Value string PowerPlanMode public const string PowerPlanMode = \"PowerPlanMode\" Field Value string Q1 public const string Q1 = \"Q1\" Field Value string Q3 public const string Q3 = \"Q3\" Field Value string Rank public const string Rank = \"Rank\" Field Value string Ratio public const string Ratio = \"Ratio\" Field Value string RatioSD public const string RatioSD = \"RatioSD\" Field Value string RetainVm public const string RetainVm = \"RetainVm\" Field Value string Run public const string Run = \"Run\" Field Value string RunStrategy public const string RunStrategy = \"RunStrategy\" Field Value string Runtime public const string Runtime = \"Runtime\" Field Value string Server public const string Server = \"Server\" Field Value string Skewness public const string Skewness = \"Skewness\" Field Value string StdDev public const string StdDev = \"StdDev\" Field Value string StdErr public const string StdErr = \"StdErr\" Field Value string Toolchain public const string Toolchain = \"Toolchain\" Field Value string Type public const string Type = \"Type\" Field Value string UnrollFactor public const string UnrollFactor = \"UnrollFactor\" Field Value string WarmupCount public const string WarmupCount = \"WarmupCount\" Field Value string"
  },
  "api/BenchmarkDotNet.Columns.ColumnCategory.html": {
    "href": "api/BenchmarkDotNet.Columns.ColumnCategory.html",
    "title": "Enum ColumnCategory | BenchmarkDotNet",
    "summary": "Enum ColumnCategory Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public enum ColumnCategory Fields Baseline = 3 Custom = 4 Job = 0 Meta = 5 Metric = 6 Params = 1 Statistics = 2"
  },
  "api/BenchmarkDotNet.Columns.ColumnExtensions.html": {
    "href": "api/BenchmarkDotNet.Columns.ColumnExtensions.html",
    "title": "Class ColumnExtensions | BenchmarkDotNet",
    "summary": "Class ColumnExtensions Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public static class ColumnExtensions Inheritance object ColumnExtensions Methods ToProvider(IColumn) public static IColumnProvider ToProvider(this IColumn column) Parameters column IColumn Returns IColumnProvider"
  },
  "api/BenchmarkDotNet.Columns.ColumnHidingByIdRule.html": {
    "href": "api/BenchmarkDotNet.Columns.ColumnHidingByIdRule.html",
    "title": "Class ColumnHidingByIdRule | BenchmarkDotNet",
    "summary": "Class ColumnHidingByIdRule Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class ColumnHidingByIdRule : IColumnHidingRule Inheritance object ColumnHidingByIdRule Implements IColumnHidingRule Constructors ColumnHidingByIdRule(IColumn) public ColumnHidingByIdRule(IColumn column) Parameters column IColumn Properties Id public string Id { get; } Property Value string Methods NeedToHide(IColumn) public bool NeedToHide(IColumn column) Parameters column IColumn Returns bool"
  },
  "api/BenchmarkDotNet.Columns.ColumnHidingByNameRule.html": {
    "href": "api/BenchmarkDotNet.Columns.ColumnHidingByNameRule.html",
    "title": "Class ColumnHidingByNameRule | BenchmarkDotNet",
    "summary": "Class ColumnHidingByNameRule Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class ColumnHidingByNameRule : IColumnHidingRule Inheritance object ColumnHidingByNameRule Implements IColumnHidingRule Constructors ColumnHidingByNameRule(string) public ColumnHidingByNameRule(string name) Parameters name string Properties Name public string Name { get; } Property Value string Methods NeedToHide(IColumn) public bool NeedToHide(IColumn column) Parameters column IColumn Returns bool"
  },
  "api/BenchmarkDotNet.Columns.CompositeColumnProvider.html": {
    "href": "api/BenchmarkDotNet.Columns.CompositeColumnProvider.html",
    "title": "Class CompositeColumnProvider | BenchmarkDotNet",
    "summary": "Class CompositeColumnProvider Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class CompositeColumnProvider : IColumnProvider Inheritance object CompositeColumnProvider Implements IColumnProvider Constructors CompositeColumnProvider(params IColumnProvider[]) public CompositeColumnProvider(params IColumnProvider[] providers) Parameters providers IColumnProvider[] Methods GetColumns(Summary) public IEnumerable<IColumn> GetColumns(Summary summary) Parameters summary Summary Returns IEnumerable<IColumn>"
  },
  "api/BenchmarkDotNet.Columns.DefaultColumnProviders.html": {
    "href": "api/BenchmarkDotNet.Columns.DefaultColumnProviders.html",
    "title": "Class DefaultColumnProviders | BenchmarkDotNet",
    "summary": "Class DefaultColumnProviders Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public static class DefaultColumnProviders Inheritance object DefaultColumnProviders Fields Descriptor public static readonly IColumnProvider Descriptor Field Value IColumnProvider Instance public static readonly IColumnProvider[] Instance Field Value IColumnProvider[] Job public static readonly IColumnProvider Job Field Value IColumnProvider Metrics public static readonly IColumnProvider Metrics Field Value IColumnProvider Params public static readonly IColumnProvider Params Field Value IColumnProvider Statistics public static readonly IColumnProvider Statistics Field Value IColumnProvider"
  },
  "api/BenchmarkDotNet.Columns.EmptyColumnProvider.html": {
    "href": "api/BenchmarkDotNet.Columns.EmptyColumnProvider.html",
    "title": "Class EmptyColumnProvider | BenchmarkDotNet",
    "summary": "Class EmptyColumnProvider Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class EmptyColumnProvider : IColumnProvider Inheritance object EmptyColumnProvider Implements IColumnProvider Fields Instance public static readonly IColumnProvider Instance Field Value IColumnProvider Methods GetColumns(Summary) public IEnumerable<IColumn> GetColumns(Summary summary) Parameters summary Summary Returns IEnumerable<IColumn>"
  },
  "api/BenchmarkDotNet.Columns.html": {
    "href": "api/BenchmarkDotNet.Columns.html",
    "title": "Namespace BenchmarkDotNet.Columns | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Columns Classes BaselineAllocationRatioColumn BaselineColumn BaselineCustomColumn BaselineRatioColumn BaselineScaledColumn CategoriesColumn Column ColumnExtensions ColumnHidingByIdRule ColumnHidingByNameRule CompositeColumnProvider DefaultColumnProviders EmptyColumnProvider JobCharacteristicColumn LogicalGroupColumn MetricColumn ParamColumn RankColumn SimpleColumnProvider StatisticColumn StatisticalTestColumn TagColumn TargetMethodColumn Interfaces IColumn IColumnHidingRule IColumnProvider IStatisticColumn Enums BaselineRatioColumn.RatioMetric BaselineScaledColumn.ScaledKind ColumnCategory RatioStyle UnitType"
  },
  "api/BenchmarkDotNet.Columns.IColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.IColumn.html",
    "title": "Interface IColumn | BenchmarkDotNet",
    "summary": "Interface IColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public interface IColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Properties AlwaysShow bool AlwaysShow { get; } Property Value bool Category ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number bool IsNumeric { get; } Property Value bool Legend Column description. string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Columns.IColumnHidingRule.html": {
    "href": "api/BenchmarkDotNet.Columns.IColumnHidingRule.html",
    "title": "Interface IColumnHidingRule | BenchmarkDotNet",
    "summary": "Interface IColumnHidingRule Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public interface IColumnHidingRule Methods NeedToHide(IColumn) bool NeedToHide(IColumn column) Parameters column IColumn Returns bool"
  },
  "api/BenchmarkDotNet.Columns.IColumnProvider.html": {
    "href": "api/BenchmarkDotNet.Columns.IColumnProvider.html",
    "title": "Interface IColumnProvider | BenchmarkDotNet",
    "summary": "Interface IColumnProvider Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public interface IColumnProvider Methods GetColumns(Summary) IEnumerable<IColumn> GetColumns(Summary summary) Parameters summary Summary Returns IEnumerable<IColumn>"
  },
  "api/BenchmarkDotNet.Columns.IStatisticColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.IStatisticColumn.html",
    "title": "Interface IStatisticColumn | BenchmarkDotNet",
    "summary": "Interface IStatisticColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public interface IStatisticColumn : IColumn Inherited Members IColumn.GetValue(Summary, BenchmarkCase) IColumn.GetValue(Summary, BenchmarkCase, SummaryStyle) IColumn.IsDefault(Summary, BenchmarkCase) IColumn.IsAvailable(Summary) IColumn.Id IColumn.ColumnName IColumn.AlwaysShow IColumn.Category IColumn.PriorityInCategory IColumn.IsNumeric IColumn.UnitType IColumn.Legend Extension Methods ColumnExtensions.ToProvider(IColumn) Methods GetAllValues(Summary, SummaryStyle) List<double> GetAllValues(Summary summary, SummaryStyle style) Parameters summary Summary style SummaryStyle Returns List<double>"
  },
  "api/BenchmarkDotNet.Columns.JobCharacteristicColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.JobCharacteristicColumn.html",
    "title": "Class JobCharacteristicColumn | BenchmarkDotNet",
    "summary": "Class JobCharacteristicColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class JobCharacteristicColumn : IColumn Inheritance object JobCharacteristicColumn Implements IColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Properties AllColumns public static IColumn[] AllColumns { get; } Property Value IColumn[] AlwaysShow public bool AlwaysShow { get; } Property Value bool Category public ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public bool IsNumeric { get; } Property Value bool Legend Column description. public string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) public bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Columns.LogicalGroupColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.LogicalGroupColumn.html",
    "title": "Class LogicalGroupColumn | BenchmarkDotNet",
    "summary": "Class LogicalGroupColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class LogicalGroupColumn : IColumn Inheritance object LogicalGroupColumn Implements IColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Constructors LogicalGroupColumn() public LogicalGroupColumn() Fields Default public static readonly IColumn Default Field Value IColumn Properties AlwaysShow public bool AlwaysShow { get; } Property Value bool Category public ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public bool IsNumeric { get; } Property Value bool Legend Column description. public string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) public bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Columns.MetricColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.MetricColumn.html",
    "title": "Class MetricColumn | BenchmarkDotNet",
    "summary": "Class MetricColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class MetricColumn : IColumn Inheritance object MetricColumn Implements IColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Constructors MetricColumn(IMetricDescriptor) public MetricColumn(IMetricDescriptor metricDescriptor) Parameters metricDescriptor IMetricDescriptor Properties AlwaysShow public bool AlwaysShow { get; } Property Value bool Category public ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public bool IsNumeric { get; } Property Value bool Legend Column description. public string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) public bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Columns.ParamColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.ParamColumn.html",
    "title": "Class ParamColumn | BenchmarkDotNet",
    "summary": "Class ParamColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class ParamColumn : IColumn Inheritance object ParamColumn Implements IColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Constructors ParamColumn(string, int) public ParamColumn(string columnName, int priorityInCategory = 0) Parameters columnName string priorityInCategory int Properties AlwaysShow public bool AlwaysShow { get; } Property Value bool Category public ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public bool IsNumeric { get; } Property Value bool Legend Column description. public string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) public bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Columns.RankColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.RankColumn.html",
    "title": "Class RankColumn | BenchmarkDotNet",
    "summary": "Class RankColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class RankColumn : IColumn Inheritance object RankColumn Implements IColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Constructors RankColumn(NumeralSystem) public RankColumn(NumeralSystem system) Parameters system NumeralSystem Fields Arabic public static readonly IColumn Arabic Field Value IColumn Roman public static readonly IColumn Roman Field Value IColumn Stars public static readonly IColumn Stars Field Value IColumn Properties AlwaysShow public bool AlwaysShow { get; } Property Value bool Category public ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public bool IsNumeric { get; } Property Value bool Legend Column description. public string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) public bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Columns.RatioStyle.html": {
    "href": "api/BenchmarkDotNet.Columns.RatioStyle.html",
    "title": "Enum RatioStyle | BenchmarkDotNet",
    "summary": "Enum RatioStyle Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public enum RatioStyle Fields Percentage = 1 Trend = 2 Value = 0"
  },
  "api/BenchmarkDotNet.Columns.SimpleColumnProvider.html": {
    "href": "api/BenchmarkDotNet.Columns.SimpleColumnProvider.html",
    "title": "Class SimpleColumnProvider | BenchmarkDotNet",
    "summary": "Class SimpleColumnProvider Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class SimpleColumnProvider : IColumnProvider Inheritance object SimpleColumnProvider Implements IColumnProvider Constructors SimpleColumnProvider(params IColumn[]) public SimpleColumnProvider(params IColumn[] columns) Parameters columns IColumn[] Methods GetColumns(Summary) public IEnumerable<IColumn> GetColumns(Summary summary) Parameters summary Summary Returns IEnumerable<IColumn>"
  },
  "api/BenchmarkDotNet.Columns.StatisticalTestColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.StatisticalTestColumn.html",
    "title": "Class StatisticalTestColumn | BenchmarkDotNet",
    "summary": "Class StatisticalTestColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class StatisticalTestColumn : BaselineCustomColumn, IColumn Inheritance object BaselineCustomColumn StatisticalTestColumn Implements IColumn Inherited Members BaselineCustomColumn.GetValue(Summary, BenchmarkCase) BaselineCustomColumn.IsAvailable(Summary) BaselineCustomColumn.GetValue(Summary, BenchmarkCase, SummaryStyle) BaselineCustomColumn.ToString() BaselineCustomColumn.IsDefault(Summary, BenchmarkCase) BaselineCustomColumn.AlwaysShow BaselineCustomColumn.Category Extension Methods ColumnExtensions.ToProvider(IColumn) Constructors StatisticalTestColumn(Threshold, SignificanceLevel?) public StatisticalTestColumn(Threshold threshold, SignificanceLevel? significanceLevel = null) Parameters threshold Threshold significanceLevel SignificanceLevel? Properties ColumnName Display column title in the summary. public override string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public override string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public override bool IsNumeric { get; } Property Value bool Legend Column description. public override string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public override int PriorityInCategory { get; } Property Value int SignificanceLevel public SignificanceLevel SignificanceLevel { get; } Property Value SignificanceLevel Threshold public Threshold Threshold { get; } Property Value Threshold UnitType Defines how to format column's value public override UnitType UnitType { get; } Property Value UnitType Methods Create(Threshold, SignificanceLevel?) public static StatisticalTestColumn Create(Threshold threshold, SignificanceLevel? significanceLevel = null) Parameters threshold Threshold significanceLevel SignificanceLevel? Returns StatisticalTestColumn Create(string, SignificanceLevel?) public static StatisticalTestColumn Create(string threshold, SignificanceLevel? significanceLevel = null) Parameters threshold string significanceLevel SignificanceLevel? Returns StatisticalTestColumn CreateDefault() public static StatisticalTestColumn CreateDefault() Returns StatisticalTestColumn GetValue(Summary, BenchmarkCase, Statistics, IReadOnlyDictionary<string, Metric>, Statistics, IReadOnlyDictionary<string, Metric>, bool) public override string GetValue(Summary summary, BenchmarkCase benchmarkCase, Statistics baseline, IReadOnlyDictionary<string, Metric> baselineMetrics, Statistics current, IReadOnlyDictionary<string, Metric> currentMetrics, bool isBaseline) Parameters summary Summary benchmarkCase BenchmarkCase baseline Statistics baselineMetrics IReadOnlyDictionary<string, Metric> current Statistics currentMetrics IReadOnlyDictionary<string, Metric> isBaseline bool Returns string"
  },
  "api/BenchmarkDotNet.Columns.StatisticColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.StatisticColumn.html",
    "title": "Class StatisticColumn | BenchmarkDotNet",
    "summary": "Class StatisticColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class StatisticColumn : IStatisticColumn, IColumn Inheritance object StatisticColumn Implements IStatisticColumn IColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Fields AllStatistics public static readonly IColumn[] AllStatistics Field Value IColumn[] Error public static readonly IColumn Error Field Value IColumn Iterations public static readonly IColumn Iterations Field Value IColumn Kurtosis public static readonly IColumn Kurtosis Field Value IColumn MValue See http://www.brendangregg.com/FrequencyTrails/modes.html public static readonly IColumn MValue Field Value IColumn Max public static readonly IColumn Max Field Value IColumn Mean public static readonly IStatisticColumn Mean Field Value IStatisticColumn Median public static readonly IColumn Median Field Value IColumn Min public static readonly IColumn Min Field Value IColumn OperationsPerSecond public static readonly IColumn OperationsPerSecond Field Value IColumn P0 public static readonly IColumn P0 Field Value IColumn P100 public static readonly IColumn P100 Field Value IColumn P25 public static readonly IColumn P25 Field Value IColumn P50 public static readonly IColumn P50 Field Value IColumn P67 public static readonly IColumn P67 Field Value IColumn P80 public static readonly IColumn P80 Field Value IColumn P85 public static readonly IColumn P85 Field Value IColumn P90 public static readonly IColumn P90 Field Value IColumn P95 public static readonly IColumn P95 Field Value IColumn Q1 public static readonly IColumn Q1 Field Value IColumn Q3 public static readonly IColumn Q3 Field Value IColumn Skewness public static readonly IColumn Skewness Field Value IColumn StdDev public static readonly IColumn StdDev Field Value IColumn StdErr public static readonly IColumn StdErr Field Value IColumn Properties AlwaysShow public bool AlwaysShow { get; } Property Value bool Category public ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public bool IsNumeric { get; } Property Value bool Legend Column description. public string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public UnitType UnitType { get; } Property Value UnitType Methods CiError(ConfidenceLevel) public static IColumn CiError(ConfidenceLevel level) Parameters level ConfidenceLevel Returns IColumn CiLower(ConfidenceLevel) public static IColumn CiLower(ConfidenceLevel level) Parameters level ConfidenceLevel Returns IColumn CiUpper(ConfidenceLevel) public static IColumn CiUpper(ConfidenceLevel level) Parameters level ConfidenceLevel Returns IColumn GetAllValues(Summary, SummaryStyle) public List<double> GetAllValues(Summary summary, SummaryStyle style) Parameters summary Summary style SummaryStyle Returns List<double> GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) public bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Columns.TagColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.TagColumn.html",
    "title": "Class TagColumn | BenchmarkDotNet",
    "summary": "Class TagColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class TagColumn : IColumn Inheritance object TagColumn Implements IColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Constructors TagColumn(string, Func<string, string>) public TagColumn(string columnName, Func<string, string> getTag) Parameters columnName string getTag Func<string, string> Properties AlwaysShow public bool AlwaysShow { get; } Property Value bool Category public ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public bool IsNumeric { get; } Property Value bool Legend Column description. public string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) public bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Columns.TargetMethodColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.TargetMethodColumn.html",
    "title": "Class TargetMethodColumn | BenchmarkDotNet",
    "summary": "Class TargetMethodColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class TargetMethodColumn : IColumn Inheritance object TargetMethodColumn Implements IColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Fields Method public static readonly IColumn Method Field Value IColumn Namespace public static readonly IColumn Namespace Field Value IColumn Type public static readonly IColumn Type Field Value IColumn Properties AlwaysShow public bool AlwaysShow { get; } Property Value bool Category public ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public bool IsNumeric { get; } Property Value bool Legend Column description. public string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) public bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Columns.UnitType.html": {
    "href": "api/BenchmarkDotNet.Columns.UnitType.html",
    "title": "Enum UnitType | BenchmarkDotNet",
    "summary": "Enum UnitType Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public enum UnitType Fields CodeSize = 3 Dimensionless = 0 Size = 2 Time = 1"
  },
  "api/BenchmarkDotNet.Configs.BenchmarkLogicalGroupRule.html": {
    "href": "api/BenchmarkDotNet.Configs.BenchmarkLogicalGroupRule.html",
    "title": "Enum BenchmarkLogicalGroupRule | BenchmarkDotNet",
    "summary": "Enum BenchmarkLogicalGroupRule Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll public enum BenchmarkLogicalGroupRule Fields ByCategory = 3 ByJob = 1 ByMethod = 0 ByParams = 2"
  },
  "api/BenchmarkDotNet.Configs.ConfigExtensions.html": {
    "href": "api/BenchmarkDotNet.Configs.ConfigExtensions.html",
    "title": "Class ConfigExtensions | BenchmarkDotNet",
    "summary": "Class ConfigExtensions Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll public static class ConfigExtensions Inheritance object ConfigExtensions Methods AddAnalyser(IConfig, params IAnalyser[]) public static ManualConfig AddAnalyser(this IConfig config, params IAnalyser[] analysers) Parameters config IConfig analysers IAnalyser[] Returns ManualConfig AddColumn(IConfig, params IColumn[]) public static ManualConfig AddColumn(this IConfig config, params IColumn[] columns) Parameters config IConfig columns IColumn[] Returns ManualConfig AddColumnProvider(IConfig, params IColumnProvider[]) public static ManualConfig AddColumnProvider(this IConfig config, params IColumnProvider[] columnProviders) Parameters config IConfig columnProviders IColumnProvider[] Returns ManualConfig AddDiagnoser(IConfig, params IDiagnoser[]) public static ManualConfig AddDiagnoser(this IConfig config, params IDiagnoser[] diagnosers) Parameters config IConfig diagnosers IDiagnoser[] Returns ManualConfig AddEventProcessor(IConfig, params EventProcessor[]) public static ManualConfig AddEventProcessor(this IConfig config, params EventProcessor[] eventProcessors) Parameters config IConfig eventProcessors EventProcessor[] Returns ManualConfig AddExporter(IConfig, params IExporter[]) public static ManualConfig AddExporter(this IConfig config, params IExporter[] exporters) Parameters config IConfig exporters IExporter[] Returns ManualConfig AddFilter(IConfig, params IFilter[]) public static ManualConfig AddFilter(this IConfig config, params IFilter[] filters) Parameters config IConfig filters IFilter[] Returns ManualConfig AddHardwareCounters(IConfig, params HardwareCounter[]) public static ManualConfig AddHardwareCounters(this IConfig config, params HardwareCounter[] counters) Parameters config IConfig counters HardwareCounter[] Returns ManualConfig AddJob(IConfig, Job) public static ManualConfig AddJob(this IConfig config, Job job) Parameters config IConfig job Job Returns ManualConfig AddLogger(IConfig, params ILogger[]) public static ManualConfig AddLogger(this IConfig config, params ILogger[] loggers) Parameters config IConfig loggers ILogger[] Returns ManualConfig AddLogicalGroupRules(IConfig, params BenchmarkLogicalGroupRule[]) public static ManualConfig AddLogicalGroupRules(this IConfig config, params BenchmarkLogicalGroupRule[] rules) Parameters config IConfig rules BenchmarkLogicalGroupRule[] Returns ManualConfig AddValidator(IConfig, params IValidator[]) public static ManualConfig AddValidator(this IConfig config, params IValidator[] validators) Parameters config IConfig validators IValidator[] Returns ManualConfig CreateImmutableConfig(IConfig) public static ImmutableConfig CreateImmutableConfig(this IConfig config) Parameters config IConfig Returns ImmutableConfig DontOverwriteResults(IConfig, bool) determines if the exported result files should not be overwritten (be default they are overwritten) public static IConfig DontOverwriteResults(this IConfig config, bool value = true) Parameters config IConfig value bool Returns IConfig HideColumns(IConfig, params IColumnHidingRule[]) public static ManualConfig HideColumns(this IConfig config, params IColumnHidingRule[] rules) Parameters config IConfig rules IColumnHidingRule[] Returns ManualConfig HideColumns(IConfig, params IColumn[]) public static ManualConfig HideColumns(this IConfig config, params IColumn[] columns) Parameters config IConfig columns IColumn[] Returns ManualConfig HideColumns(IConfig, params string[]) public static ManualConfig HideColumns(this IConfig config, params string[] columnNames) Parameters config IConfig columnNames string[] Returns ManualConfig KeepBenchmarkFiles(IConfig, bool) determines if all auto-generated files should be kept or removed after running the benchmarks public static IConfig KeepBenchmarkFiles(this IConfig config, bool value = true) Parameters config IConfig value bool Returns IConfig StopOnFirstError(IConfig, bool) determines if benchmarking should be stopped after the first error (by default it's not) public static IConfig StopOnFirstError(this IConfig config, bool value = true) Parameters config IConfig value bool Returns IConfig WithArtifactsPath(IConfig, string) public static ManualConfig WithArtifactsPath(this IConfig config, string artifactsPath) Parameters config IConfig artifactsPath string Returns ManualConfig WithCultureInfo(IConfig, CultureInfo) public static ManualConfig WithCultureInfo(this IConfig config, CultureInfo cultureInfo) Parameters config IConfig cultureInfo CultureInfo Returns ManualConfig WithOption(IConfig, ConfigOptions, bool) sets given option to provided value public static ManualConfig WithOption(this IConfig config, ConfigOptions option, bool value) Parameters config IConfig option ConfigOptions value bool Returns ManualConfig WithOptions(IConfig, ConfigOptions) sets given options for the config public static ManualConfig WithOptions(this IConfig config, ConfigOptions options) Parameters config IConfig options ConfigOptions Returns ManualConfig WithOrderer(IConfig, IOrderer) public static ManualConfig WithOrderer(this IConfig config, IOrderer orderer) Parameters config IConfig orderer IOrderer Returns ManualConfig WithSummaryStyle(IConfig, SummaryStyle) public static ManualConfig WithSummaryStyle(this IConfig config, SummaryStyle summaryStyle) Parameters config IConfig summaryStyle SummaryStyle Returns ManualConfig WithUnionRule(IConfig, ConfigUnionRule) public static ManualConfig WithUnionRule(this IConfig config, ConfigUnionRule unionRule) Parameters config IConfig unionRule ConfigUnionRule Returns ManualConfig"
  },
  "api/BenchmarkDotNet.Configs.ConfigOptions.html": {
    "href": "api/BenchmarkDotNet.Configs.ConfigOptions.html",
    "title": "Enum ConfigOptions | BenchmarkDotNet",
    "summary": "Enum ConfigOptions Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll [Flags] public enum ConfigOptions Fields ApplesToApples = 256 Performs apples-to-apples comparison for provided benchmarks and jobs. Experimental, will change in the near future! Default = 0 no custom settings DisableLogFile = 32 Determines if the log file should be disabled. DisableOptimizationsValidator = 8 determines if \"mandatory\" optimizations validator should be entirely turned off DisableParallelBuild = 1024 Determines whether parallel build of benchmark projects should be disabled. DontOverwriteResults = 16 determines if the exported result files should not be overwritten (be default they are overwritten) GenerateMSBuildBinLog = 128 Determines whether to generate msbuild binlogs JoinSummary = 2 determines if all benchmarks results should be joined into a single summary (by default we have a summary per type) KeepBenchmarkFiles = 1 determines if all auto-generated files should be kept after running the benchmarks (be default they are removed) LogBuildOutput = 64 Determines whether build output should be logged. Resume = 512 Continue the execution if the last run was stopped. StopOnFirstError = 4 determines if benchmarking should be stopped after the first error (by default it's not)"
  },
  "api/BenchmarkDotNet.Configs.ConfigUnionRule.html": {
    "href": "api/BenchmarkDotNet.Configs.ConfigUnionRule.html",
    "title": "Enum ConfigUnionRule | BenchmarkDotNet",
    "summary": "Enum ConfigUnionRule Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll public enum ConfigUnionRule Fields AlwaysUseGlobal = 2 AlwaysUseLocal = 1 Union = 0"
  },
  "api/BenchmarkDotNet.Configs.DebugBuildConfig.html": {
    "href": "api/BenchmarkDotNet.Configs.DebugBuildConfig.html",
    "title": "Class DebugBuildConfig | BenchmarkDotNet",
    "summary": "Class DebugBuildConfig Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll config which allows to build benchmarks in Debug public class DebugBuildConfig : DebugConfig, IConfig Inheritance object DebugConfig DebugBuildConfig Implements IConfig Inherited Members DebugConfig.GetValidators() DebugConfig.GetColumnProviders() DebugConfig.GetExporters() DebugConfig.GetLoggers() DebugConfig.GetDiagnosers() DebugConfig.GetAnalysers() DebugConfig.GetHardwareCounters() DebugConfig.GetEventProcessors() DebugConfig.GetFilters() DebugConfig.GetColumnHidingRules() DebugConfig.GetLogicalGroupRules() DebugConfig.Orderer DebugConfig.CategoryDiscoverer DebugConfig.SummaryStyle DebugConfig.UnionRule DebugConfig.BuildTimeout DebugConfig.WakeLock DebugConfig.ArtifactsPath DebugConfig.CultureInfo DebugConfig.Options DebugConfig.ConfigAnalysisConclusion Extension Methods ConfigExtensions.AddAnalyser(IConfig, params IAnalyser[]) ConfigExtensions.AddColumn(IConfig, params IColumn[]) ConfigExtensions.AddColumnProvider(IConfig, params IColumnProvider[]) ConfigExtensions.AddDiagnoser(IConfig, params IDiagnoser[]) ConfigExtensions.AddEventProcessor(IConfig, params EventProcessor[]) ConfigExtensions.AddExporter(IConfig, params IExporter[]) ConfigExtensions.AddFilter(IConfig, params IFilter[]) ConfigExtensions.AddHardwareCounters(IConfig, params HardwareCounter[]) ConfigExtensions.AddJob(IConfig, Job) ConfigExtensions.AddLogger(IConfig, params ILogger[]) ConfigExtensions.AddLogicalGroupRules(IConfig, params BenchmarkLogicalGroupRule[]) ConfigExtensions.AddValidator(IConfig, params IValidator[]) ConfigExtensions.CreateImmutableConfig(IConfig) ConfigExtensions.DontOverwriteResults(IConfig, bool) ConfigExtensions.HideColumns(IConfig, params IColumn[]) ConfigExtensions.HideColumns(IConfig, params IColumnHidingRule[]) ConfigExtensions.HideColumns(IConfig, params string[]) ConfigExtensions.KeepBenchmarkFiles(IConfig, bool) ConfigExtensions.StopOnFirstError(IConfig, bool) ConfigExtensions.WithArtifactsPath(IConfig, string) ConfigExtensions.WithCultureInfo(IConfig, CultureInfo) ConfigExtensions.WithOption(IConfig, ConfigOptions, bool) ConfigExtensions.WithOptions(IConfig, ConfigOptions) ConfigExtensions.WithOrderer(IConfig, IOrderer) ConfigExtensions.WithSummaryStyle(IConfig, SummaryStyle) ConfigExtensions.WithUnionRule(IConfig, ConfigUnionRule) Constructors DebugBuildConfig() public DebugBuildConfig() Methods GetJobs() public override IEnumerable<Job> GetJobs() Returns IEnumerable<Job>"
  },
  "api/BenchmarkDotNet.Configs.DebugConfig.html": {
    "href": "api/BenchmarkDotNet.Configs.DebugConfig.html",
    "title": "Class DebugConfig | BenchmarkDotNet",
    "summary": "Class DebugConfig Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll public abstract class DebugConfig : IConfig Inheritance object DebugConfig Implements IConfig Derived DebugBuildConfig DebugInProcessConfig Extension Methods ConfigExtensions.AddAnalyser(IConfig, params IAnalyser[]) ConfigExtensions.AddColumn(IConfig, params IColumn[]) ConfigExtensions.AddColumnProvider(IConfig, params IColumnProvider[]) ConfigExtensions.AddDiagnoser(IConfig, params IDiagnoser[]) ConfigExtensions.AddEventProcessor(IConfig, params EventProcessor[]) ConfigExtensions.AddExporter(IConfig, params IExporter[]) ConfigExtensions.AddFilter(IConfig, params IFilter[]) ConfigExtensions.AddHardwareCounters(IConfig, params HardwareCounter[]) ConfigExtensions.AddJob(IConfig, Job) ConfigExtensions.AddLogger(IConfig, params ILogger[]) ConfigExtensions.AddLogicalGroupRules(IConfig, params BenchmarkLogicalGroupRule[]) ConfigExtensions.AddValidator(IConfig, params IValidator[]) ConfigExtensions.CreateImmutableConfig(IConfig) ConfigExtensions.DontOverwriteResults(IConfig, bool) ConfigExtensions.HideColumns(IConfig, params IColumn[]) ConfigExtensions.HideColumns(IConfig, params IColumnHidingRule[]) ConfigExtensions.HideColumns(IConfig, params string[]) ConfigExtensions.KeepBenchmarkFiles(IConfig, bool) ConfigExtensions.StopOnFirstError(IConfig, bool) ConfigExtensions.WithArtifactsPath(IConfig, string) ConfigExtensions.WithCultureInfo(IConfig, CultureInfo) ConfigExtensions.WithOption(IConfig, ConfigOptions, bool) ConfigExtensions.WithOptions(IConfig, ConfigOptions) ConfigExtensions.WithOrderer(IConfig, IOrderer) ConfigExtensions.WithSummaryStyle(IConfig, SummaryStyle) ConfigExtensions.WithUnionRule(IConfig, ConfigUnionRule) Constructors DebugConfig() protected DebugConfig() Properties ArtifactsPath the default value is \"./BenchmarkDotNet.Artifacts\" public string ArtifactsPath { get; } Property Value string BuildTimeout the auto-generated project build timeout public TimeSpan BuildTimeout { get; } Property Value TimeSpan CategoryDiscoverer public ICategoryDiscoverer? CategoryDiscoverer { get; } Property Value ICategoryDiscoverer ConfigAnalysisConclusion Collect any errors or warnings when composing the configuration public IReadOnlyList<Conclusion> ConfigAnalysisConclusion { get; } Property Value IReadOnlyList<Conclusion> CultureInfo public CultureInfo CultureInfo { get; } Property Value CultureInfo Options a set of custom flags that can enable/disable various settings public ConfigOptions Options { get; } Property Value ConfigOptions Orderer public IOrderer Orderer { get; } Property Value IOrderer SummaryStyle public SummaryStyle SummaryStyle { get; } Property Value SummaryStyle UnionRule public ConfigUnionRule UnionRule { get; } Property Value ConfigUnionRule WakeLock public WakeLockType WakeLock { get; } Property Value WakeLockType Methods GetAnalysers() public IEnumerable<IAnalyser> GetAnalysers() Returns IEnumerable<IAnalyser> GetColumnHidingRules() public IEnumerable<IColumnHidingRule> GetColumnHidingRules() Returns IEnumerable<IColumnHidingRule> GetColumnProviders() public IEnumerable<IColumnProvider> GetColumnProviders() Returns IEnumerable<IColumnProvider> GetDiagnosers() public IEnumerable<IDiagnoser> GetDiagnosers() Returns IEnumerable<IDiagnoser> GetEventProcessors() public IEnumerable<EventProcessor> GetEventProcessors() Returns IEnumerable<EventProcessor> GetExporters() public IEnumerable<IExporter> GetExporters() Returns IEnumerable<IExporter> GetFilters() public IEnumerable<IFilter> GetFilters() Returns IEnumerable<IFilter> GetHardwareCounters() public IEnumerable<HardwareCounter> GetHardwareCounters() Returns IEnumerable<HardwareCounter> GetJobs() public abstract IEnumerable<Job> GetJobs() Returns IEnumerable<Job> GetLoggers() public IEnumerable<ILogger> GetLoggers() Returns IEnumerable<ILogger> GetLogicalGroupRules() public IEnumerable<BenchmarkLogicalGroupRule> GetLogicalGroupRules() Returns IEnumerable<BenchmarkLogicalGroupRule> GetValidators() public IEnumerable<IValidator> GetValidators() Returns IEnumerable<IValidator>"
  },
  "api/BenchmarkDotNet.Configs.DebugInProcessConfig.html": {
    "href": "api/BenchmarkDotNet.Configs.DebugInProcessConfig.html",
    "title": "Class DebugInProcessConfig | BenchmarkDotNet",
    "summary": "Class DebugInProcessConfig Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll config which allows to debug benchmarks running it in the same process public class DebugInProcessConfig : DebugConfig, IConfig Inheritance object DebugConfig DebugInProcessConfig Implements IConfig Inherited Members DebugConfig.GetValidators() DebugConfig.GetColumnProviders() DebugConfig.GetExporters() DebugConfig.GetLoggers() DebugConfig.GetDiagnosers() DebugConfig.GetAnalysers() DebugConfig.GetHardwareCounters() DebugConfig.GetEventProcessors() DebugConfig.GetFilters() DebugConfig.GetColumnHidingRules() DebugConfig.GetLogicalGroupRules() DebugConfig.Orderer DebugConfig.CategoryDiscoverer DebugConfig.SummaryStyle DebugConfig.UnionRule DebugConfig.BuildTimeout DebugConfig.WakeLock DebugConfig.ArtifactsPath DebugConfig.CultureInfo DebugConfig.Options DebugConfig.ConfigAnalysisConclusion Extension Methods ConfigExtensions.AddAnalyser(IConfig, params IAnalyser[]) ConfigExtensions.AddColumn(IConfig, params IColumn[]) ConfigExtensions.AddColumnProvider(IConfig, params IColumnProvider[]) ConfigExtensions.AddDiagnoser(IConfig, params IDiagnoser[]) ConfigExtensions.AddEventProcessor(IConfig, params EventProcessor[]) ConfigExtensions.AddExporter(IConfig, params IExporter[]) ConfigExtensions.AddFilter(IConfig, params IFilter[]) ConfigExtensions.AddHardwareCounters(IConfig, params HardwareCounter[]) ConfigExtensions.AddJob(IConfig, Job) ConfigExtensions.AddLogger(IConfig, params ILogger[]) ConfigExtensions.AddLogicalGroupRules(IConfig, params BenchmarkLogicalGroupRule[]) ConfigExtensions.AddValidator(IConfig, params IValidator[]) ConfigExtensions.CreateImmutableConfig(IConfig) ConfigExtensions.DontOverwriteResults(IConfig, bool) ConfigExtensions.HideColumns(IConfig, params IColumn[]) ConfigExtensions.HideColumns(IConfig, params IColumnHidingRule[]) ConfigExtensions.HideColumns(IConfig, params string[]) ConfigExtensions.KeepBenchmarkFiles(IConfig, bool) ConfigExtensions.StopOnFirstError(IConfig, bool) ConfigExtensions.WithArtifactsPath(IConfig, string) ConfigExtensions.WithCultureInfo(IConfig, CultureInfo) ConfigExtensions.WithOption(IConfig, ConfigOptions, bool) ConfigExtensions.WithOptions(IConfig, ConfigOptions) ConfigExtensions.WithOrderer(IConfig, IOrderer) ConfigExtensions.WithSummaryStyle(IConfig, SummaryStyle) ConfigExtensions.WithUnionRule(IConfig, ConfigUnionRule) Constructors DebugInProcessConfig() public DebugInProcessConfig() Methods GetJobs() public override IEnumerable<Job> GetJobs() Returns IEnumerable<Job>"
  },
  "api/BenchmarkDotNet.Configs.DefaultConfig.html": {
    "href": "api/BenchmarkDotNet.Configs.DefaultConfig.html",
    "title": "Class DefaultConfig | BenchmarkDotNet",
    "summary": "Class DefaultConfig Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll public class DefaultConfig : IConfig Inheritance object DefaultConfig Implements IConfig Extension Methods ConfigExtensions.AddAnalyser(IConfig, params IAnalyser[]) ConfigExtensions.AddColumn(IConfig, params IColumn[]) ConfigExtensions.AddColumnProvider(IConfig, params IColumnProvider[]) ConfigExtensions.AddDiagnoser(IConfig, params IDiagnoser[]) ConfigExtensions.AddEventProcessor(IConfig, params EventProcessor[]) ConfigExtensions.AddExporter(IConfig, params IExporter[]) ConfigExtensions.AddFilter(IConfig, params IFilter[]) ConfigExtensions.AddHardwareCounters(IConfig, params HardwareCounter[]) ConfigExtensions.AddJob(IConfig, Job) ConfigExtensions.AddLogger(IConfig, params ILogger[]) ConfigExtensions.AddLogicalGroupRules(IConfig, params BenchmarkLogicalGroupRule[]) ConfigExtensions.AddValidator(IConfig, params IValidator[]) ConfigExtensions.CreateImmutableConfig(IConfig) ConfigExtensions.DontOverwriteResults(IConfig, bool) ConfigExtensions.HideColumns(IConfig, params IColumn[]) ConfigExtensions.HideColumns(IConfig, params IColumnHidingRule[]) ConfigExtensions.HideColumns(IConfig, params string[]) ConfigExtensions.KeepBenchmarkFiles(IConfig, bool) ConfigExtensions.StopOnFirstError(IConfig, bool) ConfigExtensions.WithArtifactsPath(IConfig, string) ConfigExtensions.WithCultureInfo(IConfig, CultureInfo) ConfigExtensions.WithOption(IConfig, ConfigOptions, bool) ConfigExtensions.WithOptions(IConfig, ConfigOptions) ConfigExtensions.WithOrderer(IConfig, IOrderer) ConfigExtensions.WithSummaryStyle(IConfig, SummaryStyle) ConfigExtensions.WithUnionRule(IConfig, ConfigUnionRule) Fields Instance public static readonly IConfig Instance Field Value IConfig Properties ArtifactsPath the default value is \"./BenchmarkDotNet.Artifacts\" public string ArtifactsPath { get; } Property Value string BuildTimeout the auto-generated project build timeout public TimeSpan BuildTimeout { get; } Property Value TimeSpan CategoryDiscoverer public ICategoryDiscoverer? CategoryDiscoverer { get; } Property Value ICategoryDiscoverer ConfigAnalysisConclusion Collect any errors or warnings when composing the configuration public IReadOnlyList<Conclusion> ConfigAnalysisConclusion { get; } Property Value IReadOnlyList<Conclusion> CultureInfo public CultureInfo CultureInfo { get; } Property Value CultureInfo Options a set of custom flags that can enable/disable various settings public ConfigOptions Options { get; } Property Value ConfigOptions Orderer public IOrderer Orderer { get; } Property Value IOrderer SummaryStyle public SummaryStyle SummaryStyle { get; } Property Value SummaryStyle UnionRule public ConfigUnionRule UnionRule { get; } Property Value ConfigUnionRule WakeLock public WakeLockType WakeLock { get; } Property Value WakeLockType Methods GetAnalysers() public IEnumerable<IAnalyser> GetAnalysers() Returns IEnumerable<IAnalyser> GetColumnHidingRules() public IEnumerable<IColumnHidingRule> GetColumnHidingRules() Returns IEnumerable<IColumnHidingRule> GetColumnProviders() public IEnumerable<IColumnProvider> GetColumnProviders() Returns IEnumerable<IColumnProvider> GetDiagnosers() public IEnumerable<IDiagnoser> GetDiagnosers() Returns IEnumerable<IDiagnoser> GetEventProcessors() public IEnumerable<EventProcessor> GetEventProcessors() Returns IEnumerable<EventProcessor> GetExporters() public IEnumerable<IExporter> GetExporters() Returns IEnumerable<IExporter> GetFilters() public IEnumerable<IFilter> GetFilters() Returns IEnumerable<IFilter> GetHardwareCounters() public IEnumerable<HardwareCounter> GetHardwareCounters() Returns IEnumerable<HardwareCounter> GetJobs() public IEnumerable<Job> GetJobs() Returns IEnumerable<Job> GetLoggers() public IEnumerable<ILogger> GetLoggers() Returns IEnumerable<ILogger> GetLogicalGroupRules() public IEnumerable<BenchmarkLogicalGroupRule> GetLogicalGroupRules() Returns IEnumerable<BenchmarkLogicalGroupRule> GetValidators() public IEnumerable<IValidator> GetValidators() Returns IEnumerable<IValidator>"
  },
  "api/BenchmarkDotNet.Configs.html": {
    "href": "api/BenchmarkDotNet.Configs.html",
    "title": "Namespace BenchmarkDotNet.Configs | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Configs Classes ConfigExtensions DebugBuildConfig config which allows to build benchmarks in Debug DebugConfig DebugInProcessConfig config which allows to debug benchmarks running it in the same process DefaultConfig ImmutableConfig ImmutableConfigBuilder this class is responsible for config that has no duplicates, does all of the internal hacks and is ready to run ManualConfig Interfaces IConfig IConfigSource Enums BenchmarkLogicalGroupRule ConfigOptions ConfigUnionRule WakeLockType"
  },
  "api/BenchmarkDotNet.Configs.IConfig.html": {
    "href": "api/BenchmarkDotNet.Configs.IConfig.html",
    "title": "Interface IConfig | BenchmarkDotNet",
    "summary": "Interface IConfig Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll public interface IConfig Extension Methods ConfigExtensions.AddAnalyser(IConfig, params IAnalyser[]) ConfigExtensions.AddColumn(IConfig, params IColumn[]) ConfigExtensions.AddColumnProvider(IConfig, params IColumnProvider[]) ConfigExtensions.AddDiagnoser(IConfig, params IDiagnoser[]) ConfigExtensions.AddEventProcessor(IConfig, params EventProcessor[]) ConfigExtensions.AddExporter(IConfig, params IExporter[]) ConfigExtensions.AddFilter(IConfig, params IFilter[]) ConfigExtensions.AddHardwareCounters(IConfig, params HardwareCounter[]) ConfigExtensions.AddJob(IConfig, Job) ConfigExtensions.AddLogger(IConfig, params ILogger[]) ConfigExtensions.AddLogicalGroupRules(IConfig, params BenchmarkLogicalGroupRule[]) ConfigExtensions.AddValidator(IConfig, params IValidator[]) ConfigExtensions.CreateImmutableConfig(IConfig) ConfigExtensions.DontOverwriteResults(IConfig, bool) ConfigExtensions.HideColumns(IConfig, params IColumn[]) ConfigExtensions.HideColumns(IConfig, params IColumnHidingRule[]) ConfigExtensions.HideColumns(IConfig, params string[]) ConfigExtensions.KeepBenchmarkFiles(IConfig, bool) ConfigExtensions.StopOnFirstError(IConfig, bool) ConfigExtensions.WithArtifactsPath(IConfig, string) ConfigExtensions.WithCultureInfo(IConfig, CultureInfo) ConfigExtensions.WithOption(IConfig, ConfigOptions, bool) ConfigExtensions.WithOptions(IConfig, ConfigOptions) ConfigExtensions.WithOrderer(IConfig, IOrderer) ConfigExtensions.WithSummaryStyle(IConfig, SummaryStyle) ConfigExtensions.WithUnionRule(IConfig, ConfigUnionRule) Properties ArtifactsPath the default value is \"./BenchmarkDotNet.Artifacts\" string ArtifactsPath { get; } Property Value string BuildTimeout the auto-generated project build timeout TimeSpan BuildTimeout { get; } Property Value TimeSpan CategoryDiscoverer ICategoryDiscoverer? CategoryDiscoverer { get; } Property Value ICategoryDiscoverer ConfigAnalysisConclusion Collect any errors or warnings when composing the configuration IReadOnlyList<Conclusion> ConfigAnalysisConclusion { get; } Property Value IReadOnlyList<Conclusion> CultureInfo CultureInfo? CultureInfo { get; } Property Value CultureInfo Options a set of custom flags that can enable/disable various settings ConfigOptions Options { get; } Property Value ConfigOptions Orderer IOrderer? Orderer { get; } Property Value IOrderer SummaryStyle SummaryStyle SummaryStyle { get; } Property Value SummaryStyle UnionRule ConfigUnionRule UnionRule { get; } Property Value ConfigUnionRule WakeLock WakeLockType WakeLock { get; } Property Value WakeLockType Methods GetAnalysers() IEnumerable<IAnalyser> GetAnalysers() Returns IEnumerable<IAnalyser> GetColumnHidingRules() IEnumerable<IColumnHidingRule> GetColumnHidingRules() Returns IEnumerable<IColumnHidingRule> GetColumnProviders() IEnumerable<IColumnProvider> GetColumnProviders() Returns IEnumerable<IColumnProvider> GetDiagnosers() IEnumerable<IDiagnoser> GetDiagnosers() Returns IEnumerable<IDiagnoser> GetEventProcessors() IEnumerable<EventProcessor> GetEventProcessors() Returns IEnumerable<EventProcessor> GetExporters() IEnumerable<IExporter> GetExporters() Returns IEnumerable<IExporter> GetFilters() IEnumerable<IFilter> GetFilters() Returns IEnumerable<IFilter> GetHardwareCounters() IEnumerable<HardwareCounter> GetHardwareCounters() Returns IEnumerable<HardwareCounter> GetJobs() IEnumerable<Job> GetJobs() Returns IEnumerable<Job> GetLoggers() IEnumerable<ILogger> GetLoggers() Returns IEnumerable<ILogger> GetLogicalGroupRules() IEnumerable<BenchmarkLogicalGroupRule> GetLogicalGroupRules() Returns IEnumerable<BenchmarkLogicalGroupRule> GetValidators() IEnumerable<IValidator> GetValidators() Returns IEnumerable<IValidator>"
  },
  "api/BenchmarkDotNet.Configs.IConfigSource.html": {
    "href": "api/BenchmarkDotNet.Configs.IConfigSource.html",
    "title": "Interface IConfigSource | BenchmarkDotNet",
    "summary": "Interface IConfigSource Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll public interface IConfigSource Properties Config IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Configs.ImmutableConfig.html": {
    "href": "api/BenchmarkDotNet.Configs.ImmutableConfig.html",
    "title": "Class ImmutableConfig | BenchmarkDotNet",
    "summary": "Class ImmutableConfig Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll public sealed class ImmutableConfig : IConfig Inheritance object ImmutableConfig Implements IConfig Extension Methods ConfigExtensions.AddAnalyser(IConfig, params IAnalyser[]) ConfigExtensions.AddColumn(IConfig, params IColumn[]) ConfigExtensions.AddColumnProvider(IConfig, params IColumnProvider[]) ConfigExtensions.AddDiagnoser(IConfig, params IDiagnoser[]) ConfigExtensions.AddEventProcessor(IConfig, params EventProcessor[]) ConfigExtensions.AddExporter(IConfig, params IExporter[]) ConfigExtensions.AddFilter(IConfig, params IFilter[]) ConfigExtensions.AddHardwareCounters(IConfig, params HardwareCounter[]) ConfigExtensions.AddJob(IConfig, Job) ConfigExtensions.AddLogger(IConfig, params ILogger[]) ConfigExtensions.AddLogicalGroupRules(IConfig, params BenchmarkLogicalGroupRule[]) ConfigExtensions.AddValidator(IConfig, params IValidator[]) ConfigExtensions.CreateImmutableConfig(IConfig) ConfigExtensions.DontOverwriteResults(IConfig, bool) ConfigExtensions.HideColumns(IConfig, params IColumn[]) ConfigExtensions.HideColumns(IConfig, params IColumnHidingRule[]) ConfigExtensions.HideColumns(IConfig, params string[]) ConfigExtensions.KeepBenchmarkFiles(IConfig, bool) ConfigExtensions.StopOnFirstError(IConfig, bool) ConfigExtensions.WithArtifactsPath(IConfig, string) ConfigExtensions.WithCultureInfo(IConfig, CultureInfo) ConfigExtensions.WithOption(IConfig, ConfigOptions, bool) ConfigExtensions.WithOptions(IConfig, ConfigOptions) ConfigExtensions.WithOrderer(IConfig, IOrderer) ConfigExtensions.WithSummaryStyle(IConfig, SummaryStyle) ConfigExtensions.WithUnionRule(IConfig, ConfigUnionRule) Properties ArtifactsPath the default value is \"./BenchmarkDotNet.Artifacts\" public string ArtifactsPath { get; } Property Value string BuildTimeout the auto-generated project build timeout public TimeSpan BuildTimeout { get; } Property Value TimeSpan CategoryDiscoverer public ICategoryDiscoverer CategoryDiscoverer { get; } Property Value ICategoryDiscoverer ConfigAnalysisConclusion Collect any errors or warnings when composing the configuration public IReadOnlyList<Conclusion> ConfigAnalysisConclusion { get; } Property Value IReadOnlyList<Conclusion> CultureInfo public CultureInfo CultureInfo { get; } Property Value CultureInfo Options a set of custom flags that can enable/disable various settings public ConfigOptions Options { get; } Property Value ConfigOptions Orderer public IOrderer Orderer { get; } Property Value IOrderer SummaryStyle public SummaryStyle SummaryStyle { get; } Property Value SummaryStyle UnionRule public ConfigUnionRule UnionRule { get; } Property Value ConfigUnionRule WakeLock public WakeLockType WakeLock { get; } Property Value WakeLockType Methods GetAnalysers() public IEnumerable<IAnalyser> GetAnalysers() Returns IEnumerable<IAnalyser> GetColumnHidingRules() public IEnumerable<IColumnHidingRule> GetColumnHidingRules() Returns IEnumerable<IColumnHidingRule> GetColumnProviders() public IEnumerable<IColumnProvider> GetColumnProviders() Returns IEnumerable<IColumnProvider> GetCompositeAnalyser() public IAnalyser GetCompositeAnalyser() Returns IAnalyser GetCompositeDiagnoser() public IDiagnoser GetCompositeDiagnoser() Returns IDiagnoser GetCompositeDiagnoser(BenchmarkCase, RunMode) public IDiagnoser? GetCompositeDiagnoser(BenchmarkCase benchmarkCase, RunMode runMode) Parameters benchmarkCase BenchmarkCase runMode RunMode Returns IDiagnoser GetCompositeExporter() public IExporter GetCompositeExporter() Returns IExporter GetCompositeLogger() public ILogger GetCompositeLogger() Returns ILogger GetCompositeValidator() public IValidator GetCompositeValidator() Returns IValidator GetDiagnosers() public IEnumerable<IDiagnoser> GetDiagnosers() Returns IEnumerable<IDiagnoser> GetEventProcessors() public IEnumerable<EventProcessor> GetEventProcessors() Returns IEnumerable<EventProcessor> GetExporters() public IEnumerable<IExporter> GetExporters() Returns IEnumerable<IExporter> GetFilters() public IEnumerable<IFilter> GetFilters() Returns IEnumerable<IFilter> GetHardwareCounters() public IEnumerable<HardwareCounter> GetHardwareCounters() Returns IEnumerable<HardwareCounter> GetJobs() public IEnumerable<Job> GetJobs() Returns IEnumerable<Job> GetLoggers() public IEnumerable<ILogger> GetLoggers() Returns IEnumerable<ILogger> GetLogicalGroupRules() public IEnumerable<BenchmarkLogicalGroupRule> GetLogicalGroupRules() Returns IEnumerable<BenchmarkLogicalGroupRule> GetValidators() public IEnumerable<IValidator> GetValidators() Returns IEnumerable<IValidator> HasExceptionDiagnoser() public bool HasExceptionDiagnoser() Returns bool HasExtraStatsDiagnoser() public bool HasExtraStatsDiagnoser() Returns bool HasMemoryDiagnoser() public bool HasMemoryDiagnoser() Returns bool HasThreadingDiagnoser() public bool HasThreadingDiagnoser() Returns bool"
  },
  "api/BenchmarkDotNet.Configs.ImmutableConfigBuilder.html": {
    "href": "api/BenchmarkDotNet.Configs.ImmutableConfigBuilder.html",
    "title": "Class ImmutableConfigBuilder | BenchmarkDotNet",
    "summary": "Class ImmutableConfigBuilder Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll this class is responsible for config that has no duplicates, does all of the internal hacks and is ready to run public static class ImmutableConfigBuilder Inheritance object ImmutableConfigBuilder Methods Create(IConfig) removes duplicates and applies all extra logic required to make the config a final one public static ImmutableConfig Create(IConfig source) Parameters source IConfig Returns ImmutableConfig"
  },
  "api/BenchmarkDotNet.Configs.ManualConfig.html": {
    "href": "api/BenchmarkDotNet.Configs.ManualConfig.html",
    "title": "Class ManualConfig | BenchmarkDotNet",
    "summary": "Class ManualConfig Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll public class ManualConfig : IConfig Inheritance object ManualConfig Implements IConfig Extension Methods ConfigExtensions.AddAnalyser(IConfig, params IAnalyser[]) ConfigExtensions.AddColumn(IConfig, params IColumn[]) ConfigExtensions.AddColumnProvider(IConfig, params IColumnProvider[]) ConfigExtensions.AddDiagnoser(IConfig, params IDiagnoser[]) ConfigExtensions.AddEventProcessor(IConfig, params EventProcessor[]) ConfigExtensions.AddExporter(IConfig, params IExporter[]) ConfigExtensions.AddFilter(IConfig, params IFilter[]) ConfigExtensions.AddHardwareCounters(IConfig, params HardwareCounter[]) ConfigExtensions.AddJob(IConfig, Job) ConfigExtensions.AddLogger(IConfig, params ILogger[]) ConfigExtensions.AddLogicalGroupRules(IConfig, params BenchmarkLogicalGroupRule[]) ConfigExtensions.AddValidator(IConfig, params IValidator[]) ConfigExtensions.CreateImmutableConfig(IConfig) ConfigExtensions.DontOverwriteResults(IConfig, bool) ConfigExtensions.HideColumns(IConfig, params IColumn[]) ConfigExtensions.HideColumns(IConfig, params IColumnHidingRule[]) ConfigExtensions.HideColumns(IConfig, params string[]) ConfigExtensions.KeepBenchmarkFiles(IConfig, bool) ConfigExtensions.StopOnFirstError(IConfig, bool) ConfigExtensions.WithArtifactsPath(IConfig, string) ConfigExtensions.WithCultureInfo(IConfig, CultureInfo) ConfigExtensions.WithOption(IConfig, ConfigOptions, bool) ConfigExtensions.WithOptions(IConfig, ConfigOptions) ConfigExtensions.WithOrderer(IConfig, IOrderer) ConfigExtensions.WithSummaryStyle(IConfig, SummaryStyle) ConfigExtensions.WithUnionRule(IConfig, ConfigUnionRule) Constructors ManualConfig() public ManualConfig() Properties ArtifactsPath the default value is \"./BenchmarkDotNet.Artifacts\" public string ArtifactsPath { get; set; } Property Value string BuildTimeout the auto-generated project build timeout public TimeSpan BuildTimeout { get; set; } Property Value TimeSpan CategoryDiscoverer public ICategoryDiscoverer CategoryDiscoverer { get; set; } Property Value ICategoryDiscoverer ConfigAnalysisConclusion Collect any errors or warnings when composing the configuration public IReadOnlyList<Conclusion> ConfigAnalysisConclusion { get; } Property Value IReadOnlyList<Conclusion> CultureInfo public CultureInfo CultureInfo { get; set; } Property Value CultureInfo Options a set of custom flags that can enable/disable various settings public ConfigOptions Options { get; set; } Property Value ConfigOptions Orderer public IOrderer Orderer { get; set; } Property Value IOrderer SummaryStyle public SummaryStyle SummaryStyle { get; set; } Property Value SummaryStyle UnionRule public ConfigUnionRule UnionRule { get; set; } Property Value ConfigUnionRule WakeLock public WakeLockType WakeLock { get; set; } Property Value WakeLockType Methods Add(IConfig) public void Add(IConfig config) Parameters config IConfig AddAnalyser(params IAnalyser[]) public ManualConfig AddAnalyser(params IAnalyser[] newAnalysers) Parameters newAnalysers IAnalyser[] Returns ManualConfig AddColumn(params IColumn[]) public ManualConfig AddColumn(params IColumn[] newColumns) Parameters newColumns IColumn[] Returns ManualConfig AddColumnProvider(params IColumnProvider[]) public ManualConfig AddColumnProvider(params IColumnProvider[] newColumnProviders) Parameters newColumnProviders IColumnProvider[] Returns ManualConfig AddDiagnoser(params IDiagnoser[]) public ManualConfig AddDiagnoser(params IDiagnoser[] newDiagnosers) Parameters newDiagnosers IDiagnoser[] Returns ManualConfig AddEventProcessor(params EventProcessor[]) public ManualConfig AddEventProcessor(params EventProcessor[] newEventProcessors) Parameters newEventProcessors EventProcessor[] Returns ManualConfig AddExporter(params IExporter[]) public ManualConfig AddExporter(params IExporter[] newExporters) Parameters newExporters IExporter[] Returns ManualConfig AddFilter(params IFilter[]) public ManualConfig AddFilter(params IFilter[] newFilters) Parameters newFilters IFilter[] Returns ManualConfig AddHardwareCounters(params HardwareCounter[]) public ManualConfig AddHardwareCounters(params HardwareCounter[] newHardwareCounters) Parameters newHardwareCounters HardwareCounter[] Returns ManualConfig AddJob(params Job[]) public ManualConfig AddJob(params Job[] newJobs) Parameters newJobs Job[] Returns ManualConfig AddLogger(params ILogger[]) public ManualConfig AddLogger(params ILogger[] newLoggers) Parameters newLoggers ILogger[] Returns ManualConfig AddLogicalGroupRules(params BenchmarkLogicalGroupRule[]) public ManualConfig AddLogicalGroupRules(params BenchmarkLogicalGroupRule[] rules) Parameters rules BenchmarkLogicalGroupRule[] Returns ManualConfig AddValidator(params IValidator[]) public ManualConfig AddValidator(params IValidator[] newValidators) Parameters newValidators IValidator[] Returns ManualConfig Create(IConfig) public static ManualConfig Create(IConfig config) Parameters config IConfig Returns ManualConfig CreateEmpty() Creates a completely EMPTY config with no predefined settings. public static ManualConfig CreateEmpty() Returns ManualConfig Remarks You should most probably use the CreateMinimumViable() method instead. CreateMinimumViable() Creates a minimum viable config with predefined columns provider and console logger. public static ManualConfig CreateMinimumViable() Returns ManualConfig GetAnalysers() public IEnumerable<IAnalyser> GetAnalysers() Returns IEnumerable<IAnalyser> GetColumnHidingRules() public IEnumerable<IColumnHidingRule> GetColumnHidingRules() Returns IEnumerable<IColumnHidingRule> GetColumnProviders() public IEnumerable<IColumnProvider> GetColumnProviders() Returns IEnumerable<IColumnProvider> GetDiagnosers() public IEnumerable<IDiagnoser> GetDiagnosers() Returns IEnumerable<IDiagnoser> GetEventProcessors() public IEnumerable<EventProcessor> GetEventProcessors() Returns IEnumerable<EventProcessor> GetExporters() public IEnumerable<IExporter> GetExporters() Returns IEnumerable<IExporter> GetFilters() public IEnumerable<IFilter> GetFilters() Returns IEnumerable<IFilter> GetHardwareCounters() public IEnumerable<HardwareCounter> GetHardwareCounters() Returns IEnumerable<HardwareCounter> GetJobs() public IEnumerable<Job> GetJobs() Returns IEnumerable<Job> GetLoggers() public IEnumerable<ILogger> GetLoggers() Returns IEnumerable<ILogger> GetLogicalGroupRules() public IEnumerable<BenchmarkLogicalGroupRule> GetLogicalGroupRules() Returns IEnumerable<BenchmarkLogicalGroupRule> GetValidators() public IEnumerable<IValidator> GetValidators() Returns IEnumerable<IValidator> HideColumns(params IColumnHidingRule[]) public ManualConfig HideColumns(params IColumnHidingRule[] rules) Parameters rules IColumnHidingRule[] Returns ManualConfig HideColumns(params IColumn[]) public ManualConfig HideColumns(params IColumn[] columns) Parameters columns IColumn[] Returns ManualConfig HideColumns(params string[]) public ManualConfig HideColumns(params string[] columnNames) Parameters columnNames string[] Returns ManualConfig Union(IConfig, IConfig) public static ManualConfig Union(IConfig globalConfig, IConfig localConfig) Parameters globalConfig IConfig localConfig IConfig Returns ManualConfig WithArtifactsPath(string) public ManualConfig WithArtifactsPath(string artifactsPath) Parameters artifactsPath string Returns ManualConfig WithBuildTimeout(TimeSpan) public ManualConfig WithBuildTimeout(TimeSpan buildTimeout) Parameters buildTimeout TimeSpan Returns ManualConfig WithCategoryDiscoverer(ICategoryDiscoverer) public ManualConfig WithCategoryDiscoverer(ICategoryDiscoverer categoryDiscoverer) Parameters categoryDiscoverer ICategoryDiscoverer Returns ManualConfig WithOption(ConfigOptions, bool) public ManualConfig WithOption(ConfigOptions option, bool value) Parameters option ConfigOptions value bool Returns ManualConfig WithOptions(ConfigOptions) public ManualConfig WithOptions(ConfigOptions options) Parameters options ConfigOptions Returns ManualConfig WithOrderer(IOrderer) public ManualConfig WithOrderer(IOrderer orderer) Parameters orderer IOrderer Returns ManualConfig WithSummaryStyle(SummaryStyle) public ManualConfig WithSummaryStyle(SummaryStyle summaryStyle) Parameters summaryStyle SummaryStyle Returns ManualConfig WithUnionRule(ConfigUnionRule) public ManualConfig WithUnionRule(ConfigUnionRule unionRule) Parameters unionRule ConfigUnionRule Returns ManualConfig WithWakeLock(WakeLockType) public ManualConfig WithWakeLock(WakeLockType wakeLockType) Parameters wakeLockType WakeLockType Returns ManualConfig"
  },
  "api/BenchmarkDotNet.Configs.WakeLockType.html": {
    "href": "api/BenchmarkDotNet.Configs.WakeLockType.html",
    "title": "Enum WakeLockType | BenchmarkDotNet",
    "summary": "Enum WakeLockType Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll public enum WakeLockType Fields Display = 2 Forces the display to be on while benchmarks are running. None = 0 Allows the system to enter sleep and/or turn off the display while benchmarks are running. System = 1 Forces the system to be in the working state while benchmarks are running."
  },
  "api/BenchmarkDotNet.ConsoleArguments.CommandLineOptions.html": {
    "href": "api/BenchmarkDotNet.ConsoleArguments.CommandLineOptions.html",
    "title": "Class CommandLineOptions | BenchmarkDotNet",
    "summary": "Class CommandLineOptions Namespace BenchmarkDotNet.ConsoleArguments Assembly BenchmarkDotNet.dll public class CommandLineOptions Inheritance object CommandLineOptions Constructors CommandLineOptions() public CommandLineOptions() Properties AOTCompilerMode public MonoAotCompilerMode AOTCompilerMode { get; set; } Property Value MonoAotCompilerMode AOTCompilerPath public FileInfo AOTCompilerPath { get; set; } Property Value FileInfo Affinity public int? Affinity { get; set; } Property Value int? AllCategories public IEnumerable<string> AllCategories { get; set; } Property Value IEnumerable<string> AnyCategories public IEnumerable<string> AnyCategories { get; set; } Property Value IEnumerable<string> ApplesToApples public bool ApplesToApples { get; set; } Property Value bool ArtifactsDirectory public DirectoryInfo ArtifactsDirectory { get; set; } Property Value DirectoryInfo AttributeNames public IEnumerable<string> AttributeNames { get; set; } Property Value IEnumerable<string> BaseJob public string BaseJob { get; set; } Property Value string CliPath public FileInfo CliPath { get; set; } Property Value FileInfo ClrVersion public string ClrVersion { get; set; } Property Value string CoreRunPaths public IReadOnlyList<FileInfo> CoreRunPaths { get; set; } Property Value IReadOnlyList<FileInfo> CustomRuntimePack public string CustomRuntimePack { get; set; } Property Value string DisableLogFile public bool DisableLogFile { get; set; } Property Value bool DisassemblerDiff public bool DisassemblerDiff { get; set; } Property Value bool DisassemblerFilters public IEnumerable<string> DisassemblerFilters { get; set; } Property Value IEnumerable<string> DisassemblerRecursiveDepth public int DisassemblerRecursiveDepth { get; set; } Property Value int DisplayAllStatistics public bool DisplayAllStatistics { get; set; } Property Value bool DontOverwriteResults public bool DontOverwriteResults { get; set; } Property Value bool EnvironmentVariables public IEnumerable<string> EnvironmentVariables { get; set; } Property Value IEnumerable<string> Examples public static IEnumerable<Example> Examples { get; } Property Value IEnumerable<Example> Exporters public IEnumerable<string> Exporters { get; set; } Property Value IEnumerable<string> Filters public IEnumerable<string> Filters { get; set; } Property Value IEnumerable<string> GenerateMSBuildBinLog public bool GenerateMSBuildBinLog { get; set; } Property Value bool HardwareCounters public IEnumerable<string> HardwareCounters { get; set; } Property Value IEnumerable<string> HiddenColumns public IEnumerable<string> HiddenColumns { get; set; } Property Value IEnumerable<string> ILCompilerVersion public string ILCompilerVersion { get; set; } Property Value string IlcPackages public DirectoryInfo IlcPackages { get; set; } Property Value DirectoryInfo InvocationCount public long? InvocationCount { get; set; } Property Value long? IterationCount public int? IterationCount { get; set; } Property Value int? IterationTimeInMilliseconds public int? IterationTimeInMilliseconds { get; set; } Property Value int? Join public bool Join { get; set; } Property Value bool KeepBenchmarkFiles public bool KeepBenchmarkFiles { get; set; } Property Value bool LaunchCount public int? LaunchCount { get; set; } Property Value int? ListBenchmarkCaseMode public ListBenchmarkCaseMode ListBenchmarkCaseMode { get; set; } Property Value ListBenchmarkCaseMode LogBuildOutput public bool LogBuildOutput { get; set; } Property Value bool MaxIterationCount public int? MaxIterationCount { get; set; } Property Value int? MaxParameterColumnWidth public int? MaxParameterColumnWidth { get; set; } Property Value int? MaxWarmupIterationCount public int? MaxWarmupIterationCount { get; set; } Property Value int? MemoryRandomization public bool MemoryRandomization { get; set; } Property Value bool MinIterationCount public int? MinIterationCount { get; set; } Property Value int? MinWarmupIterationCount public int? MinWarmupIterationCount { get; set; } Property Value int? MonoPath public FileInfo MonoPath { get; set; } Property Value FileInfo NoEvaluationOverhead public bool NoEvaluationOverhead { get; set; } Property Value bool NoForcedGCs public bool NoForcedGCs { get; set; } Property Value bool Outliers public OutlierMode Outliers { get; set; } Property Value OutlierMode Platform public Platform? Platform { get; set; } Property Value Platform? PrintInformation public bool PrintInformation { get; set; } Property Value bool Profiler public string Profiler { get; set; } Property Value string RestorePath public DirectoryInfo RestorePath { get; set; } Property Value DirectoryInfo Resume public bool Resume { get; set; } Property Value bool RunInProcess public bool RunInProcess { get; set; } Property Value bool RunOncePerIteration public bool RunOncePerIteration { get; set; } Property Value bool RunStrategy public RunStrategy? RunStrategy { get; set; } Property Value RunStrategy? Runtimes public IEnumerable<string> Runtimes { get; set; } Property Value IEnumerable<string> StatisticalTestThreshold public string StatisticalTestThreshold { get; set; } Property Value string StopOnFirstError public bool StopOnFirstError { get; set; } Property Value bool TimeOutInSeconds public int? TimeOutInSeconds { get; set; } Property Value int? UnrollFactor public int? UnrollFactor { get; set; } Property Value int? UseDisassemblyDiagnoser public bool UseDisassemblyDiagnoser { get; set; } Property Value bool UseExceptionDiagnoser public bool UseExceptionDiagnoser { get; set; } Property Value bool UseMemoryDiagnoser public bool UseMemoryDiagnoser { get; set; } Property Value bool UseThreadingDiagnoser public bool UseThreadingDiagnoser { get; set; } Property Value bool WakeLock public WakeLockType? WakeLock { get; set; } Property Value WakeLockType? WarmupIterationCount public int? WarmupIterationCount { get; set; } Property Value int? WasmDataDirectory public DirectoryInfo WasmDataDirectory { get; set; } Property Value DirectoryInfo WasmJavaScriptEngineArguments public string WasmJavaScriptEngineArguments { get; set; } Property Value string WasmJavascriptEngine public FileInfo WasmJavascriptEngine { get; set; } Property Value FileInfo"
  },
  "api/BenchmarkDotNet.ConsoleArguments.ConfigParser.html": {
    "href": "api/BenchmarkDotNet.ConsoleArguments.ConfigParser.html",
    "title": "Class ConfigParser | BenchmarkDotNet",
    "summary": "Class ConfigParser Namespace BenchmarkDotNet.ConsoleArguments Assembly BenchmarkDotNet.dll public static class ConfigParser Inheritance object ConfigParser Methods Parse(string[], ILogger, IConfig?) public static (bool isSuccess, IConfig config, CommandLineOptions options) Parse(string[] args, ILogger logger, IConfig? globalConfig = null) Parameters args string[] logger ILogger globalConfig IConfig Returns (bool isSuccess, IConfig config, CommandLineOptions options)"
  },
  "api/BenchmarkDotNet.ConsoleArguments.CorrectionsSuggester.html": {
    "href": "api/BenchmarkDotNet.ConsoleArguments.CorrectionsSuggester.html",
    "title": "Class CorrectionsSuggester | BenchmarkDotNet",
    "summary": "Class CorrectionsSuggester Namespace BenchmarkDotNet.ConsoleArguments Assembly BenchmarkDotNet.dll public class CorrectionsSuggester Inheritance object CorrectionsSuggester Constructors CorrectionsSuggester(IReadOnlyList<Type>) public CorrectionsSuggester(IReadOnlyList<Type> types) Parameters types IReadOnlyList<Type> Methods GetAllBenchmarkNames() public string[] GetAllBenchmarkNames() Returns string[] SuggestFor(string) public string[] SuggestFor(string userInput) Parameters userInput string Returns string[]"
  },
  "api/BenchmarkDotNet.ConsoleArguments.html": {
    "href": "api/BenchmarkDotNet.ConsoleArguments.html",
    "title": "Namespace BenchmarkDotNet.ConsoleArguments | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.ConsoleArguments Classes CommandLineOptions ConfigParser CorrectionsSuggester"
  },
  "api/BenchmarkDotNet.ConsoleArguments.ListBenchmarks.html": {
    "href": "api/BenchmarkDotNet.ConsoleArguments.ListBenchmarks.html",
    "title": "Namespace BenchmarkDotNet.ConsoleArguments.ListBenchmarks | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.ConsoleArguments.ListBenchmarks Enums ListBenchmarkCaseMode"
  },
  "api/BenchmarkDotNet.ConsoleArguments.ListBenchmarks.ListBenchmarkCaseMode.html": {
    "href": "api/BenchmarkDotNet.ConsoleArguments.ListBenchmarks.ListBenchmarkCaseMode.html",
    "title": "Enum ListBenchmarkCaseMode | BenchmarkDotNet",
    "summary": "Enum ListBenchmarkCaseMode Namespace BenchmarkDotNet.ConsoleArguments.ListBenchmarks Assembly BenchmarkDotNet.dll public enum ListBenchmarkCaseMode Fields Disabled = 0 Do not print any of the available full benchmark names. Flat = 1 Prints flat list of the available benchmark names. Tree = 2 Prints tree of the available full benchmark names."
  },
  "api/BenchmarkDotNet.Detectors.Cpu.html": {
    "href": "api/BenchmarkDotNet.Detectors.Cpu.html",
    "title": "Namespace BenchmarkDotNet.Detectors.Cpu | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Detectors.Cpu Interfaces ICpuDetector Loads the Perfolizer.Models.CpuInfo for the current hardware"
  },
  "api/BenchmarkDotNet.Detectors.Cpu.ICpuDetector.html": {
    "href": "api/BenchmarkDotNet.Detectors.Cpu.ICpuDetector.html",
    "title": "Interface ICpuDetector | BenchmarkDotNet",
    "summary": "Interface ICpuDetector Namespace BenchmarkDotNet.Detectors.Cpu Assembly BenchmarkDotNet.dll Loads the Perfolizer.Models.CpuInfo for the current hardware public interface ICpuDetector Methods Detect() CpuInfo? Detect() Returns CpuInfo IsApplicable() bool IsApplicable() Returns bool"
  },
  "api/BenchmarkDotNet.Detectors.CpuDetector.html": {
    "href": "api/BenchmarkDotNet.Detectors.CpuDetector.html",
    "title": "Class CpuDetector | BenchmarkDotNet",
    "summary": "Class CpuDetector Namespace BenchmarkDotNet.Detectors Assembly BenchmarkDotNet.dll public class CpuDetector : ICpuDetector Inheritance object CpuDetector Implements ICpuDetector Constructors CpuDetector(params ICpuDetector[]) public CpuDetector(params ICpuDetector[] detectors) Parameters detectors ICpuDetector[] Properties Cpu public static CpuInfo? Cpu { get; } Property Value CpuInfo CrossPlatform public static CpuDetector CrossPlatform { get; } Property Value CpuDetector Methods Detect() public CpuInfo? Detect() Returns CpuInfo IsApplicable() public bool IsApplicable() Returns bool"
  },
  "api/BenchmarkDotNet.Detectors.html": {
    "href": "api/BenchmarkDotNet.Detectors.html",
    "title": "Namespace BenchmarkDotNet.Detectors | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Detectors Classes CpuDetector OsDetector"
  },
  "api/BenchmarkDotNet.Detectors.OsDetector.html": {
    "href": "api/BenchmarkDotNet.Detectors.OsDetector.html",
    "title": "Class OsDetector | BenchmarkDotNet",
    "summary": "Class OsDetector Namespace BenchmarkDotNet.Detectors Assembly BenchmarkDotNet.dll public class OsDetector Inheritance object OsDetector Fields Instance public static readonly OsDetector Instance Field Value OsDetector Methods GetOs() public static OsInfo GetOs() Returns OsInfo"
  },
  "api/BenchmarkDotNet.Diagnosers.CompositeDiagnoser.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.CompositeDiagnoser.html",
    "title": "Class CompositeDiagnoser | BenchmarkDotNet",
    "summary": "Class CompositeDiagnoser Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class CompositeDiagnoser : IDiagnoser Inheritance object CompositeDiagnoser Implements IDiagnoser Constructors CompositeDiagnoser(ImmutableHashSet<IDiagnoser>) public CompositeDiagnoser(ImmutableHashSet<IDiagnoser> diagnosers) Parameters diagnosers ImmutableHashSet<IDiagnoser> Properties Analysers public IEnumerable<IAnalyser> Analysers { get; } Property Value IEnumerable<IAnalyser> Exporters public IEnumerable<IExporter> Exporters { get; } Property Value IEnumerable<IExporter> Ids public IEnumerable<string> Ids { get; } Property Value IEnumerable<string> Methods DisplayResults(ILogger) public void DisplayResults(ILogger logger) Parameters logger ILogger GetRunMode(BenchmarkCase) public RunMode GetRunMode(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns RunMode Handle(HostSignal, DiagnoserActionParameters) public void Handle(HostSignal signal, DiagnoserActionParameters parameters) Parameters signal HostSignal parameters DiagnoserActionParameters ProcessResults(DiagnoserResults) public IEnumerable<Metric> ProcessResults(DiagnoserResults results) Parameters results DiagnoserResults Returns IEnumerable<Metric> Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Diagnosers.DiagnoserActionParameters.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.DiagnoserActionParameters.html",
    "title": "Class DiagnoserActionParameters | BenchmarkDotNet",
    "summary": "Class DiagnoserActionParameters Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class DiagnoserActionParameters Inheritance object DiagnoserActionParameters Constructors DiagnoserActionParameters(Process?, BenchmarkCase, BenchmarkId) public DiagnoserActionParameters(Process? process, BenchmarkCase benchmarkCase, BenchmarkId benchmarkId) Parameters process Process benchmarkCase BenchmarkCase benchmarkId BenchmarkId Properties BenchmarkCase public BenchmarkCase BenchmarkCase { get; } Property Value BenchmarkCase BenchmarkId public BenchmarkId BenchmarkId { get; } Property Value BenchmarkId Config public ImmutableConfig Config { get; } Property Value ImmutableConfig Process public Process Process { get; } Property Value Process"
  },
  "api/BenchmarkDotNet.Diagnosers.DiagnoserResults.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.DiagnoserResults.html",
    "title": "Class DiagnoserResults | BenchmarkDotNet",
    "summary": "Class DiagnoserResults Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class DiagnoserResults Inheritance object DiagnoserResults Constructors DiagnoserResults(BenchmarkCase, ExecuteResult, BuildResult) public DiagnoserResults(BenchmarkCase benchmarkCase, ExecuteResult executeResult, BuildResult buildResult) Parameters benchmarkCase BenchmarkCase executeResult ExecuteResult buildResult BuildResult Properties BenchmarkCase public BenchmarkCase BenchmarkCase { get; } Property Value BenchmarkCase BuildResult public BuildResult BuildResult { get; } Property Value BuildResult ExceptionFrequency public double ExceptionFrequency { get; } Property Value double GcStats public GcStats GcStats { get; } Property Value GcStats Measurements public IReadOnlyList<Measurement> Measurements { get; } Property Value IReadOnlyList<Measurement> ThreadingStats public ThreadingStats ThreadingStats { get; } Property Value ThreadingStats TotalOperations public long TotalOperations { get; } Property Value long"
  },
  "api/BenchmarkDotNet.Diagnosers.DisassemblyDiagnoser.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.DisassemblyDiagnoser.html",
    "title": "Class DisassemblyDiagnoser | BenchmarkDotNet",
    "summary": "Class DisassemblyDiagnoser Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class DisassemblyDiagnoser : IDiagnoser Inheritance object DisassemblyDiagnoser Implements IDiagnoser Constructors DisassemblyDiagnoser(DisassemblyDiagnoserConfig) public DisassemblyDiagnoser(DisassemblyDiagnoserConfig config) Parameters config DisassemblyDiagnoserConfig Properties Analysers public IEnumerable<IAnalyser> Analysers { get; } Property Value IEnumerable<IAnalyser> Config public DisassemblyDiagnoserConfig Config { get; } Property Value DisassemblyDiagnoserConfig Exporters public IEnumerable<IExporter> Exporters { get; } Property Value IEnumerable<IExporter> Ids public IEnumerable<string> Ids { get; } Property Value IEnumerable<string> Results public IReadOnlyDictionary<BenchmarkCase, DisassemblyResult> Results { get; } Property Value IReadOnlyDictionary<BenchmarkCase, DisassemblyResult> Methods DisplayResults(ILogger) public void DisplayResults(ILogger logger) Parameters logger ILogger GetRunMode(BenchmarkCase) public RunMode GetRunMode(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns RunMode Handle(HostSignal, DiagnoserActionParameters) public void Handle(HostSignal signal, DiagnoserActionParameters parameters) Parameters signal HostSignal parameters DiagnoserActionParameters ProcessResults(DiagnoserResults) public IEnumerable<Metric> ProcessResults(DiagnoserResults diagnoserResults) Parameters diagnoserResults DiagnoserResults Returns IEnumerable<Metric> Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Diagnosers.DisassemblyDiagnoserConfig.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.DisassemblyDiagnoserConfig.html",
    "title": "Class DisassemblyDiagnoserConfig | BenchmarkDotNet",
    "summary": "Class DisassemblyDiagnoserConfig Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class DisassemblyDiagnoserConfig Inheritance object DisassemblyDiagnoserConfig Constructors DisassemblyDiagnoserConfig(int, DisassemblySyntax, string[]?, FormatterOptions?, bool, bool, bool, bool, bool, bool) public DisassemblyDiagnoserConfig(int maxDepth = 1, DisassemblySyntax syntax = DisassemblySyntax.Masm, string[]? filters = null, FormatterOptions? formatterOptions = null, bool printSource = false, bool printInstructionAddresses = false, bool exportGithubMarkdown = true, bool exportHtml = false, bool exportCombinedDisassemblyReport = false, bool exportDiff = false) Parameters maxDepth int Includes called methods to given level. 1 by default, indexed from 1. To print just the benchmark set it to 0. syntax DisassemblySyntax The disassembly syntax. MASM is the default. filters string[] Glob patterns applied to full method signatures by the the disassembler. formatterOptions FormatterOptions Code formatter options. If not provided, the recommended settings will be used. printSource bool C#|F#|VB source code will be printed. False by default. printInstructionAddresses bool Print instruction addresses. False by default exportGithubMarkdown bool Exports to GitHub markdown. True by default. exportHtml bool Exports to HTML with clickable links. False by default. exportCombinedDisassemblyReport bool Exports all benchmarks to a single HTML report. Makes it easy to compare different runtimes or methods (each becomes a column in HTML table). exportDiff bool Exports a diff of the assembly code to the Github markdown format. False by default. Properties ExportCombinedDisassemblyReport public bool ExportCombinedDisassemblyReport { get; } Property Value bool ExportDiff public bool ExportDiff { get; } Property Value bool ExportGithubMarkdown public bool ExportGithubMarkdown { get; } Property Value bool ExportHtml public bool ExportHtml { get; } Property Value bool Filters public string[] Filters { get; } Property Value string[] Formatting public FormatterOptions Formatting { get; } Property Value FormatterOptions MaxDepth public int MaxDepth { get; } Property Value int PrintInstructionAddresses public bool PrintInstructionAddresses { get; } Property Value bool PrintSource public bool PrintSource { get; } Property Value bool Syntax public DisassemblySyntax Syntax { get; } Property Value DisassemblySyntax"
  },
  "api/BenchmarkDotNet.Diagnosers.DisassemblySyntax.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.DisassemblySyntax.html",
    "title": "Enum DisassemblySyntax | BenchmarkDotNet",
    "summary": "Enum DisassemblySyntax Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public enum DisassemblySyntax Fields Att = 2 Indicates a disassembler should use AT&T syntax for generated assembly code. Intel = 1 Indicates a disassembler should use Intel syntax for generated assembly code. Masm = 0 Indicates a disassembler should use MASM syntax for generated assembly code"
  },
  "api/BenchmarkDotNet.Diagnosers.EventPipeProfile.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.EventPipeProfile.html",
    "title": "Enum EventPipeProfile | BenchmarkDotNet",
    "summary": "Enum EventPipeProfile Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public enum EventPipeProfile Fields CpuSampling = 0 Useful for tracking CPU usage and general .NET runtime information. This is the default option if no profile or providers are specified. GcCollect = 2 Tracks GC collections only at very low overhead. GcVerbose = 1 Tracks GC collections and samples object allocations. Jit = 3 Logging when Just in time (JIT) compilation occurs. Logging of the internal workings of the Just In Time compiler. This is fairly verbose. It details decisions about interesting optimization (like inlining and tail call)"
  },
  "api/BenchmarkDotNet.Diagnosers.EventPipeProfiler.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.EventPipeProfiler.html",
    "title": "Class EventPipeProfiler | BenchmarkDotNet",
    "summary": "Class EventPipeProfiler Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class EventPipeProfiler : IDiagnoser Inheritance object EventPipeProfiler Implements IDiagnoser Constructors EventPipeProfiler() public EventPipeProfiler() EventPipeProfiler(EventPipeProfile, IReadOnlyCollection<EventPipeProvider>?, bool) Creates a new instance of EventPipeProfiler public EventPipeProfiler(EventPipeProfile profile = EventPipeProfile.CpuSampling, IReadOnlyCollection<EventPipeProvider>? providers = null, bool performExtraBenchmarksRun = true) Parameters profile EventPipeProfile A named pre-defined set of provider configurations that allows common tracing scenarios to be specified succinctly. providers IReadOnlyCollection<EventPipeProvider> A list of EventPipe providers to be enabled. performExtraBenchmarksRun bool if set to true, benchmarks will be executed one more time with the profiler attached. If set to false, there will be no extra run but the results will contain overhead. True by default. Fields Default public static readonly EventPipeProfiler Default Field Value EventPipeProfiler Properties Analysers public IEnumerable<IAnalyser> Analysers { get; } Property Value IEnumerable<IAnalyser> Exporters public IEnumerable<IExporter> Exporters { get; } Property Value IEnumerable<IExporter> Ids public IEnumerable<string> Ids { get; } Property Value IEnumerable<string> ShortName public string ShortName { get; } Property Value string Methods DisplayResults(ILogger) public void DisplayResults(ILogger resultLogger) Parameters resultLogger ILogger GetRunMode(BenchmarkCase) public RunMode GetRunMode(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns RunMode Handle(HostSignal, DiagnoserActionParameters) public void Handle(HostSignal signal, DiagnoserActionParameters parameters) Parameters signal HostSignal parameters DiagnoserActionParameters ProcessResults(DiagnoserResults) public IEnumerable<Metric> ProcessResults(DiagnoserResults results) Parameters results DiagnoserResults Returns IEnumerable<Metric> Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Diagnosers.ExceptionDiagnoser.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.ExceptionDiagnoser.html",
    "title": "Class ExceptionDiagnoser | BenchmarkDotNet",
    "summary": "Class ExceptionDiagnoser Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class ExceptionDiagnoser : IDiagnoser Inheritance object ExceptionDiagnoser Implements IDiagnoser Constructors ExceptionDiagnoser(ExceptionDiagnoserConfig) public ExceptionDiagnoser(ExceptionDiagnoserConfig config) Parameters config ExceptionDiagnoserConfig Fields Default public static readonly ExceptionDiagnoser Default Field Value ExceptionDiagnoser Properties Analysers public IEnumerable<IAnalyser> Analysers { get; } Property Value IEnumerable<IAnalyser> Config public ExceptionDiagnoserConfig Config { get; } Property Value ExceptionDiagnoserConfig Exporters public IEnumerable<IExporter> Exporters { get; } Property Value IEnumerable<IExporter> Ids public IEnumerable<string> Ids { get; } Property Value IEnumerable<string> Methods DisplayResults(ILogger) public void DisplayResults(ILogger logger) Parameters logger ILogger GetRunMode(BenchmarkCase) public RunMode GetRunMode(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns RunMode Handle(HostSignal, DiagnoserActionParameters) public void Handle(HostSignal signal, DiagnoserActionParameters parameters) Parameters signal HostSignal parameters DiagnoserActionParameters ProcessResults(DiagnoserResults) public IEnumerable<Metric> ProcessResults(DiagnoserResults results) Parameters results DiagnoserResults Returns IEnumerable<Metric> Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Diagnosers.HardwareCounter.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.HardwareCounter.html",
    "title": "Enum HardwareCounter | BenchmarkDotNet",
    "summary": "Enum HardwareCounter Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public enum HardwareCounter Extension Methods HardwareCounterExtensions.TheGreaterTheBetter(HardwareCounter) HardwareCounterExtensions.ToShortName(HardwareCounter) Fields BranchInstructionRetired = 12 BranchInstructions = 3 BranchMispredictions = 5 BranchMispredictsRetired = 13 CacheMisses = 4 InstructionRetired = 8 LlcMisses = 11 LlcReference = 10 NotSet = 0 Timer = 1 TotalCycles = 6 TotalIssues = 2 UnhaltedCoreCycles = 7 UnhaltedReferenceCycles = 9"
  },
  "api/BenchmarkDotNet.Diagnosers.HardwareCounterExtensions.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.HardwareCounterExtensions.html",
    "title": "Class HardwareCounterExtensions | BenchmarkDotNet",
    "summary": "Class HardwareCounterExtensions Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public static class HardwareCounterExtensions Inheritance object HardwareCounterExtensions Methods TheGreaterTheBetter(HardwareCounter) public static bool TheGreaterTheBetter(this HardwareCounter hardwareCounter) Parameters hardwareCounter HardwareCounter Returns bool ToShortName(HardwareCounter) public static string ToShortName(this HardwareCounter hardwareCounter) Parameters hardwareCounter HardwareCounter Returns string"
  },
  "api/BenchmarkDotNet.Diagnosers.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.html",
    "title": "Namespace BenchmarkDotNet.Diagnosers | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Diagnosers Classes CompositeDiagnoser DiagnoserActionParameters DiagnoserResults DisassemblyDiagnoser DisassemblyDiagnoserConfig EventPipeProfiler ExceptionDiagnoser HardwareCounterExtensions MemoryDiagnoser MemoryDiagnoserConfig PerfCollectProfiler PerfCollectProfilerConfig PmcStats PreciseMachineCounter SnapshotProfilerBase SnapshotProfilerBase.Progress ThreadingDiagnoser ThreadingDiagnoserConfig UnresolvedDiagnoser Interfaces IConfigurableDiagnoser<TConfig> IDiagnoser Enums DisassemblySyntax EventPipeProfile HardwareCounter RunMode"
  },
  "api/BenchmarkDotNet.Diagnosers.IConfigurableDiagnoser-1.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.IConfigurableDiagnoser-1.html",
    "title": "Interface IConfigurableDiagnoser<TConfig> | BenchmarkDotNet",
    "summary": "Interface IConfigurableDiagnoser<TConfig> Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public interface IConfigurableDiagnoser<in TConfig> : IDiagnoser Type Parameters TConfig Inherited Members IDiagnoser.GetRunMode(BenchmarkCase) IDiagnoser.Handle(HostSignal, DiagnoserActionParameters) IDiagnoser.ProcessResults(DiagnoserResults) IDiagnoser.DisplayResults(ILogger) IDiagnoser.Validate(ValidationParameters) IDiagnoser.Ids IDiagnoser.Exporters IDiagnoser.Analysers Methods Configure(TConfig) IConfigurableDiagnoser<in TConfig> Configure(TConfig config) Parameters config TConfig Returns IConfigurableDiagnoser<TConfig>"
  },
  "api/BenchmarkDotNet.Diagnosers.IDiagnoser.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.IDiagnoser.html",
    "title": "Interface IDiagnoser | BenchmarkDotNet",
    "summary": "Interface IDiagnoser Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public interface IDiagnoser Properties Analysers IEnumerable<IAnalyser> Analysers { get; } Property Value IEnumerable<IAnalyser> Exporters IEnumerable<IExporter> Exporters { get; } Property Value IEnumerable<IExporter> Ids IEnumerable<string> Ids { get; } Property Value IEnumerable<string> Methods DisplayResults(ILogger) void DisplayResults(ILogger logger) Parameters logger ILogger GetRunMode(BenchmarkCase) RunMode GetRunMode(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns RunMode Handle(HostSignal, DiagnoserActionParameters) void Handle(HostSignal signal, DiagnoserActionParameters parameters) Parameters signal HostSignal parameters DiagnoserActionParameters ProcessResults(DiagnoserResults) IEnumerable<Metric> ProcessResults(DiagnoserResults results) Parameters results DiagnoserResults Returns IEnumerable<Metric> Validate(ValidationParameters) IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Diagnosers.MemoryDiagnoser.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.MemoryDiagnoser.html",
    "title": "Class MemoryDiagnoser | BenchmarkDotNet",
    "summary": "Class MemoryDiagnoser Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class MemoryDiagnoser : IDiagnoser Inheritance object MemoryDiagnoser Implements IDiagnoser Constructors MemoryDiagnoser(MemoryDiagnoserConfig) public MemoryDiagnoser(MemoryDiagnoserConfig config) Parameters config MemoryDiagnoserConfig Fields Default public static readonly MemoryDiagnoser Default Field Value MemoryDiagnoser Properties Analysers public IEnumerable<IAnalyser> Analysers { get; } Property Value IEnumerable<IAnalyser> Config public MemoryDiagnoserConfig Config { get; } Property Value MemoryDiagnoserConfig Exporters public IEnumerable<IExporter> Exporters { get; } Property Value IEnumerable<IExporter> Ids public IEnumerable<string> Ids { get; } Property Value IEnumerable<string> Methods DisplayResults(ILogger) public void DisplayResults(ILogger logger) Parameters logger ILogger GetRunMode(BenchmarkCase) public RunMode GetRunMode(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns RunMode Handle(HostSignal, DiagnoserActionParameters) public void Handle(HostSignal signal, DiagnoserActionParameters parameters) Parameters signal HostSignal parameters DiagnoserActionParameters ProcessResults(DiagnoserResults) public IEnumerable<Metric> ProcessResults(DiagnoserResults diagnoserResults) Parameters diagnoserResults DiagnoserResults Returns IEnumerable<Metric> Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Diagnosers.MemoryDiagnoserConfig.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.MemoryDiagnoserConfig.html",
    "title": "Class MemoryDiagnoserConfig | BenchmarkDotNet",
    "summary": "Class MemoryDiagnoserConfig Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class MemoryDiagnoserConfig Inheritance object MemoryDiagnoserConfig Constructors MemoryDiagnoserConfig(bool) public MemoryDiagnoserConfig(bool displayGenColumns = true) Parameters displayGenColumns bool Display Garbage Collections per Generation columns (Gen 0, Gen 1, Gen 2). True by default. Properties DisplayGenColumns public bool DisplayGenColumns { get; } Property Value bool"
  },
  "api/BenchmarkDotNet.Diagnosers.PerfCollectProfiler.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.PerfCollectProfiler.html",
    "title": "Class PerfCollectProfiler | BenchmarkDotNet",
    "summary": "Class PerfCollectProfiler Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class PerfCollectProfiler : IDiagnoser Inheritance object PerfCollectProfiler Implements IDiagnoser Constructors PerfCollectProfiler(PerfCollectProfilerConfig) public PerfCollectProfiler(PerfCollectProfilerConfig config) Parameters config PerfCollectProfilerConfig Fields Default public static readonly IDiagnoser Default Field Value IDiagnoser Properties Analysers public IEnumerable<IAnalyser> Analysers { get; } Property Value IEnumerable<IAnalyser> Exporters public IEnumerable<IExporter> Exporters { get; } Property Value IEnumerable<IExporter> Ids public IEnumerable<string> Ids { get; } Property Value IEnumerable<string> ShortName public string ShortName { get; } Property Value string Methods DisplayResults(ILogger) public void DisplayResults(ILogger logger) Parameters logger ILogger GetRunMode(BenchmarkCase) public RunMode GetRunMode(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns RunMode Handle(HostSignal, DiagnoserActionParameters) public void Handle(HostSignal signal, DiagnoserActionParameters parameters) Parameters signal HostSignal parameters DiagnoserActionParameters ProcessResults(DiagnoserResults) public IEnumerable<Metric> ProcessResults(DiagnoserResults results) Parameters results DiagnoserResults Returns IEnumerable<Metric> Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Diagnosers.PerfCollectProfilerConfig.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.PerfCollectProfilerConfig.html",
    "title": "Class PerfCollectProfilerConfig | BenchmarkDotNet",
    "summary": "Class PerfCollectProfilerConfig Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class PerfCollectProfilerConfig Inheritance object PerfCollectProfilerConfig Constructors PerfCollectProfilerConfig(bool, int) public PerfCollectProfilerConfig(bool performExtraBenchmarksRun = false, int timeoutInSeconds = 300) Parameters performExtraBenchmarksRun bool When set to true, benchmarks will be executed one more time with the profiler attached. If set to false, there will be no extra run but the results will contain overhead. False by default. timeoutInSeconds int How long should we wait for the perfcollect script to finish processing the trace. 300s by default. Properties RunMode public RunMode RunMode { get; } Property Value RunMode Timeout public TimeSpan Timeout { get; } Property Value TimeSpan"
  },
  "api/BenchmarkDotNet.Diagnosers.PmcStats.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.PmcStats.html",
    "title": "Class PmcStats | BenchmarkDotNet",
    "summary": "Class PmcStats Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class PmcStats Inheritance object PmcStats Constructors PmcStats() public PmcStats() PmcStats(IReadOnlyCollection<HardwareCounter>, Func<HardwareCounter, PreciseMachineCounter>) public PmcStats(IReadOnlyCollection<HardwareCounter> hardwareCounters, Func<HardwareCounter, PreciseMachineCounter> factory) Parameters hardwareCounters IReadOnlyCollection<HardwareCounter> factory Func<HardwareCounter, PreciseMachineCounter> Properties Counters public IReadOnlyDictionary<HardwareCounter, PreciseMachineCounter> Counters { get; } Property Value IReadOnlyDictionary<HardwareCounter, PreciseMachineCounter> TotalOperations public long TotalOperations { get; set; } Property Value long"
  },
  "api/BenchmarkDotNet.Diagnosers.PreciseMachineCounter.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.PreciseMachineCounter.html",
    "title": "Class PreciseMachineCounter | BenchmarkDotNet",
    "summary": "Class PreciseMachineCounter Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class PreciseMachineCounter Inheritance object PreciseMachineCounter Properties Count public ulong Count { get; } Property Value ulong Counter public HardwareCounter Counter { get; } Property Value HardwareCounter Interval public int Interval { get; } Property Value int Name public string Name { get; } Property Value string PerInstructionPointer public Dictionary<ulong, ulong> PerInstructionPointer { get; } Property Value Dictionary<ulong, ulong> ProfileSourceId public int ProfileSourceId { get; } Property Value int Methods OnSample(ulong) public void OnSample(ulong instructionPointer) Parameters instructionPointer ulong"
  },
  "api/BenchmarkDotNet.Diagnosers.RunMode.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.RunMode.html",
    "title": "Enum RunMode | BenchmarkDotNet",
    "summary": "Enum RunMode Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public enum RunMode : byte Fields ExtraRun = 1 needs extra run of the benchmark NoOverhead = 2 no overhead, can be executed without extra run None = 0 given diagnoser should not be executed for given benchmark SeparateLogic = 3 implements some separate logic, that can be executed at any time"
  },
  "api/BenchmarkDotNet.Diagnosers.SnapshotProfilerBase.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.SnapshotProfilerBase.html",
    "title": "Class SnapshotProfilerBase | BenchmarkDotNet",
    "summary": "Class SnapshotProfilerBase Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public abstract class SnapshotProfilerBase : IDiagnoser Inheritance object SnapshotProfilerBase Implements IDiagnoser Constructors SnapshotProfilerBase() protected SnapshotProfilerBase() Properties Analysers public IEnumerable<IAnalyser> Analysers { get; } Property Value IEnumerable<IAnalyser> Exporters public IEnumerable<IExporter> Exporters { get; } Property Value IEnumerable<IExporter> Ids public IEnumerable<string> Ids { get; } Property Value IEnumerable<string> ShortName public abstract string ShortName { get; } Property Value string Methods AttachToCurrentProcess(string) protected abstract void AttachToCurrentProcess(string snapshotFile) Parameters snapshotFile string AttachToProcessByPid(int, string) protected abstract void AttachToProcessByPid(int pid, string snapshotFile) Parameters pid int snapshotFile string CreateSnapshotFilePath(DiagnoserActionParameters) protected abstract string CreateSnapshotFilePath(DiagnoserActionParameters parameters) Parameters parameters DiagnoserActionParameters Returns string Detach() protected abstract void Detach() DisplayResults(ILogger) public void DisplayResults(ILogger logger) Parameters logger ILogger GetRunMode(BenchmarkCase) public RunMode GetRunMode(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns RunMode GetRunnerPath() protected abstract string GetRunnerPath() Returns string Handle(HostSignal, DiagnoserActionParameters) public void Handle(HostSignal signal, DiagnoserActionParameters parameters) Parameters signal HostSignal parameters DiagnoserActionParameters InitTool(Progress) protected abstract void InitTool(SnapshotProfilerBase.Progress progress) Parameters progress SnapshotProfilerBase.Progress ProcessResults(DiagnoserResults) public IEnumerable<Metric> ProcessResults(DiagnoserResults results) Parameters results DiagnoserResults Returns IEnumerable<Metric> TakeSnapshot() protected abstract void TakeSnapshot() Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Diagnosers.SnapshotProfilerBase.Progress.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.SnapshotProfilerBase.Progress.html",
    "title": "Class SnapshotProfilerBase.Progress | BenchmarkDotNet",
    "summary": "Class SnapshotProfilerBase.Progress Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll protected class SnapshotProfilerBase.Progress : IProgress<double> Inheritance object SnapshotProfilerBase.Progress Implements IProgress<double> Constructors Progress(ILogger, string) public Progress(ILogger logger, string title) Parameters logger ILogger title string Methods Report(double) public void Report(double value) Parameters value double"
  },
  "api/BenchmarkDotNet.Diagnosers.ThreadingDiagnoser.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.ThreadingDiagnoser.html",
    "title": "Class ThreadingDiagnoser | BenchmarkDotNet",
    "summary": "Class ThreadingDiagnoser Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class ThreadingDiagnoser : IDiagnoser Inheritance object ThreadingDiagnoser Implements IDiagnoser Constructors ThreadingDiagnoser(ThreadingDiagnoserConfig) public ThreadingDiagnoser(ThreadingDiagnoserConfig config) Parameters config ThreadingDiagnoserConfig Fields Default public static readonly ThreadingDiagnoser Default Field Value ThreadingDiagnoser Properties Analysers public IEnumerable<IAnalyser> Analysers { get; } Property Value IEnumerable<IAnalyser> Config public ThreadingDiagnoserConfig Config { get; } Property Value ThreadingDiagnoserConfig Exporters public IEnumerable<IExporter> Exporters { get; } Property Value IEnumerable<IExporter> Ids public IEnumerable<string> Ids { get; } Property Value IEnumerable<string> Methods DisplayResults(ILogger) public void DisplayResults(ILogger logger) Parameters logger ILogger GetRunMode(BenchmarkCase) public RunMode GetRunMode(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns RunMode Handle(HostSignal, DiagnoserActionParameters) public void Handle(HostSignal signal, DiagnoserActionParameters parameters) Parameters signal HostSignal parameters DiagnoserActionParameters ProcessResults(DiagnoserResults) public IEnumerable<Metric> ProcessResults(DiagnoserResults results) Parameters results DiagnoserResults Returns IEnumerable<Metric> Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Diagnosers.ThreadingDiagnoserConfig.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.ThreadingDiagnoserConfig.html",
    "title": "Class ThreadingDiagnoserConfig | BenchmarkDotNet",
    "summary": "Class ThreadingDiagnoserConfig Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class ThreadingDiagnoserConfig Inheritance object ThreadingDiagnoserConfig Constructors ThreadingDiagnoserConfig(bool, bool) public ThreadingDiagnoserConfig(bool displayLockContentionWhenZero = true, bool displayCompletedWorkItemCountWhenZero = true) Parameters displayLockContentionWhenZero bool Display configuration for 'LockContentionCount' when it is empty. True (displayed) by default. displayCompletedWorkItemCountWhenZero bool Display configuration for 'CompletedWorkItemCount' when it is empty. True (displayed) by default. Properties DisplayCompletedWorkItemCountWhenZero public bool DisplayCompletedWorkItemCountWhenZero { get; } Property Value bool DisplayLockContentionWhenZero public bool DisplayLockContentionWhenZero { get; } Property Value bool"
  },
  "api/BenchmarkDotNet.Diagnosers.UnresolvedDiagnoser.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.UnresolvedDiagnoser.html",
    "title": "Class UnresolvedDiagnoser | BenchmarkDotNet",
    "summary": "Class UnresolvedDiagnoser Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class UnresolvedDiagnoser : IDiagnoser Inheritance object UnresolvedDiagnoser Implements IDiagnoser Constructors UnresolvedDiagnoser(Type) public UnresolvedDiagnoser(Type unresolved) Parameters unresolved Type Properties Analysers public IEnumerable<IAnalyser> Analysers { get; } Property Value IEnumerable<IAnalyser> Exporters public IEnumerable<IExporter> Exporters { get; } Property Value IEnumerable<IExporter> Ids public IEnumerable<string> Ids { get; } Property Value IEnumerable<string> Methods DisplayResults(ILogger) public void DisplayResults(ILogger logger) Parameters logger ILogger GetRunMode(BenchmarkCase) public RunMode GetRunMode(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns RunMode Handle(HostSignal, DiagnoserActionParameters) public void Handle(HostSignal signal, DiagnoserActionParameters parameters) Parameters signal HostSignal parameters DiagnoserActionParameters ProcessResults(DiagnoserResults) public IEnumerable<Metric> ProcessResults(DiagnoserResults _) Parameters _ DiagnoserResults Returns IEnumerable<Metric> Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Disassemblers.Arm64Asm.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.Arm64Asm.html",
    "title": "Class Arm64Asm | BenchmarkDotNet",
    "summary": "Class Arm64Asm Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public class Arm64Asm : Asm Inheritance object SourceCode Asm Arm64Asm Inherited Members Asm.InstructionLength Asm.ReferencedAddress Asm.IsReferencedAddressIndirect SourceCode.InstructionPointer Constructors Arm64Asm() public Arm64Asm() Properties Instruction public Arm64Instruction Instruction { get; set; } Property Value Arm64Instruction Methods ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Disassemblers.Asm.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.Asm.html",
    "title": "Class Asm | BenchmarkDotNet",
    "summary": "Class Asm Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public abstract class Asm : SourceCode Inheritance object SourceCode Asm Derived Arm64Asm IntelAsm Inherited Members SourceCode.InstructionPointer Constructors Asm() protected Asm() Properties InstructionLength public int InstructionLength { get; set; } Property Value int IsReferencedAddressIndirect public bool IsReferencedAddressIndirect { get; set; } Property Value bool ReferencedAddress public ulong? ReferencedAddress { get; set; } Property Value ulong?"
  },
  "api/BenchmarkDotNet.Disassemblers.DisassembledMethod.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.DisassembledMethod.html",
    "title": "Class DisassembledMethod | BenchmarkDotNet",
    "summary": "Class DisassembledMethod Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public class DisassembledMethod Inheritance object DisassembledMethod Constructors DisassembledMethod() public DisassembledMethod() Properties CommandLine public string CommandLine { get; set; } Property Value string Maps public Map[] Maps { get; set; } Property Value Map[] Name public string Name { get; set; } Property Value string NativeCode public ulong NativeCode { get; set; } Property Value ulong Problem public string Problem { get; set; } Property Value string Methods Empty(string, ulong, string) public static DisassembledMethod Empty(string fullSignature, ulong nativeCode, string problem) Parameters fullSignature string nativeCode ulong problem string Returns DisassembledMethod"
  },
  "api/BenchmarkDotNet.Disassemblers.DisassemblerConstants.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.DisassemblerConstants.html",
    "title": "Class DisassemblerConstants | BenchmarkDotNet",
    "summary": "Class DisassemblerConstants Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public static class DisassemblerConstants Inheritance object DisassemblerConstants Fields DisassemblerEntryMethodName public const string DisassemblerEntryMethodName = \"__ForDisassemblyDiagnoser__\" Field Value string"
  },
  "api/BenchmarkDotNet.Disassemblers.DisassemblyResult.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.DisassemblyResult.html",
    "title": "Class DisassemblyResult | BenchmarkDotNet",
    "summary": "Class DisassemblyResult Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public class DisassemblyResult Inheritance object DisassemblyResult Constructors DisassemblyResult() public DisassemblyResult() Properties AddressToNameMapping public Dictionary<ulong, string> AddressToNameMapping { get; } Property Value Dictionary<ulong, string> Errors public string[] Errors { get; set; } Property Value string[] Methods public DisassembledMethod[] Methods { get; set; } Property Value DisassembledMethod[] PointerSize public uint PointerSize { get; set; } Property Value uint SerializedAddressToNameMapping public DisassemblyResult.MutablePair[] SerializedAddressToNameMapping { get; set; } Property Value MutablePair[]"
  },
  "api/BenchmarkDotNet.Disassemblers.DisassemblyResult.MutablePair.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.DisassemblyResult.MutablePair.html",
    "title": "Struct DisassemblyResult.MutablePair | BenchmarkDotNet",
    "summary": "Struct DisassemblyResult.MutablePair Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public struct DisassemblyResult.MutablePair Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() Properties Key public ulong Key { readonly get; set; } Property Value ulong Value public string Value { readonly get; set; } Property Value string"
  },
  "api/BenchmarkDotNet.Disassemblers.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.html",
    "title": "Namespace BenchmarkDotNet.Disassemblers | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Disassemblers Classes Arm64Asm Asm DisassembledMethod DisassemblerConstants DisassemblyResult IntelAsm Map MonoCode Sharp SourceCode WindowsDisassembler Structs DisassemblyResult.MutablePair"
  },
  "api/BenchmarkDotNet.Disassemblers.IntelAsm.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.IntelAsm.html",
    "title": "Class IntelAsm | BenchmarkDotNet",
    "summary": "Class IntelAsm Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public class IntelAsm : Asm Inheritance object SourceCode Asm IntelAsm Inherited Members Asm.InstructionLength Asm.ReferencedAddress Asm.IsReferencedAddressIndirect SourceCode.InstructionPointer Constructors IntelAsm() public IntelAsm() Properties Instruction public Instruction Instruction { get; set; } Property Value Instruction Methods ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Disassemblers.Map.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.Map.html",
    "title": "Class Map | BenchmarkDotNet",
    "summary": "Class Map Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public class Map Inheritance object Map Constructors Map() public Map() Properties SourceCodes public SourceCode[] SourceCodes { get; set; } Property Value SourceCode[]"
  },
  "api/BenchmarkDotNet.Disassemblers.MonoCode.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.MonoCode.html",
    "title": "Class MonoCode | BenchmarkDotNet",
    "summary": "Class MonoCode Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public class MonoCode : SourceCode Inheritance object SourceCode MonoCode Inherited Members SourceCode.InstructionPointer Constructors MonoCode() public MonoCode() Properties Text public string Text { get; set; } Property Value string"
  },
  "api/BenchmarkDotNet.Disassemblers.Sharp.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.Sharp.html",
    "title": "Class Sharp | BenchmarkDotNet",
    "summary": "Class Sharp Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public class Sharp : SourceCode Inheritance object SourceCode Sharp Inherited Members SourceCode.InstructionPointer Constructors Sharp() public Sharp() Properties FilePath public string FilePath { get; set; } Property Value string LineNumber public int LineNumber { get; set; } Property Value int Text public string Text { get; set; } Property Value string"
  },
  "api/BenchmarkDotNet.Disassemblers.SourceCode.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.SourceCode.html",
    "title": "Class SourceCode | BenchmarkDotNet",
    "summary": "Class SourceCode Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public abstract class SourceCode Inheritance object SourceCode Derived Asm MonoCode Sharp Constructors SourceCode() protected SourceCode() Properties InstructionPointer public ulong InstructionPointer { get; set; } Property Value ulong"
  },
  "api/BenchmarkDotNet.Disassemblers.WindowsDisassembler.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.WindowsDisassembler.html",
    "title": "Class WindowsDisassembler | BenchmarkDotNet",
    "summary": "Class WindowsDisassembler Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public class WindowsDisassembler Inheritance object WindowsDisassembler Constructors WindowsDisassembler(DisassemblyDiagnoserConfig) public WindowsDisassembler(DisassemblyDiagnoserConfig config) Parameters config DisassemblyDiagnoserConfig Methods Disassemble(DiagnoserActionParameters) public DisassemblyResult Disassemble(DiagnoserActionParameters parameters) Parameters parameters DiagnoserActionParameters Returns DisassemblyResult"
  },
  "api/BenchmarkDotNet.Engines.AnonymousPipesHost.html": {
    "href": "api/BenchmarkDotNet.Engines.AnonymousPipesHost.html",
    "title": "Class AnonymousPipesHost | BenchmarkDotNet",
    "summary": "Class AnonymousPipesHost Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public class AnonymousPipesHost : IHost, IDisposable Inheritance object AnonymousPipesHost Implements IHost IDisposable Extension Methods HostExtensions.AfterAll(IHost) HostExtensions.AfterMainRun(IHost) HostExtensions.BeforeAnythingElse(IHost) HostExtensions.BeforeMainRun(IHost) HostExtensions.WriteLine(IHost, string, params object[]) Constructors AnonymousPipesHost(string, string) public AnonymousPipesHost(string writHandle, string readHandle) Parameters writHandle string readHandle string Methods Dispose() public void Dispose() ReportResults(RunResults) public void ReportResults(RunResults runResults) Parameters runResults RunResults SendError(string) public void SendError(string message) Parameters message string SendSignal(HostSignal) public void SendSignal(HostSignal hostSignal) Parameters hostSignal HostSignal TryGetFileHandles(string[], out string?, out string?) public static bool TryGetFileHandles(string[] args, out string? writeHandle, out string? readHandle) Parameters args string[] writeHandle string readHandle string Returns bool Write(string) public void Write(string message) Parameters message string WriteLine() public void WriteLine() WriteLine(string) public void WriteLine(string message) Parameters message string"
  },
  "api/BenchmarkDotNet.Engines.Consumer.html": {
    "href": "api/BenchmarkDotNet.Engines.Consumer.html",
    "title": "Class Consumer | BenchmarkDotNet",
    "summary": "Class Consumer Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public class Consumer Inheritance object Consumer Constructors Consumer() public Consumer() Methods Consume(bool) public void Consume(bool boolValue) Parameters boolValue bool Consume(byte) public void Consume(byte byteValue) Parameters byteValue byte Consume(char) public void Consume(char charValue) Parameters charValue char Consume(double) public void Consume(double doubleValue) Parameters doubleValue double Consume(short) public void Consume(short shortValue) Parameters shortValue short Consume(int) public void Consume(int intValue) Parameters intValue int Consume(long) public void Consume(long longValue) Parameters longValue long Consume(nint) public void Consume(nint intPtrValue) Parameters intPtrValue nint Consume(object) public void Consume(object objectValue) Parameters objectValue object Consume(sbyte) [CLSCompliant(false)] public void Consume(sbyte sbyteValue) Parameters sbyteValue sbyte Consume(float) public void Consume(float floatValue) Parameters floatValue float Consume(string) public void Consume(string stringValue) Parameters stringValue string Consume(ushort) [CLSCompliant(false)] public void Consume(ushort ushortValue) Parameters ushortValue ushort Consume(uint) [CLSCompliant(false)] public void Consume(uint uintValue) Parameters uintValue uint Consume(ulong) [CLSCompliant(false)] public void Consume(ulong ulongValue) Parameters ulongValue ulong Consume(nuint) public void Consume(nuint uintPtrValue) Parameters uintPtrValue nuint Consume(void*) public void Consume(void* ptrValue) Parameters ptrValue void* Consume<T>(T) public void Consume<T>(T objectValue) where T : class Parameters objectValue T Type Parameters T Consume<T>(T*) public void Consume<T>(T* ptrValue) where T : unmanaged Parameters ptrValue T* Type Parameters T Consume<T>(in T) public void Consume<T>(in T value) Parameters value T Type Parameters T"
  },
  "api/BenchmarkDotNet.Engines.ConsumerExtensions.html": {
    "href": "api/BenchmarkDotNet.Engines.ConsumerExtensions.html",
    "title": "Class ConsumerExtensions | BenchmarkDotNet",
    "summary": "Class ConsumerExtensions Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public static class ConsumerExtensions Inheritance object ConsumerExtensions Methods Consume(IEnumerable, Consumer) executes and consumes given IEnumerable By using non-generic IEnumerable you pay for boxing. Use generic IEnumerable<T> if you can. public static void Consume(this IEnumerable enumerable, Consumer consumer) Parameters enumerable IEnumerable non-generic IEnumerable consumer Consumer instance of Consumer. Create it on your own once, store it in the field and just pass here Consume(IQueryable, Consumer) executes and consumes given IQueryable By using non-generic IQueryable you pay for boxing. Use generic IQueryable<T> if you can. public static void Consume(this IQueryable queryable, Consumer consumer) Parameters queryable IQueryable non-generic IQueryable consumer Consumer instance of Consumer. Create it on your own once, store it in the field and just pass here Consume<T>(IEnumerable<T>, Consumer) executes and consumes given IEnumerable<T> public static void Consume<T>(this IEnumerable<T> enumerable, Consumer consumer) Parameters enumerable IEnumerable<T> generic IEnumerable<T> consumer Consumer instance of Consumer. Create it on your own once, store it in the field and just pass here Type Parameters T Consume<T>(IQueryable<T>, Consumer) executes and consumes given IQueryable<T> public static void Consume<T>(this IQueryable<T> queryable, Consumer consumer) Parameters queryable IQueryable<T> generic IQueryable<T> consumer Consumer instance of Consumer. Create it on your own once, store it in the field and just pass here Type Parameters T"
  },
  "api/BenchmarkDotNet.Engines.DeadCodeEliminationHelper.html": {
    "href": "api/BenchmarkDotNet.Engines.DeadCodeEliminationHelper.html",
    "title": "Class DeadCodeEliminationHelper | BenchmarkDotNet",
    "summary": "Class DeadCodeEliminationHelper Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public static class DeadCodeEliminationHelper Inheritance object DeadCodeEliminationHelper Methods KeepAliveWithoutBoxingReadonly<T>(in T) This method can't get inlined, so any value send to it will not get eliminated by the dead code elimination it's not called KeepAliveWithoutBoxing because compiler would not be able to diff ref and in public static void KeepAliveWithoutBoxingReadonly<T>(in T value) Parameters value T Type Parameters T KeepAliveWithoutBoxing<T>(T) This method can't get inlined, so any value send to it will not get eliminated by the dead code elimination public static void KeepAliveWithoutBoxing<T>(T value) Parameters value T Type Parameters T KeepAliveWithoutBoxing<T>(ref T) This method can't get inlined, so any value send to it will not get eliminated by the dead code elimination public static void KeepAliveWithoutBoxing<T>(ref T value) Parameters value T Type Parameters T"
  },
  "api/BenchmarkDotNet.Engines.Engine.html": {
    "href": "api/BenchmarkDotNet.Engines.Engine.html",
    "title": "Class Engine | BenchmarkDotNet",
    "summary": "Class Engine Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public class Engine : IEngine, IDisposable Inheritance object Engine Implements IEngine IDisposable Properties BenchmarkName public string BenchmarkName { get; } Property Value string CultureInfo public CultureInfo CultureInfo { get; } Property Value CultureInfo Dummy1Action public Action Dummy1Action { get; } Property Value Action Dummy2Action public Action Dummy2Action { get; } Property Value Action Dummy3Action public Action Dummy3Action { get; } Property Value Action GlobalCleanupAction public Action GlobalCleanupAction { get; } Property Value Action GlobalSetupAction public Action GlobalSetupAction { get; } Property Value Action Host public IHost Host { get; } Property Value IHost IterationCleanupAction public Action IterationCleanupAction { get; } Property Value Action IterationSetupAction public Action IterationSetupAction { get; } Property Value Action OperationsPerInvoke public long OperationsPerInvoke { get; } Property Value long OverheadAction public Action<long> OverheadAction { get; } Property Value Action<long> Resolver public IResolver Resolver { get; } Property Value IResolver TargetJob public Job TargetJob { get; } Property Value Job WorkloadAction public Action<long> WorkloadAction { get; } Property Value Action<long> Methods Dispose() public void Dispose() Run() public RunResults Run() Returns RunResults RunIteration(IterationData) public Measurement RunIteration(IterationData data) Parameters data IterationData Returns Measurement WriteLine() public void WriteLine() WriteLine(string) public void WriteLine(string text) Parameters text string"
  },
  "api/BenchmarkDotNet.Engines.Engine.Signals.html": {
    "href": "api/BenchmarkDotNet.Engines.Engine.Signals.html",
    "title": "Class Engine.Signals | BenchmarkDotNet",
    "summary": "Class Engine.Signals Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public static class Engine.Signals Inheritance object Engine.Signals Fields Acknowledgment public const string Acknowledgment = \"Acknowledgment\" Field Value string Methods ToMessage(HostSignal) public static string ToMessage(HostSignal signal) Parameters signal HostSignal Returns string TryGetSignal(string, out HostSignal) public static bool TryGetSignal(string message, out HostSignal signal) Parameters message string signal HostSignal Returns bool"
  },
  "api/BenchmarkDotNet.Engines.EngineEventSource.html": {
    "href": "api/BenchmarkDotNet.Engines.EngineEventSource.html",
    "title": "Class EngineEventSource | BenchmarkDotNet",
    "summary": "Class EngineEventSource Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll [EventSource(Name = \"BenchmarkDotNet.EngineEventSource\")] public class EngineEventSource : EventSource, IDisposable Inheritance object EventSource EngineEventSource Implements IDisposable Inherited Members EventSource.IsEnabled() EventSource.IsEnabled(EventLevel, EventKeywords) EventSource.IsEnabled(EventLevel, EventKeywords, EventChannel) EventSource.GetGuid(Type) EventSource.GetName(Type) EventSource.GenerateManifest(Type, string) EventSource.GenerateManifest(Type, string, EventManifestOptions) EventSource.GetSources() EventSource.SendCommand(EventSource, EventCommand, IDictionary<string, string>) EventSource.GetTrait(string) EventSource.ToString() EventSource.SetCurrentThreadActivityId(Guid) EventSource.SetCurrentThreadActivityId(Guid, out Guid) EventSource.OnEventCommand(EventCommandEventArgs) EventSource.WriteEvent(int) EventSource.WriteEvent(int, int) EventSource.WriteEvent(int, int, int) EventSource.WriteEvent(int, int, int, int) EventSource.WriteEvent(int, long) EventSource.WriteEvent(int, long, long) EventSource.WriteEvent(int, long, long, long) EventSource.WriteEvent(int, string) EventSource.WriteEvent(int, string, string) EventSource.WriteEvent(int, string, string, string) EventSource.WriteEvent(int, string, int) EventSource.WriteEvent(int, string, int, int) EventSource.WriteEvent(int, string, long) EventSource.WriteEvent(int, long, string) EventSource.WriteEvent(int, int, string) EventSource.WriteEvent(int, byte[]) EventSource.WriteEvent(int, long, byte[]) EventSource.WriteEventCore(int, int, EventSource.EventData*) EventSource.WriteEventWithRelatedActivityIdCore(int, Guid*, int, EventSource.EventData*) EventSource.WriteEvent(int, params EventSource.EventSourcePrimitive[]) EventSource.WriteEvent(int, params object[]) EventSource.WriteEventWithRelatedActivityId(int, Guid, params object[]) EventSource.Dispose() EventSource.Dispose(bool) EventSource.Write(string) EventSource.Write(string, EventSourceOptions) EventSource.Write<T>(string, T) EventSource.Write<T>(string, EventSourceOptions, T) EventSource.Write<T>(string, ref EventSourceOptions, ref T) EventSource.Write<T>(string, ref EventSourceOptions, ref Guid, ref Guid, ref T) EventSource.Name EventSource.Guid EventSource.Settings EventSource.ConstructionException EventSource.CurrentThreadActivityId EventSource.EventCommandExecuted Fields BenchmarkStartEventId public const int BenchmarkStartEventId = 1 Field Value int BenchmarkStopEventId public const int BenchmarkStopEventId = 2 Field Value int OverheadActualStartEventId public const int OverheadActualStartEventId = 11 Field Value int OverheadActualStopEventId public const int OverheadActualStopEventId = 12 Field Value int OverheadJittingStartEventId public const int OverheadJittingStartEventId = 3 Field Value int OverheadJittingStopEventId public const int OverheadJittingStopEventId = 4 Field Value int OverheadWarmupStartEventId public const int OverheadWarmupStartEventId = 9 Field Value int OverheadWarmupStopEventId public const int OverheadWarmupStopEventId = 10 Field Value int SourceName public const string SourceName = \"BenchmarkDotNet.EngineEventSource\" Field Value string WorkloadActualStartEventId public const int WorkloadActualStartEventId = 15 Field Value int WorkloadActualStopEventId public const int WorkloadActualStopEventId = 16 Field Value int WorkloadJittingStartEventId public const int WorkloadJittingStartEventId = 5 Field Value int WorkloadJittingStopEventId public const int WorkloadJittingStopEventId = 6 Field Value int WorkloadPilotStartEventId public const int WorkloadPilotStartEventId = 7 Field Value int WorkloadPilotStopEventId public const int WorkloadPilotStopEventId = 8 Field Value int WorkloadWarmupStartEventId public const int WorkloadWarmupStartEventId = 13 Field Value int WorkloadWarmupStopEventId public const int WorkloadWarmupStopEventId = 14 Field Value int"
  },
  "api/BenchmarkDotNet.Engines.EngineEventSource.Tasks.html": {
    "href": "api/BenchmarkDotNet.Engines.EngineEventSource.Tasks.html",
    "title": "Class EngineEventSource.Tasks | BenchmarkDotNet",
    "summary": "Class EngineEventSource.Tasks Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public class EngineEventSource.Tasks Inheritance object EngineEventSource.Tasks Constructors Tasks() public Tasks() Fields Benchmark public const EventTask Benchmark = (EventTask)1 Field Value EventTask OverheadActual public const EventTask OverheadActual = (EventTask)6 Field Value EventTask OverheadJitting public const EventTask OverheadJitting = (EventTask)2 Field Value EventTask OverheadWarmup public const EventTask OverheadWarmup = (EventTask)5 Field Value EventTask WorkloadActual public const EventTask WorkloadActual = (EventTask)8 Field Value EventTask WorkloadJitting public const EventTask WorkloadJitting = (EventTask)3 Field Value EventTask WorkloadPilot public const EventTask WorkloadPilot = (EventTask)4 Field Value EventTask WorkloadWarmup public const EventTask WorkloadWarmup = (EventTask)7 Field Value EventTask"
  },
  "api/BenchmarkDotNet.Engines.EngineFactory.html": {
    "href": "api/BenchmarkDotNet.Engines.EngineFactory.html",
    "title": "Class EngineFactory | BenchmarkDotNet",
    "summary": "Class EngineFactory Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public class EngineFactory : IEngineFactory Inheritance object EngineFactory Implements IEngineFactory Constructors EngineFactory() public EngineFactory() Methods CreateReadyToRun(EngineParameters) public IEngine CreateReadyToRun(EngineParameters engineParameters) Parameters engineParameters EngineParameters Returns IEngine"
  },
  "api/BenchmarkDotNet.Engines.EngineParameters.html": {
    "href": "api/BenchmarkDotNet.Engines.EngineParameters.html",
    "title": "Class EngineParameters | BenchmarkDotNet",
    "summary": "Class EngineParameters Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public class EngineParameters Inheritance object EngineParameters Constructors EngineParameters() public EngineParameters() Fields DefaultResolver public static readonly IResolver DefaultResolver Field Value IResolver Properties BenchmarkName public string BenchmarkName { get; set; } Property Value string Dummy1Action public Action Dummy1Action { get; set; } Property Value Action Dummy2Action public Action Dummy2Action { get; set; } Property Value Action Dummy3Action public Action Dummy3Action { get; set; } Property Value Action GlobalCleanupAction public Action GlobalCleanupAction { get; set; } Property Value Action GlobalSetupAction public Action GlobalSetupAction { get; set; } Property Value Action HasInvocationCount public bool HasInvocationCount { get; } Property Value bool HasUnrollFactor public bool HasUnrollFactor { get; } Property Value bool Host public IHost Host { get; set; } Property Value IHost IterationCleanupAction public Action IterationCleanupAction { get; set; } Property Value Action IterationSetupAction public Action IterationSetupAction { get; set; } Property Value Action IterationTime public TimeInterval IterationTime { get; } Property Value TimeInterval MeasureExtraStats public bool MeasureExtraStats { get; set; } Property Value bool NeedsJitting public bool NeedsJitting { get; } Property Value bool OperationsPerInvoke public long OperationsPerInvoke { get; set; } Property Value long OverheadActionNoUnroll public Action<long> OverheadActionNoUnroll { get; set; } Property Value Action<long> OverheadActionUnroll public Action<long> OverheadActionUnroll { get; set; } Property Value Action<long> TargetJob public Job TargetJob { get; set; } Property Value Job UnrollFactor public int UnrollFactor { get; } Property Value int WorkloadActionNoUnroll public Action<long> WorkloadActionNoUnroll { get; set; } Property Value Action<long> WorkloadActionUnroll public Action<long> WorkloadActionUnroll { get; set; } Property Value Action<long>"
  },
  "api/BenchmarkDotNet.Engines.EngineResolver.html": {
    "href": "api/BenchmarkDotNet.Engines.EngineResolver.html",
    "title": "Class EngineResolver | BenchmarkDotNet",
    "summary": "Class EngineResolver Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public class EngineResolver : Resolver, IResolver Inheritance object Resolver EngineResolver Implements IResolver Inherited Members Resolver.Register<T>(Characteristic<T>, Func<T>) Resolver.Register<T>(Characteristic<T>, Func<CharacteristicObject, T>) Resolver.CanResolve(Characteristic) Resolver.Resolve(CharacteristicObject, Characteristic) Resolver.Resolve<T>(CharacteristicObject, Characteristic<T>) Resolver.Resolve(CharacteristicObject, Characteristic, object) Resolver.Resolve<T>(CharacteristicObject, Characteristic<T>, T) Fields Instance public static readonly IResolver Instance Field Value IResolver"
  },
  "api/BenchmarkDotNet.Engines.GcStats.html": {
    "href": "api/BenchmarkDotNet.Engines.GcStats.html",
    "title": "Struct GcStats | BenchmarkDotNet",
    "summary": "Struct GcStats Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public struct GcStats : IEquatable<GcStats> Implements IEquatable<GcStats> Fields AllocationQuantum public static readonly long AllocationQuantum Field Value long Empty public static readonly GcStats Empty Field Value GcStats Properties Gen0Collections public readonly int Gen0Collections { get; } Property Value int Gen1Collections public readonly int Gen1Collections { get; } Property Value int Gen2Collections public readonly int Gen2Collections { get; } Property Value int TotalOperations public readonly long TotalOperations { get; } Property Value long Methods Equals(GcStats) public bool Equals(GcStats other) Parameters other GcStats Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool FromForced(int) public static GcStats FromForced(int forcedFullGarbageCollections) Parameters forcedFullGarbageCollections int Returns GcStats GetBytesAllocatedPerOperation(BenchmarkCase) public long? GetBytesAllocatedPerOperation(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns long? GetCollectionsCount(int) public int GetCollectionsCount(int generation) Parameters generation int Returns int GetHashCode() public override int GetHashCode() Returns int GetTotalAllocatedBytes(bool) returns total allocated bytes (not per operation) public long? GetTotalAllocatedBytes(bool excludeAllocationQuantumSideEffects) Parameters excludeAllocationQuantumSideEffects bool Allocation quantum can affecting some of our nano-benchmarks in non-deterministic way. when this parameter is set to true and the number of all allocated bytes is less or equal AQ, we ignore AQ and put 0 to the results Returns long? Parse(string) public static GcStats Parse(string line) Parameters line string Returns GcStats ReadFinal() public static GcStats ReadFinal() Returns GcStats ReadInitial() public static GcStats ReadInitial() Returns GcStats ToOutputLine() public string ToOutputLine() Returns string ToString() public override string ToString() Returns string WithTotalOperations(long) public GcStats WithTotalOperations(long totalOperationsCount) Parameters totalOperationsCount long Returns GcStats Operators operator +(GcStats, GcStats) public static GcStats operator +(GcStats left, GcStats right) Parameters left GcStats right GcStats Returns GcStats operator -(GcStats, GcStats) public static GcStats operator -(GcStats left, GcStats right) Parameters left GcStats right GcStats Returns GcStats"
  },
  "api/BenchmarkDotNet.Engines.HostExtensions.html": {
    "href": "api/BenchmarkDotNet.Engines.HostExtensions.html",
    "title": "Class HostExtensions | BenchmarkDotNet",
    "summary": "Class HostExtensions Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public static class HostExtensions Inheritance object HostExtensions Methods AfterAll(IHost) public static void AfterAll(this IHost host) Parameters host IHost AfterMainRun(IHost) public static void AfterMainRun(this IHost host) Parameters host IHost BeforeAnythingElse(IHost) public static void BeforeAnythingElse(this IHost host) Parameters host IHost BeforeMainRun(IHost) public static void BeforeMainRun(this IHost host) Parameters host IHost WriteLine(IHost, string, params object[]) public static void WriteLine(this IHost host, string messageFormat, params object[] args) Parameters host IHost messageFormat string args object[]"
  },
  "api/BenchmarkDotNet.Engines.HostSignal.html": {
    "href": "api/BenchmarkDotNet.Engines.HostSignal.html",
    "title": "Enum HostSignal | BenchmarkDotNet",
    "summary": "Enum HostSignal Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public enum HostSignal Fields AfterActualRun = 4 after main run, but before global Cleanup AfterAll = 5 after all (the last thing the benchmarking engine does is to fire this signal) AfterProcessExit = 7 after the benchmarking process exits AfterProcessStart = 1 right after we start the benchmarking process BeforeActualRun = 3 after globalSetup, warmup and pilot but before the main run BeforeAnythingElse = 2 before jitting, warmup BeforeProcessStart = 0 before we start the benchmarking process SeparateLogic = 6 used to run some code independent to the benchmarked process"
  },
  "api/BenchmarkDotNet.Engines.html": {
    "href": "api/BenchmarkDotNet.Engines.html",
    "title": "Namespace BenchmarkDotNet.Engines | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Engines Classes AnonymousPipesHost Consumer ConsumerExtensions DeadCodeEliminationHelper Engine Engine.Signals EngineEventSource EngineEventSource.Tasks EngineFactory EngineParameters EngineResolver HostExtensions NoAcknowledgementConsoleHost RunStrategyExtensions Structs GcStats IterationData RunResults ThreadingStats Interfaces IEngine IEngineFactory IHost Enums HostSignal IterationMode IterationStage RunStrategy"
  },
  "api/BenchmarkDotNet.Engines.IEngine.html": {
    "href": "api/BenchmarkDotNet.Engines.IEngine.html",
    "title": "Interface IEngine | BenchmarkDotNet",
    "summary": "Interface IEngine Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public interface IEngine : IDisposable Inherited Members IDisposable.Dispose() Properties GlobalCleanupAction Action? GlobalCleanupAction { get; } Property Value Action GlobalSetupAction Action? GlobalSetupAction { get; } Property Value Action Host IHost Host { get; } Property Value IHost OperationsPerInvoke long OperationsPerInvoke { get; } Property Value long OverheadAction Action<long> OverheadAction { get; } Property Value Action<long> Resolver IResolver Resolver { get; } Property Value IResolver TargetJob Job TargetJob { get; } Property Value Job WorkloadAction Action<long> WorkloadAction { get; } Property Value Action<long> Methods Run() RunResults Run() Returns RunResults RunIteration(IterationData) Measurement RunIteration(IterationData data) Parameters data IterationData Returns Measurement WriteLine() void WriteLine() WriteLine(string) void WriteLine(string line) Parameters line string"
  },
  "api/BenchmarkDotNet.Engines.IEngineFactory.html": {
    "href": "api/BenchmarkDotNet.Engines.IEngineFactory.html",
    "title": "Interface IEngineFactory | BenchmarkDotNet",
    "summary": "Interface IEngineFactory Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public interface IEngineFactory Methods CreateReadyToRun(EngineParameters) IEngine CreateReadyToRun(EngineParameters engineParameters) Parameters engineParameters EngineParameters Returns IEngine"
  },
  "api/BenchmarkDotNet.Engines.IHost.html": {
    "href": "api/BenchmarkDotNet.Engines.IHost.html",
    "title": "Interface IHost | BenchmarkDotNet",
    "summary": "Interface IHost Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public interface IHost : IDisposable Inherited Members IDisposable.Dispose() Extension Methods HostExtensions.AfterAll(IHost) HostExtensions.AfterMainRun(IHost) HostExtensions.BeforeAnythingElse(IHost) HostExtensions.BeforeMainRun(IHost) HostExtensions.WriteLine(IHost, string, params object[]) Methods ReportResults(RunResults) void ReportResults(RunResults runResults) Parameters runResults RunResults SendError(string) void SendError(string message) Parameters message string SendSignal(HostSignal) void SendSignal(HostSignal hostSignal) Parameters hostSignal HostSignal Write(string) void Write(string message) Parameters message string WriteLine() void WriteLine() WriteLine(string) void WriteLine(string message) Parameters message string"
  },
  "api/BenchmarkDotNet.Engines.IterationData.html": {
    "href": "api/BenchmarkDotNet.Engines.IterationData.html",
    "title": "Struct IterationData | BenchmarkDotNet",
    "summary": "Struct IterationData Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public struct IterationData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() Constructors IterationData(IterationMode, IterationStage, int, long, int) public IterationData(IterationMode iterationMode, IterationStage iterationStage, int index, long invokeCount, int unrollFactor) Parameters iterationMode IterationMode iterationStage IterationStage index int invokeCount long unrollFactor int Properties Index public readonly int Index { get; } Property Value int InvokeCount public readonly long InvokeCount { get; } Property Value long IterationMode public readonly IterationMode IterationMode { get; } Property Value IterationMode IterationStage public readonly IterationStage IterationStage { get; } Property Value IterationStage UnrollFactor public readonly int UnrollFactor { get; } Property Value int"
  },
  "api/BenchmarkDotNet.Engines.IterationMode.html": {
    "href": "api/BenchmarkDotNet.Engines.IterationMode.html",
    "title": "Enum IterationMode | BenchmarkDotNet",
    "summary": "Enum IterationMode Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public enum IterationMode Fields Overhead = 0 Unknown = 2 Workload = 1"
  },
  "api/BenchmarkDotNet.Engines.IterationStage.html": {
    "href": "api/BenchmarkDotNet.Engines.IterationStage.html",
    "title": "Enum IterationStage | BenchmarkDotNet",
    "summary": "Enum IterationStage Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public enum IterationStage Fields Actual = 3 Jitting = 0 Pilot = 1 https://en.wikipedia.org/wiki/Pilot_experiment Result = 4 Unknown = 5 Warmup = 2"
  },
  "api/BenchmarkDotNet.Engines.NoAcknowledgementConsoleHost.html": {
    "href": "api/BenchmarkDotNet.Engines.NoAcknowledgementConsoleHost.html",
    "title": "Class NoAcknowledgementConsoleHost | BenchmarkDotNet",
    "summary": "Class NoAcknowledgementConsoleHost Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public sealed class NoAcknowledgementConsoleHost : IHost, IDisposable Inheritance object NoAcknowledgementConsoleHost Implements IHost IDisposable Extension Methods HostExtensions.AfterAll(IHost) HostExtensions.AfterMainRun(IHost) HostExtensions.BeforeAnythingElse(IHost) HostExtensions.BeforeMainRun(IHost) HostExtensions.WriteLine(IHost, string, params object[]) Constructors NoAcknowledgementConsoleHost() public NoAcknowledgementConsoleHost() Methods Dispose() public void Dispose() ReportResults(RunResults) public void ReportResults(RunResults runResults) Parameters runResults RunResults SendError(string) public void SendError(string message) Parameters message string SendSignal(HostSignal) public void SendSignal(HostSignal hostSignal) Parameters hostSignal HostSignal Write(string) public void Write(string message) Parameters message string WriteLine() public void WriteLine() WriteLine(string) public void WriteLine(string message) Parameters message string"
  },
  "api/BenchmarkDotNet.Engines.RunResults.html": {
    "href": "api/BenchmarkDotNet.Engines.RunResults.html",
    "title": "Struct RunResults | BenchmarkDotNet",
    "summary": "Struct RunResults Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public struct RunResults Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() Constructors RunResults(IReadOnlyList<Measurement>, OutlierMode, GcStats, ThreadingStats, double) public RunResults(IReadOnlyList<Measurement> engineMeasurements, OutlierMode outlierMode, GcStats gcStats, ThreadingStats threadingStats, double exceptionFrequency) Parameters engineMeasurements IReadOnlyList<Measurement> outlierMode OutlierMode gcStats GcStats threadingStats ThreadingStats exceptionFrequency double Properties EngineMeasurements public readonly IReadOnlyList<Measurement> EngineMeasurements { get; } Property Value IReadOnlyList<Measurement> ExceptionFrequency public readonly double ExceptionFrequency { get; } Property Value double GCStats public readonly GcStats GCStats { get; } Property Value GcStats Overhead public IReadOnlyList<Measurement>? Overhead { get; } Property Value IReadOnlyList<Measurement> ThreadingStats public readonly ThreadingStats ThreadingStats { get; } Property Value ThreadingStats Workload public IReadOnlyList<Measurement> Workload { get; } Property Value IReadOnlyList<Measurement> Methods GetAllMeasurements() public IEnumerable<Measurement> GetAllMeasurements() Returns IEnumerable<Measurement> GetWorkloadResultMeasurements() public IEnumerable<Measurement> GetWorkloadResultMeasurements() Returns IEnumerable<Measurement> Print(TextWriter) public void Print(TextWriter outWriter) Parameters outWriter TextWriter"
  },
  "api/BenchmarkDotNet.Engines.RunStrategy.html": {
    "href": "api/BenchmarkDotNet.Engines.RunStrategy.html",
    "title": "Enum RunStrategy | BenchmarkDotNet",
    "summary": "Enum RunStrategy Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public enum RunStrategy Extension Methods RunStrategyExtensions.NeedsJitting(RunStrategy) Fields ColdStart = 1 A mode without overhead evaluating and warmup, with single invocation. Perfect for startup time evaluation. Monitoring = 2 A mode without overhead evaluating, with several target iterations. Perfect for macrobenchmarks without a steady state with high variance. Throughput = 0 Throughput mode. Perfect for microbenchmarking."
  },
  "api/BenchmarkDotNet.Engines.RunStrategyExtensions.html": {
    "href": "api/BenchmarkDotNet.Engines.RunStrategyExtensions.html",
    "title": "Class RunStrategyExtensions | BenchmarkDotNet",
    "summary": "Class RunStrategyExtensions Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public static class RunStrategyExtensions Inheritance object RunStrategyExtensions Methods NeedsJitting(RunStrategy) public static bool NeedsJitting(this RunStrategy runStrategy) Parameters runStrategy RunStrategy Returns bool"
  },
  "api/BenchmarkDotNet.Engines.ThreadingStats.html": {
    "href": "api/BenchmarkDotNet.Engines.ThreadingStats.html",
    "title": "Struct ThreadingStats | BenchmarkDotNet",
    "summary": "Struct ThreadingStats Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public struct ThreadingStats : IEquatable<ThreadingStats> Implements IEquatable<ThreadingStats> Constructors ThreadingStats(long, long, long) public ThreadingStats(long completedWorkItemCount, long lockContentionCount, long totalOperations) Parameters completedWorkItemCount long lockContentionCount long totalOperations long Properties CompletedWorkItemCount public readonly long CompletedWorkItemCount { get; } Property Value long Empty public static ThreadingStats Empty { get; } Property Value ThreadingStats LockContentionCount public readonly long LockContentionCount { get; } Property Value long TotalOperations public readonly long TotalOperations { get; } Property Value long Methods Equals(ThreadingStats) public bool Equals(ThreadingStats other) Parameters other ThreadingStats Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int Parse(string) public static ThreadingStats Parse(string line) Parameters line string Returns ThreadingStats ReadFinal() public static ThreadingStats ReadFinal() Returns ThreadingStats ReadInitial() public static ThreadingStats ReadInitial() Returns ThreadingStats ToOutputLine() public string ToOutputLine() Returns string ToString() public override string ToString() Returns string WithTotalOperations(long) public ThreadingStats WithTotalOperations(long totalOperationsCount) Parameters totalOperationsCount long Returns ThreadingStats Operators operator +(ThreadingStats, ThreadingStats) public static ThreadingStats operator +(ThreadingStats left, ThreadingStats right) Parameters left ThreadingStats right ThreadingStats Returns ThreadingStats operator -(ThreadingStats, ThreadingStats) public static ThreadingStats operator -(ThreadingStats left, ThreadingStats right) Parameters left ThreadingStats right ThreadingStats Returns ThreadingStats"
  },
  "api/BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.html": {
    "href": "api/BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.html",
    "title": "Class BenchmarkEnvironmentInfo | BenchmarkDotNet",
    "summary": "Class BenchmarkEnvironmentInfo Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public class BenchmarkEnvironmentInfo Inheritance object BenchmarkEnvironmentInfo Derived HostEnvironmentInfo Constructors BenchmarkEnvironmentInfo() protected BenchmarkEnvironmentInfo() Properties Architecture public string Architecture { get; protected set; } Property Value string Configuration public string Configuration { get; protected set; } Property Value string GCAllocationQuantum public long GCAllocationQuantum { get; protected set; } Property Value long HardwareIntrinsicsShort public string HardwareIntrinsicsShort { get; protected set; } Property Value string HasAttachedDebugger public bool HasAttachedDebugger { get; protected set; } Property Value bool HasRyuJit public bool HasRyuJit { get; protected set; } Property Value bool InDocker public bool InDocker { get; protected set; } Property Value bool IsConcurrentGC public bool IsConcurrentGC { get; protected set; } Property Value bool IsServerGC public bool IsServerGC { get; protected set; } Property Value bool JitInfo public string JitInfo { get; protected set; } Property Value string RuntimeVersion public string RuntimeVersion { get; protected set; } Property Value string Methods GetConfigurationFlag() protected string GetConfigurationFlag() Returns string GetCurrent() public static BenchmarkEnvironmentInfo GetCurrent() Returns BenchmarkEnvironmentInfo GetDebuggerFlag() protected string GetDebuggerFlag() Returns string GetGcConcurrentFlag() protected string GetGcConcurrentFlag() Returns string GetGcServerFlag() protected string GetGcServerFlag() Returns string ToFormattedString() public virtual IEnumerable<string> ToFormattedString() Returns IEnumerable<string> Validate(Job) public static IEnumerable<ValidationError> Validate(Job job) Parameters job Job Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Environments.ClrRuntime.html": {
    "href": "api/BenchmarkDotNet.Environments.ClrRuntime.html",
    "title": "Class ClrRuntime | BenchmarkDotNet",
    "summary": "Class ClrRuntime Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public class ClrRuntime : Runtime, IEquatable<Runtime>, IEquatable<ClrRuntime> Inheritance object Runtime ClrRuntime Implements IEquatable<Runtime> IEquatable<ClrRuntime> Inherited Members Runtime.ToString() Runtime.Equals(Runtime) Runtime.Name Runtime.RuntimeMoniker Runtime.MsBuildMoniker Runtime.IsAOT Fields Net461 public static readonly ClrRuntime Net461 Field Value ClrRuntime Net462 public static readonly ClrRuntime Net462 Field Value ClrRuntime Net47 public static readonly ClrRuntime Net47 Field Value ClrRuntime Net471 public static readonly ClrRuntime Net471 Field Value ClrRuntime Net472 public static readonly ClrRuntime Net472 Field Value ClrRuntime Net48 public static readonly ClrRuntime Net48 Field Value ClrRuntime Net481 public static readonly ClrRuntime Net481 Field Value ClrRuntime Properties Version public string Version { get; } Property Value string Methods CreateForLocalFullNetFrameworkBuild(string) public static ClrRuntime CreateForLocalFullNetFrameworkBuild(string version) Parameters version string YOU PROBABLY DON'T NEED IT, but if you are a .NET Runtime developer.. please set it to particular .NET Runtime version if you want to benchmark it. BenchmarkDotNet in going to pass COMPLUS_Version env var to the process for you. Returns ClrRuntime Equals(ClrRuntime) public bool Equals(ClrRuntime other) Parameters other ClrRuntime Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/BenchmarkDotNet.Environments.CoreRtRuntime.html": {
    "href": "api/BenchmarkDotNet.Environments.CoreRtRuntime.html",
    "title": "Class CoreRtRuntime | BenchmarkDotNet",
    "summary": "Class CoreRtRuntime Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll [Obsolete(\"Please use NativeAotRuntime instead.\", true)] public class CoreRtRuntime Inheritance object CoreRtRuntime Constructors CoreRtRuntime() public CoreRtRuntime()"
  },
  "api/BenchmarkDotNet.Environments.CoreRuntime.html": {
    "href": "api/BenchmarkDotNet.Environments.CoreRuntime.html",
    "title": "Class CoreRuntime | BenchmarkDotNet",
    "summary": "Class CoreRuntime Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public class CoreRuntime : Runtime, IEquatable<Runtime> Inheritance object Runtime CoreRuntime Implements IEquatable<Runtime> Inherited Members Runtime.ToString() Runtime.Equals(Runtime) Runtime.Equals(object) Runtime.GetHashCode() Runtime.Name Runtime.RuntimeMoniker Runtime.MsBuildMoniker Runtime.IsAOT Fields Core10_0 public static readonly CoreRuntime Core10_0 Field Value CoreRuntime Core20 public static readonly CoreRuntime Core20 Field Value CoreRuntime Core21 public static readonly CoreRuntime Core21 Field Value CoreRuntime Core22 public static readonly CoreRuntime Core22 Field Value CoreRuntime Core30 public static readonly CoreRuntime Core30 Field Value CoreRuntime Core31 public static readonly CoreRuntime Core31 Field Value CoreRuntime Core50 public static readonly CoreRuntime Core50 Field Value CoreRuntime Core60 public static readonly CoreRuntime Core60 Field Value CoreRuntime Core70 public static readonly CoreRuntime Core70 Field Value CoreRuntime Core80 public static readonly CoreRuntime Core80 Field Value CoreRuntime Core90 public static readonly CoreRuntime Core90 Field Value CoreRuntime Properties IsPlatformSpecific public bool IsPlatformSpecific { get; } Property Value bool Latest public static CoreRuntime Latest { get; } Property Value CoreRuntime Methods CreateForNewVersion(string, string) use this method if you want to target .NET version not supported by current version of BenchmarkDotNet. Example: .NET 10 public static CoreRuntime CreateForNewVersion(string msBuildMoniker, string displayName) Parameters msBuildMoniker string msbuild moniker, example: net10.0 displayName string display name used by BDN to print the results Returns CoreRuntime new runtime information"
  },
  "api/BenchmarkDotNet.Environments.CustomRuntime.html": {
    "href": "api/BenchmarkDotNet.Environments.CustomRuntime.html",
    "title": "Class CustomRuntime | BenchmarkDotNet",
    "summary": "Class CustomRuntime Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public abstract class CustomRuntime : Runtime, IEquatable<Runtime> Inheritance object Runtime CustomRuntime Implements IEquatable<Runtime> Inherited Members Runtime.ToString() Runtime.Equals(Runtime) Runtime.Equals(object) Runtime.GetHashCode() Runtime.Name Runtime.RuntimeMoniker Runtime.MsBuildMoniker Runtime.IsAOT Constructors CustomRuntime(RuntimeMoniker, string, string) protected CustomRuntime(RuntimeMoniker runtimeMoniker, string msBuildMoniker, string displayName) Parameters runtimeMoniker RuntimeMoniker msBuildMoniker string displayName string"
  },
  "api/BenchmarkDotNet.Environments.EnvironmentResolver.html": {
    "href": "api/BenchmarkDotNet.Environments.EnvironmentResolver.html",
    "title": "Class EnvironmentResolver | BenchmarkDotNet",
    "summary": "Class EnvironmentResolver Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public class EnvironmentResolver : Resolver, IResolver Inheritance object Resolver EnvironmentResolver Implements IResolver Inherited Members Resolver.Register<T>(Characteristic<T>, Func<T>) Resolver.Register<T>(Characteristic<T>, Func<CharacteristicObject, T>) Resolver.CanResolve(Characteristic) Resolver.Resolve(CharacteristicObject, Characteristic) Resolver.Resolve<T>(CharacteristicObject, Characteristic<T>) Resolver.Resolve(CharacteristicObject, Characteristic, object) Resolver.Resolve<T>(CharacteristicObject, Characteristic<T>, T) Fields DefaultUnrollFactorForThroughput public const int DefaultUnrollFactorForThroughput = 16 Field Value int Instance public static readonly IResolver Instance Field Value IResolver"
  },
  "api/BenchmarkDotNet.Environments.GcResolver.html": {
    "href": "api/BenchmarkDotNet.Environments.GcResolver.html",
    "title": "Class GcResolver | BenchmarkDotNet",
    "summary": "Class GcResolver Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public class GcResolver : Resolver, IResolver Inheritance object Resolver GcResolver Implements IResolver Inherited Members Resolver.Register<T>(Characteristic<T>, Func<T>) Resolver.Register<T>(Characteristic<T>, Func<CharacteristicObject, T>) Resolver.CanResolve(Characteristic) Resolver.Resolve(CharacteristicObject, Characteristic) Resolver.Resolve<T>(CharacteristicObject, Characteristic<T>) Resolver.Resolve(CharacteristicObject, Characteristic, object) Resolver.Resolve<T>(CharacteristicObject, Characteristic<T>, T) Fields Instance public static readonly IResolver Instance Field Value IResolver"
  },
  "api/BenchmarkDotNet.Environments.HostEnvironmentInfo.html": {
    "href": "api/BenchmarkDotNet.Environments.HostEnvironmentInfo.html",
    "title": "Class HostEnvironmentInfo | BenchmarkDotNet",
    "summary": "Class HostEnvironmentInfo Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public class HostEnvironmentInfo : BenchmarkEnvironmentInfo Inheritance object BenchmarkEnvironmentInfo HostEnvironmentInfo Inherited Members BenchmarkEnvironmentInfo.GetConfigurationFlag() BenchmarkEnvironmentInfo.GetDebuggerFlag() BenchmarkEnvironmentInfo.GetGcServerFlag() BenchmarkEnvironmentInfo.GetGcConcurrentFlag() BenchmarkEnvironmentInfo.Validate(Job) BenchmarkEnvironmentInfo.Architecture BenchmarkEnvironmentInfo.Configuration BenchmarkEnvironmentInfo.RuntimeVersion BenchmarkEnvironmentInfo.HasAttachedDebugger BenchmarkEnvironmentInfo.HasRyuJit BenchmarkEnvironmentInfo.JitInfo BenchmarkEnvironmentInfo.HardwareIntrinsicsShort BenchmarkEnvironmentInfo.IsServerGC BenchmarkEnvironmentInfo.IsConcurrentGC BenchmarkEnvironmentInfo.GCAllocationQuantum BenchmarkEnvironmentInfo.InDocker Constructors HostEnvironmentInfo() protected HostEnvironmentInfo() Fields BenchmarkDotNetCaption public const string BenchmarkDotNetCaption = \"BenchmarkDotNet\" Field Value string Properties AntivirusProducts public Lazy<ICollection<Antivirus>> AntivirusProducts { get; } Property Value Lazy<ICollection<Antivirus>> BenchmarkDotNetVersion public string BenchmarkDotNetVersion { get; protected set; } Property Value string ChronometerFrequency The frequency of the timer as the number of ticks per second. public Frequency ChronometerFrequency { get; protected set; } Property Value Frequency ChronometerResolution public TimeInterval ChronometerResolution { get; } Property Value TimeInterval Cpu is expensive to call (1s) public Lazy<CpuInfo> Cpu { get; protected set; } Property Value Lazy<CpuInfo> DotNetSdkVersion .NET Core SDK version It's expensive to call (creates new process by calling dotnet --version) public Lazy<string> DotNetSdkVersion { get; protected set; } Property Value Lazy<string> FallbackLogger Logger to use when there's no config available. public static ILogger FallbackLogger { get; } Property Value ILogger HardwareTimerKind public HardwareTimerKind HardwareTimerKind { get; protected set; } Property Value HardwareTimerKind IsMonoInstalled checks if Mono is installed It's expensive to call (creates new process by calling mono --version) public Lazy<bool> IsMonoInstalled { get; } Property Value Lazy<bool> Os public Lazy<OsInfo> Os { get; protected set; } Property Value Lazy<OsInfo> VirtualMachineHypervisor public Lazy<VirtualMachineHypervisor?> VirtualMachineHypervisor { get; protected set; } Property Value Lazy<VirtualMachineHypervisor> Methods GetCurrent() public static HostEnvironmentInfo GetCurrent() Returns HostEnvironmentInfo GetInformation() Return string representation of CPU and environment configuration including BenchmarkDotNet, OS and .NET version public static string GetInformation() Returns string IsDotNetCliInstalled() public bool IsDotNetCliInstalled() Returns bool ToFormattedString() public override IEnumerable<string> ToFormattedString() Returns IEnumerable<string>"
  },
  "api/BenchmarkDotNet.Environments.html": {
    "href": "api/BenchmarkDotNet.Environments.html",
    "title": "Namespace BenchmarkDotNet.Environments | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Environments Classes BenchmarkEnvironmentInfo ClrRuntime CoreRtRuntime CoreRuntime CustomRuntime EnvironmentResolver GcResolver HostEnvironmentInfo InfrastructureResolver MonoAotLLVMRuntime MonoRuntime NativeAotRuntime Runtime WasmRuntime Enums Jit Platform PowerPlan"
  },
  "api/BenchmarkDotNet.Environments.InfrastructureResolver.html": {
    "href": "api/BenchmarkDotNet.Environments.InfrastructureResolver.html",
    "title": "Class InfrastructureResolver | BenchmarkDotNet",
    "summary": "Class InfrastructureResolver Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public class InfrastructureResolver : Resolver, IResolver Inheritance object Resolver InfrastructureResolver Implements IResolver Inherited Members Resolver.Register<T>(Characteristic<T>, Func<T>) Resolver.Register<T>(Characteristic<T>, Func<CharacteristicObject, T>) Resolver.CanResolve(Characteristic) Resolver.Resolve(CharacteristicObject, Characteristic) Resolver.Resolve<T>(CharacteristicObject, Characteristic<T>) Resolver.Resolve(CharacteristicObject, Characteristic, object) Resolver.Resolve<T>(CharacteristicObject, Characteristic<T>, T) Fields Instance public static readonly IResolver Instance Field Value IResolver"
  },
  "api/BenchmarkDotNet.Environments.Jit.html": {
    "href": "api/BenchmarkDotNet.Environments.Jit.html",
    "title": "Enum Jit | BenchmarkDotNet",
    "summary": "Enum Jit Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public enum Jit Extension Methods ConfigurationExtensions.ToConfig(Jit) Fields Default = 0 Default By default LegacyJit = 1 LegacyJIT Supported only for Full Framework Llvm = 3 LLVM Supported only for Mono RyuJit = 2 RyuJIT Full Framework or CoreCLR"
  },
  "api/BenchmarkDotNet.Environments.MonoAotLLVMRuntime.html": {
    "href": "api/BenchmarkDotNet.Environments.MonoAotLLVMRuntime.html",
    "title": "Class MonoAotLLVMRuntime | BenchmarkDotNet",
    "summary": "Class MonoAotLLVMRuntime Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public class MonoAotLLVMRuntime : Runtime, IEquatable<Runtime>, IEquatable<MonoAotLLVMRuntime> Inheritance object Runtime MonoAotLLVMRuntime Implements IEquatable<Runtime> IEquatable<MonoAotLLVMRuntime> Inherited Members Runtime.ToString() Runtime.Equals(Runtime) Runtime.Name Runtime.RuntimeMoniker Runtime.MsBuildMoniker Constructors MonoAotLLVMRuntime(FileInfo, MonoAotCompilerMode, string, string, RuntimeMoniker) creates new instance of MonoAotLLVMRuntime public MonoAotLLVMRuntime(FileInfo aotCompilerPath, MonoAotCompilerMode aotCompilerMode, string msBuildMoniker = \"net6.0\", string displayName = \"MonoAOTLLVM\", RuntimeMoniker moniker = RuntimeMoniker.MonoAOTLLVM) Parameters aotCompilerPath FileInfo aotCompilerMode MonoAotCompilerMode msBuildMoniker string displayName string moniker RuntimeMoniker Properties AOTCompilerMode public MonoAotCompilerMode AOTCompilerMode { get; } Property Value MonoAotCompilerMode AOTCompilerPath public FileInfo AOTCompilerPath { get; } Property Value FileInfo IsAOT public override bool IsAOT { get; } Property Value bool Methods Equals(MonoAotLLVMRuntime) public bool Equals(MonoAotLLVMRuntime other) Parameters other MonoAotLLVMRuntime Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/BenchmarkDotNet.Environments.MonoRuntime.html": {
    "href": "api/BenchmarkDotNet.Environments.MonoRuntime.html",
    "title": "Class MonoRuntime | BenchmarkDotNet",
    "summary": "Class MonoRuntime Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public class MonoRuntime : Runtime, IEquatable<Runtime>, IEquatable<MonoRuntime> Inheritance object Runtime MonoRuntime Implements IEquatable<Runtime> IEquatable<MonoRuntime> Inherited Members Runtime.ToString() Runtime.Equals(Runtime) Runtime.Name Runtime.RuntimeMoniker Runtime.MsBuildMoniker Constructors MonoRuntime(string, string) public MonoRuntime(string name, string customPath) Parameters name string customPath string MonoRuntime(string, string, string, string) public MonoRuntime(string name, string customPath, string aotArgs, string monoBclPath) Parameters name string customPath string aotArgs string monoBclPath string Fields Default public static readonly MonoRuntime Default Field Value MonoRuntime Mono10_0 public static readonly MonoRuntime Mono10_0 Field Value MonoRuntime Mono60 public static readonly MonoRuntime Mono60 Field Value MonoRuntime Mono70 public static readonly MonoRuntime Mono70 Field Value MonoRuntime Mono80 public static readonly MonoRuntime Mono80 Field Value MonoRuntime Mono90 public static readonly MonoRuntime Mono90 Field Value MonoRuntime Properties AotArgs public string AotArgs { get; } Property Value string CustomPath public string CustomPath { get; } Property Value string IsAOT public override bool IsAOT { get; } Property Value bool MonoBclPath public string MonoBclPath { get; } Property Value string Methods Equals(MonoRuntime) public bool Equals(MonoRuntime other) Parameters other MonoRuntime Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/BenchmarkDotNet.Environments.NativeAotRuntime.html": {
    "href": "api/BenchmarkDotNet.Environments.NativeAotRuntime.html",
    "title": "Class NativeAotRuntime | BenchmarkDotNet",
    "summary": "Class NativeAotRuntime Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public class NativeAotRuntime : Runtime, IEquatable<Runtime> Inheritance object Runtime NativeAotRuntime Implements IEquatable<Runtime> Inherited Members Runtime.ToString() Runtime.Equals(Runtime) Runtime.Equals(object) Runtime.GetHashCode() Runtime.Name Runtime.RuntimeMoniker Runtime.MsBuildMoniker Fields Net10_0 NativeAOT compiled as net10.0 public static readonly NativeAotRuntime Net10_0 Field Value NativeAotRuntime Net60 NativeAOT compiled as net6.0 public static readonly NativeAotRuntime Net60 Field Value NativeAotRuntime Net70 NativeAOT compiled as net7.0 public static readonly NativeAotRuntime Net70 Field Value NativeAotRuntime Net80 NativeAOT compiled as net8.0 public static readonly NativeAotRuntime Net80 Field Value NativeAotRuntime Net90 NativeAOT compiled as net9.0 public static readonly NativeAotRuntime Net90 Field Value NativeAotRuntime Properties IsAOT public override bool IsAOT { get; } Property Value bool Methods GetCurrentVersion() public static NativeAotRuntime GetCurrentVersion() Returns NativeAotRuntime"
  },
  "api/BenchmarkDotNet.Environments.Platform.html": {
    "href": "api/BenchmarkDotNet.Environments.Platform.html",
    "title": "Enum Platform | BenchmarkDotNet",
    "summary": "Enum Platform Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public enum Platform Extension Methods ConfigurationExtensions.ToConfig(Platform) Fields AnyCpu = 0 AnyCPU Arm = 3 ARM Arm64 = 4 ARM64 Armv6 = 8 A 32-bit ARMv6 processor architecture. LoongArch64 = 7 LOONGARCH64 Ppc64le = 9 A PowerPC 64-bit (little-endian) processor architecture. RiscV64 = 10 A RiscV 64-bit processor architecture. S390x = 6 S390x Wasm = 5 Wasm X64 = 2 x64 X86 = 1 x86"
  },
  "api/BenchmarkDotNet.Environments.PowerPlan.html": {
    "href": "api/BenchmarkDotNet.Environments.PowerPlan.html",
    "title": "Enum PowerPlan | BenchmarkDotNet",
    "summary": "Enum PowerPlan Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public enum PowerPlan Fields Balanced = 3 HighPerformance = 0 PowerSaver = 2 UltimatePerformance = 4 UserPowerPlan = 1"
  },
  "api/BenchmarkDotNet.Environments.Runtime.html": {
    "href": "api/BenchmarkDotNet.Environments.Runtime.html",
    "title": "Class Runtime | BenchmarkDotNet",
    "summary": "Class Runtime Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public abstract class Runtime : IEquatable<Runtime> Inheritance object Runtime Implements IEquatable<Runtime> Derived ClrRuntime CoreRuntime CustomRuntime MonoAotLLVMRuntime MonoRuntime NativeAotRuntime WasmRuntime Constructors Runtime(RuntimeMoniker, string, string) protected Runtime(RuntimeMoniker runtimeMoniker, string msBuildMoniker, string displayName) Parameters runtimeMoniker RuntimeMoniker msBuildMoniker string displayName string Properties IsAOT public virtual bool IsAOT { get; } Property Value bool MsBuildMoniker MsBuild Target Framework Moniker, example: net462, net8.0 public string MsBuildMoniker { get; } Property Value string Name Display name public string Name { get; } Property Value string RuntimeMoniker Target Framework Moniker public RuntimeMoniker RuntimeMoniker { get; } Property Value RuntimeMoniker Methods Equals(Runtime) public bool Equals(Runtime other) Parameters other Runtime Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Environments.WasmRuntime.html": {
    "href": "api/BenchmarkDotNet.Environments.WasmRuntime.html",
    "title": "Class WasmRuntime | BenchmarkDotNet",
    "summary": "Class WasmRuntime Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public class WasmRuntime : Runtime, IEquatable<Runtime>, IEquatable<WasmRuntime> Inheritance object Runtime WasmRuntime Implements IEquatable<Runtime> IEquatable<WasmRuntime> Inherited Members Runtime.ToString() Runtime.Equals(Runtime) Runtime.Name Runtime.RuntimeMoniker Runtime.MsBuildMoniker Runtime.IsAOT Constructors WasmRuntime(string, string, string, string, bool, string?, RuntimeMoniker) creates new instance of WasmRuntime public WasmRuntime(string msBuildMoniker = \"net5.0\", string displayName = \"Wasm\", string javaScriptEngine = \"v8\", string javaScriptEngineArguments = \"--expose_wasm\", bool aot = false, string? wasmDataDir = null, RuntimeMoniker moniker = RuntimeMoniker.Wasm) Parameters msBuildMoniker string moniker, default: \"net5.0\" displayName string default: \"Wasm\" javaScriptEngine string Full path to a java script engine used to run the benchmarks. \"v8\" by default javaScriptEngineArguments string Arguments for the javascript engine. \"--expose_wasm\" by default aot bool Specifies whether AOT or Interpreter (default) project should be generated. wasmDataDir string Specifies a wasm data directory surfaced as $(WasmDataDir) for the project moniker RuntimeMoniker Runtime moniker Properties Aot public bool Aot { get; } Property Value bool JavaScriptEngine public string JavaScriptEngine { get; } Property Value string JavaScriptEngineArguments public string JavaScriptEngineArguments { get; } Property Value string WasmDataDir public string WasmDataDir { get; } Property Value string Methods Equals(WasmRuntime) public bool Equals(WasmRuntime other) Parameters other WasmRuntime Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/BenchmarkDotNet.EventProcessors.EventProcessor.html": {
    "href": "api/BenchmarkDotNet.EventProcessors.EventProcessor.html",
    "title": "Class EventProcessor | BenchmarkDotNet",
    "summary": "Class EventProcessor Namespace BenchmarkDotNet.EventProcessors Assembly BenchmarkDotNet.dll public abstract class EventProcessor Inheritance object EventProcessor Constructors EventProcessor() protected EventProcessor() Methods OnBuildComplete(BuildPartition, BuildResult) public virtual void OnBuildComplete(BuildPartition partition, BuildResult buildResult) Parameters partition BuildPartition buildResult BuildResult OnEndBuildStage() public virtual void OnEndBuildStage() OnEndRunBenchmark(BenchmarkCase, BenchmarkReport) public virtual void OnEndRunBenchmark(BenchmarkCase benchmarkCase, BenchmarkReport report) Parameters benchmarkCase BenchmarkCase report BenchmarkReport OnEndRunBenchmarksInType(Type, Summary) public virtual void OnEndRunBenchmarksInType(Type type, Summary summary) Parameters type Type summary Summary OnEndRunStage() public virtual void OnEndRunStage() OnEndValidationStage() public virtual void OnEndValidationStage() OnStartBuildStage(IReadOnlyList<BuildPartition>) public virtual void OnStartBuildStage(IReadOnlyList<BuildPartition> partitions) Parameters partitions IReadOnlyList<BuildPartition> OnStartRunBenchmark(BenchmarkCase) public virtual void OnStartRunBenchmark(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase OnStartRunBenchmarksInType(Type, IReadOnlyList<BenchmarkCase>) public virtual void OnStartRunBenchmarksInType(Type type, IReadOnlyList<BenchmarkCase> benchmarks) Parameters type Type benchmarks IReadOnlyList<BenchmarkCase> OnStartRunStage() public virtual void OnStartRunStage() OnStartValidationStage() public virtual void OnStartValidationStage() OnValidationError(ValidationError) public virtual void OnValidationError(ValidationError validationError) Parameters validationError ValidationError"
  },
  "api/BenchmarkDotNet.EventProcessors.html": {
    "href": "api/BenchmarkDotNet.EventProcessors.html",
    "title": "Namespace BenchmarkDotNet.EventProcessors | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.EventProcessors Classes EventProcessor"
  },
  "api/BenchmarkDotNet.Exporters.AsciiDocExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.AsciiDocExporter.html",
    "title": "Class AsciiDocExporter | BenchmarkDotNet",
    "summary": "Class AsciiDocExporter Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public class AsciiDocExporter : ExporterBase, IExporter Inheritance object ExporterBase AsciiDocExporter Implements IExporter Inherited Members ExporterBase.ExportToFiles(Summary, ILogger) ExporterBase.GetArtifactFullName(Summary) ExporterBase.Name ExporterBase.FileNameSuffix ExporterBase.FileCaption Fields Default public static readonly IExporter Default Field Value IExporter Properties FileExtension protected override string FileExtension { get; } Property Value string Methods ExportToLog(Summary, ILogger) public override void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger"
  },
  "api/BenchmarkDotNet.Exporters.BenchmarkReportExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.BenchmarkReportExporter.html",
    "title": "Class BenchmarkReportExporter | BenchmarkDotNet",
    "summary": "Class BenchmarkReportExporter Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public class BenchmarkReportExporter : ExporterBase, IExporter Inheritance object ExporterBase BenchmarkReportExporter Implements IExporter Inherited Members ExporterBase.ExportToFiles(Summary, ILogger) ExporterBase.GetArtifactFullName(Summary) ExporterBase.Name ExporterBase.FileExtension ExporterBase.FileNameSuffix ExporterBase.FileCaption Fields Default public static readonly IExporter Default Field Value IExporter Methods ExportToLog(Summary, ILogger) public override void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger"
  },
  "api/BenchmarkDotNet.Exporters.CompositeExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.CompositeExporter.html",
    "title": "Class CompositeExporter | BenchmarkDotNet",
    "summary": "Class CompositeExporter Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public class CompositeExporter : IExporter Inheritance object CompositeExporter Implements IExporter Constructors CompositeExporter(ImmutableArray<IExporter>) public CompositeExporter(ImmutableArray<IExporter> exporters) Parameters exporters ImmutableArray<IExporter> Properties Name public string Name { get; } Property Value string Methods ExportToFiles(Summary, ILogger) public IEnumerable<string> ExportToFiles(Summary summary, ILogger consoleLogger) Parameters summary Summary consoleLogger ILogger Returns IEnumerable<string> ExportToLog(Summary, ILogger) public void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger"
  },
  "api/BenchmarkDotNet.Exporters.Csv.CsvExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.Csv.CsvExporter.html",
    "title": "Class CsvExporter | BenchmarkDotNet",
    "summary": "Class CsvExporter Namespace BenchmarkDotNet.Exporters.Csv Assembly BenchmarkDotNet.dll public class CsvExporter : ExporterBase, IExporter Inheritance object ExporterBase CsvExporter Implements IExporter Inherited Members ExporterBase.ExportToFiles(Summary, ILogger) ExporterBase.GetArtifactFullName(Summary) ExporterBase.Name ExporterBase.FileNameSuffix ExporterBase.FileCaption Constructors CsvExporter(CsvSeparator, SummaryStyle?) public CsvExporter(CsvSeparator separator, SummaryStyle? style = null) Parameters separator CsvSeparator style SummaryStyle Fields Default public static readonly IExporter Default Field Value IExporter Properties FileExtension protected override string FileExtension { get; } Property Value string Methods ExportToLog(Summary, ILogger) public override void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger"
  },
  "api/BenchmarkDotNet.Exporters.Csv.CsvHelper.html": {
    "href": "api/BenchmarkDotNet.Exporters.Csv.CsvHelper.html",
    "title": "Class CsvHelper | BenchmarkDotNet",
    "summary": "Class CsvHelper Namespace BenchmarkDotNet.Exporters.Csv Assembly BenchmarkDotNet.dll public static class CsvHelper Inheritance object CsvHelper Methods Escape(string?, string) public static string Escape(string? value, string currentListSeparator) Parameters value string currentListSeparator string Returns string"
  },
  "api/BenchmarkDotNet.Exporters.Csv.CsvMeasurementsExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.Csv.CsvMeasurementsExporter.html",
    "title": "Class CsvMeasurementsExporter | BenchmarkDotNet",
    "summary": "Class CsvMeasurementsExporter Namespace BenchmarkDotNet.Exporters.Csv Assembly BenchmarkDotNet.dll public class CsvMeasurementsExporter : ExporterBase, IExporter Inheritance object ExporterBase CsvMeasurementsExporter Implements IExporter Inherited Members ExporterBase.ExportToFiles(Summary, ILogger) ExporterBase.GetArtifactFullName(Summary) ExporterBase.Name ExporterBase.FileNameSuffix Constructors CsvMeasurementsExporter(CsvSeparator, SummaryStyle?) public CsvMeasurementsExporter(CsvSeparator separator, SummaryStyle? style = null) Parameters separator CsvSeparator style SummaryStyle Fields Default public static readonly CsvMeasurementsExporter Default Field Value CsvMeasurementsExporter Properties FileCaption protected override string FileCaption { get; } Property Value string FileExtension protected override string FileExtension { get; } Property Value string Separator public string Separator { get; } Property Value string Style public SummaryStyle Style { get; } Property Value SummaryStyle Methods ExportToLog(Summary, ILogger) public override void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger GetJobs(Summary) public static Job[] GetJobs(Summary summary) Parameters summary Summary Returns Job[] WithStyle(SummaryStyle) public static CsvMeasurementsExporter WithStyle(SummaryStyle style) Parameters style SummaryStyle Returns CsvMeasurementsExporter"
  },
  "api/BenchmarkDotNet.Exporters.Csv.CsvSeparator.html": {
    "href": "api/BenchmarkDotNet.Exporters.Csv.CsvSeparator.html",
    "title": "Enum CsvSeparator | BenchmarkDotNet",
    "summary": "Enum CsvSeparator Namespace BenchmarkDotNet.Exporters.Csv Assembly BenchmarkDotNet.dll public enum CsvSeparator Extension Methods CsvSeparatorExtensions.ToRealSeparator(CsvSeparator) Fields Comma = 0 ',' will be used as the CSV separator. CurrentCulture = 2 Semicolon = 1 ';' will be used as the CSV separator."
  },
  "api/BenchmarkDotNet.Exporters.Csv.CsvSeparatorExtensions.html": {
    "href": "api/BenchmarkDotNet.Exporters.Csv.CsvSeparatorExtensions.html",
    "title": "Class CsvSeparatorExtensions | BenchmarkDotNet",
    "summary": "Class CsvSeparatorExtensions Namespace BenchmarkDotNet.Exporters.Csv Assembly BenchmarkDotNet.dll public static class CsvSeparatorExtensions Inheritance object CsvSeparatorExtensions Methods ToRealSeparator(CsvSeparator) Return a string which represent real CSV separator which can be used as plain text. public static string ToRealSeparator(this CsvSeparator separator) Parameters separator CsvSeparator Returns string"
  },
  "api/BenchmarkDotNet.Exporters.Csv.html": {
    "href": "api/BenchmarkDotNet.Exporters.Csv.html",
    "title": "Namespace BenchmarkDotNet.Exporters.Csv | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Exporters.Csv Classes CsvExporter CsvHelper CsvMeasurementsExporter CsvSeparatorExtensions Enums CsvSeparator"
  },
  "api/BenchmarkDotNet.Exporters.DefaultExporters.html": {
    "href": "api/BenchmarkDotNet.Exporters.DefaultExporters.html",
    "title": "Class DefaultExporters | BenchmarkDotNet",
    "summary": "Class DefaultExporters Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public static class DefaultExporters Inheritance object DefaultExporters Fields AsciiDoc public static readonly IExporter AsciiDoc Field Value IExporter Csv public static readonly IExporter Csv Field Value IExporter CsvMeasurements public static readonly IExporter CsvMeasurements Field Value IExporter Html public static readonly IExporter Html Field Value IExporter Json public static readonly IExporter Json Field Value IExporter JsonBrief public static readonly IExporter JsonBrief Field Value IExporter JsonBriefCompressed public static readonly IExporter JsonBriefCompressed Field Value IExporter JsonFull public static readonly IExporter JsonFull Field Value IExporter JsonFullCompressed public static readonly IExporter JsonFullCompressed Field Value IExporter Markdown public static readonly IExporter Markdown Field Value IExporter Plain public static readonly IExporter Plain Field Value IExporter RPlot public static readonly IExporter RPlot Field Value IExporter Xml public static readonly IExporter Xml Field Value IExporter XmlBrief public static readonly IExporter XmlBrief Field Value IExporter XmlBriefCompressed public static readonly IExporter XmlBriefCompressed Field Value IExporter XmlFull public static readonly IExporter XmlFull Field Value IExporter XmlFullCompressed public static readonly IExporter XmlFullCompressed Field Value IExporter"
  },
  "api/BenchmarkDotNet.Exporters.ExporterBase.html": {
    "href": "api/BenchmarkDotNet.Exporters.ExporterBase.html",
    "title": "Class ExporterBase | BenchmarkDotNet",
    "summary": "Class ExporterBase Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public abstract class ExporterBase : IExporter Inheritance object ExporterBase Implements IExporter Derived AsciiDocExporter BenchmarkReportExporter CsvExporter CsvMeasurementsExporter HtmlExporter JsonExporterBase MarkdownExporter PlainExporter XmlExporterBase Constructors ExporterBase() protected ExporterBase() Properties FileCaption protected virtual string FileCaption { get; } Property Value string FileExtension protected virtual string FileExtension { get; } Property Value string FileNameSuffix protected virtual string FileNameSuffix { get; } Property Value string Name public string Name { get; } Property Value string Methods ExportToFiles(Summary, ILogger) public IEnumerable<string> ExportToFiles(Summary summary, ILogger consoleLogger) Parameters summary Summary consoleLogger ILogger Returns IEnumerable<string> ExportToLog(Summary, ILogger) public abstract void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger GetArtifactFullName(Summary) public string GetArtifactFullName(Summary summary) Parameters summary Summary Returns string"
  },
  "api/BenchmarkDotNet.Exporters.FullNameProvider.html": {
    "href": "api/BenchmarkDotNet.Exporters.FullNameProvider.html",
    "title": "Class FullNameProvider | BenchmarkDotNet",
    "summary": "Class FullNameProvider Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public static class FullNameProvider Inheritance object FullNameProvider Methods GetBenchmarkName(BenchmarkCase) public static string GetBenchmarkName(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns string"
  },
  "api/BenchmarkDotNet.Exporters.html": {
    "href": "api/BenchmarkDotNet.Exporters.html",
    "title": "Namespace BenchmarkDotNet.Exporters | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Exporters Classes AsciiDocExporter BenchmarkReportExporter CompositeExporter DefaultExporters ExporterBase FullNameProvider HtmlExporter MarkdownExporter PlainExporter RPlotExporter Interfaces IExporter Enums MarkdownExporter.MarkdownHighlightStrategy"
  },
  "api/BenchmarkDotNet.Exporters.HtmlExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.HtmlExporter.html",
    "title": "Class HtmlExporter | BenchmarkDotNet",
    "summary": "Class HtmlExporter Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public class HtmlExporter : ExporterBase, IExporter Inheritance object ExporterBase HtmlExporter Implements IExporter Inherited Members ExporterBase.ExportToFiles(Summary, ILogger) ExporterBase.GetArtifactFullName(Summary) ExporterBase.Name ExporterBase.FileNameSuffix ExporterBase.FileCaption Constructors HtmlExporter() public HtmlExporter() Fields Default public static readonly IExporter Default Field Value IExporter Properties FileExtension protected override string FileExtension { get; } Property Value string Methods ExportToLog(Summary, ILogger) public override void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger"
  },
  "api/BenchmarkDotNet.Exporters.IExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.IExporter.html",
    "title": "Interface IExporter | BenchmarkDotNet",
    "summary": "Interface IExporter Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public interface IExporter Properties Name string Name { get; } Property Value string Methods ExportToFiles(Summary, ILogger) IEnumerable<string> ExportToFiles(Summary summary, ILogger consoleLogger) Parameters summary Summary consoleLogger ILogger Returns IEnumerable<string> ExportToLog(Summary, ILogger) void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger"
  },
  "api/BenchmarkDotNet.Exporters.Json.html": {
    "href": "api/BenchmarkDotNet.Exporters.Json.html",
    "title": "Namespace BenchmarkDotNet.Exporters.Json | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Exporters.Json Classes JsonExporter JsonExporterBase"
  },
  "api/BenchmarkDotNet.Exporters.Json.JsonExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.Json.JsonExporter.html",
    "title": "Class JsonExporter | BenchmarkDotNet",
    "summary": "Class JsonExporter Namespace BenchmarkDotNet.Exporters.Json Assembly BenchmarkDotNet.dll public class JsonExporter : JsonExporterBase, IExporter Inheritance object ExporterBase JsonExporterBase JsonExporter Implements IExporter Inherited Members JsonExporterBase.ExportToLog(Summary, ILogger) JsonExporterBase.GetDataToSerialize(Summary) JsonExporterBase.GetDataToSerialize(HostEnvironmentInfo) JsonExporterBase.GetDataToSerialize(BenchmarkReport) JsonExporterBase.FileExtension ExporterBase.ExportToFiles(Summary, ILogger) ExporterBase.GetArtifactFullName(Summary) ExporterBase.Name ExporterBase.FileCaption Constructors JsonExporter(string, bool, bool) public JsonExporter(string fileNameSuffix = \"\", bool indentJson = false, bool excludeMeasurements = false) Parameters fileNameSuffix string indentJson bool excludeMeasurements bool Fields Brief public static readonly IExporter Brief Field Value IExporter BriefCompressed public static readonly IExporter BriefCompressed Field Value IExporter Default public static readonly IExporter Default Field Value IExporter Full public static readonly IExporter Full Field Value IExporter FullCompressed public static readonly IExporter FullCompressed Field Value IExporter Properties FileNameSuffix protected override string FileNameSuffix { get; } Property Value string Methods Custom(string, bool, bool) public static IExporter Custom(string fileNameSuffix = \"\", bool indentJson = false, bool excludeMeasurements = false) Parameters fileNameSuffix string indentJson bool excludeMeasurements bool Returns IExporter"
  },
  "api/BenchmarkDotNet.Exporters.Json.JsonExporterBase.html": {
    "href": "api/BenchmarkDotNet.Exporters.Json.JsonExporterBase.html",
    "title": "Class JsonExporterBase | BenchmarkDotNet",
    "summary": "Class JsonExporterBase Namespace BenchmarkDotNet.Exporters.Json Assembly BenchmarkDotNet.dll public abstract class JsonExporterBase : ExporterBase, IExporter Inheritance object ExporterBase JsonExporterBase Implements IExporter Derived JsonExporter Inherited Members ExporterBase.ExportToFiles(Summary, ILogger) ExporterBase.GetArtifactFullName(Summary) ExporterBase.Name ExporterBase.FileNameSuffix ExporterBase.FileCaption Constructors JsonExporterBase(bool, bool) protected JsonExporterBase(bool indentJson = false, bool excludeMeasurements = false) Parameters indentJson bool excludeMeasurements bool Properties FileExtension protected override string FileExtension { get; } Property Value string Methods ExportToLog(Summary, ILogger) public override void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger GetDataToSerialize(HostEnvironmentInfo) protected virtual IReadOnlyDictionary<string, object> GetDataToSerialize(HostEnvironmentInfo environmentInfo) Parameters environmentInfo HostEnvironmentInfo Returns IReadOnlyDictionary<string, object> GetDataToSerialize(BenchmarkReport) protected virtual IReadOnlyDictionary<string, object> GetDataToSerialize(BenchmarkReport report) Parameters report BenchmarkReport Returns IReadOnlyDictionary<string, object> GetDataToSerialize(Summary) protected virtual IReadOnlyDictionary<string, object> GetDataToSerialize(Summary summary) Parameters summary Summary Returns IReadOnlyDictionary<string, object>"
  },
  "api/BenchmarkDotNet.Exporters.MarkdownExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.MarkdownExporter.html",
    "title": "Class MarkdownExporter | BenchmarkDotNet",
    "summary": "Class MarkdownExporter Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public class MarkdownExporter : ExporterBase, IExporter Inheritance object ExporterBase MarkdownExporter Implements IExporter Inherited Members ExporterBase.ExportToFiles(Summary, ILogger) ExporterBase.GetArtifactFullName(Summary) ExporterBase.Name ExporterBase.FileCaption Constructors MarkdownExporter() protected MarkdownExporter() Fields Atlassian public static readonly IExporter Atlassian Field Value IExporter BoldMarkupFormat protected string BoldMarkupFormat Field Value string CodeBlockEnd protected string CodeBlockEnd Field Value string CodeBlockStart protected string CodeBlockStart Field Value string ColumnsStartWithSeparator protected bool ColumnsStartWithSeparator Field Value bool Console public static readonly IExporter Console Field Value IExporter Default public static readonly IExporter Default Field Value IExporter EscapeHtml protected bool EscapeHtml Field Value bool GitHub public static readonly IExporter GitHub Field Value IExporter Prefix protected string Prefix Field Value string StackOverflow public static readonly IExporter StackOverflow Field Value IExporter StartOfGroupHighlightStrategy protected MarkdownExporter.MarkdownHighlightStrategy StartOfGroupHighlightStrategy Field Value MarkdownExporter.MarkdownHighlightStrategy TableColumnSeparator protected string TableColumnSeparator Field Value string TableHeaderSeparator protected string TableHeaderSeparator Field Value string UseCodeBlocks protected bool UseCodeBlocks Field Value bool UseHeaderSeparatingRow protected bool UseHeaderSeparatingRow Field Value bool Properties Dialect protected string Dialect { get; set; } Property Value string FileExtension protected override string FileExtension { get; } Property Value string FileNameSuffix protected override string FileNameSuffix { get; } Property Value string Methods ExportToLog(Summary, ILogger) public override void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger"
  },
  "api/BenchmarkDotNet.Exporters.MarkdownExporter.MarkdownHighlightStrategy.html": {
    "href": "api/BenchmarkDotNet.Exporters.MarkdownExporter.MarkdownHighlightStrategy.html",
    "title": "Enum MarkdownExporter.MarkdownHighlightStrategy | BenchmarkDotNet",
    "summary": "Enum MarkdownExporter.MarkdownHighlightStrategy Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public enum MarkdownExporter.MarkdownHighlightStrategy Fields Bold = 1 Marker = 2 None = 0"
  },
  "api/BenchmarkDotNet.Exporters.PlainExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.PlainExporter.html",
    "title": "Class PlainExporter | BenchmarkDotNet",
    "summary": "Class PlainExporter Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public class PlainExporter : ExporterBase, IExporter Inheritance object ExporterBase PlainExporter Implements IExporter Inherited Members ExporterBase.ExportToFiles(Summary, ILogger) ExporterBase.GetArtifactFullName(Summary) ExporterBase.Name ExporterBase.FileExtension ExporterBase.FileNameSuffix ExporterBase.FileCaption Fields Default public static readonly IExporter Default Field Value IExporter Methods ExportToLog(Summary, ILogger) public override void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger"
  },
  "api/BenchmarkDotNet.Exporters.RPlotExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.RPlotExporter.html",
    "title": "Class RPlotExporter | BenchmarkDotNet",
    "summary": "Class RPlotExporter Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public class RPlotExporter : IExporter Inheritance object RPlotExporter Implements IExporter Constructors RPlotExporter() public RPlotExporter() Fields Default public static readonly IExporter Default Field Value IExporter Properties Dependencies public IEnumerable<IExporter> Dependencies { get; } Property Value IEnumerable<IExporter> Name public string Name { get; } Property Value string Methods ExportToFiles(Summary, ILogger) public IEnumerable<string> ExportToFiles(Summary summary, ILogger consoleLogger) Parameters summary Summary consoleLogger ILogger Returns IEnumerable<string> ExportToLog(Summary, ILogger) public void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger"
  },
  "api/BenchmarkDotNet.Exporters.Xml.html": {
    "href": "api/BenchmarkDotNet.Exporters.Xml.html",
    "title": "Namespace BenchmarkDotNet.Exporters.Xml | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Exporters.Xml Classes XmlExporter XmlExporterBase"
  },
  "api/BenchmarkDotNet.Exporters.Xml.XmlExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.Xml.XmlExporter.html",
    "title": "Class XmlExporter | BenchmarkDotNet",
    "summary": "Class XmlExporter Namespace BenchmarkDotNet.Exporters.Xml Assembly BenchmarkDotNet.dll public class XmlExporter : XmlExporterBase, IExporter Inheritance object ExporterBase XmlExporterBase XmlExporter Implements IExporter Inherited Members XmlExporterBase.ExportToLog(Summary, ILogger) XmlExporterBase.FileExtension ExporterBase.ExportToFiles(Summary, ILogger) ExporterBase.GetArtifactFullName(Summary) ExporterBase.Name ExporterBase.FileCaption Constructors XmlExporter(string, bool, bool) public XmlExporter(string fileNameSuffix = \"\", bool indentXml = false, bool excludeMeasurements = false) Parameters fileNameSuffix string indentXml bool excludeMeasurements bool Fields Brief public static readonly IExporter Brief Field Value IExporter BriefCompressed public static readonly IExporter BriefCompressed Field Value IExporter Default public static readonly IExporter Default Field Value IExporter Full public static readonly IExporter Full Field Value IExporter FullCompressed public static readonly IExporter FullCompressed Field Value IExporter Properties FileNameSuffix protected override string FileNameSuffix { get; } Property Value string Methods Custom(string, bool, bool) public static IExporter Custom(string fileNameSuffix = \"\", bool indentXml = false, bool excludeMeasurements = false) Parameters fileNameSuffix string indentXml bool excludeMeasurements bool Returns IExporter"
  },
  "api/BenchmarkDotNet.Exporters.Xml.XmlExporterBase.html": {
    "href": "api/BenchmarkDotNet.Exporters.Xml.XmlExporterBase.html",
    "title": "Class XmlExporterBase | BenchmarkDotNet",
    "summary": "Class XmlExporterBase Namespace BenchmarkDotNet.Exporters.Xml Assembly BenchmarkDotNet.dll public abstract class XmlExporterBase : ExporterBase, IExporter Inheritance object ExporterBase XmlExporterBase Implements IExporter Derived XmlExporter Inherited Members ExporterBase.ExportToFiles(Summary, ILogger) ExporterBase.GetArtifactFullName(Summary) ExporterBase.Name ExporterBase.FileNameSuffix ExporterBase.FileCaption Constructors XmlExporterBase(bool, bool) protected XmlExporterBase(bool indentXml = false, bool excludeMeasurements = false) Parameters indentXml bool excludeMeasurements bool Properties FileExtension protected override string FileExtension { get; } Property Value string Methods ExportToLog(Summary, ILogger) public override void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger"
  },
  "api/BenchmarkDotNet.Extensions.ConfigurationExtensions.html": {
    "href": "api/BenchmarkDotNet.Extensions.ConfigurationExtensions.html",
    "title": "Class ConfigurationExtensions | BenchmarkDotNet",
    "summary": "Class ConfigurationExtensions Namespace BenchmarkDotNet.Extensions Assembly BenchmarkDotNet.dll public static class ConfigurationExtensions Inheritance object ConfigurationExtensions Methods ToConfig(Jit) public static string ToConfig(this Jit jit) Parameters jit Jit Returns string ToConfig(Platform) public static string ToConfig(this Platform platform) Parameters platform Platform Returns string"
  },
  "api/BenchmarkDotNet.Extensions.html": {
    "href": "api/BenchmarkDotNet.Extensions.html",
    "title": "Namespace BenchmarkDotNet.Extensions | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Extensions Classes ConfigurationExtensions ReportExtensions StatisticsExtensions"
  },
  "api/BenchmarkDotNet.Extensions.ReportExtensions.html": {
    "href": "api/BenchmarkDotNet.Extensions.ReportExtensions.html",
    "title": "Class ReportExtensions | BenchmarkDotNet",
    "summary": "Class ReportExtensions Namespace BenchmarkDotNet.Extensions Assembly BenchmarkDotNet.dll public static class ReportExtensions Inheritance object ReportExtensions Methods GetReportFor<T>(Summary, Expression<Action<T>>) public static BenchmarkReport GetReportFor<T>(this Summary summary, Expression<Action<T>> actionExp) Parameters summary Summary actionExp Expression<Action<T>> Returns BenchmarkReport Type Parameters T GetRunsFor<T>(Summary, Expression<Action<T>>) public static IList<Measurement> GetRunsFor<T>(this Summary summary, Expression<Action<T>> actionExp) Parameters summary Summary actionExp Expression<Action<T>> Returns IList<Measurement> Type Parameters T GetStatistics(IEnumerable<Measurement>) public static Statistics GetStatistics(this IEnumerable<Measurement> runs) Parameters runs IEnumerable<Measurement> Returns Statistics GetStatistics(IReadOnlyCollection<Measurement>) public static Statistics GetStatistics(this IReadOnlyCollection<Measurement> runs) Parameters runs IReadOnlyCollection<Measurement> Returns Statistics"
  },
  "api/BenchmarkDotNet.Extensions.StatisticsExtensions.html": {
    "href": "api/BenchmarkDotNet.Extensions.StatisticsExtensions.html",
    "title": "Class StatisticsExtensions | BenchmarkDotNet",
    "summary": "Class StatisticsExtensions Namespace BenchmarkDotNet.Extensions Assembly BenchmarkDotNet.dll public static class StatisticsExtensions Inheritance object StatisticsExtensions Methods CreateNanosecondFormatter(Statistics, CultureInfo, string) public static Func<double, string> CreateNanosecondFormatter(this Statistics s, CultureInfo cultureInfo, string format = \"N3\") Parameters s Statistics cultureInfo CultureInfo format string Returns Func<double, string> ToString(Statistics?, CultureInfo, Func<double, string>, bool) public static string ToString(this Statistics? s, CultureInfo cultureInfo, Func<double, string> formatter, bool calcHistogram = false) Parameters s Statistics cultureInfo CultureInfo formatter Func<double, string> calcHistogram bool Returns string"
  },
  "api/BenchmarkDotNet.Filters.AllCategoriesFilter.html": {
    "href": "api/BenchmarkDotNet.Filters.AllCategoriesFilter.html",
    "title": "Class AllCategoriesFilter | BenchmarkDotNet",
    "summary": "Class AllCategoriesFilter Namespace BenchmarkDotNet.Filters Assembly BenchmarkDotNet.dll Filter benchmarks which have all the target categories public class AllCategoriesFilter : IFilter Inheritance object AllCategoriesFilter Implements IFilter Constructors AllCategoriesFilter(string[]) public AllCategoriesFilter(string[] targetCategories) Parameters targetCategories string[] Methods Predicate(BenchmarkCase) public bool Predicate(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Filters.AnyCategoriesFilter.html": {
    "href": "api/BenchmarkDotNet.Filters.AnyCategoriesFilter.html",
    "title": "Class AnyCategoriesFilter | BenchmarkDotNet",
    "summary": "Class AnyCategoriesFilter Namespace BenchmarkDotNet.Filters Assembly BenchmarkDotNet.dll Filter benchmarks which have any of the target categories public class AnyCategoriesFilter : IFilter Inheritance object AnyCategoriesFilter Implements IFilter Constructors AnyCategoriesFilter(string[]) public AnyCategoriesFilter(string[] targetCategories) Parameters targetCategories string[] Methods Predicate(BenchmarkCase) public bool Predicate(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Filters.AttributesFilter.html": {
    "href": "api/BenchmarkDotNet.Filters.AttributesFilter.html",
    "title": "Class AttributesFilter | BenchmarkDotNet",
    "summary": "Class AttributesFilter Namespace BenchmarkDotNet.Filters Assembly BenchmarkDotNet.dll filters benchmarks by provided attribute names public class AttributesFilter : IFilter Inheritance object AttributesFilter Implements IFilter Constructors AttributesFilter(string[]) public AttributesFilter(string[] attributes) Parameters attributes string[] Methods Predicate(BenchmarkCase) public bool Predicate(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Filters.DisjunctionFilter.html": {
    "href": "api/BenchmarkDotNet.Filters.DisjunctionFilter.html",
    "title": "Class DisjunctionFilter | BenchmarkDotNet",
    "summary": "Class DisjunctionFilter Namespace BenchmarkDotNet.Filters Assembly BenchmarkDotNet.dll public class DisjunctionFilter : IFilter Inheritance object DisjunctionFilter Implements IFilter Constructors DisjunctionFilter(params IFilter[]) public DisjunctionFilter(params IFilter[] filters) Parameters filters IFilter[] Methods Predicate(BenchmarkCase) public bool Predicate(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Filters.GlobFilter.html": {
    "href": "api/BenchmarkDotNet.Filters.GlobFilter.html",
    "title": "Class GlobFilter | BenchmarkDotNet",
    "summary": "Class GlobFilter Namespace BenchmarkDotNet.Filters Assembly BenchmarkDotNet.dll filters benchmarks by provided glob patterns public class GlobFilter : IFilter Inheritance object GlobFilter Implements IFilter Constructors GlobFilter(string[]) public GlobFilter(string[] patterns) Parameters patterns string[] Methods Predicate(BenchmarkCase) public bool Predicate(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Filters.html": {
    "href": "api/BenchmarkDotNet.Filters.html",
    "title": "Namespace BenchmarkDotNet.Filters | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Filters Classes AllCategoriesFilter Filter benchmarks which have all the target categories AnyCategoriesFilter Filter benchmarks which have any of the target categories AttributesFilter filters benchmarks by provided attribute names DisjunctionFilter GlobFilter filters benchmarks by provided glob patterns NameFilter SimpleFilter UnionFilter Interfaces IFilter"
  },
  "api/BenchmarkDotNet.Filters.IFilter.html": {
    "href": "api/BenchmarkDotNet.Filters.IFilter.html",
    "title": "Interface IFilter | BenchmarkDotNet",
    "summary": "Interface IFilter Namespace BenchmarkDotNet.Filters Assembly BenchmarkDotNet.dll public interface IFilter Methods Predicate(BenchmarkCase) bool Predicate(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Filters.NameFilter.html": {
    "href": "api/BenchmarkDotNet.Filters.NameFilter.html",
    "title": "Class NameFilter | BenchmarkDotNet",
    "summary": "Class NameFilter Namespace BenchmarkDotNet.Filters Assembly BenchmarkDotNet.dll public class NameFilter : SimpleFilter, IFilter Inheritance object SimpleFilter NameFilter Implements IFilter Inherited Members SimpleFilter.Predicate(BenchmarkCase) Constructors NameFilter(Func<string, bool>) public NameFilter(Func<string, bool> predicate) Parameters predicate Func<string, bool>"
  },
  "api/BenchmarkDotNet.Filters.SimpleFilter.html": {
    "href": "api/BenchmarkDotNet.Filters.SimpleFilter.html",
    "title": "Class SimpleFilter | BenchmarkDotNet",
    "summary": "Class SimpleFilter Namespace BenchmarkDotNet.Filters Assembly BenchmarkDotNet.dll public class SimpleFilter : IFilter Inheritance object SimpleFilter Implements IFilter Derived NameFilter Constructors SimpleFilter(Func<BenchmarkCase, bool>) public SimpleFilter(Func<BenchmarkCase, bool> predicate) Parameters predicate Func<BenchmarkCase, bool> Methods Predicate(BenchmarkCase) public bool Predicate(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Filters.UnionFilter.html": {
    "href": "api/BenchmarkDotNet.Filters.UnionFilter.html",
    "title": "Class UnionFilter | BenchmarkDotNet",
    "summary": "Class UnionFilter Namespace BenchmarkDotNet.Filters Assembly BenchmarkDotNet.dll public class UnionFilter : IFilter Inheritance object UnionFilter Implements IFilter Constructors UnionFilter(params IFilter[]) public UnionFilter(params IFilter[] filters) Parameters filters IFilter[] Methods Predicate(BenchmarkCase) public bool Predicate(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Helpers.AwaitHelper.html": {
    "href": "api/BenchmarkDotNet.Helpers.AwaitHelper.html",
    "title": "Class AwaitHelper | BenchmarkDotNet",
    "summary": "Class AwaitHelper Namespace BenchmarkDotNet.Helpers Assembly BenchmarkDotNet.dll public static class AwaitHelper Inheritance object AwaitHelper Methods GetResult(Task) public static void GetResult(Task task) Parameters task Task GetResult(ValueTask) public static void GetResult(ValueTask task) Parameters task ValueTask GetResult<T>(Task<T>) public static T GetResult<T>(Task<T> task) Parameters task Task<T> Returns T Type Parameters T GetResult<T>(ValueTask<T>) public static T GetResult<T>(ValueTask<T> task) Parameters task ValueTask<T> Returns T Type Parameters T"
  },
  "api/BenchmarkDotNet.Helpers.DisposeAtProcessTermination.html": {
    "href": "api/BenchmarkDotNet.Helpers.DisposeAtProcessTermination.html",
    "title": "Class DisposeAtProcessTermination | BenchmarkDotNet",
    "summary": "Class DisposeAtProcessTermination Namespace BenchmarkDotNet.Helpers Assembly BenchmarkDotNet.dll Ensures that explicit Dispose is called at termination of the Process. public abstract class DisposeAtProcessTermination : IDisposable Inheritance object DisposeAtProcessTermination Implements IDisposable Remarks This class exists to help in reverting system state where C#'s using statement does not suffice. I.e. when Benchmark's process is aborted via Ctrl-C, Ctrl-Break or via click on the X in the upper right of Window. Usage: Derive your clas that changes system state of this class. Revert system state in override of Dispose() implementation. Use your class in C#'s using statement, to ensure system state is reverted in normal situations. This class ensures your override is also called at process 'abort'. Note: This class is explicitly not responsible for cleanup of Native resources. Of course, derived classes can cleanup their Native resources (usually managed via SafeHandle derived classes), by delegating explicit Disposal to their IDisposable fields. Constructors DisposeAtProcessTermination() protected DisposeAtProcessTermination() Methods Dispose() public virtual void Dispose()"
  },
  "api/BenchmarkDotNet.Helpers.ExternalToolsHelper.html": {
    "href": "api/BenchmarkDotNet.Helpers.ExternalToolsHelper.html",
    "title": "Class ExternalToolsHelper | BenchmarkDotNet",
    "summary": "Class ExternalToolsHelper Namespace BenchmarkDotNet.Helpers Assembly BenchmarkDotNet.dll public static class ExternalToolsHelper Inheritance object ExternalToolsHelper Fields MacSystemProfilerData Output of the system_profiler SPSoftwareDataType command. MacOSX only. public static readonly Lazy<Dictionary<string, string>> MacSystemProfilerData Field Value Lazy<Dictionary<string, string>>"
  },
  "api/BenchmarkDotNet.Helpers.FolderNameHelper.html": {
    "href": "api/BenchmarkDotNet.Helpers.FolderNameHelper.html",
    "title": "Class FolderNameHelper | BenchmarkDotNet",
    "summary": "Class FolderNameHelper Namespace BenchmarkDotNet.Helpers Assembly BenchmarkDotNet.dll public static class FolderNameHelper Inheritance object FolderNameHelper Methods ToFolderName(object) public static string ToFolderName(object value) Parameters value object Returns string ToFolderName(Type, bool, bool) public static string ToFolderName(Type type, bool includeNamespace = true, bool includeGenericArgumentsNamespace = false) Parameters type Type includeNamespace bool includeGenericArgumentsNamespace bool Returns string"
  },
  "api/BenchmarkDotNet.Helpers.html": {
    "href": "api/BenchmarkDotNet.Helpers.html",
    "title": "Namespace BenchmarkDotNet.Helpers | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Helpers Classes AwaitHelper DisposeAtProcessTermination Ensures that explicit Dispose is called at termination of the Process. ExternalToolsHelper FolderNameHelper SourceCodeHelper UnitHelper"
  },
  "api/BenchmarkDotNet.Helpers.SourceCodeHelper.html": {
    "href": "api/BenchmarkDotNet.Helpers.SourceCodeHelper.html",
    "title": "Class SourceCodeHelper | BenchmarkDotNet",
    "summary": "Class SourceCodeHelper Namespace BenchmarkDotNet.Helpers Assembly BenchmarkDotNet.dll public static class SourceCodeHelper Inheritance object SourceCodeHelper Methods IsCompilationTimeConstant(object) public static bool IsCompilationTimeConstant(object value) Parameters value object Returns bool IsCompilationTimeConstant(Type) public static bool IsCompilationTimeConstant(Type type) Parameters type Type Returns bool ToSourceCode(object) public static string ToSourceCode(object value) Parameters value object Returns string"
  },
  "api/BenchmarkDotNet.Helpers.UnitHelper.html": {
    "href": "api/BenchmarkDotNet.Helpers.UnitHelper.html",
    "title": "Class UnitHelper | BenchmarkDotNet",
    "summary": "Class UnitHelper Namespace BenchmarkDotNet.Helpers Assembly BenchmarkDotNet.dll public static class UnitHelper Inheritance object UnitHelper Fields DefaultPresentation public static readonly UnitPresentation DefaultPresentation Field Value UnitPresentation Methods ToDefaultString(TimeInterval, string?) public static string ToDefaultString(this TimeInterval timeInterval, string? format = null) Parameters timeInterval TimeInterval format string Returns string"
  },
  "api/BenchmarkDotNet.Jobs.AccuracyMode.html": {
    "href": "api/BenchmarkDotNet.Jobs.AccuracyMode.html",
    "title": "Class AccuracyMode | BenchmarkDotNet",
    "summary": "Class AccuracyMode Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public sealed class AccuracyMode : JobMode<AccuracyMode> Inheritance object CharacteristicObject CharacteristicObject<AccuracyMode> JobMode<AccuracyMode> AccuracyMode Inherited Members JobMode<AccuracyMode>.Default JobMode<AccuracyMode>.Job CharacteristicObject<AccuracyMode>.Apply(CharacteristicObject) CharacteristicObject<AccuracyMode>.Apply(params CharacteristicObject[]) CharacteristicObject<AccuracyMode>.ApplyAndFreeze(CharacteristicObject) CharacteristicObject<AccuracyMode>.ApplyAndFreeze(params CharacteristicObject[]) CharacteristicObject<AccuracyMode>.Freeze() CharacteristicObject<AccuracyMode>.UnfreezeCopy() CharacteristicObject.IdCharacteristic CharacteristicObject.GetCharacteristicsWithValues() CharacteristicObject.HasValue(Characteristic) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver, T) CharacteristicObject.ResolveValue(Characteristic, IResolver) CharacteristicObject.ResolveValue(Characteristic, IResolver, object) CharacteristicObject.ResolveValue<T>(Characteristic<T>, T) CharacteristicObject.ResolveValue(Characteristic, object) CharacteristicObject.ResolveValueAsNullable<T>(Characteristic<T>) CharacteristicObject.ToString() CharacteristicObject.Frozen CharacteristicObject.HasChanges CharacteristicObject.Id Extension Methods CharacteristicHelper.GetAllCharacteristics(CharacteristicObject) CharacteristicHelper.GetThisTypeCharacteristics(CharacteristicObject) Constructors AccuracyMode() public AccuracyMode() Fields AnalyzeLaunchVarianceCharacteristic public static readonly Characteristic<bool> AnalyzeLaunchVarianceCharacteristic Field Value Characteristic<bool> EvaluateOverheadCharacteristic public static readonly Characteristic<bool> EvaluateOverheadCharacteristic Field Value Characteristic<bool> MaxAbsoluteErrorCharacteristic public static readonly Characteristic<TimeInterval> MaxAbsoluteErrorCharacteristic Field Value Characteristic<TimeInterval> MaxRelativeErrorCharacteristic public static readonly Characteristic<double> MaxRelativeErrorCharacteristic Field Value Characteristic<double> MinInvokeCountCharacteristic public static readonly Characteristic<int> MinInvokeCountCharacteristic Field Value Characteristic<int> MinIterationTimeCharacteristic public static readonly Characteristic<TimeInterval> MinIterationTimeCharacteristic Field Value Characteristic<TimeInterval> OutlierModeCharacteristic public static readonly Characteristic<OutlierMode> OutlierModeCharacteristic Field Value Characteristic<OutlierMode> Properties AnalyzeLaunchVariance public bool AnalyzeLaunchVariance { get; set; } Property Value bool EvaluateOverhead Specifies if the overhead should be evaluated (Idle runs) and it's average value subtracted from every result. True by default, very important for nano-benchmarks. public bool EvaluateOverhead { get; set; } Property Value bool MaxAbsoluteError Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error). Doesn't have a default value. If MaxRelativeError is also provided, the smallest value is used as stop criteria. public TimeInterval MaxAbsoluteError { get; set; } Property Value TimeInterval MaxRelativeError Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error). The default value is 0.02. If MaxAbsoluteError is also provided, the smallest value is used as stop criteria. public double MaxRelativeError { get; set; } Property Value double MinInvokeCount Minimum count of benchmark invocations per iteration. The default value is 4. public int MinInvokeCount { get; set; } Property Value int MinIterationTime Minimum time of a single iteration. Unlike Run.IterationTime, this characteristic specifies only the lower limit. In case of need, BenchmarkDotNet can increase this value. The default value is 500 milliseconds. public TimeInterval MinIterationTime { get; set; } Property Value TimeInterval OutlierMode Specifies which outliers should be removed from the distribution. public OutlierMode OutlierMode { get; set; } Property Value OutlierMode"
  },
  "api/BenchmarkDotNet.Jobs.Argument.html": {
    "href": "api/BenchmarkDotNet.Jobs.Argument.html",
    "title": "Class Argument | BenchmarkDotNet",
    "summary": "Class Argument Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public abstract class Argument : IEquatable<Argument> Inheritance object Argument Implements IEquatable<Argument> Derived MonoArgument MsBuildArgument Constructors Argument(string) protected Argument(string value) Parameters value string Properties TextRepresentation public string TextRepresentation { get; } Property Value string Methods Equals(Argument) public bool Equals(Argument other) Parameters other Argument Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Jobs.EnvironmentMode.html": {
    "href": "api/BenchmarkDotNet.Jobs.EnvironmentMode.html",
    "title": "Class EnvironmentMode | BenchmarkDotNet",
    "summary": "Class EnvironmentMode Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public sealed class EnvironmentMode : JobMode<EnvironmentMode> Inheritance object CharacteristicObject CharacteristicObject<EnvironmentMode> JobMode<EnvironmentMode> EnvironmentMode Inherited Members JobMode<EnvironmentMode>.Default JobMode<EnvironmentMode>.Job CharacteristicObject<EnvironmentMode>.Apply(CharacteristicObject) CharacteristicObject<EnvironmentMode>.Apply(params CharacteristicObject[]) CharacteristicObject<EnvironmentMode>.ApplyAndFreeze(CharacteristicObject) CharacteristicObject<EnvironmentMode>.ApplyAndFreeze(params CharacteristicObject[]) CharacteristicObject<EnvironmentMode>.Freeze() CharacteristicObject<EnvironmentMode>.UnfreezeCopy() CharacteristicObject.IdCharacteristic CharacteristicObject.GetCharacteristicsWithValues() CharacteristicObject.HasValue(Characteristic) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver, T) CharacteristicObject.ResolveValue(Characteristic, IResolver) CharacteristicObject.ResolveValue(Characteristic, IResolver, object) CharacteristicObject.ResolveValue<T>(Characteristic<T>, T) CharacteristicObject.ResolveValue(Characteristic, object) CharacteristicObject.ResolveValueAsNullable<T>(Characteristic<T>) CharacteristicObject.ToString() CharacteristicObject.Frozen CharacteristicObject.HasChanges CharacteristicObject.Id Extension Methods CharacteristicHelper.GetAllCharacteristics(CharacteristicObject) CharacteristicHelper.GetThisTypeCharacteristics(CharacteristicObject) Constructors EnvironmentMode() public EnvironmentMode() EnvironmentMode(Runtime) public EnvironmentMode(Runtime runtime) Parameters runtime Runtime EnvironmentMode(string) public EnvironmentMode(string id) Parameters id string EnvironmentMode(string, Jit, Platform) public EnvironmentMode(string id, Jit jit, Platform platform) Parameters id string jit Jit platform Platform Fields AffinityCharacteristic public static readonly Characteristic<nint> AffinityCharacteristic Field Value Characteristic<nint> EnvironmentVariablesCharacteristic public static readonly Characteristic<IReadOnlyList<EnvironmentVariable>> EnvironmentVariablesCharacteristic Field Value Characteristic<IReadOnlyList<EnvironmentVariable>> GcCharacteristic public static readonly Characteristic<GcMode> GcCharacteristic Field Value Characteristic<GcMode> JitCharacteristic public static readonly Characteristic<Jit> JitCharacteristic Field Value Characteristic<Jit> LargeAddressAwareCharacteristic public static readonly Characteristic<bool> LargeAddressAwareCharacteristic Field Value Characteristic<bool> LegacyJitX64 public static readonly EnvironmentMode LegacyJitX64 Field Value EnvironmentMode LegacyJitX86 public static readonly EnvironmentMode LegacyJitX86 Field Value EnvironmentMode PlatformCharacteristic public static readonly Characteristic<Platform> PlatformCharacteristic Field Value Characteristic<Platform> PowerPlanModeCharacteristic public static readonly Characteristic<Guid?> PowerPlanModeCharacteristic Field Value Characteristic<Guid?> RuntimeCharacteristic public static readonly Characteristic<Runtime> RuntimeCharacteristic Field Value Characteristic<Runtime> RyuJitX64 public static readonly EnvironmentMode RyuJitX64 Field Value EnvironmentMode RyuJitX86 public static readonly EnvironmentMode RyuJitX86 Field Value EnvironmentMode Properties Affinity ProcessorAffinity for the benchmark process. See also: https://msdn.microsoft.com/library/system.diagnostics.process.processoraffinity.aspx public nint Affinity { get; set; } Property Value nint EnvironmentVariables public IReadOnlyList<EnvironmentVariable> EnvironmentVariables { get; set; } Property Value IReadOnlyList<EnvironmentVariable> Gc GcMode public GcMode Gc { get; } Property Value GcMode Jit JIT (Just-In-Time compiler) public Jit Jit { get; set; } Property Value Jit LargeAddressAware Specifies that benchmark can handle addresses larger than 2 gigabytes. false: Benchmark uses the default (64-bit: enabled; 32-bit:disabled). This is the default. true: Explicitly specify that benchmark can handle addresses larger than 2 gigabytes. public bool LargeAddressAware { get; set; } Property Value bool Platform Platform (x86 or x64) public Platform Platform { get; set; } Property Value Platform PowerPlanMode Power Plan Mode public Guid? PowerPlanMode { get; set; } Property Value Guid? Remarks Supported only on Windows. Runtime Runtime public Runtime? Runtime { get; set; } Property Value Runtime Methods SetEnvironmentVariable(EnvironmentVariable) Adds the specified variable to EnvironmentVariables. If EnvironmentVariables already contains a variable with the same key, it will be overriden. public void SetEnvironmentVariable(EnvironmentVariable variable) Parameters variable EnvironmentVariable The new environment variable which should be added to EnvironmentVariables"
  },
  "api/BenchmarkDotNet.Jobs.EnvironmentVariable.html": {
    "href": "api/BenchmarkDotNet.Jobs.EnvironmentVariable.html",
    "title": "Class EnvironmentVariable | BenchmarkDotNet",
    "summary": "Class EnvironmentVariable Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public class EnvironmentVariable : IEquatable<EnvironmentVariable> Inheritance object EnvironmentVariable Implements IEquatable<EnvironmentVariable> Constructors EnvironmentVariable(string, string) public EnvironmentVariable(string key, string value) Parameters key string value string Properties Key public string Key { get; } Property Value string Value public string Value { get; } Property Value string Methods Equals(EnvironmentVariable) public bool Equals(EnvironmentVariable other) Parameters other EnvironmentVariable Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Jobs.GcMode.html": {
    "href": "api/BenchmarkDotNet.Jobs.GcMode.html",
    "title": "Class GcMode | BenchmarkDotNet",
    "summary": "Class GcMode Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public sealed class GcMode : JobMode<GcMode>, IEquatable<GcMode> Inheritance object CharacteristicObject CharacteristicObject<GcMode> JobMode<GcMode> GcMode Implements IEquatable<GcMode> Inherited Members JobMode<GcMode>.Default JobMode<GcMode>.Job CharacteristicObject<GcMode>.Apply(CharacteristicObject) CharacteristicObject<GcMode>.Apply(params CharacteristicObject[]) CharacteristicObject<GcMode>.ApplyAndFreeze(CharacteristicObject) CharacteristicObject<GcMode>.ApplyAndFreeze(params CharacteristicObject[]) CharacteristicObject<GcMode>.Freeze() CharacteristicObject<GcMode>.UnfreezeCopy() CharacteristicObject.IdCharacteristic CharacteristicObject.GetCharacteristicsWithValues() CharacteristicObject.HasValue(Characteristic) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver, T) CharacteristicObject.ResolveValue(Characteristic, IResolver) CharacteristicObject.ResolveValue(Characteristic, IResolver, object) CharacteristicObject.ResolveValue<T>(Characteristic<T>, T) CharacteristicObject.ResolveValue(Characteristic, object) CharacteristicObject.ResolveValueAsNullable<T>(Characteristic<T>) CharacteristicObject.ToString() CharacteristicObject.Frozen CharacteristicObject.HasChanges CharacteristicObject.Id Extension Methods CharacteristicHelper.GetAllCharacteristics(CharacteristicObject) CharacteristicHelper.GetThisTypeCharacteristics(CharacteristicObject) GcModeExtensions.WithAllowVeryLargeObjects(GcMode, bool) GcModeExtensions.WithConcurrent(GcMode, bool) GcModeExtensions.WithCpuGroups(GcMode, bool) GcModeExtensions.WithForce(GcMode, bool) GcModeExtensions.WithHeapAffinitizeMask(GcMode, int) GcModeExtensions.WithHeapCount(GcMode, int) GcModeExtensions.WithNoAffinitize(GcMode, bool) GcModeExtensions.WithRetainVm(GcMode, bool) GcModeExtensions.WithServer(GcMode, bool) Constructors GcMode() public GcMode() Fields AllowVeryLargeObjectsCharacteristic public static readonly Characteristic<bool> AllowVeryLargeObjectsCharacteristic Field Value Characteristic<bool> ConcurrentCharacteristic public static readonly Characteristic<bool> ConcurrentCharacteristic Field Value Characteristic<bool> CpuGroupsCharacteristic public static readonly Characteristic<bool> CpuGroupsCharacteristic Field Value Characteristic<bool> ForceCharacteristic public static readonly Characteristic<bool> ForceCharacteristic Field Value Characteristic<bool> HeapAffinitizeMaskCharacteristic public static readonly Characteristic<int> HeapAffinitizeMaskCharacteristic Field Value Characteristic<int> HeapCountCharacteristic public static readonly Characteristic<int> HeapCountCharacteristic Field Value Characteristic<int> NoAffinitizeCharacteristic public static readonly Characteristic<bool> NoAffinitizeCharacteristic Field Value Characteristic<bool> RetainVmCharacteristic public static readonly Characteristic<bool> RetainVmCharacteristic Field Value Characteristic<bool> ServerCharacteristic public static readonly Characteristic<bool> ServerCharacteristic Field Value Characteristic<bool> Properties AllowVeryLargeObjects On 64-bit platforms, enables arrays that are greater than 2 gigabytes (GB) in total size. false: Arrays greater than 2 GB in total size are not enabled. This is the default. true: Arrays greater than 2 GB in total size are enabled on 64-bit platforms. public bool AllowVeryLargeObjects { get; set; } Property Value bool Concurrent Specifies whether the common language runtime runs garbage collection on a separate thread. false: Does not run garbage collection concurrently. true: Runs garbage collection concurrently. This is the default. public bool Concurrent { get; set; } Property Value bool CpuGroups Specifies whether garbage collection supports multiple CPU groups. false: Garbage collection does not support multiple CPU groups. This is the default. true: Garbage collection supports multiple CPU groups, if server garbage collection is enabled. public bool CpuGroups { get; set; } Property Value bool Force Specifies whether the BenchmarkDotNet's benchmark runner forces full garbage collection after each benchmark invocation false: Does not force garbage collection. true: Forces full garbage collection after each benchmark invocation. This is the default. public bool Force { get; set; } Property Value bool HeapAffinitizeMask process mask, see MSDN for more. public int HeapAffinitizeMask { get; set; } Property Value int HeapCount specify the # of Server GC threads/heaps, must be smaller than the # of logical CPUs the process is allowed to run on, ie, if you don't specifically affinitize your process it means the # of total logical CPUs on the machine; otherwise this is the # of logical CPUs you affinitized your process to. public int HeapCount { get; set; } Property Value int NoAffinitize specify true to disable hard affinity of Server GC threads to CPUs public bool NoAffinitize { get; set; } Property Value bool RetainVm Put segments that should be deleted on a standby list for future use instead of releasing them back to the OS The default is false public bool RetainVm { get; set; } Property Value bool Server Specifies whether the common language runtime runs server garbage collection. false: Does not run server garbage collection. This is the default. true: Runs server garbage collection. public bool Server { get; set; } Property Value bool Methods Equals(GcMode) public bool Equals(GcMode other) Parameters other GcMode Returns bool GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/BenchmarkDotNet.Jobs.GcModeExtensions.html": {
    "href": "api/BenchmarkDotNet.Jobs.GcModeExtensions.html",
    "title": "Class GcModeExtensions | BenchmarkDotNet",
    "summary": "Class GcModeExtensions Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public static class GcModeExtensions Inheritance object GcModeExtensions Methods WithAllowVeryLargeObjects(GcMode, bool) On 64-bit platforms, enables arrays that are greater than 2 gigabytes (GB) in total size. false: Arrays greater than 2 GB in total size are not enabled. This is the default. true: Arrays greater than 2 GB in total size are enabled on 64-bit platforms. public static GcMode WithAllowVeryLargeObjects(this GcMode mode, bool value) Parameters mode GcMode value bool Returns GcMode WithConcurrent(GcMode, bool) Specifies whether the common language runtime runs garbage collection on a separate thread. false: Does not run garbage collection concurrently. true: Runs garbage collection concurrently. This is the default. public static GcMode WithConcurrent(this GcMode mode, bool value) Parameters mode GcMode value bool Returns GcMode WithCpuGroups(GcMode, bool) Specifies whether garbage collection supports multiple CPU groups. false: Garbage collection does not support multiple CPU groups. This is the default. true: Garbage collection supports multiple CPU groups, if server garbage collection is enabled. public static GcMode WithCpuGroups(this GcMode mode, bool value) Parameters mode GcMode value bool Returns GcMode WithForce(GcMode, bool) Specifies whether the BenchmarkDotNet's benchmark runner forces full garbage collection after each benchmark invocation false: Does not force garbage collection. true: Forces full garbage collection after each benchmark invocation. This is the default. public static GcMode WithForce(this GcMode mode, bool value) Parameters mode GcMode value bool Returns GcMode WithHeapAffinitizeMask(GcMode, int) process mask, see MSDN for more. public static GcMode WithHeapAffinitizeMask(this GcMode mode, int heapAffinitizeMask) Parameters mode GcMode heapAffinitizeMask int Returns GcMode WithHeapCount(GcMode, int) specify the # of Server GC threads/heaps, must be smaller than the # of logical CPUs the process is allowed to run on, ie, if you don't specifically affinitize your process it means the # of total logical CPUs on the machine; otherwise this is the # of logical CPUs you affinitized your process to. public static GcMode WithHeapCount(this GcMode mode, int heapCount) Parameters mode GcMode heapCount int Returns GcMode WithNoAffinitize(GcMode, bool) specify true to disable hard affinity of Server GC threads to CPUs public static GcMode WithNoAffinitize(this GcMode mode, bool value) Parameters mode GcMode value bool Returns GcMode WithRetainVm(GcMode, bool) Put segments that should be deleted on a standby list for future use instead of releasing them back to the OS The default is false public static GcMode WithRetainVm(this GcMode mode, bool value) Parameters mode GcMode value bool Returns GcMode WithServer(GcMode, bool) Specifies whether the common language runtime runs server garbage collection. false: Does not run server garbage collection. This is the default. true: Runs server garbage collection. public static GcMode WithServer(this GcMode mode, bool value) Parameters mode GcMode value bool Returns GcMode"
  },
  "api/BenchmarkDotNet.Jobs.html": {
    "href": "api/BenchmarkDotNet.Jobs.html",
    "title": "Namespace BenchmarkDotNet.Jobs | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Jobs Classes AccuracyMode Argument EnvironmentMode EnvironmentVariable GcMode GcModeExtensions InfrastructureMode Job JobExtensions JobIdGenerator JobMode<T> MetaMode MonoArgument Argument passed directly to mono when executing benchmarks (mono [options]) example: new MonoArgument(\"--gc=sgen\") MsBuildArgument Argument passed to dotnet cli when restoring and building the project example: new MsBuildArgument(\"/p:MyCustomSetting=123\") RunMode Enums RuntimeMoniker"
  },
  "api/BenchmarkDotNet.Jobs.InfrastructureMode.html": {
    "href": "api/BenchmarkDotNet.Jobs.InfrastructureMode.html",
    "title": "Class InfrastructureMode | BenchmarkDotNet",
    "summary": "Class InfrastructureMode Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public sealed class InfrastructureMode : JobMode<InfrastructureMode> Inheritance object CharacteristicObject CharacteristicObject<InfrastructureMode> JobMode<InfrastructureMode> InfrastructureMode Inherited Members JobMode<InfrastructureMode>.Default JobMode<InfrastructureMode>.Job CharacteristicObject<InfrastructureMode>.Apply(CharacteristicObject) CharacteristicObject<InfrastructureMode>.Apply(params CharacteristicObject[]) CharacteristicObject<InfrastructureMode>.ApplyAndFreeze(CharacteristicObject) CharacteristicObject<InfrastructureMode>.ApplyAndFreeze(params CharacteristicObject[]) CharacteristicObject<InfrastructureMode>.Freeze() CharacteristicObject<InfrastructureMode>.UnfreezeCopy() CharacteristicObject.IdCharacteristic CharacteristicObject.GetCharacteristicsWithValues() CharacteristicObject.HasValue(Characteristic) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver, T) CharacteristicObject.ResolveValue(Characteristic, IResolver) CharacteristicObject.ResolveValue(Characteristic, IResolver, object) CharacteristicObject.ResolveValue<T>(Characteristic<T>, T) CharacteristicObject.ResolveValue(Characteristic, object) CharacteristicObject.ResolveValueAsNullable<T>(Characteristic<T>) CharacteristicObject.ToString() CharacteristicObject.Frozen CharacteristicObject.HasChanges CharacteristicObject.Id Extension Methods CharacteristicHelper.GetAllCharacteristics(CharacteristicObject) CharacteristicHelper.GetThisTypeCharacteristics(CharacteristicObject) Constructors InfrastructureMode() public InfrastructureMode() Fields ArgumentsCharacteristic public static readonly Characteristic<IReadOnlyList<Argument>> ArgumentsCharacteristic Field Value Characteristic<IReadOnlyList<Argument>> BuildConfigurationCharacteristic public static readonly Characteristic<string> BuildConfigurationCharacteristic Field Value Characteristic<string> ClockCharacteristic public static readonly Characteristic<IClock> ClockCharacteristic Field Value Characteristic<IClock> EngineFactoryCharacteristic public static readonly Characteristic<IEngineFactory> EngineFactoryCharacteristic Field Value Characteristic<IEngineFactory> InProcess public static readonly InfrastructureMode InProcess Field Value InfrastructureMode InProcessDontLogOutput public static readonly InfrastructureMode InProcessDontLogOutput Field Value InfrastructureMode ReleaseConfigurationName public const string ReleaseConfigurationName = \"Release\" Field Value string ToolchainCharacteristic public static readonly Characteristic<IToolchain> ToolchainCharacteristic Field Value Characteristic<IToolchain> Properties Arguments public IReadOnlyList<Argument> Arguments { get; set; } Property Value IReadOnlyList<Argument> BuildConfiguration public string BuildConfiguration { get; set; } Property Value string Clock public IClock Clock { get; set; } Property Value IClock EngineFactory this type will be used in the auto-generated program to create engine in separate process it must have parameterless constructor public IEngineFactory EngineFactory { get; set; } Property Value IEngineFactory Toolchain public IToolchain Toolchain { get; set; } Property Value IToolchain Methods TryGetToolchain(out IToolchain) public bool TryGetToolchain(out IToolchain toolchain) Parameters toolchain IToolchain Returns bool"
  },
  "api/BenchmarkDotNet.Jobs.Job.html": {
    "href": "api/BenchmarkDotNet.Jobs.Job.html",
    "title": "Class Job | BenchmarkDotNet",
    "summary": "Class Job Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public sealed class Job : JobMode<Job> Inheritance object CharacteristicObject CharacteristicObject<Job> JobMode<Job> Job Inherited Members JobMode<Job>.Default JobMode<Job>.Job CharacteristicObject<Job>.Apply(CharacteristicObject) CharacteristicObject<Job>.Apply(params CharacteristicObject[]) CharacteristicObject<Job>.ApplyAndFreeze(CharacteristicObject) CharacteristicObject<Job>.ApplyAndFreeze(params CharacteristicObject[]) CharacteristicObject<Job>.Freeze() CharacteristicObject<Job>.UnfreezeCopy() CharacteristicObject.IdCharacteristic CharacteristicObject.GetCharacteristicsWithValues() CharacteristicObject.HasValue(Characteristic) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver, T) CharacteristicObject.ResolveValue(Characteristic, IResolver) CharacteristicObject.ResolveValue(Characteristic, IResolver, object) CharacteristicObject.ResolveValue<T>(Characteristic<T>, T) CharacteristicObject.ResolveValue(Characteristic, object) CharacteristicObject.ResolveValueAsNullable<T>(Characteristic<T>) CharacteristicObject.ToString() CharacteristicObject.Frozen CharacteristicObject.HasChanges CharacteristicObject.Id Extension Methods CharacteristicHelper.GetAllCharacteristics(CharacteristicObject) CharacteristicHelper.GetThisTypeCharacteristics(CharacteristicObject) JobExtensions.AsBaseline(Job) JobExtensions.AsDefault(Job, bool) JobExtensions.AsMutator(Job) JobExtensions.DontEnforcePowerPlan(Job) JobExtensions.RunOncePerIteration(Job) JobExtensions.WithAffinity(Job, nint) JobExtensions.WithAnalyzeLaunchVariance(Job, bool) JobExtensions.WithArguments(Job, IReadOnlyList<Argument>) JobExtensions.WithBaseline(Job, bool) JobExtensions.WithClock(Job, IClock) JobExtensions.WithCustomBuildConfiguration(Job, string) JobExtensions.WithEngineFactory(Job, IEngineFactory) JobExtensions.WithEnvironmentVariable(Job, EnvironmentVariable) JobExtensions.WithEnvironmentVariable(Job, string, string) JobExtensions.WithEnvironmentVariables(Job, params EnvironmentVariable[]) JobExtensions.WithEvaluateOverhead(Job, bool) JobExtensions.WithGcAllowVeryLargeObjects(Job, bool) JobExtensions.WithGcConcurrent(Job, bool) JobExtensions.WithGcCpuGroups(Job, bool) JobExtensions.WithGcForce(Job, bool) JobExtensions.WithGcMode(Job, GcMode) JobExtensions.WithGcRetainVm(Job, bool) JobExtensions.WithGcServer(Job, bool) JobExtensions.WithHeapAffinitizeMask(Job, int) JobExtensions.WithHeapCount(Job, int) JobExtensions.WithId(Job, string) JobExtensions.WithInvocationCount(Job, long) JobExtensions.WithIterationCount(Job, int) JobExtensions.WithIterationTime(Job, TimeInterval) JobExtensions.WithJit(Job, Jit) JobExtensions.WithLargeAddressAware(Job, bool) JobExtensions.WithLaunchCount(Job, int) JobExtensions.WithMaxAbsoluteError(Job, TimeInterval) JobExtensions.WithMaxIterationCount(Job, int) JobExtensions.WithMaxRelativeError(Job, double) JobExtensions.WithMaxWarmupCount(Job, int) JobExtensions.WithMemoryRandomization(Job, bool) JobExtensions.WithMinInvokeCount(Job, int) JobExtensions.WithMinIterationCount(Job, int) JobExtensions.WithMinIterationTime(Job, TimeInterval) JobExtensions.WithMinWarmupCount(Job, int) JobExtensions.WithMsBuildArguments(Job, params string[]) JobExtensions.WithNoAffinitize(Job, bool) JobExtensions.WithoutEnvironmentVariables(Job) JobExtensions.WithOutlierMode(Job, OutlierMode) JobExtensions.WithPlatform(Job, Platform) JobExtensions.WithPowerPlan(Job, PowerPlan) JobExtensions.WithPowerPlan(Job, Guid) JobExtensions.WithRuntime(Job, Runtime) JobExtensions.WithStrategy(Job, RunStrategy) JobExtensions.WithToolchain(Job, IToolchain) JobExtensions.WithUnrollFactor(Job, int) JobExtensions.WithWarmupCount(Job, int) Constructors Job() public Job() Job(CharacteristicObject) public Job(CharacteristicObject other) Parameters other CharacteristicObject Job(params CharacteristicObject[]) public Job(params CharacteristicObject[] others) Parameters others CharacteristicObject[] Job(string?) public Job(string? id) Parameters id string Job(string?, CharacteristicObject) public Job(string? id, CharacteristicObject other) Parameters id string other CharacteristicObject Job(string?, params CharacteristicObject[]) public Job(string? id, params CharacteristicObject[] others) Parameters id string others CharacteristicObject[] Fields AccuracyCharacteristic public static readonly Characteristic<AccuracyMode> AccuracyCharacteristic Field Value Characteristic<AccuracyMode> Dry public static readonly Job Dry Field Value Job EnvironmentCharacteristic public static readonly Characteristic<EnvironmentMode> EnvironmentCharacteristic Field Value Characteristic<EnvironmentMode> InProcess public static readonly Job InProcess Field Value Job InProcessDontLogOutput public static readonly Job InProcessDontLogOutput Field Value Job InfrastructureCharacteristic public static readonly Characteristic<InfrastructureMode> InfrastructureCharacteristic Field Value Characteristic<InfrastructureMode> LegacyJitX64 public static readonly Job LegacyJitX64 Field Value Job LegacyJitX86 public static readonly Job LegacyJitX86 Field Value Job LongRun public static readonly Job LongRun Field Value Job MediumRun public static readonly Job MediumRun Field Value Job MetaCharacteristic public static readonly Characteristic<MetaMode> MetaCharacteristic Field Value Characteristic<MetaMode> RunCharacteristic public static readonly Characteristic<RunMode> RunCharacteristic Field Value Characteristic<RunMode> RyuJitX64 public static readonly Job RyuJitX64 Field Value Job RyuJitX86 public static readonly Job RyuJitX86 Field Value Job ShortRun public static readonly Job ShortRun Field Value Job VeryLongRun public static readonly Job VeryLongRun Field Value Job Properties Accuracy public AccuracyMode Accuracy { get; } Property Value AccuracyMode DisplayInfo public string DisplayInfo { get; } Property Value string Environment public EnvironmentMode Environment { get; } Property Value EnvironmentMode FolderInfo public string FolderInfo { get; } Property Value string Infrastructure public InfrastructureMode Infrastructure { get; } Property Value InfrastructureMode Meta public MetaMode Meta { get; } Property Value MetaMode ResolvedId public string ResolvedId { get; } Property Value string Run public RunMode Run { get; } Property Value RunMode"
  },
  "api/BenchmarkDotNet.Jobs.JobExtensions.html": {
    "href": "api/BenchmarkDotNet.Jobs.JobExtensions.html",
    "title": "Class JobExtensions | BenchmarkDotNet",
    "summary": "Class JobExtensions Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public static class JobExtensions Inheritance object JobExtensions Methods AsBaseline(Job) public static Job AsBaseline(this Job job) Parameters job Job Returns Job AsDefault(Job, bool) use it if you want to specify custom default settings for default job used by console arguments parser public static Job AsDefault(this Job job, bool value = true) Parameters job Job value bool Returns Job AsMutator(Job) mutator job should not be added to the config, but instead applied to other jobs in given config public static Job AsMutator(this Job job) Parameters job Job Returns Job DontEnforcePowerPlan(Job) ensures that BenchmarkDotNet does not enforce any power plan public static Job DontEnforcePowerPlan(this Job job) Parameters job Job Returns Job RunOncePerIteration(Job) Run the benchmark exactly once per iteration. public static Job RunOncePerIteration(this Job job) Parameters job Job Returns Job WithAffinity(Job, nint) ProcessorAffinity for the benchmark process. See also: https://msdn.microsoft.com/library/system.diagnostics.process.processoraffinity.aspx public static Job WithAffinity(this Job job, nint affinity) Parameters job Job affinity nint Returns Job WithAnalyzeLaunchVariance(Job, bool) public static Job WithAnalyzeLaunchVariance(this Job job, bool value) Parameters job Job value bool Returns Job WithArguments(Job, IReadOnlyList<Argument>) public static Job WithArguments(this Job job, IReadOnlyList<Argument> arguments) Parameters job Job arguments IReadOnlyList<Argument> Returns Job WithBaseline(Job, bool) public static Job WithBaseline(this Job job, bool value) Parameters job Job value bool Returns Job WithClock(Job, IClock) public static Job WithClock(this Job job, IClock clock) Parameters job Job clock IClock Returns Job WithCustomBuildConfiguration(Job, string) public static Job WithCustomBuildConfiguration(this Job job, string buildConfiguration) Parameters job Job buildConfiguration string Returns Job WithEngineFactory(Job, IEngineFactory) public static Job WithEngineFactory(this Job job, IEngineFactory engineFactory) Parameters job Job engineFactory IEngineFactory Returns Job WithEnvironmentVariable(Job, EnvironmentVariable) Creates a new job based on the given job with additional environment variable. All existed environment variables of the original job will be copied to the new one. If the original job already contains an environment variable with the same key, it will be overriden. public static Job WithEnvironmentVariable(this Job job, EnvironmentVariable environmentVariable) Parameters job Job The original job environmentVariable EnvironmentVariable The new environment variable which should be added for the new job Returns Job The new job with additional environment variable WithEnvironmentVariable(Job, string, string) Creates a new job based on the given job with additional environment variable. All existed environment variables of the original job will be copied to the new one. If the original job already contains an environment variable with the same key, it will be overriden. public static Job WithEnvironmentVariable(this Job job, string key, string value) Parameters job Job The original job key string The key of the new environment variable value string The value of the new environment variable Returns Job The new job with additional environment variable WithEnvironmentVariables(Job, params EnvironmentVariable[]) Creates a new job based on the given job with specified environment variables. It overrides the whole list of environment variables which were defined in the original job. public static Job WithEnvironmentVariables(this Job job, params EnvironmentVariable[] environmentVariables) Parameters job Job The original job environmentVariables EnvironmentVariable[] The environment variables for the new job Returns Job The new job with overriden environment variables Exceptions InvalidOperationException Throws an exception if environmentVariables contains two variables with the same key. WithEvaluateOverhead(Job, bool) Specifies if the overhead should be evaluated (Idle runs) and it's average value subtracted from every result. True by default, very important for nano-benchmarks. public static Job WithEvaluateOverhead(this Job job, bool value) Parameters job Job value bool Returns Job WithGcAllowVeryLargeObjects(Job, bool) On 64-bit platforms, enables arrays that are greater than 2 gigabytes (GB) in total size. false: Arrays greater than 2 GB in total size are not enabled. This is the default. true: Arrays greater than 2 GB in total size are enabled on 64-bit platforms. public static Job WithGcAllowVeryLargeObjects(this Job job, bool value) Parameters job Job value bool Returns Job WithGcConcurrent(Job, bool) Specifies whether the common language runtime runs garbage collection on a separate thread. false: Does not run garbage collection concurrently. true: Runs garbage collection concurrently. This is the default. public static Job WithGcConcurrent(this Job job, bool value) Parameters job Job value bool Returns Job WithGcCpuGroups(Job, bool) Specifies whether garbage collection supports multiple CPU groups. false: Garbage collection does not support multiple CPU groups. This is the default. true: Garbage collection supports multiple CPU groups, if server garbage collection is enabled. public static Job WithGcCpuGroups(this Job job, bool value) Parameters job Job value bool Returns Job WithGcForce(Job, bool) Specifies whether the BenchmarkDotNet's benchmark runner forces full garbage collection after each benchmark invocation false: Does not force garbage collection. true: Forces full garbage collection after each benchmark invocation. This is the default. public static Job WithGcForce(this Job job, bool value) Parameters job Job value bool Returns Job WithGcMode(Job, GcMode) public static Job WithGcMode(this Job job, GcMode gc) Parameters job Job gc GcMode Returns Job WithGcRetainVm(Job, bool) Put segments that should be deleted on a standby list for future use instead of releasing them back to the OS The default is false public static Job WithGcRetainVm(this Job job, bool value) Parameters job Job value bool Returns Job WithGcServer(Job, bool) Specifies whether the common language runtime runs server garbage collection. false: Does not run server garbage collection. This is the default. true: Runs server garbage collection. public static Job WithGcServer(this Job job, bool value) Parameters job Job value bool Returns Job WithHeapAffinitizeMask(Job, int) process mask, see MSDN for more. public static Job WithHeapAffinitizeMask(this Job job, int heapAffinitizeMask) Parameters job Job heapAffinitizeMask int Returns Job WithHeapCount(Job, int) specify the # of Server GC threads/heaps, must be smaller than the # of logical CPUs the process is allowed to run on, ie, if you don't specifically affinitize your process it means the # of total logical CPUs on the machine; otherwise this is the # of logical CPUs you affinitized your process to. public static Job WithHeapCount(this Job job, int heapCount) Parameters job Job heapCount int Returns Job WithId(Job, string) public static Job WithId(this Job job, string id) Parameters job Job id string Returns Job WithInvocationCount(Job, long) Invocation count in a single iteration. If specified, IterationTime will be ignored. If specified, it must be a multiple of UnrollFactor. public static Job WithInvocationCount(this Job job, long count) Parameters job Job count long Returns Job WithIterationCount(Job, int) How many target iterations should be performed. If specified, MinIterationCount will be ignored. If specified, MaxIterationCount will be ignored. public static Job WithIterationCount(this Job job, int count) Parameters job Job count int Returns Job WithIterationTime(Job, TimeInterval) Desired time of execution of an iteration. Used by Pilot stage to estimate the number of invocations per iteration. The default value is 500 milliseconds. public static Job WithIterationTime(this Job job, TimeInterval time) Parameters job Job time TimeInterval Returns Job WithJit(Job, Jit) public static Job WithJit(this Job job, Jit jit) Parameters job Job jit Jit Returns Job WithLargeAddressAware(Job, bool) Specifies that benchmark can handle addresses larger than 2 gigabytes. public static Job WithLargeAddressAware(this Job job, bool value = true) Parameters job Job value bool Returns Job WithLaunchCount(Job, int) How many times we should launch process with target benchmark. public static Job WithLaunchCount(this Job job, int count) Parameters job Job count int Returns Job WithMaxAbsoluteError(Job, TimeInterval) Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error). Doesn't have a default value. If MaxRelativeError is also provided, the smallest value is used as stop criteria. public static Job WithMaxAbsoluteError(this Job job, TimeInterval interval) Parameters job Job interval TimeInterval Returns Job WithMaxIterationCount(Job, int) Maximum count of target iterations that should be performed. The default value is 100. If you set this value to below 15, then MultimodalDistributionAnalyzer is not going to work. public static Job WithMaxIterationCount(this Job job, int count) Parameters job Job count int Returns Job WithMaxRelativeError(Job, double) Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error). The default value is 0.02. If MaxAbsoluteError is also provided, the smallest value is used as stop criteria. public static Job WithMaxRelativeError(this Job job, double value) Parameters job Job value double Returns Job WithMaxWarmupCount(Job, int) Maximum count of warmup iterations that should be performed The default value is 50 public static Job WithMaxWarmupCount(this Job job, int count) Parameters job Job count int Returns Job WithMemoryRandomization(Job, bool) specifies whether Engine should allocate some random-sized memory between iterations it makes [GlobalCleanup] and [GlobalSetup] methods to be executed after every iteration public static Job WithMemoryRandomization(this Job job, bool enable = true) Parameters job Job enable bool Returns Job WithMinInvokeCount(Job, int) Minimum count of benchmark invocations per iteration The default value is 4. public static Job WithMinInvokeCount(this Job job, int value) Parameters job Job value int Returns Job WithMinIterationCount(Job, int) Minimum count of target iterations that should be performed. The default value is 15. If you set this value to below 15, then MultimodalDistributionAnalyzer is not going to work. public static Job WithMinIterationCount(this Job job, int count) Parameters job Job count int Returns Job WithMinIterationTime(Job, TimeInterval) Minimum time of a single iteration. Unlike Run.IterationTime, this characteristic specifies only the lower limit. In case of need, BenchmarkDotNet can increase this value. The default value is 500 milliseconds. public static Job WithMinIterationTime(this Job job, TimeInterval interval) Parameters job Job interval TimeInterval Returns Job WithMinWarmupCount(Job, int) Minimum count of warmup iterations that should be performed The default value is 6 public static Job WithMinWarmupCount(this Job job, int count) Parameters job Job count int Returns Job WithMsBuildArguments(Job, params string[]) public static Job WithMsBuildArguments(this Job job, params string[] msBuildArguments) Parameters job Job msBuildArguments string[] Returns Job WithNoAffinitize(Job, bool) specify true to disable hard affinity of Server GC threads to CPUs public static Job WithNoAffinitize(this Job job, bool value) Parameters job Job value bool Returns Job WithOutlierMode(Job, OutlierMode) Specifies which outliers should be removed from the distribution public static Job WithOutlierMode(this Job job, OutlierMode value) Parameters job Job value OutlierMode Returns Job WithPlatform(Job, Platform) public static Job WithPlatform(this Job job, Platform platform) Parameters job Job platform Platform Returns Job WithPowerPlan(Job, PowerPlan) Power plan for benchmarks. The default value is HighPerformance. Only available for Windows. public static Job WithPowerPlan(this Job job, PowerPlan powerPlan) Parameters job Job powerPlan PowerPlan Returns Job WithPowerPlan(Job, Guid) Setting power plans by guid. The default value is HighPerformance. Only available for Windows. public static Job WithPowerPlan(this Job job, Guid powerPlanGuid) Parameters job Job powerPlanGuid Guid Returns Job WithRuntime(Job, Runtime) public static Job WithRuntime(this Job job, Runtime runtime) Parameters job Job runtime Runtime Returns Job WithStrategy(Job, RunStrategy) Available values: Throughput, ColdStart and Monitoring. Throughput: default strategy which allows to get good precision level. ColdStart: should be used only for measuring cold start of the application or testing purpose. Monitoring: no overhead evaluating, with several target iterations. Perfect for macrobenchmarks without a steady state with high variance. public static Job WithStrategy(this Job job, RunStrategy strategy) Parameters job Job strategy RunStrategy Returns Job WithToolchain(Job, IToolchain) public static Job WithToolchain(this Job job, IToolchain toolchain) Parameters job Job toolchain IToolchain Returns Job WithUnrollFactor(Job, int) How many times the benchmark method will be invoked per one iteration of a generated loop. The default value is 16. public static Job WithUnrollFactor(this Job job, int factor) Parameters job Job factor int Returns Job WithWarmupCount(Job, int) How many warmup iterations should be performed. public static Job WithWarmupCount(this Job job, int count) Parameters job Job count int Returns Job WithoutEnvironmentVariables(Job) Creates a new job based on the given job without any environment variables. public static Job WithoutEnvironmentVariables(this Job job) Parameters job Job The original job Returns Job The new job which doesn't have any environment variables"
  },
  "api/BenchmarkDotNet.Jobs.JobIdGenerator.html": {
    "href": "api/BenchmarkDotNet.Jobs.JobIdGenerator.html",
    "title": "Class JobIdGenerator | BenchmarkDotNet",
    "summary": "Class JobIdGenerator Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public static class JobIdGenerator Inheritance object JobIdGenerator Methods GenerateRandomId(Job) public static string GenerateRandomId(Job job) Parameters job Job Returns string"
  },
  "api/BenchmarkDotNet.Jobs.JobMode-1.html": {
    "href": "api/BenchmarkDotNet.Jobs.JobMode-1.html",
    "title": "Class JobMode<T> | BenchmarkDotNet",
    "summary": "Class JobMode<T> Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public abstract class JobMode<T> : CharacteristicObject<T> where T : JobMode<T>, new() Type Parameters T Inheritance object CharacteristicObject CharacteristicObject<T> JobMode<T> Derived AccuracyMode EnvironmentMode GcMode InfrastructureMode Job MetaMode RunMode Inherited Members CharacteristicObject<T>.Apply(CharacteristicObject) CharacteristicObject<T>.Apply(params CharacteristicObject[]) CharacteristicObject<T>.ApplyAndFreeze(CharacteristicObject) CharacteristicObject<T>.ApplyAndFreeze(params CharacteristicObject[]) CharacteristicObject<T>.Freeze() CharacteristicObject<T>.UnfreezeCopy() CharacteristicObject<T>.CreateCharacteristic<TC>(string) CharacteristicObject<T>.CreateHiddenCharacteristic<TC>(string) CharacteristicObject<T>.CreateIgnoreOnApplyCharacteristic<TC>(string) CharacteristicObject.IdCharacteristic CharacteristicObject.ResolveId(CharacteristicObject, string) CharacteristicObject.GetCharacteristicsWithValues() CharacteristicObject.HasValue(Characteristic) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver, T) CharacteristicObject.ResolveValue(Characteristic, IResolver) CharacteristicObject.ResolveValue(Characteristic, IResolver, object) CharacteristicObject.ResolveValue<T>(Characteristic<T>, T) CharacteristicObject.ResolveValue(Characteristic, object) CharacteristicObject.ResolveValueAsNullable<T>(Characteristic<T>) CharacteristicObject.ApplyCore(CharacteristicObject) CharacteristicObject.FreezeCore() CharacteristicObject.UnfreezeCopyCore() CharacteristicObject.ToString() CharacteristicObject.OwnerOrSelf CharacteristicObject.Frozen CharacteristicObject.IsPropertyBag CharacteristicObject.HasChanges CharacteristicObject.Id Extension Methods CharacteristicHelper.GetAllCharacteristics(CharacteristicObject) CharacteristicHelper.GetThisTypeCharacteristics(CharacteristicObject) Constructors JobMode() protected JobMode() JobMode(string?) protected JobMode(string? id) Parameters id string Fields Default public static readonly T Default Field Value T Properties Job public Job Job { get; } Property Value Job"
  },
  "api/BenchmarkDotNet.Jobs.MetaMode.html": {
    "href": "api/BenchmarkDotNet.Jobs.MetaMode.html",
    "title": "Class MetaMode | BenchmarkDotNet",
    "summary": "Class MetaMode Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public class MetaMode : JobMode<MetaMode> Inheritance object CharacteristicObject CharacteristicObject<MetaMode> JobMode<MetaMode> MetaMode Inherited Members JobMode<MetaMode>.Default JobMode<MetaMode>.Job CharacteristicObject<MetaMode>.Apply(CharacteristicObject) CharacteristicObject<MetaMode>.Apply(params CharacteristicObject[]) CharacteristicObject<MetaMode>.ApplyAndFreeze(CharacteristicObject) CharacteristicObject<MetaMode>.ApplyAndFreeze(params CharacteristicObject[]) CharacteristicObject<MetaMode>.Freeze() CharacteristicObject<MetaMode>.UnfreezeCopy() CharacteristicObject<MetaMode>.CreateCharacteristic<TC>(string) CharacteristicObject<MetaMode>.CreateHiddenCharacteristic<TC>(string) CharacteristicObject<MetaMode>.CreateIgnoreOnApplyCharacteristic<TC>(string) CharacteristicObject.IdCharacteristic CharacteristicObject.ResolveId(CharacteristicObject, string) CharacteristicObject.GetCharacteristicsWithValues() CharacteristicObject.HasValue(Characteristic) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver, T) CharacteristicObject.ResolveValue(Characteristic, IResolver) CharacteristicObject.ResolveValue(Characteristic, IResolver, object) CharacteristicObject.ResolveValue<T>(Characteristic<T>, T) CharacteristicObject.ResolveValue(Characteristic, object) CharacteristicObject.ResolveValueAsNullable<T>(Characteristic<T>) CharacteristicObject.ApplyCore(CharacteristicObject) CharacteristicObject.FreezeCore() CharacteristicObject.UnfreezeCopyCore() CharacteristicObject.ToString() CharacteristicObject.OwnerOrSelf CharacteristicObject.Frozen CharacteristicObject.IsPropertyBag CharacteristicObject.HasChanges CharacteristicObject.Id Extension Methods CharacteristicHelper.GetAllCharacteristics(CharacteristicObject) CharacteristicHelper.GetThisTypeCharacteristics(CharacteristicObject) Constructors MetaMode() public MetaMode() Fields BaselineCharacteristic public static readonly Characteristic<bool> BaselineCharacteristic Field Value Characteristic<bool> IsDefaultCharacteristic public static readonly Characteristic<bool> IsDefaultCharacteristic Field Value Characteristic<bool> IsMutatorCharacteristic public static readonly Characteristic<bool> IsMutatorCharacteristic Field Value Characteristic<bool> Properties Baseline public bool Baseline { get; set; } Property Value bool IsDefault set to true if you want to specify custom default settings for default job used by console arguments parser public bool IsDefault { get; set; } Property Value bool IsMutator mutator job should not be added to the config, but instead applied to other jobs in given config public bool IsMutator { get; set; } Property Value bool"
  },
  "api/BenchmarkDotNet.Jobs.MonoArgument.html": {
    "href": "api/BenchmarkDotNet.Jobs.MonoArgument.html",
    "title": "Class MonoArgument | BenchmarkDotNet",
    "summary": "Class MonoArgument Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll Argument passed directly to mono when executing benchmarks (mono [options]) example: new MonoArgument(\"--gc=sgen\") public class MonoArgument : Argument, IEquatable<Argument> Inheritance object Argument MonoArgument Implements IEquatable<Argument> Inherited Members Argument.ToString() Argument.Equals(Argument) Argument.Equals(object) Argument.GetHashCode() Argument.TextRepresentation Constructors MonoArgument(string) public MonoArgument(string value) Parameters value string"
  },
  "api/BenchmarkDotNet.Jobs.MsBuildArgument.html": {
    "href": "api/BenchmarkDotNet.Jobs.MsBuildArgument.html",
    "title": "Class MsBuildArgument | BenchmarkDotNet",
    "summary": "Class MsBuildArgument Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll Argument passed to dotnet cli when restoring and building the project example: new MsBuildArgument(\"/p:MyCustomSetting=123\") public class MsBuildArgument : Argument, IEquatable<Argument> Inheritance object Argument MsBuildArgument Implements IEquatable<Argument> Inherited Members Argument.ToString() Argument.Equals(Argument) Argument.Equals(object) Argument.GetHashCode() Argument.TextRepresentation Constructors MsBuildArgument(string) public MsBuildArgument(string value) Parameters value string"
  },
  "api/BenchmarkDotNet.Jobs.RunMode.html": {
    "href": "api/BenchmarkDotNet.Jobs.RunMode.html",
    "title": "Class RunMode | BenchmarkDotNet",
    "summary": "Class RunMode Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public sealed class RunMode : JobMode<RunMode> Inheritance object CharacteristicObject CharacteristicObject<RunMode> JobMode<RunMode> RunMode Inherited Members JobMode<RunMode>.Default JobMode<RunMode>.Job CharacteristicObject<RunMode>.Apply(CharacteristicObject) CharacteristicObject<RunMode>.Apply(params CharacteristicObject[]) CharacteristicObject<RunMode>.ApplyAndFreeze(CharacteristicObject) CharacteristicObject<RunMode>.ApplyAndFreeze(params CharacteristicObject[]) CharacteristicObject<RunMode>.Freeze() CharacteristicObject<RunMode>.UnfreezeCopy() CharacteristicObject.IdCharacteristic CharacteristicObject.GetCharacteristicsWithValues() CharacteristicObject.HasValue(Characteristic) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver, T) CharacteristicObject.ResolveValue(Characteristic, IResolver) CharacteristicObject.ResolveValue(Characteristic, IResolver, object) CharacteristicObject.ResolveValue<T>(Characteristic<T>, T) CharacteristicObject.ResolveValue(Characteristic, object) CharacteristicObject.ResolveValueAsNullable<T>(Characteristic<T>) CharacteristicObject.ToString() CharacteristicObject.Frozen CharacteristicObject.HasChanges CharacteristicObject.Id Extension Methods CharacteristicHelper.GetAllCharacteristics(CharacteristicObject) CharacteristicHelper.GetThisTypeCharacteristics(CharacteristicObject) Constructors RunMode() public RunMode() Fields Dry public static readonly RunMode Dry Field Value RunMode InvocationCountCharacteristic public static readonly Characteristic<long> InvocationCountCharacteristic Field Value Characteristic<long> IterationCountCharacteristic public static readonly Characteristic<int> IterationCountCharacteristic Field Value Characteristic<int> IterationTimeCharacteristic public static readonly Characteristic<TimeInterval> IterationTimeCharacteristic Field Value Characteristic<TimeInterval> LaunchCountCharacteristic public static readonly Characteristic<int> LaunchCountCharacteristic Field Value Characteristic<int> Long public static readonly RunMode Long Field Value RunMode MaxIterationCountCharacteristic public static readonly Characteristic<int> MaxIterationCountCharacteristic Field Value Characteristic<int> MaxWarmupIterationCountCharacteristic public static readonly Characteristic<int> MaxWarmupIterationCountCharacteristic Field Value Characteristic<int> Medium public static readonly RunMode Medium Field Value RunMode MemoryRandomizationCharacteristic public static readonly Characteristic<bool> MemoryRandomizationCharacteristic Field Value Characteristic<bool> MinIterationCountCharacteristic public static readonly Characteristic<int> MinIterationCountCharacteristic Field Value Characteristic<int> MinWarmupIterationCountCharacteristic public static readonly Characteristic<int> MinWarmupIterationCountCharacteristic Field Value Characteristic<int> RunStrategyCharacteristic public static readonly Characteristic<RunStrategy> RunStrategyCharacteristic Field Value Characteristic<RunStrategy> Short public static readonly RunMode Short Field Value RunMode UnrollFactorCharacteristic public static readonly Characteristic<int> UnrollFactorCharacteristic Field Value Characteristic<int> VeryLong public static readonly RunMode VeryLong Field Value RunMode WarmupCountCharacteristic public static readonly Characteristic<int> WarmupCountCharacteristic Field Value Characteristic<int> Properties InvocationCount Invocation count in a single iteration. If specified, IterationTime will be ignored. If specified, it must be a multiple of UnrollFactor. public long InvocationCount { get; set; } Property Value long IterationCount How many target iterations should be performed If specified, MinIterationCount will be ignored. If specified, MaxIterationCount will be ignored. public int IterationCount { get; set; } Property Value int IterationTime Desired time of execution of an iteration. Used by Pilot stage to estimate the number of invocations per iteration. The default value is 500 milliseconds. public TimeInterval IterationTime { get; set; } Property Value TimeInterval LaunchCount How many times we should launch process with target benchmark. public int LaunchCount { get; set; } Property Value int MaxIterationCount Maximum count of target iterations that should be performed The default value is 100 If you set this value to below 15, then MultimodalDistributionAnalyzer is not going to work public int MaxIterationCount { get; set; } Property Value int MaxWarmupIterationCount Maximum count of warmup iterations that should be performed The default value is 50 public int MaxWarmupIterationCount { get; set; } Property Value int MemoryRandomization specifies whether Engine should allocate some random-sized memory between iterations it makes [GlobalCleanup] and [GlobalSetup] methods to be executed after every iteration public bool MemoryRandomization { get; set; } Property Value bool MinIterationCount Minimum count of target iterations that should be performed The default value is 15 If you set this value to below 15, then MultimodalDistributionAnalyzer is not going to work public int MinIterationCount { get; set; } Property Value int MinWarmupIterationCount Minimum count of warmup iterations that should be performed The default value is 6 public int MinWarmupIterationCount { get; set; } Property Value int RunStrategy Available values: Throughput and ColdStart. Throughput: default strategy which allows to get good precision level. ColdStart: should be used only for measuring cold start of the application or testing purpose. Monitoring: no overhead evaluating, with several target iterations. Perfect for macrobenchmarks without a steady state with high variance. public RunStrategy RunStrategy { get; set; } Property Value RunStrategy UnrollFactor How many times the benchmark method will be invoked per one iteration of a generated loop. public int UnrollFactor { get; set; } Property Value int WarmupCount How many warmup iterations should be performed. public int WarmupCount { get; set; } Property Value int"
  },
  "api/BenchmarkDotNet.Jobs.RuntimeMoniker.html": {
    "href": "api/BenchmarkDotNet.Jobs.RuntimeMoniker.html",
    "title": "Enum RuntimeMoniker | BenchmarkDotNet",
    "summary": "Enum RuntimeMoniker Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.Annotations.dll public enum RuntimeMoniker Fields HostProcess = 0 the same Runtime as the host Process (default setting) Mono = 2 Mono Mono10_0 = 44 .NET 10 using MonoVM (not CLR which is the default) Mono60 = 40 .NET 6 using MonoVM (not CLR which is the default) Mono70 = 41 .NET 7 using MonoVM (not CLR which is the default) Mono80 = 42 .NET 8 using MonoVM (not CLR which is the default) Mono90 = 43 .NET 9 using MonoVM (not CLR which is the default) MonoAOTLLVM = 34 Mono with the Ahead of Time LLVM Compiler backend MonoAOTLLVMNet10_0 = 39 Mono with the Ahead of Time LLVM Compiler backend and net10.0 MonoAOTLLVMNet60 = 35 Mono with the Ahead of Time LLVM Compiler backend and net6.0 MonoAOTLLVMNet70 = 36 Mono with the Ahead of Time LLVM Compiler backend and net7.0 MonoAOTLLVMNet80 = 37 Mono with the Ahead of Time LLVM Compiler backend and net8.0 MonoAOTLLVMNet90 = 38 Mono with the Ahead of Time LLVM Compiler backend and net9.0 NativeAot10_0 = 26 NativeAOT compiled as net10.0 NativeAot60 = 22 NativeAOT compiled as net6.0 NativeAot70 = 23 NativeAOT compiled as net7.0 NativeAot80 = 24 NativeAOT compiled as net8.0 NativeAot90 = 25 NativeAOT compiled as net9.0 Net10_0 = 21 .NET 10.0 Net461 = 3 .NET 4.6.1 Net462 = 4 .NET 4.6.2 Net47 = 5 .NET 4.7 Net471 = 6 .NET 4.7.1 Net472 = 7 .NET 4.7.2 Net48 = 8 .NET 4.8 Net481 = 9 .NET 4.8.1 Net50 = 16 .NET 5.0 Net60 = 17 .NET 6.0 Net70 = 18 .NET 7.0 Net80 = 19 .NET 8.0 Net90 = 20 .NET 9.0 NetCoreApp20 = 10 .NET Core 2.0 NetCoreApp21 = 11 .NET Core 2.1 NetCoreApp22 = 12 .NET Core 2.2 NetCoreApp30 = 13 .NET Core 3.0 NetCoreApp31 = 14 .NET Core 3.1 [Obsolete(\"Please switch to the 'RuntimeMoniker.Net50'\")] NetCoreApp50 = 15 .NET Core 5.0 aka \".NET 5\" NotRecognized = 1 not recognized, possibly a new version of .NET Core Wasm = 27 WebAssembly with default .Net version WasmNet10_0 = 33 WebAssembly with net10.0 WasmNet50 = 28 WebAssembly with net5.0 WasmNet60 = 29 WebAssembly with net6.0 WasmNet70 = 30 WebAssembly with net7.0 WasmNet80 = 31 WebAssembly with net8.0 WasmNet90 = 32 WebAssembly with net9.0"
  },
  "api/BenchmarkDotNet.Loggers.AccumulationLogger.html": {
    "href": "api/BenchmarkDotNet.Loggers.AccumulationLogger.html",
    "title": "Class AccumulationLogger | BenchmarkDotNet",
    "summary": "Class AccumulationLogger Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll public class AccumulationLogger : ILogger Inheritance object AccumulationLogger Implements ILogger Extension Methods LoggerExtensions.Write(ILogger, string) LoggerExtensions.WriteError(ILogger, string) LoggerExtensions.WriteHeader(ILogger, string) LoggerExtensions.WriteHelp(ILogger, string) LoggerExtensions.WriteHint(ILogger, string) LoggerExtensions.WriteInfo(ILogger, string) LoggerExtensions.WriteLine(ILogger, string) LoggerExtensions.WriteLineError(ILogger, string) LoggerExtensions.WriteLineHeader(ILogger, string) LoggerExtensions.WriteLineHelp(ILogger, string) LoggerExtensions.WriteLineHint(ILogger, string) LoggerExtensions.WriteLineInfo(ILogger, string) LoggerExtensions.WriteLineResult(ILogger, string) LoggerExtensions.WriteLineStatistic(ILogger, string) LoggerExtensions.WriteLineWarning(ILogger, string) LoggerExtensions.WriteResult(ILogger, string) LoggerExtensions.WriteStatistic(ILogger, string) LoggerExtensions.WriteWarning(ILogger, string) Constructors AccumulationLogger() public AccumulationLogger() Properties Id public string Id { get; } Property Value string Priority If there are several loggers with the same Id, only logger with the highest priority will be used. public int Priority { get; } Property Value int Methods ClearLog() public void ClearLog() Flush() public void Flush() GetLog() public string GetLog() Returns string Write(LogKind, string) public virtual void Write(LogKind logKind, string text) Parameters logKind LogKind text string WriteLine() public virtual void WriteLine() WriteLine(LogKind, string) public virtual void WriteLine(LogKind logKind, string text) Parameters logKind LogKind text string"
  },
  "api/BenchmarkDotNet.Loggers.ConsoleLogger.html": {
    "href": "api/BenchmarkDotNet.Loggers.ConsoleLogger.html",
    "title": "Class ConsoleLogger | BenchmarkDotNet",
    "summary": "Class ConsoleLogger Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll public sealed class ConsoleLogger : ILogger Inheritance object ConsoleLogger Implements ILogger Extension Methods LoggerExtensions.Write(ILogger, string) LoggerExtensions.WriteError(ILogger, string) LoggerExtensions.WriteHeader(ILogger, string) LoggerExtensions.WriteHelp(ILogger, string) LoggerExtensions.WriteHint(ILogger, string) LoggerExtensions.WriteInfo(ILogger, string) LoggerExtensions.WriteLine(ILogger, string) LoggerExtensions.WriteLineError(ILogger, string) LoggerExtensions.WriteLineHeader(ILogger, string) LoggerExtensions.WriteLineHelp(ILogger, string) LoggerExtensions.WriteLineHint(ILogger, string) LoggerExtensions.WriteLineInfo(ILogger, string) LoggerExtensions.WriteLineResult(ILogger, string) LoggerExtensions.WriteLineStatistic(ILogger, string) LoggerExtensions.WriteLineWarning(ILogger, string) LoggerExtensions.WriteResult(ILogger, string) LoggerExtensions.WriteStatistic(ILogger, string) LoggerExtensions.WriteWarning(ILogger, string) Constructors ConsoleLogger(bool, Dictionary<LogKind, ConsoleColor>?) public ConsoleLogger(bool unicodeSupport = false, Dictionary<LogKind, ConsoleColor>? colorScheme = null) Parameters unicodeSupport bool colorScheme Dictionary<LogKind, ConsoleColor> Fields Ascii public static readonly ILogger Ascii Field Value ILogger Default public static readonly ILogger Default Field Value ILogger Unicode public static readonly ILogger Unicode Field Value ILogger Properties Id public string Id { get; } Property Value string Priority If there are several loggers with the same Id, only logger with the highest priority will be used. public int Priority { get; } Property Value int Methods CreateGrayScheme() public static Dictionary<LogKind, ConsoleColor> CreateGrayScheme() Returns Dictionary<LogKind, ConsoleColor> Flush() public void Flush() Write(LogKind, string) public void Write(LogKind logKind, string text) Parameters logKind LogKind text string WriteLine() public void WriteLine() WriteLine(LogKind, string) public void WriteLine(LogKind logKind, string text) Parameters logKind LogKind text string"
  },
  "api/BenchmarkDotNet.Loggers.html": {
    "href": "api/BenchmarkDotNet.Loggers.html",
    "title": "Namespace BenchmarkDotNet.Loggers | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Loggers Classes AccumulationLogger ConsoleLogger LinqPadLogger LogCapture LoggerExtensions LoggerWithPrefix Adds prefix for each line NullLogger StreamLogger TextLogger Structs OutputLine Interfaces ILogger Enums LogKind"
  },
  "api/BenchmarkDotNet.Loggers.ILogger.html": {
    "href": "api/BenchmarkDotNet.Loggers.ILogger.html",
    "title": "Interface ILogger | BenchmarkDotNet",
    "summary": "Interface ILogger Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll public interface ILogger Extension Methods LoggerExtensions.Write(ILogger, string) LoggerExtensions.WriteError(ILogger, string) LoggerExtensions.WriteHeader(ILogger, string) LoggerExtensions.WriteHelp(ILogger, string) LoggerExtensions.WriteHint(ILogger, string) LoggerExtensions.WriteInfo(ILogger, string) LoggerExtensions.WriteLine(ILogger, string) LoggerExtensions.WriteLineError(ILogger, string) LoggerExtensions.WriteLineHeader(ILogger, string) LoggerExtensions.WriteLineHelp(ILogger, string) LoggerExtensions.WriteLineHint(ILogger, string) LoggerExtensions.WriteLineInfo(ILogger, string) LoggerExtensions.WriteLineResult(ILogger, string) LoggerExtensions.WriteLineStatistic(ILogger, string) LoggerExtensions.WriteLineWarning(ILogger, string) LoggerExtensions.WriteResult(ILogger, string) LoggerExtensions.WriteStatistic(ILogger, string) LoggerExtensions.WriteWarning(ILogger, string) Properties Id string Id { get; } Property Value string Priority If there are several loggers with the same Id, only logger with the highest priority will be used. int Priority { get; } Property Value int Methods Flush() void Flush() Write(LogKind, string) void Write(LogKind logKind, string text) Parameters logKind LogKind text string WriteLine() void WriteLine() WriteLine(LogKind, string) void WriteLine(LogKind logKind, string text) Parameters logKind LogKind text string"
  },
  "api/BenchmarkDotNet.Loggers.LinqPadLogger.html": {
    "href": "api/BenchmarkDotNet.Loggers.LinqPadLogger.html",
    "title": "Class LinqPadLogger | BenchmarkDotNet",
    "summary": "Class LinqPadLogger Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll public sealed class LinqPadLogger : ILogger Inheritance object LinqPadLogger Implements ILogger Extension Methods LoggerExtensions.Write(ILogger, string) LoggerExtensions.WriteError(ILogger, string) LoggerExtensions.WriteHeader(ILogger, string) LoggerExtensions.WriteHelp(ILogger, string) LoggerExtensions.WriteHint(ILogger, string) LoggerExtensions.WriteInfo(ILogger, string) LoggerExtensions.WriteLine(ILogger, string) LoggerExtensions.WriteLineError(ILogger, string) LoggerExtensions.WriteLineHeader(ILogger, string) LoggerExtensions.WriteLineHelp(ILogger, string) LoggerExtensions.WriteLineHint(ILogger, string) LoggerExtensions.WriteLineInfo(ILogger, string) LoggerExtensions.WriteLineResult(ILogger, string) LoggerExtensions.WriteLineStatistic(ILogger, string) LoggerExtensions.WriteLineWarning(ILogger, string) LoggerExtensions.WriteResult(ILogger, string) LoggerExtensions.WriteStatistic(ILogger, string) LoggerExtensions.WriteWarning(ILogger, string) Fields lazyInstance public static readonly Lazy<LinqPadLogger> lazyInstance Field Value Lazy<LinqPadLogger> Properties Id public string Id { get; } Property Value string Instance public static ILogger Instance { get; } Property Value ILogger IsAvailable public static bool IsAvailable { get; } Property Value bool Priority If there are several loggers with the same Id, only logger with the highest priority will be used. public int Priority { get; } Property Value int Methods Flush() public void Flush() Write(LogKind, string) public void Write(LogKind logKind, string text) Parameters logKind LogKind text string WriteLine() public void WriteLine() WriteLine(LogKind, string) public void WriteLine(LogKind logKind, string text) Parameters logKind LogKind text string"
  },
  "api/BenchmarkDotNet.Loggers.LogCapture.html": {
    "href": "api/BenchmarkDotNet.Loggers.LogCapture.html",
    "title": "Class LogCapture | BenchmarkDotNet",
    "summary": "Class LogCapture Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll public class LogCapture : ILogger Inheritance object LogCapture Implements ILogger Extension Methods LoggerExtensions.Write(ILogger, string) LoggerExtensions.WriteError(ILogger, string) LoggerExtensions.WriteHeader(ILogger, string) LoggerExtensions.WriteHelp(ILogger, string) LoggerExtensions.WriteHint(ILogger, string) LoggerExtensions.WriteInfo(ILogger, string) LoggerExtensions.WriteLine(ILogger, string) LoggerExtensions.WriteLineError(ILogger, string) LoggerExtensions.WriteLineHeader(ILogger, string) LoggerExtensions.WriteLineHelp(ILogger, string) LoggerExtensions.WriteLineHint(ILogger, string) LoggerExtensions.WriteLineInfo(ILogger, string) LoggerExtensions.WriteLineResult(ILogger, string) LoggerExtensions.WriteLineStatistic(ILogger, string) LoggerExtensions.WriteLineWarning(ILogger, string) LoggerExtensions.WriteResult(ILogger, string) LoggerExtensions.WriteStatistic(ILogger, string) LoggerExtensions.WriteWarning(ILogger, string) Constructors LogCapture() public LogCapture() Properties CapturedOutput public IReadOnlyList<OutputLine> CapturedOutput { get; } Property Value IReadOnlyList<OutputLine> Id public string Id { get; } Property Value string Priority If there are several loggers with the same Id, only logger with the highest priority will be used. public int Priority { get; } Property Value int Methods Clear() public void Clear() Flush() public void Flush() Write(LogKind, string) public void Write(LogKind logKind, string text) Parameters logKind LogKind text string WriteLine() public void WriteLine() WriteLine(LogKind, string) public void WriteLine(LogKind logKind, string text) Parameters logKind LogKind text string"
  },
  "api/BenchmarkDotNet.Loggers.LoggerExtensions.html": {
    "href": "api/BenchmarkDotNet.Loggers.LoggerExtensions.html",
    "title": "Class LoggerExtensions | BenchmarkDotNet",
    "summary": "Class LoggerExtensions Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll public static class LoggerExtensions Inheritance object LoggerExtensions Methods Write(ILogger, string) public static void Write(this ILogger logger, string text) Parameters logger ILogger text string WriteError(ILogger, string) public static void WriteError(this ILogger logger, string text) Parameters logger ILogger text string WriteHeader(ILogger, string) public static void WriteHeader(this ILogger logger, string text) Parameters logger ILogger text string WriteHelp(ILogger, string) public static void WriteHelp(this ILogger logger, string text) Parameters logger ILogger text string WriteHint(ILogger, string) public static void WriteHint(this ILogger logger, string text) Parameters logger ILogger text string WriteInfo(ILogger, string) public static void WriteInfo(this ILogger logger, string text) Parameters logger ILogger text string WriteLine(ILogger, string) public static void WriteLine(this ILogger logger, string text) Parameters logger ILogger text string WriteLineError(ILogger, string) public static void WriteLineError(this ILogger logger, string text) Parameters logger ILogger text string WriteLineHeader(ILogger, string) public static void WriteLineHeader(this ILogger logger, string text) Parameters logger ILogger text string WriteLineHelp(ILogger, string) public static void WriteLineHelp(this ILogger logger, string text) Parameters logger ILogger text string WriteLineHint(ILogger, string) public static void WriteLineHint(this ILogger logger, string text) Parameters logger ILogger text string WriteLineInfo(ILogger, string) public static void WriteLineInfo(this ILogger logger, string text) Parameters logger ILogger text string WriteLineResult(ILogger, string) public static void WriteLineResult(this ILogger logger, string text) Parameters logger ILogger text string WriteLineStatistic(ILogger, string) public static void WriteLineStatistic(this ILogger logger, string text) Parameters logger ILogger text string WriteLineWarning(ILogger, string) public static void WriteLineWarning(this ILogger logger, string text) Parameters logger ILogger text string WriteResult(ILogger, string) public static void WriteResult(this ILogger logger, string text) Parameters logger ILogger text string WriteStatistic(ILogger, string) public static void WriteStatistic(this ILogger logger, string text) Parameters logger ILogger text string WriteWarning(ILogger, string) public static void WriteWarning(this ILogger logger, string text) Parameters logger ILogger text string"
  },
  "api/BenchmarkDotNet.Loggers.LoggerWithPrefix.html": {
    "href": "api/BenchmarkDotNet.Loggers.LoggerWithPrefix.html",
    "title": "Class LoggerWithPrefix | BenchmarkDotNet",
    "summary": "Class LoggerWithPrefix Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll Adds prefix for each line public class LoggerWithPrefix : ILogger Inheritance object LoggerWithPrefix Implements ILogger Extension Methods LoggerExtensions.Write(ILogger, string) LoggerExtensions.WriteError(ILogger, string) LoggerExtensions.WriteHeader(ILogger, string) LoggerExtensions.WriteHelp(ILogger, string) LoggerExtensions.WriteHint(ILogger, string) LoggerExtensions.WriteInfo(ILogger, string) LoggerExtensions.WriteLine(ILogger, string) LoggerExtensions.WriteLineError(ILogger, string) LoggerExtensions.WriteLineHeader(ILogger, string) LoggerExtensions.WriteLineHelp(ILogger, string) LoggerExtensions.WriteLineHint(ILogger, string) LoggerExtensions.WriteLineInfo(ILogger, string) LoggerExtensions.WriteLineResult(ILogger, string) LoggerExtensions.WriteLineStatistic(ILogger, string) LoggerExtensions.WriteLineWarning(ILogger, string) LoggerExtensions.WriteResult(ILogger, string) LoggerExtensions.WriteStatistic(ILogger, string) LoggerExtensions.WriteWarning(ILogger, string) Constructors LoggerWithPrefix(ILogger, string) public LoggerWithPrefix(ILogger logger, string prefix) Parameters logger ILogger prefix string Properties Id public string Id { get; } Property Value string Priority If there are several loggers with the same Id, only logger with the highest priority will be used. public int Priority { get; } Property Value int Methods Flush() public void Flush() Write(LogKind, string) public void Write(LogKind logKind, string text) Parameters logKind LogKind text string WriteLine() public void WriteLine() WriteLine(LogKind, string) public void WriteLine(LogKind logKind, string text) Parameters logKind LogKind text string"
  },
  "api/BenchmarkDotNet.Loggers.LogKind.html": {
    "href": "api/BenchmarkDotNet.Loggers.LogKind.html",
    "title": "Enum LogKind | BenchmarkDotNet",
    "summary": "Enum LogKind Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll public enum LogKind Fields Default = 0 Error = 6 Header = 2 Help = 1 Hint = 7 Info = 5 Result = 3 Statistic = 4 Warning = 8"
  },
  "api/BenchmarkDotNet.Loggers.NullLogger.html": {
    "href": "api/BenchmarkDotNet.Loggers.NullLogger.html",
    "title": "Class NullLogger | BenchmarkDotNet",
    "summary": "Class NullLogger Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll public class NullLogger : ILogger Inheritance object NullLogger Implements ILogger Extension Methods LoggerExtensions.Write(ILogger, string) LoggerExtensions.WriteError(ILogger, string) LoggerExtensions.WriteHeader(ILogger, string) LoggerExtensions.WriteHelp(ILogger, string) LoggerExtensions.WriteHint(ILogger, string) LoggerExtensions.WriteInfo(ILogger, string) LoggerExtensions.WriteLine(ILogger, string) LoggerExtensions.WriteLineError(ILogger, string) LoggerExtensions.WriteLineHeader(ILogger, string) LoggerExtensions.WriteLineHelp(ILogger, string) LoggerExtensions.WriteLineHint(ILogger, string) LoggerExtensions.WriteLineInfo(ILogger, string) LoggerExtensions.WriteLineResult(ILogger, string) LoggerExtensions.WriteLineStatistic(ILogger, string) LoggerExtensions.WriteLineWarning(ILogger, string) LoggerExtensions.WriteResult(ILogger, string) LoggerExtensions.WriteStatistic(ILogger, string) LoggerExtensions.WriteWarning(ILogger, string) Fields Instance public static readonly ILogger Instance Field Value ILogger Properties Id public string Id { get; } Property Value string Priority If there are several loggers with the same Id, only logger with the highest priority will be used. public int Priority { get; } Property Value int Methods Flush() public void Flush() Write(LogKind, string) public void Write(LogKind logKind, string text) Parameters logKind LogKind text string WriteLine() public void WriteLine() WriteLine(LogKind, string) public void WriteLine(LogKind logKind, string text) Parameters logKind LogKind text string"
  },
  "api/BenchmarkDotNet.Loggers.OutputLine.html": {
    "href": "api/BenchmarkDotNet.Loggers.OutputLine.html",
    "title": "Struct OutputLine | BenchmarkDotNet",
    "summary": "Struct OutputLine Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll public struct OutputLine Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() Properties Kind public LogKind Kind { readonly get; set; } Property Value LogKind Text public string Text { readonly get; set; } Property Value string"
  },
  "api/BenchmarkDotNet.Loggers.StreamLogger.html": {
    "href": "api/BenchmarkDotNet.Loggers.StreamLogger.html",
    "title": "Class StreamLogger | BenchmarkDotNet",
    "summary": "Class StreamLogger Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll public class StreamLogger : TextLogger, ILogger, IDisposable Inheritance object TextLogger StreamLogger Implements ILogger IDisposable Inherited Members TextLogger.Write(LogKind, string) TextLogger.WriteLine() TextLogger.WriteLine(LogKind, string) TextLogger.Flush() TextLogger.Dispose() TextLogger.Priority Extension Methods LoggerExtensions.Write(ILogger, string) LoggerExtensions.WriteError(ILogger, string) LoggerExtensions.WriteHeader(ILogger, string) LoggerExtensions.WriteHelp(ILogger, string) LoggerExtensions.WriteHint(ILogger, string) LoggerExtensions.WriteInfo(ILogger, string) LoggerExtensions.WriteLine(ILogger, string) LoggerExtensions.WriteLineError(ILogger, string) LoggerExtensions.WriteLineHeader(ILogger, string) LoggerExtensions.WriteLineHelp(ILogger, string) LoggerExtensions.WriteLineHint(ILogger, string) LoggerExtensions.WriteLineInfo(ILogger, string) LoggerExtensions.WriteLineResult(ILogger, string) LoggerExtensions.WriteLineStatistic(ILogger, string) LoggerExtensions.WriteLineWarning(ILogger, string) LoggerExtensions.WriteResult(ILogger, string) LoggerExtensions.WriteStatistic(ILogger, string) LoggerExtensions.WriteWarning(ILogger, string) Constructors StreamLogger(StreamWriter) public StreamLogger(StreamWriter writer) Parameters writer StreamWriter StreamLogger(string, bool) public StreamLogger(string filePath, bool append = false) Parameters filePath string append bool Properties Id public override string Id { get; } Property Value string"
  },
  "api/BenchmarkDotNet.Loggers.TextLogger.html": {
    "href": "api/BenchmarkDotNet.Loggers.TextLogger.html",
    "title": "Class TextLogger | BenchmarkDotNet",
    "summary": "Class TextLogger Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll public class TextLogger : ILogger, IDisposable Inheritance object TextLogger Implements ILogger IDisposable Derived StreamLogger Extension Methods LoggerExtensions.Write(ILogger, string) LoggerExtensions.WriteError(ILogger, string) LoggerExtensions.WriteHeader(ILogger, string) LoggerExtensions.WriteHelp(ILogger, string) LoggerExtensions.WriteHint(ILogger, string) LoggerExtensions.WriteInfo(ILogger, string) LoggerExtensions.WriteLine(ILogger, string) LoggerExtensions.WriteLineError(ILogger, string) LoggerExtensions.WriteLineHeader(ILogger, string) LoggerExtensions.WriteLineHelp(ILogger, string) LoggerExtensions.WriteLineHint(ILogger, string) LoggerExtensions.WriteLineInfo(ILogger, string) LoggerExtensions.WriteLineResult(ILogger, string) LoggerExtensions.WriteLineStatistic(ILogger, string) LoggerExtensions.WriteLineWarning(ILogger, string) LoggerExtensions.WriteResult(ILogger, string) LoggerExtensions.WriteStatistic(ILogger, string) LoggerExtensions.WriteWarning(ILogger, string) Constructors TextLogger(TextWriter) public TextLogger(TextWriter writer) Parameters writer TextWriter Properties Id public virtual string Id { get; } Property Value string Priority If there are several loggers with the same Id, only logger with the highest priority will be used. public int Priority { get; } Property Value int Methods Dispose() public void Dispose() Flush() public void Flush() Write(LogKind, string) public void Write(LogKind logKind, string text) Parameters logKind LogKind text string WriteLine() public void WriteLine() WriteLine(LogKind, string) public void WriteLine(LogKind logKind, string text) Parameters logKind LogKind text string"
  },
  "api/BenchmarkDotNet.Mathematics.ConfidenceLevelExtensions.html": {
    "href": "api/BenchmarkDotNet.Mathematics.ConfidenceLevelExtensions.html",
    "title": "Class ConfidenceLevelExtensions | BenchmarkDotNet",
    "summary": "Class ConfidenceLevelExtensions Namespace BenchmarkDotNet.Mathematics Assembly BenchmarkDotNet.dll public static class ConfidenceLevelExtensions Inheritance object ConfidenceLevelExtensions Methods GetZValue(LegacyConfidenceLevel, int) Calculates Z value (z-star) for confidence interval public static double GetZValue(this LegacyConfidenceLevel level, int n) Parameters level LegacyConfidenceLevel ConfidenceLevel for a confidence interval n int Sample size (n >= 3) Returns double ToPercent(LegacyConfidenceLevel) public static double ToPercent(this LegacyConfidenceLevel level) Parameters level LegacyConfidenceLevel Returns double ToPercentStr(LegacyConfidenceLevel) public static string ToPercentStr(this LegacyConfidenceLevel level) Parameters level LegacyConfidenceLevel Returns string"
  },
  "api/BenchmarkDotNet.Mathematics.html": {
    "href": "api/BenchmarkDotNet.Mathematics.html",
    "title": "Namespace BenchmarkDotNet.Mathematics | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Mathematics Classes ConfidenceLevelExtensions NumeralSystemExtensions PercentileValues Statistics Structs LegacyConfidenceInterval Enums LegacyConfidenceLevel NumeralSystem"
  },
  "api/BenchmarkDotNet.Mathematics.LegacyConfidenceInterval.html": {
    "href": "api/BenchmarkDotNet.Mathematics.LegacyConfidenceInterval.html",
    "title": "Struct LegacyConfidenceInterval | BenchmarkDotNet",
    "summary": "Struct LegacyConfidenceInterval Namespace BenchmarkDotNet.Mathematics Assembly BenchmarkDotNet.dll public struct LegacyConfidenceInterval Inherited Members ValueType.Equals(object) ValueType.GetHashCode() Constructors LegacyConfidenceInterval(double, double, int, LegacyConfidenceLevel) public LegacyConfidenceInterval(double mean, double standardError, int n, LegacyConfidenceLevel level = LegacyConfidenceLevel.L999) Parameters mean double standardError double n int level LegacyConfidenceLevel Properties Level public readonly LegacyConfidenceLevel Level { get; } Property Value LegacyConfidenceLevel Lower public readonly double Lower { get; } Property Value double Margin public readonly double Margin { get; } Property Value double Mean public readonly double Mean { get; } Property Value double N public readonly int N { get; } Property Value int StandardError public readonly double StandardError { get; } Property Value double Upper public readonly double Upper { get; } Property Value double Methods Contains(double) public bool Contains(double value) Parameters value double Returns bool ToString() public override string ToString() Returns string ToString(Func<double, string>, bool) public string ToString(Func<double, string> formatter, bool showLevel = true) Parameters formatter Func<double, string> showLevel bool Returns string ToString(CultureInfo, string, bool) public string ToString(CultureInfo cultureInfo, string format = \"0.##\", bool showLevel = true) Parameters cultureInfo CultureInfo format string showLevel bool Returns string"
  },
  "api/BenchmarkDotNet.Mathematics.LegacyConfidenceLevel.html": {
    "href": "api/BenchmarkDotNet.Mathematics.LegacyConfidenceLevel.html",
    "title": "Enum LegacyConfidenceLevel | BenchmarkDotNet",
    "summary": "Enum LegacyConfidenceLevel Namespace BenchmarkDotNet.Mathematics Assembly BenchmarkDotNet.dll public enum LegacyConfidenceLevel Extension Methods ConfidenceLevelExtensions.GetZValue(LegacyConfidenceLevel, int) ConfidenceLevelExtensions.ToPercent(LegacyConfidenceLevel) ConfidenceLevelExtensions.ToPercentStr(LegacyConfidenceLevel) Fields L50 = 0 50.0% confidence interval L70 = 1 70.0% confidence interval L75 = 2 75.0% confidence interval L80 = 3 80.0% confidence interval L85 = 4 85.0% confidence interval L90 = 5 90.0% confidence interval L92 = 6 92.0% confidence interval L95 = 7 95.0% confidence interval L96 = 8 96.0% confidence interval L97 = 9 97.0% confidence interval L98 = 10 98.0% confidence interval L99 = 11 99.0% confidence interval L999 = 12 99.9% confidence interval"
  },
  "api/BenchmarkDotNet.Mathematics.NumeralSystem.html": {
    "href": "api/BenchmarkDotNet.Mathematics.NumeralSystem.html",
    "title": "Enum NumeralSystem | BenchmarkDotNet",
    "summary": "Enum NumeralSystem Namespace BenchmarkDotNet.Mathematics Assembly BenchmarkDotNet.dll public enum NumeralSystem Extension Methods NumeralSystemExtensions.ToPresentation(NumeralSystem, int) Fields Arabic = 0 Arabic numerals (1, 2, 3, 4, ...) Roman = 1 Roman numerals (I, II, III, IV, ...) Stars = 2 Unary numeral system (*, **, ***, ****, ...)"
  },
  "api/BenchmarkDotNet.Mathematics.NumeralSystemExtensions.html": {
    "href": "api/BenchmarkDotNet.Mathematics.NumeralSystemExtensions.html",
    "title": "Class NumeralSystemExtensions | BenchmarkDotNet",
    "summary": "Class NumeralSystemExtensions Namespace BenchmarkDotNet.Mathematics Assembly BenchmarkDotNet.dll public static class NumeralSystemExtensions Inheritance object NumeralSystemExtensions Methods ToPresentation(NumeralSystem, int) public static string ToPresentation(this NumeralSystem system, int value) Parameters system NumeralSystem value int Returns string"
  },
  "api/BenchmarkDotNet.Mathematics.PercentileValues.html": {
    "href": "api/BenchmarkDotNet.Mathematics.PercentileValues.html",
    "title": "Class PercentileValues | BenchmarkDotNet",
    "summary": "Class PercentileValues Namespace BenchmarkDotNet.Mathematics Assembly BenchmarkDotNet.dll public class PercentileValues Inheritance object PercentileValues Properties P0 public double P0 { get; } Property Value double P100 public double P100 { get; } Property Value double P25 public double P25 { get; } Property Value double P50 public double P50 { get; } Property Value double P67 public double P67 { get; } Property Value double P80 public double P80 { get; } Property Value double P85 public double P85 { get; } Property Value double P90 public double P90 { get; } Property Value double P95 public double P95 { get; } Property Value double Methods Percentile(int) public double Percentile(int percentile) Parameters percentile int Returns double ToString() public override string ToString() Returns string ToString(Func<double, string>) public string ToString(Func<double, string> formatter) Parameters formatter Func<double, string> Returns string ToString(CultureInfo?, string) public string ToString(CultureInfo? cultureInfo, string format = \"0.##\") Parameters cultureInfo CultureInfo format string Returns string"
  },
  "api/BenchmarkDotNet.Mathematics.Statistics.html": {
    "href": "api/BenchmarkDotNet.Mathematics.Statistics.html",
    "title": "Class Statistics | BenchmarkDotNet",
    "summary": "Class Statistics Namespace BenchmarkDotNet.Mathematics Assembly BenchmarkDotNet.dll public class Statistics Inheritance object Statistics Extension Methods StatisticsExtensions.CreateNanosecondFormatter(Statistics, CultureInfo, string) StatisticsExtensions.ToString(Statistics?, CultureInfo, Func<double, string>, bool) Constructors Statistics(Sample) public Statistics(Sample sample) Parameters sample Sample Statistics(IEnumerable<double>) public Statistics(IEnumerable<double> values) Parameters values IEnumerable<double> Statistics(IEnumerable<int>) public Statistics(IEnumerable<int> values) Parameters values IEnumerable<int> Statistics(params double[]) public Statistics(params double[] values) Parameters values double[] Properties AllOutliers public double[] AllOutliers { get; } Property Value double[] ConfidenceInterval public LegacyConfidenceInterval ConfidenceInterval { get; } Property Value LegacyConfidenceInterval InterquartileRange public double InterquartileRange { get; } Property Value double Kurtosis public double Kurtosis { get; } Property Value double LowerFence public double LowerFence { get; } Property Value double LowerOutliers public double[] LowerOutliers { get; } Property Value double[] Max public double Max { get; } Property Value double Mean public double Mean { get; } Property Value double Median public double Median { get; } Property Value double Min public double Min { get; } Property Value double N public int N { get; } Property Value int OriginalValues public IReadOnlyList<double> OriginalValues { get; } Property Value IReadOnlyList<double> Percentiles public PercentileValues Percentiles { get; } Property Value PercentileValues Q1 public double Q1 { get; } Property Value double Q3 public double Q3 { get; } Property Value double Skewness public double Skewness { get; } Property Value double StandardDeviation public double StandardDeviation { get; } Property Value double StandardError public double StandardError { get; } Property Value double UpperFence public double UpperFence { get; } Property Value double UpperOutliers public double[] UpperOutliers { get; } Property Value double[] Variance public double Variance { get; } Property Value double Methods CalcCentralMoment(int) public double CalcCentralMoment(int k) Parameters k int Returns double CanBeInverted() Returns true, if this statistics can be inverted (see Invert()). public bool CanBeInverted() Returns bool DivMean(Statistics?, Statistics?) Mean for [X/Y]. public static double DivMean(Statistics? x, Statistics? y) Parameters x Statistics y Statistics Returns double Divide(Statistics, Statistics) public static Statistics Divide(Statistics x, Statistics y) Parameters x Statistics y Statistics Returns Statistics GetActualOutliers(OutlierMode) public double[] GetActualOutliers(OutlierMode outlierMode) Parameters outlierMode OutlierMode Returns double[] GetConfidenceInterval(ConfidenceLevel) public ConfidenceInterval GetConfidenceInterval(ConfidenceLevel level) Parameters level ConfidenceLevel Returns ConfidenceInterval Invert() Statistics for [1/X]. If Min is less then or equal to 0, returns null. public Statistics Invert() Returns Statistics IsActualOutlier(double, OutlierMode) public bool IsActualOutlier(double value, OutlierMode outlierMode) Parameters value double outlierMode OutlierMode Returns bool IsLowerOutlier(double) public bool IsLowerOutlier(double value) Parameters value double Returns bool IsOutlier(double) public bool IsOutlier(double value) Parameters value double Returns bool IsUpperOutlier(double) public bool IsUpperOutlier(double value) Parameters value double Returns bool MulMean(Statistics, Statistics) Mean for [X*Y]. public static double MulMean(Statistics x, Statistics y) Parameters x Statistics y Statistics Returns double ToString() public override string ToString() Returns string WithoutOutliers() public double[] WithoutOutliers() Returns double[]"
  },
  "api/BenchmarkDotNet.Order.DefaultOrderer.html": {
    "href": "api/BenchmarkDotNet.Order.DefaultOrderer.html",
    "title": "Class DefaultOrderer | BenchmarkDotNet",
    "summary": "Class DefaultOrderer Namespace BenchmarkDotNet.Order Assembly BenchmarkDotNet.dll public class DefaultOrderer : IOrderer Inheritance object DefaultOrderer Implements IOrderer Constructors DefaultOrderer(SummaryOrderPolicy, MethodOrderPolicy, JobOrderPolicy) public DefaultOrderer(SummaryOrderPolicy summaryOrderPolicy = SummaryOrderPolicy.Default, MethodOrderPolicy methodOrderPolicy = MethodOrderPolicy.Declared, JobOrderPolicy jobOrderPolicy = JobOrderPolicy.Default) Parameters summaryOrderPolicy SummaryOrderPolicy methodOrderPolicy MethodOrderPolicy jobOrderPolicy JobOrderPolicy Fields Instance public static readonly IOrderer Instance Field Value IOrderer Properties MethodOrderPolicy public MethodOrderPolicy MethodOrderPolicy { get; } Property Value MethodOrderPolicy SeparateLogicalGroups public bool SeparateLogicalGroups { get; } Property Value bool SummaryOrderPolicy public SummaryOrderPolicy SummaryOrderPolicy { get; } Property Value SummaryOrderPolicy Methods GetExecutionOrder(ImmutableArray<BenchmarkCase>, IEnumerable<BenchmarkLogicalGroupRule>?) public virtual IEnumerable<BenchmarkCase> GetExecutionOrder(ImmutableArray<BenchmarkCase> benchmarkCases, IEnumerable<BenchmarkLogicalGroupRule>? order = null) Parameters benchmarkCases ImmutableArray<BenchmarkCase> order IEnumerable<BenchmarkLogicalGroupRule> Returns IEnumerable<BenchmarkCase> GetHighlightGroupKey(BenchmarkCase) public string GetHighlightGroupKey(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns string GetLogicalGroupKey(ImmutableArray<BenchmarkCase>, BenchmarkCase) public string GetLogicalGroupKey(ImmutableArray<BenchmarkCase> allBenchmarksCases, BenchmarkCase benchmarkCase) Parameters allBenchmarksCases ImmutableArray<BenchmarkCase> benchmarkCase BenchmarkCase Returns string GetLogicalGroupOrder(IEnumerable<IGrouping<string, BenchmarkCase>>, IEnumerable<BenchmarkLogicalGroupRule>?) public virtual IEnumerable<IGrouping<string, BenchmarkCase>> GetLogicalGroupOrder(IEnumerable<IGrouping<string, BenchmarkCase>> logicalGroups, IEnumerable<BenchmarkLogicalGroupRule>? order = null) Parameters logicalGroups IEnumerable<IGrouping<string, BenchmarkCase>> order IEnumerable<BenchmarkLogicalGroupRule> Returns IEnumerable<IGrouping<string, BenchmarkCase>> GetSummaryOrder(ImmutableArray<BenchmarkCase>, Summary) public virtual IEnumerable<BenchmarkCase> GetSummaryOrder(ImmutableArray<BenchmarkCase> benchmarksCases, Summary summary) Parameters benchmarksCases ImmutableArray<BenchmarkCase> summary Summary Returns IEnumerable<BenchmarkCase> GetSummaryOrderForGroup(ImmutableArray<BenchmarkCase>, Summary) protected virtual IEnumerable<BenchmarkCase> GetSummaryOrderForGroup(ImmutableArray<BenchmarkCase> benchmarksCase, Summary summary) Parameters benchmarksCase ImmutableArray<BenchmarkCase> summary Summary Returns IEnumerable<BenchmarkCase>"
  },
  "api/BenchmarkDotNet.Order.html": {
    "href": "api/BenchmarkDotNet.Order.html",
    "title": "Namespace BenchmarkDotNet.Order | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Order Classes DefaultOrderer Interfaces IOrderer Enums JobOrderPolicy MethodOrderPolicy SummaryOrderPolicy"
  },
  "api/BenchmarkDotNet.Order.IOrderer.html": {
    "href": "api/BenchmarkDotNet.Order.IOrderer.html",
    "title": "Interface IOrderer | BenchmarkDotNet",
    "summary": "Interface IOrderer Namespace BenchmarkDotNet.Order Assembly BenchmarkDotNet.dll public interface IOrderer Properties SeparateLogicalGroups bool SeparateLogicalGroups { get; } Property Value bool Methods GetExecutionOrder(ImmutableArray<BenchmarkCase>, IEnumerable<BenchmarkLogicalGroupRule>?) IEnumerable<BenchmarkCase> GetExecutionOrder(ImmutableArray<BenchmarkCase> benchmarksCase, IEnumerable<BenchmarkLogicalGroupRule>? order = null) Parameters benchmarksCase ImmutableArray<BenchmarkCase> order IEnumerable<BenchmarkLogicalGroupRule> Returns IEnumerable<BenchmarkCase> GetHighlightGroupKey(BenchmarkCase) string? GetHighlightGroupKey(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns string GetLogicalGroupKey(ImmutableArray<BenchmarkCase>, BenchmarkCase) string? GetLogicalGroupKey(ImmutableArray<BenchmarkCase> allBenchmarksCases, BenchmarkCase benchmarkCase) Parameters allBenchmarksCases ImmutableArray<BenchmarkCase> benchmarkCase BenchmarkCase Returns string GetLogicalGroupOrder(IEnumerable<IGrouping<string, BenchmarkCase>>, IEnumerable<BenchmarkLogicalGroupRule>?) IEnumerable<IGrouping<string, BenchmarkCase>> GetLogicalGroupOrder(IEnumerable<IGrouping<string, BenchmarkCase>> logicalGroups, IEnumerable<BenchmarkLogicalGroupRule>? order = null) Parameters logicalGroups IEnumerable<IGrouping<string, BenchmarkCase>> order IEnumerable<BenchmarkLogicalGroupRule> Returns IEnumerable<IGrouping<string, BenchmarkCase>> GetSummaryOrder(ImmutableArray<BenchmarkCase>, Summary) IEnumerable<BenchmarkCase> GetSummaryOrder(ImmutableArray<BenchmarkCase> benchmarksCases, Summary summary) Parameters benchmarksCases ImmutableArray<BenchmarkCase> summary Summary Returns IEnumerable<BenchmarkCase>"
  },
  "api/BenchmarkDotNet.Order.JobOrderPolicy.html": {
    "href": "api/BenchmarkDotNet.Order.JobOrderPolicy.html",
    "title": "Enum JobOrderPolicy | BenchmarkDotNet",
    "summary": "Enum JobOrderPolicy Namespace BenchmarkDotNet.Order Assembly BenchmarkDotNet.dll public enum JobOrderPolicy Fields Default = 0 Compare job characteristics in ordinal order. Numeric = 1 Compare job characteristics in numeric order."
  },
  "api/BenchmarkDotNet.Order.MethodOrderPolicy.html": {
    "href": "api/BenchmarkDotNet.Order.MethodOrderPolicy.html",
    "title": "Enum MethodOrderPolicy | BenchmarkDotNet",
    "summary": "Enum MethodOrderPolicy Namespace BenchmarkDotNet.Order Assembly BenchmarkDotNet.dll public enum MethodOrderPolicy Fields Alphabetical = 0 Declared = 1"
  },
  "api/BenchmarkDotNet.Order.SummaryOrderPolicy.html": {
    "href": "api/BenchmarkDotNet.Order.SummaryOrderPolicy.html",
    "title": "Enum SummaryOrderPolicy | BenchmarkDotNet",
    "summary": "Enum SummaryOrderPolicy Namespace BenchmarkDotNet.Order Assembly BenchmarkDotNet.dll public enum SummaryOrderPolicy Fields Declared = 4 Default = 0 FastestToSlowest = 1 Method = 3 SlowestToFastest = 2"
  },
  "api/BenchmarkDotNet.Parameters.html": {
    "href": "api/BenchmarkDotNet.Parameters.html",
    "title": "Namespace BenchmarkDotNet.Parameters | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Parameters Classes ParameterDefinition ParameterDefinitions ParameterExtractor ParameterInstance ParameterInstances"
  },
  "api/BenchmarkDotNet.Parameters.ParameterDefinition.html": {
    "href": "api/BenchmarkDotNet.Parameters.ParameterDefinition.html",
    "title": "Class ParameterDefinition | BenchmarkDotNet",
    "summary": "Class ParameterDefinition Namespace BenchmarkDotNet.Parameters Assembly BenchmarkDotNet.dll public class ParameterDefinition Inheritance object ParameterDefinition Constructors ParameterDefinition(string, bool, object[], bool, Type, int) public ParameterDefinition(string name, bool isStatic, object[] values, bool isArgument, Type parameterType, int priorityInCategory) Parameters name string isStatic bool values object[] isArgument bool parameterType Type priorityInCategory int Properties IsArgument public bool IsArgument { get; } Property Value bool IsStatic public bool IsStatic { get; } Property Value bool Name public string Name { get; } Property Value string ParameterType public Type ParameterType { get; } Property Value Type PriorityInCategory public int PriorityInCategory { get; } Property Value int Values public object[] Values { get; } Property Value object[]"
  },
  "api/BenchmarkDotNet.Parameters.ParameterDefinitions.html": {
    "href": "api/BenchmarkDotNet.Parameters.ParameterDefinitions.html",
    "title": "Class ParameterDefinitions | BenchmarkDotNet",
    "summary": "Class ParameterDefinitions Namespace BenchmarkDotNet.Parameters Assembly BenchmarkDotNet.dll public class ParameterDefinitions Inheritance object ParameterDefinitions Constructors ParameterDefinitions(IReadOnlyList<ParameterDefinition>) public ParameterDefinitions(IReadOnlyList<ParameterDefinition> items) Parameters items IReadOnlyList<ParameterDefinition> Properties Items public IReadOnlyList<ParameterDefinition> Items { get; } Property Value IReadOnlyList<ParameterDefinition> Methods Expand(SummaryStyle) public IReadOnlyList<ParameterInstances> Expand(SummaryStyle summaryStyle) Parameters summaryStyle SummaryStyle Returns IReadOnlyList<ParameterInstances> ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Parameters.ParameterExtractor.html": {
    "href": "api/BenchmarkDotNet.Parameters.ParameterExtractor.html",
    "title": "Class ParameterExtractor | BenchmarkDotNet",
    "summary": "Class ParameterExtractor Namespace BenchmarkDotNet.Parameters Assembly BenchmarkDotNet.dll public static class ParameterExtractor Inheritance object ParameterExtractor"
  },
  "api/BenchmarkDotNet.Parameters.ParameterInstance.html": {
    "href": "api/BenchmarkDotNet.Parameters.ParameterInstance.html",
    "title": "Class ParameterInstance | BenchmarkDotNet",
    "summary": "Class ParameterInstance Namespace BenchmarkDotNet.Parameters Assembly BenchmarkDotNet.dll public class ParameterInstance : IDisposable Inheritance object ParameterInstance Implements IDisposable Constructors ParameterInstance(ParameterDefinition, object, SummaryStyle) public ParameterInstance(ParameterDefinition definition, object value, SummaryStyle summaryStyle) Parameters definition ParameterDefinition value object summaryStyle SummaryStyle Fields NullParameterTextRepresentation public const string NullParameterTextRepresentation = \"?\" Field Value string Properties Definition public ParameterDefinition Definition { get; } Property Value ParameterDefinition IsArgument public bool IsArgument { get; } Property Value bool IsStatic public bool IsStatic { get; } Property Value bool Name public string Name { get; } Property Value string Value public object Value { get; } Property Value object Methods Dispose() public void Dispose() ToDisplayText() public string ToDisplayText() Returns string ToDisplayText(SummaryStyle) public string ToDisplayText(SummaryStyle summary) Parameters summary SummaryStyle Returns string ToSourceCode() public string ToSourceCode() Returns string ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Parameters.ParameterInstances.html": {
    "href": "api/BenchmarkDotNet.Parameters.ParameterInstances.html",
    "title": "Class ParameterInstances | BenchmarkDotNet",
    "summary": "Class ParameterInstances Namespace BenchmarkDotNet.Parameters Assembly BenchmarkDotNet.dll public class ParameterInstances : IEquatable<ParameterInstances>, IDisposable Inheritance object ParameterInstances Implements IEquatable<ParameterInstances> IDisposable Constructors ParameterInstances(IReadOnlyList<ParameterInstance>) public ParameterInstances(IReadOnlyList<ParameterInstance> items) Parameters items IReadOnlyList<ParameterInstance> Properties Count public int Count { get; } Property Value int DisplayInfo public string DisplayInfo { get; } Property Value string FolderInfo public string FolderInfo { get; } Property Value string this[int] public ParameterInstance this[int index] { get; } Parameters index int Property Value ParameterInstance this[string] public object this[string name] { get; } Parameters name string Property Value object Items public IReadOnlyList<ParameterInstance> Items { get; } Property Value IReadOnlyList<ParameterInstance> PrintInfo public string PrintInfo { get; } Property Value string ValueInfo public string ValueInfo { get; } Property Value string Methods Dispose() public void Dispose() Equals(ParameterInstances) public bool Equals(ParameterInstances other) Parameters other ParameterInstances Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetArgument(string) public ParameterInstance GetArgument(string name) Parameters name string Returns ParameterInstance GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/BenchmarkDotNet.Portability.Antivirus.html": {
    "href": "api/BenchmarkDotNet.Portability.Antivirus.html",
    "title": "Class Antivirus | BenchmarkDotNet",
    "summary": "Class Antivirus Namespace BenchmarkDotNet.Portability Assembly BenchmarkDotNet.dll public class Antivirus Inheritance object Antivirus Constructors Antivirus(string, string) public Antivirus(string name, string path) Parameters name string path string Properties Name public string Name { get; } Property Value string Path public string Path { get; } Property Value string Methods ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Portability.CodeGenHelper.html": {
    "href": "api/BenchmarkDotNet.Portability.CodeGenHelper.html",
    "title": "Class CodeGenHelper | BenchmarkDotNet",
    "summary": "Class CodeGenHelper Namespace BenchmarkDotNet.Portability Assembly BenchmarkDotNet.dll public static class CodeGenHelper Inheritance object CodeGenHelper Fields AggressiveOptimizationOption public const MethodImplOptions AggressiveOptimizationOption = AggressiveOptimization Field Value MethodImplOptions AggressiveOptimizationOptionForEmit public const MethodImplAttributes AggressiveOptimizationOptionForEmit = AggressiveOptimization Field Value MethodImplAttributes"
  },
  "api/BenchmarkDotNet.Portability.html": {
    "href": "api/BenchmarkDotNet.Portability.html",
    "title": "Namespace BenchmarkDotNet.Portability | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Portability Classes Antivirus CodeGenHelper HyperV VMware VirtualBox VirtualMachineHypervisor"
  },
  "api/BenchmarkDotNet.Portability.HyperV.html": {
    "href": "api/BenchmarkDotNet.Portability.HyperV.html",
    "title": "Class HyperV | BenchmarkDotNet",
    "summary": "Class HyperV Namespace BenchmarkDotNet.Portability Assembly BenchmarkDotNet.dll public class HyperV : VirtualMachineHypervisor Inheritance object VirtualMachineHypervisor HyperV Inherited Members VirtualMachineHypervisor.ContainsVmIdentifier(string, string) Properties Default public static HyperV Default { get; } Property Value HyperV Name public override string Name { get; } Property Value string Methods IsVirtualMachine(string, string) public override bool IsVirtualMachine(string manufacturer, string model) Parameters manufacturer string model string Returns bool"
  },
  "api/BenchmarkDotNet.Portability.VirtualBox.html": {
    "href": "api/BenchmarkDotNet.Portability.VirtualBox.html",
    "title": "Class VirtualBox | BenchmarkDotNet",
    "summary": "Class VirtualBox Namespace BenchmarkDotNet.Portability Assembly BenchmarkDotNet.dll public class VirtualBox : VirtualMachineHypervisor Inheritance object VirtualMachineHypervisor VirtualBox Inherited Members VirtualMachineHypervisor.ContainsVmIdentifier(string, string) Properties Default public static VirtualBox Default { get; } Property Value VirtualBox Name public override string Name { get; } Property Value string Methods IsVirtualMachine(string, string) public override bool IsVirtualMachine(string manufacturer, string model) Parameters manufacturer string model string Returns bool"
  },
  "api/BenchmarkDotNet.Portability.VirtualMachineHypervisor.html": {
    "href": "api/BenchmarkDotNet.Portability.VirtualMachineHypervisor.html",
    "title": "Class VirtualMachineHypervisor | BenchmarkDotNet",
    "summary": "Class VirtualMachineHypervisor Namespace BenchmarkDotNet.Portability Assembly BenchmarkDotNet.dll public abstract class VirtualMachineHypervisor Inheritance object VirtualMachineHypervisor Derived HyperV VirtualBox VMware Constructors VirtualMachineHypervisor() protected VirtualMachineHypervisor() Properties Name public abstract string Name { get; } Property Value string Methods ContainsVmIdentifier(string, string) protected static bool ContainsVmIdentifier(string systemInformation, string vmIdentifier) Parameters systemInformation string vmIdentifier string Returns bool IsVirtualMachine(string, string) public abstract bool IsVirtualMachine(string manufacturer, string model) Parameters manufacturer string model string Returns bool"
  },
  "api/BenchmarkDotNet.Portability.VMware.html": {
    "href": "api/BenchmarkDotNet.Portability.VMware.html",
    "title": "Class VMware | BenchmarkDotNet",
    "summary": "Class VMware Namespace BenchmarkDotNet.Portability Assembly BenchmarkDotNet.dll public class VMware : VirtualMachineHypervisor Inheritance object VirtualMachineHypervisor VMware Inherited Members VirtualMachineHypervisor.ContainsVmIdentifier(string, string) Properties Default public static VMware Default { get; } Property Value VMware Name public override string Name { get; } Property Value string Methods IsVirtualMachine(string, string) public override bool IsVirtualMachine(string manufacturer, string model) Parameters manufacturer string model string Returns bool"
  },
  "api/BenchmarkDotNet.Properties.BenchmarkDotNetInfo.html": {
    "href": "api/BenchmarkDotNet.Properties.BenchmarkDotNetInfo.html",
    "title": "Class BenchmarkDotNetInfo | BenchmarkDotNet",
    "summary": "Class BenchmarkDotNetInfo Namespace BenchmarkDotNet.Properties Assembly BenchmarkDotNet.dll public class BenchmarkDotNetInfo Inheritance object BenchmarkDotNetInfo Constructors BenchmarkDotNetInfo(Version, string) public BenchmarkDotNetInfo(Version assemblyVersion, string fullVersion) Parameters assemblyVersion Version fullVersion string Fields BenchmarkDotNetCaption public const string BenchmarkDotNetCaption = \"BenchmarkDotNet\" Field Value string Properties AssemblyVersion public Version AssemblyVersion { get; } Property Value Version BrandTitle public string BrandTitle { get; } Property Value string BrandVersion public string BrandVersion { get; } Property Value string FullVersion public string FullVersion { get; } Property Value string Instance public static BenchmarkDotNetInfo Instance { get; } Property Value BenchmarkDotNetInfo IsDevelop public bool IsDevelop { get; } Property Value bool IsNightly public bool IsNightly { get; } Property Value bool IsRelease public bool IsRelease { get; } Property Value bool Methods GetBdnEngineInfo() public EngineInfo GetBdnEngineInfo() Returns EngineInfo"
  },
  "api/BenchmarkDotNet.Properties.html": {
    "href": "api/BenchmarkDotNet.Properties.html",
    "title": "Namespace BenchmarkDotNet.Properties | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Properties Classes BenchmarkDotNetInfo"
  },
  "api/BenchmarkDotNet.Reports.BenchmarkReport.html": {
    "href": "api/BenchmarkDotNet.Reports.BenchmarkReport.html",
    "title": "Class BenchmarkReport | BenchmarkDotNet",
    "summary": "Class BenchmarkReport Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public sealed class BenchmarkReport Inheritance object BenchmarkReport Extension Methods BenchmarkReportExtensions.GetGcInfo(BenchmarkReport) BenchmarkReportExtensions.GetHardwareIntrinsicsInfo(BenchmarkReport) BenchmarkReportExtensions.GetRuntimeInfo(BenchmarkReport) Constructors BenchmarkReport(bool, BenchmarkCase, GenerateResult, BuildResult, IReadOnlyList<ExecuteResult>, IReadOnlyList<Metric>) public BenchmarkReport(bool success, BenchmarkCase benchmarkCase, GenerateResult generateResult, BuildResult buildResult, IReadOnlyList<ExecuteResult> executeResults, IReadOnlyList<Metric> metrics) Parameters success bool benchmarkCase BenchmarkCase generateResult GenerateResult buildResult BuildResult executeResults IReadOnlyList<ExecuteResult> metrics IReadOnlyList<Metric> Properties AllMeasurements public IReadOnlyList<Measurement> AllMeasurements { get; } Property Value IReadOnlyList<Measurement> BenchmarkCase public BenchmarkCase BenchmarkCase { get; } Property Value BenchmarkCase BuildResult public BuildResult BuildResult { get; } Property Value BuildResult ExecuteResults public IReadOnlyList<ExecuteResult> ExecuteResults { get; } Property Value IReadOnlyList<ExecuteResult> GcStats public GcStats GcStats { get; } Property Value GcStats GenerateResult public GenerateResult GenerateResult { get; } Property Value GenerateResult Metrics public IReadOnlyDictionary<string, Metric> Metrics { get; } Property Value IReadOnlyDictionary<string, Metric> ResultStatistics public Statistics? ResultStatistics { get; } Property Value Statistics Success public bool Success { get; } Property Value bool Methods GetResultRuns() public IReadOnlyList<Measurement> GetResultRuns() Returns IReadOnlyList<Measurement> ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Reports.BenchmarkReportExtensions.html": {
    "href": "api/BenchmarkDotNet.Reports.BenchmarkReportExtensions.html",
    "title": "Class BenchmarkReportExtensions | BenchmarkDotNet",
    "summary": "Class BenchmarkReportExtensions Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public static class BenchmarkReportExtensions Inheritance object BenchmarkReportExtensions Methods GetGcInfo(BenchmarkReport) public static string? GetGcInfo(this BenchmarkReport report) Parameters report BenchmarkReport Returns string GetHardwareIntrinsicsInfo(BenchmarkReport) public static string? GetHardwareIntrinsicsInfo(this BenchmarkReport report) Parameters report BenchmarkReport Returns string GetRuntimeInfo(BenchmarkReport) public static string? GetRuntimeInfo(this BenchmarkReport report) Parameters report BenchmarkReport Returns string"
  },
  "api/BenchmarkDotNet.Reports.html": {
    "href": "api/BenchmarkDotNet.Reports.html",
    "title": "Namespace BenchmarkDotNet.Reports | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Reports Classes BenchmarkReport BenchmarkReportExtensions MeasurementExtensions Metric MetricDescriptorEqualityComparer Summary SummaryExtensions SummaryStyle SummaryTable SummaryTable.SummaryTableColumn SummaryTableExtensions Structs Measurement The basic captured statistics for a benchmark Interfaces IMetricDescriptor Enums SummaryTable.SummaryTableColumn.TextJustification"
  },
  "api/BenchmarkDotNet.Reports.IMetricDescriptor.html": {
    "href": "api/BenchmarkDotNet.Reports.IMetricDescriptor.html",
    "title": "Interface IMetricDescriptor | BenchmarkDotNet",
    "summary": "Interface IMetricDescriptor Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public interface IMetricDescriptor Properties DisplayName string DisplayName { get; } Property Value string Id string Id { get; } Property Value string Legend string Legend { get; } Property Value string NumberFormat string NumberFormat { get; } Property Value string PriorityInCategory int PriorityInCategory { get; } Property Value int TheGreaterTheBetter bool TheGreaterTheBetter { get; } Property Value bool Unit string Unit { get; } Property Value string UnitType UnitType UnitType { get; } Property Value UnitType Methods GetIsAvailable(Metric) bool GetIsAvailable(Metric metric) Parameters metric Metric Returns bool"
  },
  "api/BenchmarkDotNet.Reports.Measurement.html": {
    "href": "api/BenchmarkDotNet.Reports.Measurement.html",
    "title": "Struct Measurement | BenchmarkDotNet",
    "summary": "Struct Measurement Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll The basic captured statistics for a benchmark public struct Measurement : IComparable<Measurement> Implements IComparable<Measurement> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() Extension Methods MeasurementExtensions.GetOpsPerSecond(Measurement) MeasurementExtensions.Is(Measurement, IterationMode, IterationStage) MeasurementExtensions.IsOverhead(Measurement) MeasurementExtensions.IsWorkload(Measurement) Constructors Measurement(int, IterationMode, IterationStage, int, long, double) Creates an instance of Measurement struct. public Measurement(int launchIndex, IterationMode iterationMode, IterationStage iterationStage, int iterationIndex, long operations, double nanoseconds) Parameters launchIndex int iterationMode IterationMode iterationStage IterationStage iterationIndex int operations long The number of operations performed. nanoseconds double The total number of nanoseconds it took to perform all operations. Properties IterationIndex public readonly int IterationIndex { get; } Property Value int IterationMode public readonly IterationMode IterationMode { get; } Property Value IterationMode IterationStage public readonly IterationStage IterationStage { get; } Property Value IterationStage LaunchIndex public readonly int LaunchIndex { get; } Property Value int Nanoseconds Gets the total number of nanoseconds it took to perform all operations. public readonly double Nanoseconds { get; } Property Value double Operations Gets the number of operations performed. public readonly long Operations { get; } Property Value long Methods CompareTo(Measurement) public int CompareTo(Measurement other) Parameters other Measurement Returns int GetAverageTime() Gets the average duration of one operation. public TimeInterval GetAverageTime() Returns TimeInterval Parse(string, int) Parses the benchmark statistics from the plain text line. E.g. given the input line: WorkloadTarget 1: 10 op, 1005842518 ns Will extract the number of Operations performed and the total number of Nanoseconds it took to perform them. public static Measurement Parse(string line, int processIndex) Parameters line string The line to parse. processIndex int Process launch index, indexed from one. Returns Measurement An instance of Measurement if parsed successfully. Null in case of any trouble. ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Reports.MeasurementExtensions.html": {
    "href": "api/BenchmarkDotNet.Reports.MeasurementExtensions.html",
    "title": "Class MeasurementExtensions | BenchmarkDotNet",
    "summary": "Class MeasurementExtensions Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public static class MeasurementExtensions Inheritance object MeasurementExtensions Methods GetOpsPerSecond(Measurement) Gets the number of operations performed per second (ops/sec). public static double GetOpsPerSecond(this Measurement report) Parameters report Measurement Returns double Is(Measurement, IterationMode, IterationStage) public static bool Is(this Measurement measurement, IterationMode mode, IterationStage stage) Parameters measurement Measurement mode IterationMode stage IterationStage Returns bool IsOverhead(Measurement) public static bool IsOverhead(this Measurement measurement) Parameters measurement Measurement Returns bool IsWorkload(Measurement) public static bool IsWorkload(this Measurement measurement) Parameters measurement Measurement Returns bool"
  },
  "api/BenchmarkDotNet.Reports.Metric.html": {
    "href": "api/BenchmarkDotNet.Reports.Metric.html",
    "title": "Class Metric | BenchmarkDotNet",
    "summary": "Class Metric Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public class Metric Inheritance object Metric Constructors Metric(IMetricDescriptor, double) public Metric(IMetricDescriptor descriptor, double value) Parameters descriptor IMetricDescriptor value double Properties Descriptor public IMetricDescriptor Descriptor { get; } Property Value IMetricDescriptor Value public double Value { get; } Property Value double"
  },
  "api/BenchmarkDotNet.Reports.MetricDescriptorEqualityComparer.html": {
    "href": "api/BenchmarkDotNet.Reports.MetricDescriptorEqualityComparer.html",
    "title": "Class MetricDescriptorEqualityComparer | BenchmarkDotNet",
    "summary": "Class MetricDescriptorEqualityComparer Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public class MetricDescriptorEqualityComparer : EqualityComparer<IMetricDescriptor>, IEqualityComparer, IEqualityComparer<IMetricDescriptor> Inheritance object EqualityComparer<IMetricDescriptor> MetricDescriptorEqualityComparer Implements IEqualityComparer IEqualityComparer<IMetricDescriptor> Inherited Members EqualityComparer<IMetricDescriptor>.Create(Func<IMetricDescriptor, IMetricDescriptor, bool>, Func<IMetricDescriptor, int>) EqualityComparer<IMetricDescriptor>.Default Constructors MetricDescriptorEqualityComparer() public MetricDescriptorEqualityComparer() Fields Instance public static readonly EqualityComparer<IMetricDescriptor> Instance Field Value EqualityComparer<IMetricDescriptor> Methods Equals(IMetricDescriptor, IMetricDescriptor) public override bool Equals(IMetricDescriptor x, IMetricDescriptor y) Parameters x IMetricDescriptor y IMetricDescriptor Returns bool GetHashCode(IMetricDescriptor) public override int GetHashCode(IMetricDescriptor obj) Parameters obj IMetricDescriptor Returns int"
  },
  "api/BenchmarkDotNet.Reports.Summary.html": {
    "href": "api/BenchmarkDotNet.Reports.Summary.html",
    "title": "Class Summary | BenchmarkDotNet",
    "summary": "Class Summary Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public class Summary Inheritance object Summary Extension Methods ReportExtensions.GetReportFor<T>(Summary, Expression<Action<T>>) ReportExtensions.GetRunsFor<T>(Summary, Expression<Action<T>>) SummaryExtensions.GetColumns(Summary) SummaryExtensions.GetCultureInfo(Summary?) SummaryExtensions.GetLogicalGroupForBenchmark(Summary, BenchmarkCase) Constructors Summary(string, ImmutableArray<BenchmarkReport>, HostEnvironmentInfo, string, string, TimeSpan, CultureInfo, ImmutableArray<ValidationError>, ImmutableArray<IColumnHidingRule>, SummaryStyle?) public Summary(string title, ImmutableArray<BenchmarkReport> reports, HostEnvironmentInfo hostEnvironmentInfo, string resultsDirectoryPath, string logFilePath, TimeSpan totalTime, CultureInfo cultureInfo, ImmutableArray<ValidationError> validationErrors, ImmutableArray<IColumnHidingRule> columnHidingRules, SummaryStyle? summaryStyle = null) Parameters title string reports ImmutableArray<BenchmarkReport> hostEnvironmentInfo HostEnvironmentInfo resultsDirectoryPath string logFilePath string totalTime TimeSpan cultureInfo CultureInfo validationErrors ImmutableArray<ValidationError> columnHidingRules ImmutableArray<IColumnHidingRule> summaryStyle SummaryStyle Properties AllRuntimes public string AllRuntimes { get; } Property Value string BenchmarksCases public ImmutableArray<BenchmarkCase> BenchmarksCases { get; } Property Value ImmutableArray<BenchmarkCase> ColumnHidingRules public ImmutableArray<IColumnHidingRule> ColumnHidingRules { get; } Property Value ImmutableArray<IColumnHidingRule> HasCriticalValidationErrors public bool HasCriticalValidationErrors { get; } Property Value bool HostEnvironmentInfo public HostEnvironmentInfo HostEnvironmentInfo { get; } Property Value HostEnvironmentInfo IsMultipleRuntimes public bool IsMultipleRuntimes { get; } Property Value bool this[BenchmarkCase] Returns a report for the given benchmark or null if there is no a corresponded report. public BenchmarkReport? this[BenchmarkCase benchmarkCase] { get; } Parameters benchmarkCase BenchmarkCase Property Value BenchmarkReport LogFilePath public string LogFilePath { get; } Property Value string Orderer public IOrderer Orderer { get; } Property Value IOrderer Reports public ImmutableArray<BenchmarkReport> Reports { get; } Property Value ImmutableArray<BenchmarkReport> ResultsDirectoryPath public string ResultsDirectoryPath { get; } Property Value string Style public SummaryStyle Style { get; } Property Value SummaryStyle Table public SummaryTable Table { get; } Property Value SummaryTable Title public string Title { get; } Property Value string TotalTime public TimeSpan TotalTime { get; } Property Value TimeSpan ValidationErrors public ImmutableArray<ValidationError> ValidationErrors { get; } Property Value ImmutableArray<ValidationError> Methods GetBaseline(string?) public BenchmarkCase? GetBaseline(string? logicalGroupKey) Parameters logicalGroupKey string Returns BenchmarkCase GetLogicalGroupKey(BenchmarkCase) public string? GetLogicalGroupKey(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns string GetNonBaselines(string) public IEnumerable<BenchmarkCase> GetNonBaselines(string logicalGroupKey) Parameters logicalGroupKey string Returns IEnumerable<BenchmarkCase> GetNumberOfExecutedBenchmarks() public int GetNumberOfExecutedBenchmarks() Returns int HasBaselines() public bool HasBaselines() Returns bool HasReport(BenchmarkCase) public bool HasReport(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns bool IsBaseline(BenchmarkCase) public bool IsBaseline(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Reports.SummaryExtensions.html": {
    "href": "api/BenchmarkDotNet.Reports.SummaryExtensions.html",
    "title": "Class SummaryExtensions | BenchmarkDotNet",
    "summary": "Class SummaryExtensions Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public static class SummaryExtensions Inheritance object SummaryExtensions Methods GetColumns(Summary) public static IColumn[] GetColumns(this Summary summary) Parameters summary Summary Returns IColumn[] GetCultureInfo(Summary?) public static CultureInfo GetCultureInfo(this Summary? summary) Parameters summary Summary Returns CultureInfo GetLogicalGroupForBenchmark(Summary, BenchmarkCase) public static IEnumerable<BenchmarkCase> GetLogicalGroupForBenchmark(this Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns IEnumerable<BenchmarkCase>"
  },
  "api/BenchmarkDotNet.Reports.SummaryStyle.html": {
    "href": "api/BenchmarkDotNet.Reports.SummaryStyle.html",
    "title": "Class SummaryStyle | BenchmarkDotNet",
    "summary": "Class SummaryStyle Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public class SummaryStyle : IEquatable<SummaryStyle> Inheritance object SummaryStyle Implements IEquatable<SummaryStyle> Constructors SummaryStyle(CultureInfo?, bool, SizeUnit?, TimeUnit?, bool, bool, int, RatioStyle, TextJustification, TextJustification) public SummaryStyle(CultureInfo? cultureInfo, bool printUnitsInHeader, SizeUnit? sizeUnit, TimeUnit? timeUnit, bool printUnitsInContent = true, bool printZeroValuesInContent = false, int maxParameterColumnWidth = 20, RatioStyle ratioStyle = RatioStyle.Value, SummaryTable.SummaryTableColumn.TextJustification textColumnJustification = TextJustification.Left, SummaryTable.SummaryTableColumn.TextJustification numericColumnJustification = TextJustification.Right) Parameters cultureInfo CultureInfo printUnitsInHeader bool sizeUnit SizeUnit timeUnit TimeUnit printUnitsInContent bool printZeroValuesInContent bool maxParameterColumnWidth int ratioStyle RatioStyle textColumnJustification SummaryTable.SummaryTableColumn.TextJustification numericColumnJustification SummaryTable.SummaryTableColumn.TextJustification Fields Default public static readonly SummaryStyle Default Field Value SummaryStyle Properties CultureInfo public CultureInfo CultureInfo { get; } Property Value CultureInfo MaxParameterColumnWidth public int MaxParameterColumnWidth { get; } Property Value int NumericColumnJustification public SummaryTable.SummaryTableColumn.TextJustification NumericColumnJustification { get; } Property Value SummaryTable.SummaryTableColumn.TextJustification PrintUnitsInContent public bool PrintUnitsInContent { get; } Property Value bool PrintUnitsInHeader public bool PrintUnitsInHeader { get; } Property Value bool PrintZeroValuesInContent public bool PrintZeroValuesInContent { get; } Property Value bool RatioStyle public RatioStyle RatioStyle { get; } Property Value RatioStyle SizeUnit public SizeUnit? SizeUnit { get; } Property Value SizeUnit TextColumnJustification public SummaryTable.SummaryTableColumn.TextJustification TextColumnJustification { get; } Property Value SummaryTable.SummaryTableColumn.TextJustification TimeUnit public TimeUnit? TimeUnit { get; } Property Value TimeUnit Methods Equals(SummaryStyle) public bool Equals(SummaryStyle other) Parameters other SummaryStyle Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int WithCultureInfo(CultureInfo) public SummaryStyle WithCultureInfo(CultureInfo cultureInfo) Parameters cultureInfo CultureInfo Returns SummaryStyle WithMaxParameterColumnWidth(int) public SummaryStyle WithMaxParameterColumnWidth(int maxParameterColumnWidth) Parameters maxParameterColumnWidth int Returns SummaryStyle WithRatioStyle(RatioStyle) public SummaryStyle WithRatioStyle(RatioStyle ratioStyle) Parameters ratioStyle RatioStyle Returns SummaryStyle WithSizeUnit(SizeUnit) public SummaryStyle WithSizeUnit(SizeUnit sizeUnit) Parameters sizeUnit SizeUnit Returns SummaryStyle WithTimeUnit(TimeUnit) public SummaryStyle WithTimeUnit(TimeUnit timeUnit) Parameters timeUnit TimeUnit Returns SummaryStyle WithZeroMetricValuesInContent() public SummaryStyle WithZeroMetricValuesInContent() Returns SummaryStyle Operators operator ==(SummaryStyle, SummaryStyle) public static bool operator ==(SummaryStyle left, SummaryStyle right) Parameters left SummaryStyle right SummaryStyle Returns bool operator !=(SummaryStyle, SummaryStyle) public static bool operator !=(SummaryStyle left, SummaryStyle right) Parameters left SummaryStyle right SummaryStyle Returns bool"
  },
  "api/BenchmarkDotNet.Reports.SummaryTable.html": {
    "href": "api/BenchmarkDotNet.Reports.SummaryTable.html",
    "title": "Class SummaryTable | BenchmarkDotNet",
    "summary": "Class SummaryTable Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public class SummaryTable Inheritance object SummaryTable Extension Methods SummaryTableExtensions.PrintCommonColumns(SummaryTable, ILogger) SummaryTableExtensions.PrintLine(SummaryTable, string[], ILogger, string, string, bool, bool, MarkdownExporter.MarkdownHighlightStrategy, string, bool) SummaryTableExtensions.PrintLine(SummaryTable, string[], ILogger, string, string) Properties ColumnCount public int ColumnCount { get; } Property Value int Columns public SummaryTable.SummaryTableColumn[] Columns { get; } Property Value SummaryTableColumn[] EffectiveSummaryStyle public SummaryStyle EffectiveSummaryStyle { get; } Property Value SummaryStyle FullContent public string[][] FullContent { get; } Property Value string[][] FullContentStartOfHighlightGroup public bool[] FullContentStartOfHighlightGroup { get; } Property Value bool[] FullContentStartOfLogicalGroup public bool[] FullContentStartOfLogicalGroup { get; } Property Value bool[] FullContentWithHeader public string[][] FullContentWithHeader { get; } Property Value string[][] FullHeader public string[] FullHeader { get; } Property Value string[] IsDefault public bool[] IsDefault { get; } Property Value bool[] SeparateLogicalGroups public bool SeparateLogicalGroups { get; } Property Value bool Summary public Summary Summary { get; } Property Value Summary"
  },
  "api/BenchmarkDotNet.Reports.SummaryTable.SummaryTableColumn.html": {
    "href": "api/BenchmarkDotNet.Reports.SummaryTable.SummaryTableColumn.html",
    "title": "Class SummaryTable.SummaryTableColumn | BenchmarkDotNet",
    "summary": "Class SummaryTable.SummaryTableColumn Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public class SummaryTable.SummaryTableColumn Inheritance object SummaryTable.SummaryTableColumn Constructors SummaryTableColumn(SummaryTable, int, IColumn, bool) public SummaryTableColumn(SummaryTable table, int index, IColumn column, bool hide = false) Parameters table SummaryTable index int column IColumn hide bool Properties Content public string[] Content { get; } Property Value string[] Header public string Header { get; } Property Value string Index public int Index { get; } Property Value int IsDefault public bool IsDefault { get; } Property Value bool Justify public SummaryTable.SummaryTableColumn.TextJustification Justify { get; } Property Value SummaryTable.SummaryTableColumn.TextJustification NeedToShow public bool NeedToShow { get; } Property Value bool OriginalColumn public IColumn OriginalColumn { get; } Property Value IColumn Width public int Width { get; } Property Value int Methods ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Reports.SummaryTable.SummaryTableColumn.TextJustification.html": {
    "href": "api/BenchmarkDotNet.Reports.SummaryTable.SummaryTableColumn.TextJustification.html",
    "title": "Enum SummaryTable.SummaryTableColumn.TextJustification | BenchmarkDotNet",
    "summary": "Enum SummaryTable.SummaryTableColumn.TextJustification Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public enum SummaryTable.SummaryTableColumn.TextJustification Fields Left = 0 Right = 1"
  },
  "api/BenchmarkDotNet.Reports.SummaryTableExtensions.html": {
    "href": "api/BenchmarkDotNet.Reports.SummaryTableExtensions.html",
    "title": "Class SummaryTableExtensions | BenchmarkDotNet",
    "summary": "Class SummaryTableExtensions Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public static class SummaryTableExtensions Inheritance object SummaryTableExtensions Methods PrintCommonColumns(SummaryTable, ILogger) public static void PrintCommonColumns(this SummaryTable table, ILogger logger) Parameters table SummaryTable logger ILogger PrintLine(SummaryTable, string[], ILogger, string, string) public static void PrintLine(this SummaryTable table, string[] line, ILogger logger, string leftDel, string rightDel) Parameters table SummaryTable line string[] logger ILogger leftDel string rightDel string PrintLine(SummaryTable, string[], ILogger, string, string, bool, bool, MarkdownHighlightStrategy, string, bool) public static void PrintLine(this SummaryTable table, string[] line, ILogger logger, string leftDel, string rightDel, bool highlightRow, bool startOfGroup, MarkdownExporter.MarkdownHighlightStrategy startOfGroupHighlightStrategy, string boldMarkupFormat, bool escapeHtml) Parameters table SummaryTable line string[] logger ILogger leftDel string rightDel string highlightRow bool startOfGroup bool startOfGroupHighlightStrategy MarkdownExporter.MarkdownHighlightStrategy boldMarkupFormat string escapeHtml bool"
  },
  "api/BenchmarkDotNet.Running.BenchmarkBuildInfo.html": {
    "href": "api/BenchmarkDotNet.Running.BenchmarkBuildInfo.html",
    "title": "Class BenchmarkBuildInfo | BenchmarkDotNet",
    "summary": "Class BenchmarkBuildInfo Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public class BenchmarkBuildInfo Inheritance object BenchmarkBuildInfo Constructors BenchmarkBuildInfo(BenchmarkCase, ImmutableConfig, int) public BenchmarkBuildInfo(BenchmarkCase benchmarkCase, ImmutableConfig config, int id) Parameters benchmarkCase BenchmarkCase config ImmutableConfig id int Properties BenchmarkCase public BenchmarkCase BenchmarkCase { get; } Property Value BenchmarkCase Config public ImmutableConfig Config { get; } Property Value ImmutableConfig Id public BenchmarkId Id { get; } Property Value BenchmarkId"
  },
  "api/BenchmarkDotNet.Running.BenchmarkCase.html": {
    "href": "api/BenchmarkDotNet.Running.BenchmarkCase.html",
    "title": "Class BenchmarkCase | BenchmarkDotNet",
    "summary": "Class BenchmarkCase Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public class BenchmarkCase : IComparable<BenchmarkCase>, IDisposable Inheritance object BenchmarkCase Implements IComparable<BenchmarkCase> IDisposable Properties Config public ImmutableConfig Config { get; } Property Value ImmutableConfig Descriptor public Descriptor Descriptor { get; } Property Value Descriptor DisplayInfo public string DisplayInfo { get; } Property Value string FolderInfo public string FolderInfo { get; } Property Value string HasArguments public bool HasArguments { get; } Property Value bool HasParameters public bool HasParameters { get; } Property Value bool Job public Job Job { get; } Property Value Job Parameters public ParameterInstances Parameters { get; } Property Value ParameterInstances Methods CompareTo(BenchmarkCase) public int CompareTo(BenchmarkCase other) Parameters other BenchmarkCase Returns int Create(Descriptor, Job, ParameterInstances, ImmutableConfig) public static BenchmarkCase Create(Descriptor descriptor, Job job, ParameterInstances parameters, ImmutableConfig config) Parameters descriptor Descriptor job Job parameters ParameterInstances config ImmutableConfig Returns BenchmarkCase Dispose() public void Dispose() GetRuntime() public Runtime GetRuntime() Returns Runtime ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Running.BenchmarkConverter.html": {
    "href": "api/BenchmarkDotNet.Running.BenchmarkConverter.html",
    "title": "Class BenchmarkConverter | BenchmarkDotNet",
    "summary": "Class BenchmarkConverter Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public static class BenchmarkConverter Inheritance object BenchmarkConverter Methods MethodsToBenchmarks(Type, MethodInfo[], IConfig?) public static BenchmarkRunInfo MethodsToBenchmarks(Type containingType, MethodInfo[] benchmarkMethods, IConfig? config = null) Parameters containingType Type benchmarkMethods MethodInfo[] config IConfig Returns BenchmarkRunInfo TypeToBenchmarks(Type, IConfig?) public static BenchmarkRunInfo TypeToBenchmarks(Type type, IConfig? config = null) Parameters type Type config IConfig Returns BenchmarkRunInfo"
  },
  "api/BenchmarkDotNet.Running.BenchmarkId.html": {
    "href": "api/BenchmarkDotNet.Running.BenchmarkId.html",
    "title": "Struct BenchmarkId | BenchmarkDotNet",
    "summary": "Struct BenchmarkId Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll represents an internal entity used to identify a benchmark within an executable with multiple benchmarks public struct BenchmarkId Constructors BenchmarkId(int, BenchmarkCase) public BenchmarkId(int value, BenchmarkCase benchmarkCase) Parameters value int benchmarkCase BenchmarkCase Properties Value public readonly int Value { get; } Property Value int Methods Equals(BenchmarkId) public bool Equals(BenchmarkId other) Parameters other BenchmarkId Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int ToArguments() public string ToArguments() Returns string ToArguments(string, string) public string ToArguments(string fromBenchmark, string toBenchmark) Parameters fromBenchmark string toBenchmark string Returns string ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Running.BenchmarkPartitioner.html": {
    "href": "api/BenchmarkDotNet.Running.BenchmarkPartitioner.html",
    "title": "Class BenchmarkPartitioner | BenchmarkDotNet",
    "summary": "Class BenchmarkPartitioner Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public static class BenchmarkPartitioner Inheritance object BenchmarkPartitioner Methods CreateForBuild(BenchmarkRunInfo[], IResolver) public static BuildPartition[] CreateForBuild(BenchmarkRunInfo[] supportedBenchmarks, IResolver resolver) Parameters supportedBenchmarks BenchmarkRunInfo[] resolver IResolver Returns BuildPartition[]"
  },
  "api/BenchmarkDotNet.Running.BenchmarkRunInfo.html": {
    "href": "api/BenchmarkDotNet.Running.BenchmarkRunInfo.html",
    "title": "Class BenchmarkRunInfo | BenchmarkDotNet",
    "summary": "Class BenchmarkRunInfo Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public class BenchmarkRunInfo : IDisposable Inheritance object BenchmarkRunInfo Implements IDisposable Constructors BenchmarkRunInfo(BenchmarkCase[], Type, ImmutableConfig) public BenchmarkRunInfo(BenchmarkCase[] benchmarksCase, Type type, ImmutableConfig config) Parameters benchmarksCase BenchmarkCase[] type Type config ImmutableConfig Properties BenchmarksCases public BenchmarkCase[] BenchmarksCases { get; } Property Value BenchmarkCase[] Config public ImmutableConfig Config { get; } Property Value ImmutableConfig Type public Type Type { get; } Property Value Type Methods Dispose() public void Dispose()"
  },
  "api/BenchmarkDotNet.Running.BenchmarkRunner.html": {
    "href": "api/BenchmarkDotNet.Running.BenchmarkRunner.html",
    "title": "Class BenchmarkRunner | BenchmarkDotNet",
    "summary": "Class BenchmarkRunner Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public static class BenchmarkRunner Inheritance object BenchmarkRunner Methods Run(BenchmarkRunInfo) public static Summary Run(BenchmarkRunInfo benchmarkRunInfo) Parameters benchmarkRunInfo BenchmarkRunInfo Returns Summary Run(BenchmarkRunInfo[]) public static Summary[] Run(BenchmarkRunInfo[] benchmarkRunInfos) Parameters benchmarkRunInfos BenchmarkRunInfo[] Returns Summary[] Run(Assembly, IConfig?, string[]?) public static Summary[] Run(Assembly assembly, IConfig? config = null, string[]? args = null) Parameters assembly Assembly config IConfig args string[] Returns Summary[] Run(Type, IConfig?, string[]?) public static Summary Run(Type type, IConfig? config = null, string[]? args = null) Parameters type Type config IConfig args string[] Returns Summary Run(Type, MethodInfo[], IConfig?) public static Summary Run(Type type, MethodInfo[] methods, IConfig? config = null) Parameters type Type methods MethodInfo[] config IConfig Returns Summary Run(Type[], IConfig?, string[]?) public static Summary[] Run(Type[] types, IConfig? config = null, string[]? args = null) Parameters types Type[] config IConfig args string[] Returns Summary[] Run<T>(IConfig?, string[]?) public static Summary Run<T>(IConfig? config = null, string[]? args = null) Parameters config IConfig args string[] Returns Summary Type Parameters T"
  },
  "api/BenchmarkDotNet.Running.BenchmarkSwitcher.html": {
    "href": "api/BenchmarkDotNet.Running.BenchmarkSwitcher.html",
    "title": "Class BenchmarkSwitcher | BenchmarkDotNet",
    "summary": "Class BenchmarkSwitcher Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public class BenchmarkSwitcher Inheritance object BenchmarkSwitcher Constructors BenchmarkSwitcher(Assembly) public BenchmarkSwitcher(Assembly assembly) Parameters assembly Assembly BenchmarkSwitcher(Assembly[]) public BenchmarkSwitcher(Assembly[] assemblies) Parameters assemblies Assembly[] BenchmarkSwitcher(Type[]) public BenchmarkSwitcher(Type[] types) Parameters types Type[] Methods FromAssemblies(Assembly[]) public static BenchmarkSwitcher FromAssemblies(Assembly[] assemblies) Parameters assemblies Assembly[] Returns BenchmarkSwitcher FromAssembly(Assembly) public static BenchmarkSwitcher FromAssembly(Assembly assembly) Parameters assembly Assembly Returns BenchmarkSwitcher FromTypes(Type[]) public static BenchmarkSwitcher FromTypes(Type[] types) Parameters types Type[] Returns BenchmarkSwitcher Run(string[]?, IConfig?) public IEnumerable<Summary> Run(string[]? args = null, IConfig? config = null) Parameters args string[] config IConfig Returns IEnumerable<Summary> RunAll(IConfig?, string[]?) Run all available benchmarks. public IEnumerable<Summary> RunAll(IConfig? config = null, string[]? args = null) Parameters config IConfig args string[] Returns IEnumerable<Summary> RunAllJoined(IConfig?, string[]?) Run all available benchmarks and join them to a single summary public Summary RunAllJoined(IConfig? config = null, string[]? args = null) Parameters config IConfig args string[] Returns Summary With(Assembly) public BenchmarkSwitcher With(Assembly assembly) Parameters assembly Assembly Returns BenchmarkSwitcher With(Assembly[]) public BenchmarkSwitcher With(Assembly[] assemblies) Parameters assemblies Assembly[] Returns BenchmarkSwitcher With(Type) public BenchmarkSwitcher With(Type type) Parameters type Type Returns BenchmarkSwitcher With(Type[]) public BenchmarkSwitcher With(Type[] types) Parameters types Type[] Returns BenchmarkSwitcher"
  },
  "api/BenchmarkDotNet.Running.BuildPartition.html": {
    "href": "api/BenchmarkDotNet.Running.BuildPartition.html",
    "title": "Class BuildPartition | BenchmarkDotNet",
    "summary": "Class BuildPartition Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public class BuildPartition Inheritance object BuildPartition Constructors BuildPartition(BenchmarkBuildInfo[], IResolver) public BuildPartition(BenchmarkBuildInfo[] benchmarks, IResolver resolver) Parameters benchmarks BenchmarkBuildInfo[] resolver IResolver Properties AssemblyLocation public string AssemblyLocation { get; } Property Value string Benchmarks public BenchmarkBuildInfo[] Benchmarks { get; } Property Value BenchmarkBuildInfo[] BuildConfiguration public string BuildConfiguration { get; } Property Value string GenerateMSBuildBinLog public bool GenerateMSBuildBinLog { get; } Property Value bool IsCustomBuildConfiguration public bool IsCustomBuildConfiguration { get; } Property Value bool IsNativeAot public bool IsNativeAot { get; } Property Value bool IsNetFramework public bool IsNetFramework { get; } Property Value bool IsWasm public bool IsWasm { get; } Property Value bool Jit public Jit Jit { get; } Property Value Jit LogBuildOutput public bool LogBuildOutput { get; } Property Value bool Platform public Platform Platform { get; } Property Value Platform ProgramName public string ProgramName { get; } Property Value string RepresentativeBenchmarkCase the benchmarks are grouped by the build settings so you can use this benchmark to get the runtime settings public BenchmarkCase RepresentativeBenchmarkCase { get; } Property Value BenchmarkCase Resolver public IResolver Resolver { get; } Property Value IResolver Runtime public Runtime Runtime { get; } Property Value Runtime Timeout public TimeSpan Timeout { get; } Property Value TimeSpan Methods ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Running.DefaultCategoryDiscoverer.html": {
    "href": "api/BenchmarkDotNet.Running.DefaultCategoryDiscoverer.html",
    "title": "Class DefaultCategoryDiscoverer | BenchmarkDotNet",
    "summary": "Class DefaultCategoryDiscoverer Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public class DefaultCategoryDiscoverer : ICategoryDiscoverer Inheritance object DefaultCategoryDiscoverer Implements ICategoryDiscoverer Constructors DefaultCategoryDiscoverer(bool) public DefaultCategoryDiscoverer(bool inherit = true) Parameters inherit bool Fields Instance public static readonly ICategoryDiscoverer Instance Field Value ICategoryDiscoverer Methods GetCategories(MethodInfo) public virtual string[] GetCategories(MethodInfo method) Parameters method MethodInfo Returns string[]"
  },
  "api/BenchmarkDotNet.Running.Descriptor.html": {
    "href": "api/BenchmarkDotNet.Running.Descriptor.html",
    "title": "Class Descriptor | BenchmarkDotNet",
    "summary": "Class Descriptor Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public class Descriptor : IEquatable<Descriptor> Inheritance object Descriptor Implements IEquatable<Descriptor> Constructors Descriptor(Type, MethodInfo, MethodInfo?, MethodInfo?, MethodInfo?, MethodInfo?, string?, string?, bool, string[]?, int, int) public Descriptor(Type type, MethodInfo workloadMethod, MethodInfo? globalSetupMethod = null, MethodInfo? globalCleanupMethod = null, MethodInfo? iterationSetupMethod = null, MethodInfo? iterationCleanupMethod = null, string? description = null, string? additionalLogic = null, bool baseline = false, string[]? categories = null, int operationsPerInvoke = 1, int methodIndex = 0) Parameters type Type workloadMethod MethodInfo globalSetupMethod MethodInfo globalCleanupMethod MethodInfo iterationSetupMethod MethodInfo iterationCleanupMethod MethodInfo description string additionalLogic string baseline bool categories string[] operationsPerInvoke int methodIndex int Properties AdditionalLogic public string AdditionalLogic { get; } Property Value string Baseline public bool Baseline { get; } Property Value bool Categories public string[] Categories { get; } Property Value string[] DisplayInfo public string DisplayInfo { get; } Property Value string FolderInfo public string FolderInfo { get; } Property Value string GlobalCleanupMethod public MethodInfo? GlobalCleanupMethod { get; } Property Value MethodInfo GlobalSetupMethod public MethodInfo? GlobalSetupMethod { get; } Property Value MethodInfo IterationCleanupMethod public MethodInfo? IterationCleanupMethod { get; } Property Value MethodInfo IterationSetupMethod public MethodInfo? IterationSetupMethod { get; } Property Value MethodInfo MethodIndex public int MethodIndex { get; } Property Value int OperationsPerInvoke public int OperationsPerInvoke { get; } Property Value int Type public Type Type { get; } Property Value Type WorkloadMethod public MethodInfo WorkloadMethod { get; } Property Value MethodInfo WorkloadMethodDisplayInfo public string WorkloadMethodDisplayInfo { get; } Property Value string Methods Equals(Descriptor?) public bool Equals(Descriptor? other) Parameters other Descriptor Returns bool Equals(object?) public override bool Equals(object? obj) Parameters obj object Returns bool GetFilterName() public string GetFilterName() Returns string GetHashCode() public override int GetHashCode() Returns int HasCategory(string) public bool HasCategory(string category) Parameters category string Returns bool ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Running.html": {
    "href": "api/BenchmarkDotNet.Running.html",
    "title": "Namespace BenchmarkDotNet.Running | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Running Classes BenchmarkBuildInfo BenchmarkCase BenchmarkConverter BenchmarkPartitioner BenchmarkRunInfo BenchmarkRunner BenchmarkSwitcher BuildPartition DefaultCategoryDiscoverer Descriptor InvalidBenchmarkDeclarationException TypeFilter Structs BenchmarkId represents an internal entity used to identify a benchmark within an executable with multiple benchmarks Interfaces ICategoryDiscoverer"
  },
  "api/BenchmarkDotNet.Running.ICategoryDiscoverer.html": {
    "href": "api/BenchmarkDotNet.Running.ICategoryDiscoverer.html",
    "title": "Interface ICategoryDiscoverer | BenchmarkDotNet",
    "summary": "Interface ICategoryDiscoverer Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public interface ICategoryDiscoverer Methods GetCategories(MethodInfo) string[] GetCategories(MethodInfo method) Parameters method MethodInfo Returns string[]"
  },
  "api/BenchmarkDotNet.Running.InvalidBenchmarkDeclarationException.html": {
    "href": "api/BenchmarkDotNet.Running.InvalidBenchmarkDeclarationException.html",
    "title": "Class InvalidBenchmarkDeclarationException | BenchmarkDotNet",
    "summary": "Class InvalidBenchmarkDeclarationException Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public class InvalidBenchmarkDeclarationException : Exception, ISerializable Inheritance object Exception InvalidBenchmarkDeclarationException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace Exception.SerializeObjectState Constructors InvalidBenchmarkDeclarationException(string) public InvalidBenchmarkDeclarationException(string message) Parameters message string"
  },
  "api/BenchmarkDotNet.Running.TypeFilter.html": {
    "href": "api/BenchmarkDotNet.Running.TypeFilter.html",
    "title": "Class TypeFilter | BenchmarkDotNet",
    "summary": "Class TypeFilter Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public static class TypeFilter Inheritance object TypeFilter Methods Filter(IConfig, IEnumerable<Type>) public static BenchmarkRunInfo[] Filter(IConfig effectiveConfig, IEnumerable<Type> types) Parameters effectiveConfig IConfig types IEnumerable<Type> Returns BenchmarkRunInfo[] GetTypesWithRunnableBenchmarks(IEnumerable<Type>, IEnumerable<Assembly>, ILogger) public static (bool allTypesValid, IReadOnlyList<Type> runnable) GetTypesWithRunnableBenchmarks(IEnumerable<Type> types, IEnumerable<Assembly> assemblies, ILogger logger) Parameters types IEnumerable<Type> assemblies IEnumerable<Assembly> logger ILogger Returns (bool allTypesValid, IReadOnlyList<Type> runnable)"
  },
  "api/BenchmarkDotNet.Toolchains.ArtifactsPaths.html": {
    "href": "api/BenchmarkDotNet.Toolchains.ArtifactsPaths.html",
    "title": "Class ArtifactsPaths | BenchmarkDotNet",
    "summary": "Class ArtifactsPaths Namespace BenchmarkDotNet.Toolchains Assembly BenchmarkDotNet.dll public class ArtifactsPaths Inheritance object ArtifactsPaths Derived InProcessEmitArtifactsPath Constructors ArtifactsPaths(string, string, string, string, string, string, string, string, string, string, string, string) public ArtifactsPaths(string rootArtifactsFolderPath, string buildArtifactsDirectoryPath, string binariesDirectoryPath, string publishDirectoryPath, string programCodePath, string appConfigPath, string nuGetConfigPath, string projectFilePath, string buildScriptFilePath, string executablePath, string programName, string packagesDirectoryName) Parameters rootArtifactsFolderPath string buildArtifactsDirectoryPath string binariesDirectoryPath string publishDirectoryPath string programCodePath string appConfigPath string nuGetConfigPath string projectFilePath string buildScriptFilePath string executablePath string programName string packagesDirectoryName string Fields Empty public static readonly ArtifactsPaths Empty Field Value ArtifactsPaths Properties AppConfigPath public string AppConfigPath { get; } Property Value string BinariesDirectoryPath public string BinariesDirectoryPath { get; } Property Value string BuildArtifactsDirectoryPath public string BuildArtifactsDirectoryPath { get; } Property Value string BuildScriptFilePath public string BuildScriptFilePath { get; } Property Value string ExecutablePath public string ExecutablePath { get; } Property Value string NuGetConfigPath public string NuGetConfigPath { get; } Property Value string PackagesDirectoryName public string PackagesDirectoryName { get; } Property Value string ProgramCodePath public string ProgramCodePath { get; } Property Value string ProgramName public string ProgramName { get; } Property Value string ProjectFilePath public string ProjectFilePath { get; } Property Value string PublishDirectoryPath public string PublishDirectoryPath { get; } Property Value string RootArtifactsFolderPath public string RootArtifactsFolderPath { get; } Property Value string"
  },
  "api/BenchmarkDotNet.Toolchains.CoreRt.CoreRtToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.CoreRt.CoreRtToolchain.html",
    "title": "Class CoreRtToolchain | BenchmarkDotNet",
    "summary": "Class CoreRtToolchain Namespace BenchmarkDotNet.Toolchains.CoreRt Assembly BenchmarkDotNet.dll [Obsolete(\"Please use NativeAotToolchain instead.\", true)] public class CoreRtToolchain Inheritance object CoreRtToolchain Constructors CoreRtToolchain() public CoreRtToolchain()"
  },
  "api/BenchmarkDotNet.Toolchains.CoreRt.CoreRtToolchainBuilder.html": {
    "href": "api/BenchmarkDotNet.Toolchains.CoreRt.CoreRtToolchainBuilder.html",
    "title": "Class CoreRtToolchainBuilder | BenchmarkDotNet",
    "summary": "Class CoreRtToolchainBuilder Namespace BenchmarkDotNet.Toolchains.CoreRt Assembly BenchmarkDotNet.dll [Obsolete(\"Please use NativeAotToolchainBuilder instead.\", true)] public class CoreRtToolchainBuilder Inheritance object CoreRtToolchainBuilder Constructors CoreRtToolchainBuilder() public CoreRtToolchainBuilder()"
  },
  "api/BenchmarkDotNet.Toolchains.CoreRt.html": {
    "href": "api/BenchmarkDotNet.Toolchains.CoreRt.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.CoreRt | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.CoreRt Classes CoreRtToolchain CoreRtToolchainBuilder"
  },
  "api/BenchmarkDotNet.Toolchains.CoreRun.CoreRunGenerator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.CoreRun.CoreRunGenerator.html",
    "title": "Class CoreRunGenerator | BenchmarkDotNet",
    "summary": "Class CoreRunGenerator Namespace BenchmarkDotNet.Toolchains.CoreRun Assembly BenchmarkDotNet.dll public class CoreRunGenerator : CsProjGenerator, IGenerator, IEquatable<CsProjGenerator> Inheritance object GeneratorBase DotNetCliGenerator CsProjGenerator CoreRunGenerator Implements IGenerator IEquatable<CsProjGenerator> Inherited Members CsProjGenerator.GetBuildArtifactsDirectoryPath(BuildPartition, string) CsProjGenerator.GetProjectFilePath(string) CsProjGenerator.GenerateProject(BuildPartition, ArtifactsPaths, ILogger) CsProjGenerator.GetRuntimeSettings(GcMode, IResolver) CsProjGenerator.GetProjectFilePath(Type, ILogger) CsProjGenerator.Equals(object) CsProjGenerator.Equals(CsProjGenerator) CsProjGenerator.GetHashCode() CsProjGenerator.RuntimeFrameworkVersion DotNetCliGenerator.GetExecutableExtension() DotNetCliGenerator.GenerateBuildScript(BuildPartition, ArtifactsPaths) DotNetCliGenerator.TargetFrameworkMoniker DotNetCliGenerator.CliPath DotNetCliGenerator.PackagesPath DotNetCliGenerator.IsNetCore GeneratorBase.GenerateProject(BuildPartition, ILogger, string) GeneratorBase.GetPublishDirectoryPath(string, string) GeneratorBase.GenerateNuGetConfig(ArtifactsPaths) GeneratorBase.GenerateAppConfig(BuildPartition, ArtifactsPaths) GeneratorBase.GenerateCode(BuildPartition, ArtifactsPaths) GeneratorBase.GetExecutablePath(string, string) Constructors CoreRunGenerator(FileInfo, FileInfo, string, string, string) public CoreRunGenerator(FileInfo sourceCoreRun, FileInfo copyCoreRun, string targetFrameworkMoniker, string cliPath, string packagesPath) Parameters sourceCoreRun FileInfo copyCoreRun FileInfo targetFrameworkMoniker string cliPath string packagesPath string Methods CopyAllRequiredFiles(ArtifactsPaths) if you need to copy some extra files to make the benchmarks work you should override this method protected override void CopyAllRequiredFiles(ArtifactsPaths artifactsPaths) Parameters artifactsPaths ArtifactsPaths GetArtifactsToCleanup(ArtifactsPaths) returns a list of artifacts that should be removed after running the benchmarks protected override string[] GetArtifactsToCleanup(ArtifactsPaths artifactsPaths) Parameters artifactsPaths ArtifactsPaths Returns string[] GetBinariesDirectoryPath(string, string) returns a path where executable should be found after the build (usually \\bin) protected override string GetBinariesDirectoryPath(string buildArtifactsDirectoryPath, string configuration) Parameters buildArtifactsDirectoryPath string configuration string Returns string GetPackagesDirectoryPath(string) returns a path to the folder where NuGet packages should be restored protected override string GetPackagesDirectoryPath(string buildArtifactsDirectoryPath) Parameters buildArtifactsDirectoryPath string Returns string"
  },
  "api/BenchmarkDotNet.Toolchains.CoreRun.CoreRunPublisher.html": {
    "href": "api/BenchmarkDotNet.Toolchains.CoreRun.CoreRunPublisher.html",
    "title": "Class CoreRunPublisher | BenchmarkDotNet",
    "summary": "Class CoreRunPublisher Namespace BenchmarkDotNet.Toolchains.CoreRun Assembly BenchmarkDotNet.dll public class CoreRunPublisher : IBuilder Inheritance object CoreRunPublisher Implements IBuilder Constructors CoreRunPublisher(FileInfo, FileInfo?) public CoreRunPublisher(FileInfo coreRun, FileInfo? customDotNetCliPath = null) Parameters coreRun FileInfo customDotNetCliPath FileInfo Methods Build(GenerateResult, BuildPartition, ILogger) public BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger) Parameters generateResult GenerateResult buildPartition BuildPartition logger ILogger Returns BuildResult"
  },
  "api/BenchmarkDotNet.Toolchains.CoreRun.CoreRunToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.CoreRun.CoreRunToolchain.html",
    "title": "Class CoreRunToolchain | BenchmarkDotNet",
    "summary": "Class CoreRunToolchain Namespace BenchmarkDotNet.Toolchains.CoreRun Assembly BenchmarkDotNet.dll public class CoreRunToolchain : IToolchain Inheritance object CoreRunToolchain Implements IToolchain Constructors CoreRunToolchain(FileInfo, bool, string, FileInfo?, DirectoryInfo?, string) creates a CoreRunToolchain which is using provided CoreRun to execute .NET Core apps public CoreRunToolchain(FileInfo coreRun, bool createCopy = true, string targetFrameworkMoniker = \"net8.0\", FileInfo? customDotNetCliPath = null, DirectoryInfo? restorePath = null, string displayName = \"CoreRun\") Parameters coreRun FileInfo the path to CoreRun createCopy bool should a copy of CoreRun be performed? True by default. The toolchain replaces old dependencies in CoreRun folder with newer versions if used by the benchmarks. targetFrameworkMoniker string TFM, net8.0 is the default customDotNetCliPath FileInfo path to dotnet cli, if not provided the one from PATH will be used restorePath DirectoryInfo the directory to restore packages to displayName string display name, CoreRun is the default value Properties Builder public IBuilder Builder { get; } Property Value IBuilder CopyCoreRun public FileInfo CopyCoreRun { get; } Property Value FileInfo CustomDotNetCliPath public FileInfo CustomDotNetCliPath { get; } Property Value FileInfo Executor public IExecutor Executor { get; } Property Value IExecutor Generator public IGenerator Generator { get; } Property Value IGenerator IsInProcess public bool IsInProcess { get; } Property Value bool Name public string Name { get; } Property Value string RestorePath public DirectoryInfo RestorePath { get; } Property Value DirectoryInfo SourceCoreRun public FileInfo SourceCoreRun { get; } Property Value FileInfo Methods ToString() public override string ToString() Returns string Validate(BenchmarkCase, IResolver) public IEnumerable<ValidationError> Validate(BenchmarkCase benchmark, IResolver resolver) Parameters benchmark BenchmarkCase resolver IResolver Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Toolchains.CoreRun.html": {
    "href": "api/BenchmarkDotNet.Toolchains.CoreRun.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.CoreRun | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.CoreRun Classes CoreRunGenerator CoreRunPublisher CoreRunToolchain"
  },
  "api/BenchmarkDotNet.Toolchains.CsProj.CsProjClassicNetToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.CsProj.CsProjClassicNetToolchain.html",
    "title": "Class CsProjClassicNetToolchain | BenchmarkDotNet",
    "summary": "Class CsProjClassicNetToolchain Namespace BenchmarkDotNet.Toolchains.CsProj Assembly BenchmarkDotNet.dll this toolchain is designed for the new .csprojs, to build .NET 4.x benchmarks from the context of .NET Core host process it does not work with the old .csprojs or project.json! public class CsProjClassicNetToolchain : Toolchain, IToolchain Inheritance object Toolchain CsProjClassicNetToolchain Implements IToolchain Inherited Members Toolchain.ToString() Toolchain.Name Toolchain.Generator Toolchain.Builder Toolchain.Executor Toolchain.IsInProcess Fields Net461 public static readonly IToolchain Net461 Field Value IToolchain Net462 public static readonly IToolchain Net462 Field Value IToolchain Net47 public static readonly IToolchain Net47 Field Value IToolchain Net471 public static readonly IToolchain Net471 Field Value IToolchain Net472 public static readonly IToolchain Net472 Field Value IToolchain Net48 public static readonly IToolchain Net48 Field Value IToolchain Net481 public static readonly IToolchain Net481 Field Value IToolchain Methods From(string, string?, string?) public static IToolchain From(string targetFrameworkMoniker, string? packagesPath = null, string? customDotNetCliPath = null) Parameters targetFrameworkMoniker string packagesPath string customDotNetCliPath string Returns IToolchain Validate(BenchmarkCase, IResolver) public override IEnumerable<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver) Parameters benchmarkCase BenchmarkCase resolver IResolver Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Toolchains.CsProj.CsProjCoreToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.CsProj.CsProjCoreToolchain.html",
    "title": "Class CsProjCoreToolchain | BenchmarkDotNet",
    "summary": "Class CsProjCoreToolchain Namespace BenchmarkDotNet.Toolchains.CsProj Assembly BenchmarkDotNet.dll public class CsProjCoreToolchain : Toolchain, IToolchain, IEquatable<CsProjCoreToolchain> Inheritance object Toolchain CsProjCoreToolchain Implements IToolchain IEquatable<CsProjCoreToolchain> Derived MonoToolchain Inherited Members Toolchain.ToString() Toolchain.Name Toolchain.Generator Toolchain.Builder Toolchain.Executor Toolchain.IsInProcess Fields NetCoreApp10_0 public static readonly IToolchain NetCoreApp10_0 Field Value IToolchain NetCoreApp20 public static readonly IToolchain NetCoreApp20 Field Value IToolchain NetCoreApp21 public static readonly IToolchain NetCoreApp21 Field Value IToolchain NetCoreApp22 public static readonly IToolchain NetCoreApp22 Field Value IToolchain NetCoreApp30 public static readonly IToolchain NetCoreApp30 Field Value IToolchain NetCoreApp31 public static readonly IToolchain NetCoreApp31 Field Value IToolchain NetCoreApp50 public static readonly IToolchain NetCoreApp50 Field Value IToolchain NetCoreApp60 public static readonly IToolchain NetCoreApp60 Field Value IToolchain NetCoreApp70 public static readonly IToolchain NetCoreApp70 Field Value IToolchain NetCoreApp80 public static readonly IToolchain NetCoreApp80 Field Value IToolchain NetCoreApp90 public static readonly IToolchain NetCoreApp90 Field Value IToolchain Methods Equals(CsProjCoreToolchain) public bool Equals(CsProjCoreToolchain other) Parameters other CsProjCoreToolchain Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool From(NetCoreAppSettings) public static IToolchain From(NetCoreAppSettings settings) Parameters settings NetCoreAppSettings Returns IToolchain GetHashCode() public override int GetHashCode() Returns int Validate(BenchmarkCase, IResolver) public override IEnumerable<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver) Parameters benchmarkCase BenchmarkCase resolver IResolver Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Toolchains.CsProj.CsProjGenerator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.CsProj.CsProjGenerator.html",
    "title": "Class CsProjGenerator | BenchmarkDotNet",
    "summary": "Class CsProjGenerator Namespace BenchmarkDotNet.Toolchains.CsProj Assembly BenchmarkDotNet.dll public class CsProjGenerator : DotNetCliGenerator, IGenerator, IEquatable<CsProjGenerator> Inheritance object GeneratorBase DotNetCliGenerator CsProjGenerator Implements IGenerator IEquatable<CsProjGenerator> Derived CoreRunGenerator MonoGenerator MonoAotLLVMGenerator WasmGenerator Generator Inherited Members DotNetCliGenerator.GetExecutableExtension() DotNetCliGenerator.GetArtifactsToCleanup(ArtifactsPaths) DotNetCliGenerator.CopyAllRequiredFiles(ArtifactsPaths) DotNetCliGenerator.GetPackagesDirectoryPath(string) DotNetCliGenerator.GenerateBuildScript(BuildPartition, ArtifactsPaths) DotNetCliGenerator.TargetFrameworkMoniker DotNetCliGenerator.CliPath DotNetCliGenerator.PackagesPath DotNetCliGenerator.IsNetCore GeneratorBase.GenerateProject(BuildPartition, ILogger, string) GeneratorBase.GetPublishDirectoryPath(string, string) GeneratorBase.GenerateNuGetConfig(ArtifactsPaths) GeneratorBase.GenerateAppConfig(BuildPartition, ArtifactsPaths) GeneratorBase.GenerateCode(BuildPartition, ArtifactsPaths) GeneratorBase.GetExecutablePath(string, string) Constructors CsProjGenerator(string, string, string, string, bool) public CsProjGenerator(string targetFrameworkMoniker, string cliPath, string packagesPath, string runtimeFrameworkVersion, bool isNetCore = true) Parameters targetFrameworkMoniker string cliPath string packagesPath string runtimeFrameworkVersion string isNetCore bool Properties RuntimeFrameworkVersion public string RuntimeFrameworkVersion { get; } Property Value string Methods Equals(CsProjGenerator) public bool Equals(CsProjGenerator other) Parameters other CsProjGenerator Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GenerateProject(BuildPartition, ArtifactsPaths, ILogger) generates .csproj file with a reference to the project with benchmarks protected override void GenerateProject(BuildPartition buildPartition, ArtifactsPaths artifactsPaths, ILogger logger) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths logger ILogger GetBinariesDirectoryPath(string, string) returns a path where executable should be found after the build (usually \\bin) protected override string GetBinariesDirectoryPath(string buildArtifactsDirectoryPath, string configuration) Parameters buildArtifactsDirectoryPath string configuration string Returns string GetBuildArtifactsDirectoryPath(BuildPartition, string) we need our folder to be on the same level as the project that we want to reference we are limited by xprojs (by default compiles all .cs files in all subfolders, Program.cs could be doubled and fail the build) and also by NuGet internal implementation like looking for global.json file in parent folders protected override string GetBuildArtifactsDirectoryPath(BuildPartition buildPartition, string programName) Parameters buildPartition BuildPartition programName string Returns string GetHashCode() public override int GetHashCode() Returns int GetProjectFilePath(string) returns a path to the auto-generated .csproj file protected override string GetProjectFilePath(string buildArtifactsDirectoryPath) Parameters buildArtifactsDirectoryPath string Returns string GetProjectFilePath(Type, ILogger) returns a path to the project file which defines the benchmarks protected virtual FileInfo GetProjectFilePath(Type benchmarkTarget, ILogger logger) Parameters benchmarkTarget Type logger ILogger Returns FileInfo GetRuntimeSettings(GcMode, IResolver) returns an MSBuild string that defines Runtime settings protected virtual string GetRuntimeSettings(GcMode gcMode, IResolver resolver) Parameters gcMode GcMode resolver IResolver Returns string"
  },
  "api/BenchmarkDotNet.Toolchains.CsProj.html": {
    "href": "api/BenchmarkDotNet.Toolchains.CsProj.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.CsProj | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.CsProj Classes CsProjClassicNetToolchain this toolchain is designed for the new .csprojs, to build .NET 4.x benchmarks from the context of .NET Core host process it does not work with the old .csprojs or project.json! CsProjCoreToolchain CsProjGenerator"
  },
  "api/BenchmarkDotNet.Toolchains.DotNetCli.CustomDotNetCliToolchainBuilder.html": {
    "href": "api/BenchmarkDotNet.Toolchains.DotNetCli.CustomDotNetCliToolchainBuilder.html",
    "title": "Class CustomDotNetCliToolchainBuilder | BenchmarkDotNet",
    "summary": "Class CustomDotNetCliToolchainBuilder Namespace BenchmarkDotNet.Toolchains.DotNetCli Assembly BenchmarkDotNet.dll public abstract class CustomDotNetCliToolchainBuilder Inheritance object CustomDotNetCliToolchainBuilder Derived NativeAotToolchainBuilder Constructors CustomDotNetCliToolchainBuilder() protected CustomDotNetCliToolchainBuilder() Fields Feeds protected readonly Dictionary<string, string> Feeds Field Value Dictionary<string, string> customDotNetCliPath protected string customDotNetCliPath Field Value string displayName protected string displayName Field Value string runtimeFrameworkVersion protected string runtimeFrameworkVersion Field Value string runtimeIdentifier protected string runtimeIdentifier Field Value string useNuGetClearTag protected bool useNuGetClearTag Field Value bool useTempFolderForRestore protected bool useTempFolderForRestore Field Value bool Methods AdditionalNuGetFeed(string, string) it allows you to define an additional NuGet feed, you can seal the feeds list by using the UseNuGetClearTag() method public CustomDotNetCliToolchainBuilder AdditionalNuGetFeed(string feedName, string feedAddress) Parameters feedName string the name of the feed, will be used in the auto-generated NuGet.config file feedAddress string the address of the feed, will be used in the auto-generated NuGet.config file Returns CustomDotNetCliToolchainBuilder DisplayName(string) public CustomDotNetCliToolchainBuilder DisplayName(string newDisplayName) Parameters newDisplayName string the name of the toolchain to be displayed in results Returns CustomDotNetCliToolchainBuilder DotNetCli(string) public CustomDotNetCliToolchainBuilder DotNetCli(string newCustomDotNetCliPath) Parameters newCustomDotNetCliPath string if not provided, the one from PATH will be used Returns CustomDotNetCliToolchainBuilder GetTargetFrameworkMoniker() protected string GetTargetFrameworkMoniker() Returns string RuntimeFrameworkVersion(string) public CustomDotNetCliToolchainBuilder RuntimeFrameworkVersion(string newRuntimeFrameworkVersion) Parameters newRuntimeFrameworkVersion string optional, when set it's copied to the generated .csproj file Returns CustomDotNetCliToolchainBuilder RuntimeIdentifier(string) public CustomDotNetCliToolchainBuilder RuntimeIdentifier(string newRuntimeIdentifier) Parameters newRuntimeIdentifier string if not provided, portable OS-arch will be used (example: \"win-x64\", \"linux-x86\") Returns CustomDotNetCliToolchainBuilder TargetFrameworkMoniker(string) public CustomDotNetCliToolchainBuilder TargetFrameworkMoniker(string targetFrameworkMoniker) Parameters targetFrameworkMoniker string TFM, example: net8.0 Returns CustomDotNetCliToolchainBuilder ToToolchain() public abstract IToolchain ToToolchain() Returns IToolchain UseNuGetClearTag(bool) emits clear tag in the auto-generated NuGet.config file public CustomDotNetCliToolchainBuilder UseNuGetClearTag(bool value) Parameters value bool Returns CustomDotNetCliToolchainBuilder UseTempFolderForRestore(bool) restore to temp folder to keep your CI clean or install same package many times (perhaps with different content but same version number), by default true for local builds https://github.com/dotnet/corefx/blob/master/Documentation/project-docs/dogfooding.md#3---consuming-subsequent-code-changes-by-rebuilding-the-package-alternative-2 public CustomDotNetCliToolchainBuilder UseTempFolderForRestore(bool value) Parameters value bool Returns CustomDotNetCliToolchainBuilder"
  },
  "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliBuilder.html": {
    "href": "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliBuilder.html",
    "title": "Class DotNetCliBuilder | BenchmarkDotNet",
    "summary": "Class DotNetCliBuilder Namespace BenchmarkDotNet.Toolchains.DotNetCli Assembly BenchmarkDotNet.dll public class DotNetCliBuilder : IBuilder Inheritance object DotNetCliBuilder Implements IBuilder Constructors DotNetCliBuilder(string, string?, bool) public DotNetCliBuilder(string targetFrameworkMoniker, string? customDotNetCliPath = null, bool logOutput = false) Parameters targetFrameworkMoniker string customDotNetCliPath string logOutput bool Methods Build(GenerateResult, BuildPartition, ILogger) public BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger) Parameters generateResult GenerateResult buildPartition BuildPartition logger ILogger Returns BuildResult"
  },
  "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliCommand.html": {
    "href": "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliCommand.html",
    "title": "Class DotNetCliCommand | BenchmarkDotNet",
    "summary": "Class DotNetCliCommand Namespace BenchmarkDotNet.Toolchains.DotNetCli Assembly BenchmarkDotNet.dll public class DotNetCliCommand Inheritance object DotNetCliCommand Constructors DotNetCliCommand(string, string, GenerateResult, ILogger, BuildPartition, IReadOnlyList<EnvironmentVariable>, TimeSpan, bool) public DotNetCliCommand(string cliPath, string arguments, GenerateResult generateResult, ILogger logger, BuildPartition buildPartition, IReadOnlyList<EnvironmentVariable> environmentVariables, TimeSpan timeout, bool logOutput = false) Parameters cliPath string arguments string generateResult GenerateResult logger ILogger buildPartition BuildPartition environmentVariables IReadOnlyList<EnvironmentVariable> timeout TimeSpan logOutput bool Properties Arguments public string Arguments { get; } Property Value string BuildPartition public BuildPartition BuildPartition { get; } Property Value BuildPartition CliPath public string CliPath { get; } Property Value string EnvironmentVariables public IReadOnlyList<EnvironmentVariable> EnvironmentVariables { get; } Property Value IReadOnlyList<EnvironmentVariable> GenerateResult public GenerateResult GenerateResult { get; } Property Value GenerateResult LogOutput public bool LogOutput { get; } Property Value bool Logger public ILogger Logger { get; } Property Value ILogger Timeout public TimeSpan Timeout { get; } Property Value TimeSpan Methods Build() public DotNetCliCommandResult Build() Returns DotNetCliCommandResult BuildNoRestore() public DotNetCliCommandResult BuildNoRestore() Returns DotNetCliCommandResult Publish() public DotNetCliCommandResult Publish() Returns DotNetCliCommandResult PublishNoRestore() public DotNetCliCommandResult PublishNoRestore() Returns DotNetCliCommandResult Restore() public DotNetCliCommandResult Restore() Returns DotNetCliCommandResult RestoreThenBuild() public BuildResult RestoreThenBuild() Returns BuildResult RestoreThenBuildThenPublish() public BuildResult RestoreThenBuildThenPublish() Returns BuildResult WithArguments(string) public DotNetCliCommand WithArguments(string arguments) Parameters arguments string Returns DotNetCliCommand WithCliPath(string) public DotNetCliCommand WithCliPath(string cliPath) Parameters cliPath string Returns DotNetCliCommand"
  },
  "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliCommandExecutor.html": {
    "href": "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliCommandExecutor.html",
    "title": "Class DotNetCliCommandExecutor | BenchmarkDotNet",
    "summary": "Class DotNetCliCommandExecutor Namespace BenchmarkDotNet.Toolchains.DotNetCli Assembly BenchmarkDotNet.dll public static class DotNetCliCommandExecutor Inheritance object DotNetCliCommandExecutor Methods Execute(DotNetCliCommand) public static DotNetCliCommandResult Execute(DotNetCliCommand parameters) Parameters parameters DotNetCliCommand Returns DotNetCliCommandResult"
  },
  "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliCommandResult.html": {
    "href": "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliCommandResult.html",
    "title": "Struct DotNetCliCommandResult | BenchmarkDotNet",
    "summary": "Struct DotNetCliCommandResult Namespace BenchmarkDotNet.Toolchains.DotNetCli Assembly BenchmarkDotNet.dll public struct DotNetCliCommandResult Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() Properties AllInformation public string AllInformation { get; } Property Value string ExecutionTime public readonly TimeSpan ExecutionTime { get; } Property Value TimeSpan HasNonEmptyErrorMessage public bool HasNonEmptyErrorMessage { get; } Property Value bool IsSuccess public readonly bool IsSuccess { get; } Property Value bool StandardError public readonly string StandardError { get; } Property Value string StandardOutput public readonly string StandardOutput { get; } Property Value string Methods Failure(TimeSpan, string, string) public static DotNetCliCommandResult Failure(TimeSpan time, string standardError, string standardOutput) Parameters time TimeSpan standardError string standardOutput string Returns DotNetCliCommandResult Success(TimeSpan, string) public static DotNetCliCommandResult Success(TimeSpan time, string standardOutput) Parameters time TimeSpan standardOutput string Returns DotNetCliCommandResult ToBuildResult(GenerateResult) public BuildResult ToBuildResult(GenerateResult generateResult) Parameters generateResult GenerateResult Returns BuildResult"
  },
  "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliExecutor.html": {
    "href": "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliExecutor.html",
    "title": "Class DotNetCliExecutor | BenchmarkDotNet",
    "summary": "Class DotNetCliExecutor Namespace BenchmarkDotNet.Toolchains.DotNetCli Assembly BenchmarkDotNet.dll public class DotNetCliExecutor : IExecutor Inheritance object DotNetCliExecutor Implements IExecutor Constructors DotNetCliExecutor(string) public DotNetCliExecutor(string customDotNetCliPath) Parameters customDotNetCliPath string Methods Execute(ExecuteParameters) public ExecuteResult Execute(ExecuteParameters executeParameters) Parameters executeParameters ExecuteParameters Returns ExecuteResult"
  },
  "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliGenerator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliGenerator.html",
    "title": "Class DotNetCliGenerator | BenchmarkDotNet",
    "summary": "Class DotNetCliGenerator Namespace BenchmarkDotNet.Toolchains.DotNetCli Assembly BenchmarkDotNet.dll public abstract class DotNetCliGenerator : GeneratorBase, IGenerator Inheritance object GeneratorBase DotNetCliGenerator Implements IGenerator Derived CsProjGenerator Inherited Members GeneratorBase.GenerateProject(BuildPartition, ILogger, string) GeneratorBase.GetBinariesDirectoryPath(string, string) GeneratorBase.GetPublishDirectoryPath(string, string) GeneratorBase.GetProjectFilePath(string) GeneratorBase.GenerateNuGetConfig(ArtifactsPaths) GeneratorBase.GenerateProject(BuildPartition, ArtifactsPaths, ILogger) GeneratorBase.GenerateAppConfig(BuildPartition, ArtifactsPaths) GeneratorBase.GenerateCode(BuildPartition, ArtifactsPaths) GeneratorBase.GetExecutablePath(string, string) Constructors DotNetCliGenerator(string, string, string, bool) protected DotNetCliGenerator(string targetFrameworkMoniker, string cliPath, string packagesPath, bool isNetCore) Parameters targetFrameworkMoniker string cliPath string packagesPath string isNetCore bool Properties CliPath public string CliPath { get; } Property Value string IsNetCore protected bool IsNetCore { get; } Property Value bool PackagesPath public string PackagesPath { get; } Property Value string TargetFrameworkMoniker public string TargetFrameworkMoniker { get; } Property Value string Methods CopyAllRequiredFiles(ArtifactsPaths) if you need to copy some extra files to make the benchmarks work you should override this method protected override void CopyAllRequiredFiles(ArtifactsPaths artifactsPaths) Parameters artifactsPaths ArtifactsPaths GenerateBuildScript(BuildPartition, ArtifactsPaths) generates a script can be used when debugging compilation issues protected override void GenerateBuildScript(BuildPartition buildPartition, ArtifactsPaths artifactsPaths) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths GetArtifactsToCleanup(ArtifactsPaths) returns a list of artifacts that should be removed after running the benchmarks protected override string[] GetArtifactsToCleanup(ArtifactsPaths artifactsPaths) Parameters artifactsPaths ArtifactsPaths Returns string[] GetBuildArtifactsDirectoryPath(BuildPartition, string) we need our folder to be on the same level as the project that we want to reference we are limited by xprojs (by default compiles all .cs files in all subfolders, Program.cs could be doubled and fail the build) and also by NuGet internal implementation like looking for global.json file in parent folders protected override string GetBuildArtifactsDirectoryPath(BuildPartition buildPartition, string programName) Parameters buildPartition BuildPartition programName string Returns string GetExecutableExtension() returns OS-specific executable extension protected override string GetExecutableExtension() Returns string GetPackagesDirectoryPath(string) returns a path to the folder where NuGet packages should be restored protected override string GetPackagesDirectoryPath(string buildArtifactsDirectoryPath) Parameters buildArtifactsDirectoryPath string Returns string"
  },
  "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliPublisher.html": {
    "href": "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliPublisher.html",
    "title": "Class DotNetCliPublisher | BenchmarkDotNet",
    "summary": "Class DotNetCliPublisher Namespace BenchmarkDotNet.Toolchains.DotNetCli Assembly BenchmarkDotNet.dll public class DotNetCliPublisher : IBuilder Inheritance object DotNetCliPublisher Implements IBuilder Constructors DotNetCliPublisher(string?, string?, IReadOnlyList<EnvironmentVariable>?) public DotNetCliPublisher(string? customDotNetCliPath = null, string? extraArguments = null, IReadOnlyList<EnvironmentVariable>? environmentVariables = null) Parameters customDotNetCliPath string extraArguments string environmentVariables IReadOnlyList<EnvironmentVariable> Methods Build(GenerateResult, BuildPartition, ILogger) public BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger) Parameters generateResult GenerateResult buildPartition BuildPartition logger ILogger Returns BuildResult"
  },
  "api/BenchmarkDotNet.Toolchains.DotNetCli.html": {
    "href": "api/BenchmarkDotNet.Toolchains.DotNetCli.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.DotNetCli | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.DotNetCli Classes CustomDotNetCliToolchainBuilder DotNetCliBuilder DotNetCliCommand DotNetCliCommandExecutor DotNetCliExecutor DotNetCliGenerator DotNetCliPublisher NetCoreAppSettings custom settings used in the auto-generated project.json / .csproj file Structs DotNetCliCommandResult"
  },
  "api/BenchmarkDotNet.Toolchains.DotNetCli.NetCoreAppSettings.html": {
    "href": "api/BenchmarkDotNet.Toolchains.DotNetCli.NetCoreAppSettings.html",
    "title": "Class NetCoreAppSettings | BenchmarkDotNet",
    "summary": "Class NetCoreAppSettings Namespace BenchmarkDotNet.Toolchains.DotNetCli Assembly BenchmarkDotNet.dll custom settings used in the auto-generated project.json / .csproj file public class NetCoreAppSettings Inheritance object NetCoreAppSettings Constructors NetCoreAppSettings(string, string?, string, string?, string?, string?, string?, MonoAotCompilerMode) sample values: net6.0, net8.0 used in the auto-generated .csproj file simply ignored if null or empty display name used for showing the results customize dotnet cli path if default is not desired simply ignored if null the directory to restore packages to path to a custom runtime pack path to Mono AOT compiler Mono AOT compiler moder public NetCoreAppSettings(string targetFrameworkMoniker, string? runtimeFrameworkVersion, string name, string? customDotNetCliPath = null, string? packagesPath = null, string? customRuntimePack = null, string? aotCompilerPath = null, MonoAotCompilerMode aotCompilerMode = MonoAotCompilerMode.mini) Parameters targetFrameworkMoniker string runtimeFrameworkVersion string name string customDotNetCliPath string packagesPath string customRuntimePack string aotCompilerPath string aotCompilerMode MonoAotCompilerMode Fields NetCoreApp10_0 public static readonly NetCoreAppSettings NetCoreApp10_0 Field Value NetCoreAppSettings NetCoreApp20 public static readonly NetCoreAppSettings NetCoreApp20 Field Value NetCoreAppSettings NetCoreApp21 public static readonly NetCoreAppSettings NetCoreApp21 Field Value NetCoreAppSettings NetCoreApp22 public static readonly NetCoreAppSettings NetCoreApp22 Field Value NetCoreAppSettings NetCoreApp30 public static readonly NetCoreAppSettings NetCoreApp30 Field Value NetCoreAppSettings NetCoreApp31 public static readonly NetCoreAppSettings NetCoreApp31 Field Value NetCoreAppSettings NetCoreApp50 public static readonly NetCoreAppSettings NetCoreApp50 Field Value NetCoreAppSettings NetCoreApp60 public static readonly NetCoreAppSettings NetCoreApp60 Field Value NetCoreAppSettings NetCoreApp70 public static readonly NetCoreAppSettings NetCoreApp70 Field Value NetCoreAppSettings NetCoreApp80 public static readonly NetCoreAppSettings NetCoreApp80 Field Value NetCoreAppSettings NetCoreApp90 public static readonly NetCoreAppSettings NetCoreApp90 Field Value NetCoreAppSettings Properties AOTCompilerMode Mono AOT Compiler mode, either 'mini' or 'llvm' public MonoAotCompilerMode AOTCompilerMode { get; } Property Value MonoAotCompilerMode AOTCompilerPath Path to the Mono AOT Compiler public string? AOTCompilerPath { get; } Property Value string CustomDotNetCliPath public string? CustomDotNetCliPath { get; } Property Value string CustomRuntimePack Path to a custom runtime pack. public string? CustomRuntimePack { get; } Property Value string Name display name used for showing the results public string Name { get; } Property Value string PackagesPath The directory to restore packages to. public string? PackagesPath { get; } Property Value string RuntimeFrameworkVersion public string? RuntimeFrameworkVersion { get; } Property Value string TargetFrameworkMoniker sample values: net6.0, net8.0 public string TargetFrameworkMoniker { get; } Property Value string Methods WithCustomDotNetCliPath(string, string?) public NetCoreAppSettings WithCustomDotNetCliPath(string customDotNetCliPath, string? displayName = null) Parameters customDotNetCliPath string displayName string Returns NetCoreAppSettings WithCustomPackagesRestorePath(string, string?) public NetCoreAppSettings WithCustomPackagesRestorePath(string packagesPath, string? displayName = null) Parameters packagesPath string displayName string Returns NetCoreAppSettings"
  },
  "api/BenchmarkDotNet.Toolchains.Executor.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Executor.html",
    "title": "Class Executor | BenchmarkDotNet",
    "summary": "Class Executor Namespace BenchmarkDotNet.Toolchains Assembly BenchmarkDotNet.dll public class Executor : IExecutor Inheritance object Executor Implements IExecutor Constructors Executor() public Executor() Methods Execute(ExecuteParameters) public ExecuteResult Execute(ExecuteParameters executeParameters) Parameters executeParameters ExecuteParameters Returns ExecuteResult"
  },
  "api/BenchmarkDotNet.Toolchains.GeneratorBase.html": {
    "href": "api/BenchmarkDotNet.Toolchains.GeneratorBase.html",
    "title": "Class GeneratorBase | BenchmarkDotNet",
    "summary": "Class GeneratorBase Namespace BenchmarkDotNet.Toolchains Assembly BenchmarkDotNet.dll public abstract class GeneratorBase : IGenerator Inheritance object GeneratorBase Implements IGenerator Derived DotNetCliGenerator Generator Constructors GeneratorBase() protected GeneratorBase() Methods CopyAllRequiredFiles(ArtifactsPaths) if you need to copy some extra files to make the benchmarks work you should override this method protected virtual void CopyAllRequiredFiles(ArtifactsPaths artifactsPaths) Parameters artifactsPaths ArtifactsPaths GenerateAppConfig(BuildPartition, ArtifactsPaths) generates an app.config file next to the executable with benchmarks protected virtual void GenerateAppConfig(BuildPartition buildPartition, ArtifactsPaths artifactsPaths) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths GenerateBuildScript(BuildPartition, ArtifactsPaths) generates a script can be used when debugging compilation issues protected abstract void GenerateBuildScript(BuildPartition buildPartition, ArtifactsPaths artifactsPaths) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths GenerateCode(BuildPartition, ArtifactsPaths) generates the C# source code with all required boilerplate. You most probably do NOT need to override this method!! protected virtual void GenerateCode(BuildPartition buildPartition, ArtifactsPaths artifactsPaths) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths GenerateNuGetConfig(ArtifactsPaths) generates NuGet.Config file to make sure that BDN is using the right NuGet feeds protected virtual void GenerateNuGetConfig(ArtifactsPaths artifactsPaths) Parameters artifactsPaths ArtifactsPaths GenerateProject(BuildPartition, ILogger, string) public GenerateResult GenerateProject(BuildPartition buildPartition, ILogger logger, string rootArtifactsFolderPath) Parameters buildPartition BuildPartition logger ILogger rootArtifactsFolderPath string Returns GenerateResult GenerateProject(BuildPartition, ArtifactsPaths, ILogger) generates .csproj file with a reference to the project with benchmarks protected virtual void GenerateProject(BuildPartition buildPartition, ArtifactsPaths artifactsPaths, ILogger logger) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths logger ILogger GetArtifactsToCleanup(ArtifactsPaths) returns a list of artifacts that should be removed after running the benchmarks protected abstract string[] GetArtifactsToCleanup(ArtifactsPaths artifactsPaths) Parameters artifactsPaths ArtifactsPaths Returns string[] GetBinariesDirectoryPath(string, string) returns a path where executable should be found after the build (usually \\bin) protected virtual string GetBinariesDirectoryPath(string buildArtifactsDirectoryPath, string configuration) Parameters buildArtifactsDirectoryPath string configuration string Returns string GetBuildArtifactsDirectoryPath(BuildPartition, string) returns a path to the folder where auto-generated project and code are going to be placed protected abstract string GetBuildArtifactsDirectoryPath(BuildPartition assemblyLocation, string programName) Parameters assemblyLocation BuildPartition programName string Returns string GetExecutableExtension() returns OS-specific executable extension protected virtual string GetExecutableExtension() Returns string GetExecutablePath(string, string) protected virtual string GetExecutablePath(string binariesDirectoryPath, string programName) Parameters binariesDirectoryPath string programName string Returns string GetPackagesDirectoryPath(string) returns a path to the folder where NuGet packages should be restored protected virtual string GetPackagesDirectoryPath(string buildArtifactsDirectoryPath) Parameters buildArtifactsDirectoryPath string Returns string GetProjectFilePath(string) returns a path to the auto-generated .csproj file protected virtual string GetProjectFilePath(string buildArtifactsDirectoryPath) Parameters buildArtifactsDirectoryPath string Returns string GetPublishDirectoryPath(string, string) returns a path where the publish directory should be found after the build (usually \\publish) protected virtual string GetPublishDirectoryPath(string buildArtifactsDirectoryPath, string configuration) Parameters buildArtifactsDirectoryPath string configuration string Returns string"
  },
  "api/BenchmarkDotNet.Toolchains.html": {
    "href": "api/BenchmarkDotNet.Toolchains.html",
    "title": "Namespace BenchmarkDotNet.Toolchains | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains Classes ArtifactsPaths Executor GeneratorBase Toolchain Interfaces IBuilder IExecutor IGenerator IToolchain"
  },
  "api/BenchmarkDotNet.Toolchains.IBuilder.html": {
    "href": "api/BenchmarkDotNet.Toolchains.IBuilder.html",
    "title": "Interface IBuilder | BenchmarkDotNet",
    "summary": "Interface IBuilder Namespace BenchmarkDotNet.Toolchains Assembly BenchmarkDotNet.dll public interface IBuilder Methods Build(GenerateResult, BuildPartition, ILogger) BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger) Parameters generateResult GenerateResult buildPartition BuildPartition logger ILogger Returns BuildResult"
  },
  "api/BenchmarkDotNet.Toolchains.IExecutor.html": {
    "href": "api/BenchmarkDotNet.Toolchains.IExecutor.html",
    "title": "Interface IExecutor | BenchmarkDotNet",
    "summary": "Interface IExecutor Namespace BenchmarkDotNet.Toolchains Assembly BenchmarkDotNet.dll public interface IExecutor Methods Execute(ExecuteParameters) ExecuteResult Execute(ExecuteParameters executeParameters) Parameters executeParameters ExecuteParameters Returns ExecuteResult"
  },
  "api/BenchmarkDotNet.Toolchains.IGenerator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.IGenerator.html",
    "title": "Interface IGenerator | BenchmarkDotNet",
    "summary": "Interface IGenerator Namespace BenchmarkDotNet.Toolchains Assembly BenchmarkDotNet.dll public interface IGenerator Methods GenerateProject(BuildPartition, ILogger, string) GenerateResult GenerateProject(BuildPartition buildPartition, ILogger logger, string rootArtifactsFolderPath) Parameters buildPartition BuildPartition logger ILogger rootArtifactsFolderPath string Returns GenerateResult"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.InProcess.Emit | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.InProcess.Emit Classes InProcessEmitArtifactsPath InProcessEmitBuilder InProcessEmitExecutor Implementation of IExecutor for in-process benchmarks. InProcessEmitGenerator InProcessEmitToolchain"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.ConsumableTypeInfo.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.ConsumableTypeInfo.html",
    "title": "Class ConsumableTypeInfo | BenchmarkDotNet",
    "summary": "Class ConsumableTypeInfo Namespace BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation Assembly BenchmarkDotNet.dll public class ConsumableTypeInfo Inheritance object ConsumableTypeInfo Constructors ConsumableTypeInfo(Type) public ConsumableTypeInfo(Type methodReturnType) Parameters methodReturnType Type Properties GetResultMethod public MethodInfo? GetResultMethod { get; } Property Value MethodInfo IsAwaitable public bool IsAwaitable { get; } Property Value bool IsByRef public bool IsByRef { get; } Property Value bool IsConsumable public bool IsConsumable { get; } Property Value bool IsVoid public bool IsVoid { get; } Property Value bool OriginMethodReturnType public Type OriginMethodReturnType { get; } Property Value Type OverheadMethodReturnType public Type OverheadMethodReturnType { get; } Property Value Type WorkloadConsumableField public FieldInfo? WorkloadConsumableField { get; } Property Value FieldInfo WorkloadMethodReturnType public Type WorkloadMethodReturnType { get; } Property Value Type"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation Classes ConsumableTypeInfo RunnableConstants A helper type that emits code that matches BenchmarkType.txt template. IMPORTANT: this type IS NOT thread safe. RunnableProgram RunnableReuse Enums RunnableActionKind"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableActionKind.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableActionKind.html",
    "title": "Enum RunnableActionKind | BenchmarkDotNet",
    "summary": "Enum RunnableActionKind Namespace BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation Assembly BenchmarkDotNet.dll public enum RunnableActionKind Fields Overhead = 0 Workload = 1"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableConstants.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableConstants.html",
    "title": "Class RunnableConstants | BenchmarkDotNet",
    "summary": "Class RunnableConstants Namespace BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation Assembly BenchmarkDotNet.dll A helper type that emits code that matches BenchmarkType.txt template. IMPORTANT: this type IS NOT thread safe. public class RunnableConstants Inheritance object RunnableConstants Constructors RunnableConstants() public RunnableConstants() Fields ArgFieldPrefix public const string ArgFieldPrefix = \"__argField\" Field Value string ArgParamPrefix public const string ArgParamPrefix = \"arg\" Field Value string ConsumerFieldName public const string ConsumerFieldName = \"consumer\" Field Value string Dummy1MethodName public const string Dummy1MethodName = \"Dummy1\" Field Value string Dummy2MethodName public const string Dummy2MethodName = \"Dummy2\" Field Value string Dummy3MethodName public const string Dummy3MethodName = \"Dummy3\" Field Value string DummyParamName public const string DummyParamName = \"_\" Field Value string DummyUnrollFactor public const int DummyUnrollFactor = 64 Field Value int DummyVarFieldName public const string DummyVarFieldName = \"dummyVar\" Field Value string DynamicAssemblySuffix public const string DynamicAssemblySuffix = \"Emitted\" Field Value string EmittedTypePrefix public const string EmittedTypePrefix = \"BenchmarkDotNet.Autogenerated.Runnable_\" Field Value string ForDisassemblyDiagnoserMethodName public const string ForDisassemblyDiagnoserMethodName = \"__ForDisassemblyDiagnoser__\" Field Value string GlobalCleanupActionFieldName public const string GlobalCleanupActionFieldName = \"globalCleanupAction\" Field Value string GlobalCleanupMethodName public const string GlobalCleanupMethodName = \"GlobalCleanup\" Field Value string GlobalSetupActionFieldName public const string GlobalSetupActionFieldName = \"globalSetupAction\" Field Value string GlobalSetupMethodName public const string GlobalSetupMethodName = \"GlobalSetup\" Field Value string InvokeCountParamName public const string InvokeCountParamName = \"invokeCount\" Field Value string IsByRefLikeAttributeTypeName public const string IsByRefLikeAttributeTypeName = \"System.Runtime.CompilerServices.IsByRefLikeAttribute\" Field Value string IterationCleanupActionFieldName public const string IterationCleanupActionFieldName = \"iterationCleanupAction\" Field Value string IterationCleanupMethodName public const string IterationCleanupMethodName = \"IterationCleanup\" Field Value string IterationSetupActionFieldName public const string IterationSetupActionFieldName = \"iterationSetupAction\" Field Value string IterationSetupMethodName public const string IterationSetupMethodName = \"IterationSetup\" Field Value string NonGenericKeepAliveWithoutBoxingMethodName public const string NonGenericKeepAliveWithoutBoxingMethodName = \"NonGenericKeepAliveWithoutBoxing\" Field Value string NotElevenFieldName public const string NotElevenFieldName = \"NotEleven\" Field Value string OpImplicitMethodName public const string OpImplicitMethodName = \"op_Implicit\" Field Value string OverheadActionNoUnrollMethodName public const string OverheadActionNoUnrollMethodName = \"OverheadActionNoUnroll\" Field Value string OverheadActionUnrollMethodName public const string OverheadActionUnrollMethodName = \"OverheadActionUnroll\" Field Value string OverheadDelegateFieldName public const string OverheadDelegateFieldName = \"overheadDelegate\" Field Value string OverheadDelegateTypeSuffix public const string OverheadDelegateTypeSuffix = \"OverheadDelegate\" Field Value string OverheadImplementationMethodName public const string OverheadImplementationMethodName = \"__Overhead\" Field Value string RunMethodName public const string RunMethodName = \"Run\" Field Value string TrickTheJitCoreMethodName public const string TrickTheJitCoreMethodName = \"__TrickTheJIT__\" Field Value string WorkloadActionNoUnrollMethodName public const string WorkloadActionNoUnrollMethodName = \"WorkloadActionNoUnroll\" Field Value string WorkloadActionUnrollMethodName public const string WorkloadActionUnrollMethodName = \"WorkloadActionUnroll\" Field Value string WorkloadDefaultValueHolderFieldName public const string WorkloadDefaultValueHolderFieldName = \"workloadDefaultValueHolder\" Field Value string WorkloadDelegateFieldName public const string WorkloadDelegateFieldName = \"workloadDelegate\" Field Value string WorkloadDelegateTypeSuffix public const string WorkloadDelegateTypeSuffix = \"WorkloadDelegate\" Field Value string WorkloadImplementationMethodName public const string WorkloadImplementationMethodName = \"__Workload\" Field Value string"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableProgram.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableProgram.html",
    "title": "Class RunnableProgram | BenchmarkDotNet",
    "summary": "Class RunnableProgram Namespace BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation Assembly BenchmarkDotNet.dll public class RunnableProgram Inheritance object RunnableProgram Constructors RunnableProgram() public RunnableProgram() Methods Run(BenchmarkId, Assembly, BenchmarkCase, IHost) public static int Run(BenchmarkId benchmarkId, Assembly partitionAssembly, BenchmarkCase benchmarkCase, IHost host) Parameters benchmarkId BenchmarkId partitionAssembly Assembly benchmarkCase BenchmarkCase host IHost Returns int"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableReuse.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableReuse.html",
    "title": "Class RunnableReuse | BenchmarkDotNet",
    "summary": "Class RunnableReuse Namespace BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation Assembly BenchmarkDotNet.dll public static class RunnableReuse Inheritance object RunnableReuse Methods FillObjectMembers<T>(T, BenchmarkCase) public static void FillObjectMembers<T>(T instance, BenchmarkCase benchmarkCase) Parameters instance T benchmarkCase BenchmarkCase Type Parameters T PrepareForRun<T>(T, BenchmarkCase, IHost) public static (Job, EngineParameters, IEngineFactory) PrepareForRun<T>(T instance, BenchmarkCase benchmarkCase, IHost host) Parameters instance T benchmarkCase BenchmarkCase host IHost Returns (Job, EngineParameters, IEngineFactory) Type Parameters T"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitArtifactsPath.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitArtifactsPath.html",
    "title": "Class InProcessEmitArtifactsPath | BenchmarkDotNet",
    "summary": "Class InProcessEmitArtifactsPath Namespace BenchmarkDotNet.Toolchains.InProcess.Emit Assembly BenchmarkDotNet.dll public class InProcessEmitArtifactsPath : ArtifactsPaths Inheritance object ArtifactsPaths InProcessEmitArtifactsPath Inherited Members ArtifactsPaths.Empty ArtifactsPaths.RootArtifactsFolderPath ArtifactsPaths.BuildArtifactsDirectoryPath ArtifactsPaths.BinariesDirectoryPath ArtifactsPaths.PublishDirectoryPath ArtifactsPaths.ProgramCodePath ArtifactsPaths.AppConfigPath ArtifactsPaths.NuGetConfigPath ArtifactsPaths.ProjectFilePath ArtifactsPaths.BuildScriptFilePath ArtifactsPaths.ExecutablePath ArtifactsPaths.ProgramName ArtifactsPaths.PackagesDirectoryName Constructors InProcessEmitArtifactsPath(Assembly, ArtifactsPaths) public InProcessEmitArtifactsPath(Assembly generatedAssembly, ArtifactsPaths baseArtifacts) Parameters generatedAssembly Assembly baseArtifacts ArtifactsPaths Properties GeneratedAssembly public Assembly GeneratedAssembly { get; } Property Value Assembly"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitBuilder.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitBuilder.html",
    "title": "Class InProcessEmitBuilder | BenchmarkDotNet",
    "summary": "Class InProcessEmitBuilder Namespace BenchmarkDotNet.Toolchains.InProcess.Emit Assembly BenchmarkDotNet.dll public class InProcessEmitBuilder : IBuilder Inheritance object InProcessEmitBuilder Implements IBuilder Constructors InProcessEmitBuilder() public InProcessEmitBuilder() Methods Build(GenerateResult, BuildPartition, ILogger) public BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger) Parameters generateResult GenerateResult buildPartition BuildPartition logger ILogger Returns BuildResult"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitExecutor.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitExecutor.html",
    "title": "Class InProcessEmitExecutor | BenchmarkDotNet",
    "summary": "Class InProcessEmitExecutor Namespace BenchmarkDotNet.Toolchains.InProcess.Emit Assembly BenchmarkDotNet.dll Implementation of IExecutor for in-process benchmarks. public class InProcessEmitExecutor : IExecutor Inheritance object InProcessEmitExecutor Implements IExecutor Constructors InProcessEmitExecutor(TimeSpan, bool) Initializes a new instance of the InProcessEmitExecutor class. public InProcessEmitExecutor(TimeSpan timeout, bool logOutput) Parameters timeout TimeSpan Timeout for the run. logOutput bool true if the output should be logged. Fields DefaultTimeout Default timeout for in-process benchmarks. public static readonly TimeSpan DefaultTimeout Field Value TimeSpan Properties ExecutionTimeout Timeout for the run. public TimeSpan ExecutionTimeout { get; } Property Value TimeSpan The timeout for the run. LogOutput Gets a value indicating whether the output should be logged. public bool LogOutput { get; } Property Value bool true if the output should be logged; otherwise, false. Methods Execute(ExecuteParameters) Executes the specified benchmark. public ExecuteResult Execute(ExecuteParameters executeParameters) Parameters executeParameters ExecuteParameters Returns ExecuteResult"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitGenerator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitGenerator.html",
    "title": "Class InProcessEmitGenerator | BenchmarkDotNet",
    "summary": "Class InProcessEmitGenerator Namespace BenchmarkDotNet.Toolchains.InProcess.Emit Assembly BenchmarkDotNet.dll public class InProcessEmitGenerator : IGenerator Inheritance object InProcessEmitGenerator Implements IGenerator Constructors InProcessEmitGenerator() public InProcessEmitGenerator() Methods GenerateProject(BuildPartition, ILogger, string) public GenerateResult GenerateProject(BuildPartition buildPartition, ILogger logger, string rootArtifactsFolderPath) Parameters buildPartition BuildPartition logger ILogger rootArtifactsFolderPath string Returns GenerateResult"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitToolchain.html",
    "title": "Class InProcessEmitToolchain | BenchmarkDotNet",
    "summary": "Class InProcessEmitToolchain Namespace BenchmarkDotNet.Toolchains.InProcess.Emit Assembly BenchmarkDotNet.dll public class InProcessEmitToolchain : Toolchain, IToolchain Inheritance object Toolchain InProcessEmitToolchain Implements IToolchain Inherited Members Toolchain.Validate(BenchmarkCase, IResolver) Toolchain.ToString() Toolchain.Name Toolchain.Generator Toolchain.Builder Toolchain.Executor Constructors InProcessEmitToolchain(bool) Initializes a new instance of the InProcessEmitToolchain class. public InProcessEmitToolchain(bool logOutput) Parameters logOutput bool true if the output should be logged. InProcessEmitToolchain(TimeSpan, bool) Initializes a new instance of the InProcessEmitToolchain class. public InProcessEmitToolchain(TimeSpan timeout, bool logOutput) Parameters timeout TimeSpan Timeout for the run. logOutput bool true if the output should be logged. Fields DontLogOutput The toolchain instance without output logging. public static readonly IToolchain DontLogOutput Field Value IToolchain Instance The default toolchain instance. public static readonly IToolchain Instance Field Value IToolchain Properties IsInProcess public override bool IsInProcess { get; } Property Value bool"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.InProcess | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.InProcess Classes InProcessHost Host API for in-process benchmarks. InProcessValidator Validator to be used together with InProcessNoEmitToolchain or InProcessEmitToolchain to proof that the config matches the environment."
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.InProcessHost.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.InProcessHost.html",
    "title": "Class InProcessHost | BenchmarkDotNet",
    "summary": "Class InProcessHost Namespace BenchmarkDotNet.Toolchains.InProcess Assembly BenchmarkDotNet.dll Host API for in-process benchmarks. public sealed class InProcessHost : IHost, IDisposable Inheritance object InProcessHost Implements IHost IDisposable Extension Methods HostExtensions.AfterAll(IHost) HostExtensions.AfterMainRun(IHost) HostExtensions.BeforeAnythingElse(IHost) HostExtensions.BeforeMainRun(IHost) HostExtensions.WriteLine(IHost, string, params object[]) Constructors InProcessHost(BenchmarkCase, ILogger, IDiagnoser) Creates a new instance of InProcessHost. public InProcessHost(BenchmarkCase benchmarkCase, ILogger logger, IDiagnoser diagnoser) Parameters benchmarkCase BenchmarkCase Current benchmark. logger ILogger Logger for informational output. diagnoser IDiagnoser Diagnosers, if attached. Properties Config Current config public IConfig Config { get; set; } Property Value IConfig IsDiagnoserAttached True if there are diagnosers attached. public bool IsDiagnoserAttached { get; } Property Value bool True if there are diagnosers attached. RunResults Results of the run. public RunResults RunResults { get; } Property Value RunResults Results of the run. Methods Dispose() public void Dispose() ReportResults(RunResults) Submits run results to the host. public void ReportResults(RunResults runResults) Parameters runResults RunResults The run results. SendError(string) public void SendError(string message) Parameters message string SendSignal(HostSignal) Sends notification signal to the host. public void SendSignal(HostSignal hostSignal) Parameters hostSignal HostSignal The signal to send. Write(string) Passes text to the host. public void Write(string message) Parameters message string Text to write. WriteLine() Passes new line to the host. public void WriteLine() WriteLine(string) Passes text (new line appended) to the host. public void WriteLine(string message) Parameters message string Text to write. See Also IHost"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.InProcessValidator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.InProcessValidator.html",
    "title": "Class InProcessValidator | BenchmarkDotNet",
    "summary": "Class InProcessValidator Namespace BenchmarkDotNet.Toolchains.InProcess Assembly BenchmarkDotNet.dll Validator to be used together with InProcessNoEmitToolchain or InProcessEmitToolchain to proof that the config matches the environment. public class InProcessValidator : IValidator Inheritance object InProcessValidator Implements IValidator Fields DontFailOnError The instance of validator that does NOT fail on error. public static readonly IValidator DontFailOnError Field Value IValidator FailOnError The instance of validator that DOES fail on error. public static readonly IValidator FailOnError Field Value IValidator Properties TreatsWarningsAsErrors Gets a value indicating whether warnings are treated as errors. public bool TreatsWarningsAsErrors { get; } Property Value bool true if the validator should treat warnings as errors; otherwise, false. Methods Validate(BenchmarkCase) public static IEnumerable<ValidationError> Validate(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns IEnumerable<ValidationError> Validate(ValidationParameters) Proofs that benchmarks' jobs match the environment. public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters The validation parameters. Returns IEnumerable<ValidationError> Enumerable of validation errors. See Also IValidator"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkAction.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkAction.html",
    "title": "Class BenchmarkAction | BenchmarkDotNet",
    "summary": "Class BenchmarkAction Namespace BenchmarkDotNet.Toolchains.InProcess.NoEmit Assembly BenchmarkDotNet.dll Common API to run the Setup/Clean/Idle/Run methods public abstract class BenchmarkAction Inheritance object BenchmarkAction Constructors BenchmarkAction() protected BenchmarkAction() Properties InvokeNoUnroll public Action<long> InvokeNoUnroll { get; protected set; } Property Value Action<long> InvokeSingle Gets or sets invoke single callback. public Action InvokeSingle { get; protected set; } Property Value Action Invoke single callback. InvokeUnroll Gets or sets invoke multiple times callback. public Action<long> InvokeUnroll { get; protected set; } Property Value Action<long> Invoke multiple times callback. LastRunResult Gets the last run result. public virtual object LastRunResult { get; } Property Value object The last run result."
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkActionFactory.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkActionFactory.html",
    "title": "Class BenchmarkActionFactory | BenchmarkDotNet",
    "summary": "Class BenchmarkActionFactory Namespace BenchmarkDotNet.Toolchains.InProcess.NoEmit Assembly BenchmarkDotNet.dll Helper class that creates BenchmarkAction instances. public static class BenchmarkActionFactory Inheritance object BenchmarkActionFactory Methods CreateDummy() Creates a dummy benchmark action. public static BenchmarkAction CreateDummy() Returns BenchmarkAction Dummy benchmark action. CreateGlobalCleanup(Descriptor, object) Creates global cleanup benchmark action. public static BenchmarkAction CreateGlobalCleanup(Descriptor descriptor, object instance) Parameters descriptor Descriptor Descriptor info. instance object Instance of target. Returns BenchmarkAction Cleanup benchmark action. CreateGlobalSetup(Descriptor, object) Creates global setup benchmark action. public static BenchmarkAction CreateGlobalSetup(Descriptor descriptor, object instance) Parameters descriptor Descriptor Descriptor info. instance object Instance of target. Returns BenchmarkAction Setup benchmark action. CreateIterationCleanup(Descriptor, object) Creates global cleanup benchmark action. public static BenchmarkAction CreateIterationCleanup(Descriptor descriptor, object instance) Parameters descriptor Descriptor Descriptor info. instance object Instance of target. Returns BenchmarkAction Cleanup benchmark action. CreateIterationSetup(Descriptor, object) Creates global setup benchmark action. public static BenchmarkAction CreateIterationSetup(Descriptor descriptor, object instance) Parameters descriptor Descriptor Descriptor info. instance object Instance of target. Returns BenchmarkAction Setup benchmark action. CreateOverhead(Descriptor, object, int) Creates idle benchmark action. public static BenchmarkAction CreateOverhead(Descriptor descriptor, object instance, int unrollFactor) Parameters descriptor Descriptor Descriptor info. instance object Instance of target. unrollFactor int Unroll factor. Returns BenchmarkAction Idle benchmark action. CreateWorkload(Descriptor, object, int) Creates run benchmark action. public static BenchmarkAction CreateWorkload(Descriptor descriptor, object instance, int unrollFactor) Parameters descriptor Descriptor Descriptor info. instance object Instance of target. unrollFactor int Unroll factor. Returns BenchmarkAction Run benchmark action."
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.InProcess.NoEmit | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.InProcess.NoEmit Classes BenchmarkAction Common API to run the Setup/Clean/Idle/Run methods BenchmarkActionFactory Helper class that creates BenchmarkAction instances. InProcessNoEmitBuilder In process (no emit) toolchain builder InProcessNoEmitExecutor Implementation of IExecutor for in-process (no emit) toolchain. InProcessNoEmitGenerator Implementation of IGenerator for in-process (no emit) toolchain. InProcessNoEmitToolchain A toolchain to run the benchmarks in-process (no emit)."
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitBuilder.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitBuilder.html",
    "title": "Class InProcessNoEmitBuilder | BenchmarkDotNet",
    "summary": "Class InProcessNoEmitBuilder Namespace BenchmarkDotNet.Toolchains.InProcess.NoEmit Assembly BenchmarkDotNet.dll In process (no emit) toolchain builder public class InProcessNoEmitBuilder : IBuilder Inheritance object InProcessNoEmitBuilder Implements IBuilder Constructors InProcessNoEmitBuilder() public InProcessNoEmitBuilder() Methods Build(GenerateResult, BuildPartition, ILogger) always returns success public BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger) Parameters generateResult GenerateResult buildPartition BuildPartition logger ILogger Returns BuildResult See Also IBuilder"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitExecutor.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitExecutor.html",
    "title": "Class InProcessNoEmitExecutor | BenchmarkDotNet",
    "summary": "Class InProcessNoEmitExecutor Namespace BenchmarkDotNet.Toolchains.InProcess.NoEmit Assembly BenchmarkDotNet.dll Implementation of IExecutor for in-process (no emit) toolchain. public class InProcessNoEmitExecutor : IExecutor Inheritance object InProcessNoEmitExecutor Implements IExecutor Constructors InProcessNoEmitExecutor(TimeSpan, bool) Initializes a new instance of the InProcessNoEmitExecutor class. public InProcessNoEmitExecutor(TimeSpan timeout, bool logOutput) Parameters timeout TimeSpan Timeout for the run. logOutput bool true if the output should be logged. Fields DefaultTimeout Default timeout for in-process benchmarks. public static readonly TimeSpan DefaultTimeout Field Value TimeSpan Properties ExecutionTimeout Timeout for the run. public TimeSpan ExecutionTimeout { get; } Property Value TimeSpan The timeout for the run. LogOutput Gets a value indicating whether the output should be logged. public bool LogOutput { get; } Property Value bool true if the output should be logged; otherwise, false. Methods Execute(ExecuteParameters) Executes the specified benchmark. public ExecuteResult Execute(ExecuteParameters executeParameters) Parameters executeParameters ExecuteParameters Returns ExecuteResult"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitGenerator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitGenerator.html",
    "title": "Class InProcessNoEmitGenerator | BenchmarkDotNet",
    "summary": "Class InProcessNoEmitGenerator Namespace BenchmarkDotNet.Toolchains.InProcess.NoEmit Assembly BenchmarkDotNet.dll Implementation of IGenerator for in-process (no emit) toolchain. public class InProcessNoEmitGenerator : IGenerator Inheritance object InProcessNoEmitGenerator Implements IGenerator Constructors InProcessNoEmitGenerator() public InProcessNoEmitGenerator() Methods GenerateProject(BuildPartition, ILogger, string) returns a success public GenerateResult GenerateProject(BuildPartition buildPartition, ILogger logger, string rootArtifactsFolderPath) Parameters buildPartition BuildPartition logger ILogger rootArtifactsFolderPath string Returns GenerateResult"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitToolchain.html",
    "title": "Class InProcessNoEmitToolchain | BenchmarkDotNet",
    "summary": "Class InProcessNoEmitToolchain Namespace BenchmarkDotNet.Toolchains.InProcess.NoEmit Assembly BenchmarkDotNet.dll A toolchain to run the benchmarks in-process (no emit). public sealed class InProcessNoEmitToolchain : IToolchain Inheritance object InProcessNoEmitToolchain Implements IToolchain Constructors InProcessNoEmitToolchain(bool) Initializes a new instance of the InProcessNoEmitToolchain class. public InProcessNoEmitToolchain(bool logOutput) Parameters logOutput bool true if the output should be logged. InProcessNoEmitToolchain(TimeSpan, bool) Initializes a new instance of the InProcessNoEmitToolchain class. public InProcessNoEmitToolchain(TimeSpan timeout, bool logOutput) Parameters timeout TimeSpan Timeout for the run. logOutput bool true if the output should be logged. Fields DontLogOutput The toolchain instance without output logging. public static readonly IToolchain DontLogOutput Field Value IToolchain Instance The default toolchain instance. public static readonly IToolchain Instance Field Value IToolchain Properties Builder The builder. public IBuilder Builder { get; } Property Value IBuilder The builder. Executor The executor. public IExecutor Executor { get; } Property Value IExecutor The executor. Generator The generator. public IGenerator Generator { get; } Property Value IGenerator The generator. IsInProcess public bool IsInProcess { get; } Property Value bool Name Name of the toolchain. public string Name { get; } Property Value string The name of the toolchain. Methods ToString() Returns a string that represents this instance. public override string ToString() Returns string A string that represents this instance. Validate(BenchmarkCase, IResolver) public IEnumerable<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver) Parameters benchmarkCase BenchmarkCase resolver IResolver Returns IEnumerable<ValidationError> See Also IToolchain"
  },
  "api/BenchmarkDotNet.Toolchains.IToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.IToolchain.html",
    "title": "Interface IToolchain | BenchmarkDotNet",
    "summary": "Interface IToolchain Namespace BenchmarkDotNet.Toolchains Assembly BenchmarkDotNet.dll public interface IToolchain Properties Builder IBuilder Builder { get; } Property Value IBuilder Executor IExecutor Executor { get; } Property Value IExecutor Generator IGenerator Generator { get; } Property Value IGenerator IsInProcess bool IsInProcess { get; } Property Value bool Name string Name { get; } Property Value string Methods Validate(BenchmarkCase, IResolver) IEnumerable<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver) Parameters benchmarkCase BenchmarkCase resolver IResolver Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Toolchains.Mono.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Mono.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.Mono | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.Mono Classes MonoAotBuilder MonoAotToolchain MonoGenerator MonoPublisher MonoToolchain"
  },
  "api/BenchmarkDotNet.Toolchains.Mono.MonoAotBuilder.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Mono.MonoAotBuilder.html",
    "title": "Class MonoAotBuilder | BenchmarkDotNet",
    "summary": "Class MonoAotBuilder Namespace BenchmarkDotNet.Toolchains.Mono Assembly BenchmarkDotNet.dll public class MonoAotBuilder : IBuilder Inheritance object MonoAotBuilder Implements IBuilder Constructors MonoAotBuilder() public MonoAotBuilder() Methods Build(GenerateResult, BuildPartition, ILogger) public BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger) Parameters generateResult GenerateResult buildPartition BuildPartition logger ILogger Returns BuildResult"
  },
  "api/BenchmarkDotNet.Toolchains.Mono.MonoAotToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Mono.MonoAotToolchain.html",
    "title": "Class MonoAotToolchain | BenchmarkDotNet",
    "summary": "Class MonoAotToolchain Namespace BenchmarkDotNet.Toolchains.Mono Assembly BenchmarkDotNet.dll public class MonoAotToolchain : Toolchain, IToolchain Inheritance object Toolchain MonoAotToolchain Implements IToolchain Inherited Members Toolchain.ToString() Toolchain.Name Toolchain.Generator Toolchain.Builder Toolchain.Executor Toolchain.IsInProcess Constructors MonoAotToolchain() public MonoAotToolchain() Fields Instance public static readonly IToolchain Instance Field Value IToolchain Methods Validate(BenchmarkCase, IResolver) public override IEnumerable<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver) Parameters benchmarkCase BenchmarkCase resolver IResolver Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Toolchains.Mono.MonoGenerator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Mono.MonoGenerator.html",
    "title": "Class MonoGenerator | BenchmarkDotNet",
    "summary": "Class MonoGenerator Namespace BenchmarkDotNet.Toolchains.Mono Assembly BenchmarkDotNet.dll public class MonoGenerator : CsProjGenerator, IGenerator, IEquatable<CsProjGenerator> Inheritance object GeneratorBase DotNetCliGenerator CsProjGenerator MonoGenerator Implements IGenerator IEquatable<CsProjGenerator> Inherited Members CsProjGenerator.GetBuildArtifactsDirectoryPath(BuildPartition, string) CsProjGenerator.GetProjectFilePath(string) CsProjGenerator.GetBinariesDirectoryPath(string, string) CsProjGenerator.GenerateProject(BuildPartition, ArtifactsPaths, ILogger) CsProjGenerator.GetProjectFilePath(Type, ILogger) CsProjGenerator.Equals(object) CsProjGenerator.Equals(CsProjGenerator) CsProjGenerator.GetHashCode() CsProjGenerator.RuntimeFrameworkVersion DotNetCliGenerator.GetExecutableExtension() DotNetCliGenerator.GetArtifactsToCleanup(ArtifactsPaths) DotNetCliGenerator.CopyAllRequiredFiles(ArtifactsPaths) DotNetCliGenerator.GetPackagesDirectoryPath(string) DotNetCliGenerator.GenerateBuildScript(BuildPartition, ArtifactsPaths) DotNetCliGenerator.TargetFrameworkMoniker DotNetCliGenerator.CliPath DotNetCliGenerator.PackagesPath DotNetCliGenerator.IsNetCore GeneratorBase.GenerateProject(BuildPartition, ILogger, string) GeneratorBase.GetPublishDirectoryPath(string, string) GeneratorBase.GenerateNuGetConfig(ArtifactsPaths) GeneratorBase.GenerateAppConfig(BuildPartition, ArtifactsPaths) GeneratorBase.GenerateCode(BuildPartition, ArtifactsPaths) GeneratorBase.GetExecutablePath(string, string) Constructors MonoGenerator(string, string, string, string) public MonoGenerator(string targetFrameworkMoniker, string cliPath, string packagesPath, string runtimeFrameworkVersion) Parameters targetFrameworkMoniker string cliPath string packagesPath string runtimeFrameworkVersion string Methods GetRuntimeSettings(GcMode, IResolver) returns an MSBuild string that defines Runtime settings protected override string GetRuntimeSettings(GcMode gcMode, IResolver resolver) Parameters gcMode GcMode resolver IResolver Returns string"
  },
  "api/BenchmarkDotNet.Toolchains.Mono.MonoPublisher.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Mono.MonoPublisher.html",
    "title": "Class MonoPublisher | BenchmarkDotNet",
    "summary": "Class MonoPublisher Namespace BenchmarkDotNet.Toolchains.Mono Assembly BenchmarkDotNet.dll public class MonoPublisher : IBuilder Inheritance object MonoPublisher Implements IBuilder Constructors MonoPublisher(string) public MonoPublisher(string customDotNetCliPath) Parameters customDotNetCliPath string Methods Build(GenerateResult, BuildPartition, ILogger) public BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger) Parameters generateResult GenerateResult buildPartition BuildPartition logger ILogger Returns BuildResult"
  },
  "api/BenchmarkDotNet.Toolchains.Mono.MonoToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Mono.MonoToolchain.html",
    "title": "Class MonoToolchain | BenchmarkDotNet",
    "summary": "Class MonoToolchain Namespace BenchmarkDotNet.Toolchains.Mono Assembly BenchmarkDotNet.dll public class MonoToolchain : CsProjCoreToolchain, IToolchain, IEquatable<CsProjCoreToolchain>, IEquatable<MonoToolchain> Inheritance object Toolchain CsProjCoreToolchain MonoToolchain Implements IToolchain IEquatable<CsProjCoreToolchain> IEquatable<MonoToolchain> Inherited Members CsProjCoreToolchain.NetCoreApp20 CsProjCoreToolchain.NetCoreApp21 CsProjCoreToolchain.NetCoreApp22 CsProjCoreToolchain.NetCoreApp30 CsProjCoreToolchain.NetCoreApp31 CsProjCoreToolchain.NetCoreApp50 CsProjCoreToolchain.NetCoreApp60 CsProjCoreToolchain.NetCoreApp70 CsProjCoreToolchain.NetCoreApp80 CsProjCoreToolchain.NetCoreApp90 CsProjCoreToolchain.NetCoreApp10_0 CsProjCoreToolchain.Validate(BenchmarkCase, IResolver) CsProjCoreToolchain.Equals(CsProjCoreToolchain) Toolchain.ToString() Toolchain.Name Toolchain.Generator Toolchain.Builder Toolchain.Executor Toolchain.IsInProcess Fields Mono10_0 public static readonly IToolchain Mono10_0 Field Value IToolchain Mono60 public static readonly IToolchain Mono60 Field Value IToolchain Mono70 public static readonly IToolchain Mono70 Field Value IToolchain Mono80 public static readonly IToolchain Mono80 Field Value IToolchain Mono90 public static readonly IToolchain Mono90 Field Value IToolchain Methods Equals(MonoToolchain) public bool Equals(MonoToolchain other) Parameters other MonoToolchain Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool From(NetCoreAppSettings) public static IToolchain From(NetCoreAppSettings settings) Parameters settings NetCoreAppSettings Returns IToolchain GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/BenchmarkDotNet.Toolchains.MonoAotLLVM.html": {
    "href": "api/BenchmarkDotNet.Toolchains.MonoAotLLVM.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.MonoAotLLVM | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.MonoAotLLVM Classes MonoAotLLVMGenerator MonoAotLLVMToolChain Enums MonoAotCompilerMode"
  },
  "api/BenchmarkDotNet.Toolchains.MonoAotLLVM.MonoAotCompilerMode.html": {
    "href": "api/BenchmarkDotNet.Toolchains.MonoAotLLVM.MonoAotCompilerMode.html",
    "title": "Enum MonoAotCompilerMode | BenchmarkDotNet",
    "summary": "Enum MonoAotCompilerMode Namespace BenchmarkDotNet.Toolchains.MonoAotLLVM Assembly BenchmarkDotNet.dll public enum MonoAotCompilerMode Fields llvm = 1 mini = 0 wasm = 2"
  },
  "api/BenchmarkDotNet.Toolchains.MonoAotLLVM.MonoAotLLVMGenerator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.MonoAotLLVM.MonoAotLLVMGenerator.html",
    "title": "Class MonoAotLLVMGenerator | BenchmarkDotNet",
    "summary": "Class MonoAotLLVMGenerator Namespace BenchmarkDotNet.Toolchains.MonoAotLLVM Assembly BenchmarkDotNet.dll public class MonoAotLLVMGenerator : CsProjGenerator, IGenerator, IEquatable<CsProjGenerator> Inheritance object GeneratorBase DotNetCliGenerator CsProjGenerator MonoAotLLVMGenerator Implements IGenerator IEquatable<CsProjGenerator> Inherited Members CsProjGenerator.GetBuildArtifactsDirectoryPath(BuildPartition, string) CsProjGenerator.GetProjectFilePath(string) CsProjGenerator.GetRuntimeSettings(GcMode, IResolver) CsProjGenerator.GetProjectFilePath(Type, ILogger) CsProjGenerator.Equals(object) CsProjGenerator.Equals(CsProjGenerator) CsProjGenerator.GetHashCode() CsProjGenerator.RuntimeFrameworkVersion DotNetCliGenerator.GetExecutableExtension() DotNetCliGenerator.GetArtifactsToCleanup(ArtifactsPaths) DotNetCliGenerator.CopyAllRequiredFiles(ArtifactsPaths) DotNetCliGenerator.GetPackagesDirectoryPath(string) DotNetCliGenerator.GenerateBuildScript(BuildPartition, ArtifactsPaths) DotNetCliGenerator.TargetFrameworkMoniker DotNetCliGenerator.CliPath DotNetCliGenerator.PackagesPath DotNetCliGenerator.IsNetCore GeneratorBase.GenerateProject(BuildPartition, ILogger, string) GeneratorBase.GenerateNuGetConfig(ArtifactsPaths) GeneratorBase.GenerateAppConfig(BuildPartition, ArtifactsPaths) GeneratorBase.GenerateCode(BuildPartition, ArtifactsPaths) Constructors MonoAotLLVMGenerator(string, string, string, string, string, MonoAotCompilerMode) public MonoAotLLVMGenerator(string targetFrameworkMoniker, string cliPath, string packagesPath, string customRuntimePack, string aotCompilerPath, MonoAotCompilerMode aotCompilerMode) Parameters targetFrameworkMoniker string cliPath string packagesPath string customRuntimePack string aotCompilerPath string aotCompilerMode MonoAotCompilerMode Methods GenerateProject(BuildPartition, ArtifactsPaths, ILogger) generates .csproj file with a reference to the project with benchmarks protected override void GenerateProject(BuildPartition buildPartition, ArtifactsPaths artifactsPaths, ILogger logger) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths logger ILogger GetBinariesDirectoryPath(string, string) returns a path where executable should be found after the build (usually \\bin) protected override string GetBinariesDirectoryPath(string buildArtifactsDirectoryPath, string configuration) Parameters buildArtifactsDirectoryPath string configuration string Returns string GetExecutablePath(string, string) protected override string GetExecutablePath(string binariesDirectoryPath, string programName) Parameters binariesDirectoryPath string programName string Returns string GetPublishDirectoryPath(string, string) returns a path where the publish directory should be found after the build (usually \\publish) protected override string GetPublishDirectoryPath(string buildArtifactsDirectoryPath, string configuration) Parameters buildArtifactsDirectoryPath string configuration string Returns string"
  },
  "api/BenchmarkDotNet.Toolchains.MonoAotLLVM.MonoAotLLVMToolChain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.MonoAotLLVM.MonoAotLLVMToolChain.html",
    "title": "Class MonoAotLLVMToolChain | BenchmarkDotNet",
    "summary": "Class MonoAotLLVMToolChain Namespace BenchmarkDotNet.Toolchains.MonoAotLLVM Assembly BenchmarkDotNet.dll public class MonoAotLLVMToolChain : Toolchain, IToolchain Inheritance object Toolchain MonoAotLLVMToolChain Implements IToolchain Inherited Members Toolchain.ToString() Toolchain.Name Toolchain.Generator Toolchain.Builder Toolchain.Executor Toolchain.IsInProcess Constructors MonoAotLLVMToolChain(string, IGenerator, IBuilder, IExecutor, string) public MonoAotLLVMToolChain(string name, IGenerator generator, IBuilder builder, IExecutor executor, string customDotNetCliPath) Parameters name string generator IGenerator builder IBuilder executor IExecutor customDotNetCliPath string Methods From(NetCoreAppSettings) public static IToolchain From(NetCoreAppSettings netCoreAppSettings) Parameters netCoreAppSettings NetCoreAppSettings Returns IToolchain Validate(BenchmarkCase, IResolver) public override IEnumerable<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver) Parameters benchmarkCase BenchmarkCase resolver IResolver Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Toolchains.MonoWasm.html": {
    "href": "api/BenchmarkDotNet.Toolchains.MonoWasm.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.MonoWasm | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.MonoWasm Classes WasmGenerator WasmToolchain"
  },
  "api/BenchmarkDotNet.Toolchains.MonoWasm.WasmGenerator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.MonoWasm.WasmGenerator.html",
    "title": "Class WasmGenerator | BenchmarkDotNet",
    "summary": "Class WasmGenerator Namespace BenchmarkDotNet.Toolchains.MonoWasm Assembly BenchmarkDotNet.dll public class WasmGenerator : CsProjGenerator, IGenerator, IEquatable<CsProjGenerator> Inheritance object GeneratorBase DotNetCliGenerator CsProjGenerator WasmGenerator Implements IGenerator IEquatable<CsProjGenerator> Inherited Members CsProjGenerator.GetBuildArtifactsDirectoryPath(BuildPartition, string) CsProjGenerator.GetProjectFilePath(string) CsProjGenerator.GetRuntimeSettings(GcMode, IResolver) CsProjGenerator.GetProjectFilePath(Type, ILogger) CsProjGenerator.Equals(object) CsProjGenerator.Equals(CsProjGenerator) CsProjGenerator.GetHashCode() CsProjGenerator.RuntimeFrameworkVersion DotNetCliGenerator.GetExecutableExtension() DotNetCliGenerator.GetArtifactsToCleanup(ArtifactsPaths) DotNetCliGenerator.CopyAllRequiredFiles(ArtifactsPaths) DotNetCliGenerator.GetPackagesDirectoryPath(string) DotNetCliGenerator.GenerateBuildScript(BuildPartition, ArtifactsPaths) DotNetCliGenerator.TargetFrameworkMoniker DotNetCliGenerator.CliPath DotNetCliGenerator.PackagesPath DotNetCliGenerator.IsNetCore GeneratorBase.GenerateProject(BuildPartition, ILogger, string) GeneratorBase.GetPublishDirectoryPath(string, string) GeneratorBase.GenerateNuGetConfig(ArtifactsPaths) GeneratorBase.GenerateAppConfig(BuildPartition, ArtifactsPaths) GeneratorBase.GenerateCode(BuildPartition, ArtifactsPaths) Constructors WasmGenerator(string, string, string, string, bool) public WasmGenerator(string targetFrameworkMoniker, string cliPath, string packagesPath, string customRuntimePack, bool aot) Parameters targetFrameworkMoniker string cliPath string packagesPath string customRuntimePack string aot bool Methods GenerateProject(BuildPartition, ArtifactsPaths, ILogger) generates .csproj file with a reference to the project with benchmarks protected override void GenerateProject(BuildPartition buildPartition, ArtifactsPaths artifactsPaths, ILogger logger) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths logger ILogger GenerateProjectFile(BuildPartition, ArtifactsPaths, bool, ILogger) protected void GenerateProjectFile(BuildPartition buildPartition, ArtifactsPaths artifactsPaths, bool aot, ILogger logger) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths aot bool logger ILogger GetBinariesDirectoryPath(string, string) returns a path where executable should be found after the build (usually \\bin) protected override string GetBinariesDirectoryPath(string buildArtifactsDirectoryPath, string configuration) Parameters buildArtifactsDirectoryPath string configuration string Returns string GetExecutablePath(string, string) protected override string GetExecutablePath(string binariesDirectoryPath, string programName) Parameters binariesDirectoryPath string programName string Returns string"
  },
  "api/BenchmarkDotNet.Toolchains.MonoWasm.WasmToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.MonoWasm.WasmToolchain.html",
    "title": "Class WasmToolchain | BenchmarkDotNet",
    "summary": "Class WasmToolchain Namespace BenchmarkDotNet.Toolchains.MonoWasm Assembly BenchmarkDotNet.dll public class WasmToolchain : Toolchain, IToolchain Inheritance object Toolchain WasmToolchain Implements IToolchain Inherited Members Toolchain.ToString() Toolchain.Name Toolchain.Generator Toolchain.Builder Toolchain.Executor Toolchain.IsInProcess Methods From(NetCoreAppSettings) public static IToolchain From(NetCoreAppSettings netCoreAppSettings) Parameters netCoreAppSettings NetCoreAppSettings Returns IToolchain Validate(BenchmarkCase, IResolver) public override IEnumerable<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver) Parameters benchmarkCase BenchmarkCase resolver IResolver Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Toolchains.NativeAot.Generator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.NativeAot.Generator.html",
    "title": "Class Generator | BenchmarkDotNet",
    "summary": "Class Generator Namespace BenchmarkDotNet.Toolchains.NativeAot Assembly BenchmarkDotNet.dll generates new csproj file for self-contained NativeAOT app based on https://github.com/dotnet/corert/blob/7f902d4d8b1c3280e60f5e06c71951a60da173fb/Documentation/how-to-build-and-run-ilcompiler-in-console-shell-prompt.md#compiling-source-to-native-code-using-the-ilcompiler-you-built and https://github.com/dotnet/corert/tree/7f902d4d8b1c3280e60f5e06c71951a60da173fb/samples/HelloWorld#add-corert-to-your-project public class Generator : CsProjGenerator, IGenerator, IEquatable<CsProjGenerator> Inheritance object GeneratorBase DotNetCliGenerator CsProjGenerator Generator Implements IGenerator IEquatable<CsProjGenerator> Inherited Members CsProjGenerator.GetProjectFilePath(string) CsProjGenerator.GetRuntimeSettings(GcMode, IResolver) CsProjGenerator.GetProjectFilePath(Type, ILogger) CsProjGenerator.Equals(object) CsProjGenerator.Equals(CsProjGenerator) CsProjGenerator.GetHashCode() CsProjGenerator.RuntimeFrameworkVersion DotNetCliGenerator.CopyAllRequiredFiles(ArtifactsPaths) DotNetCliGenerator.GetPackagesDirectoryPath(string) DotNetCliGenerator.TargetFrameworkMoniker DotNetCliGenerator.CliPath DotNetCliGenerator.PackagesPath DotNetCliGenerator.IsNetCore GeneratorBase.GenerateProject(BuildPartition, ILogger, string) GeneratorBase.GetPublishDirectoryPath(string, string) GeneratorBase.GenerateAppConfig(BuildPartition, ArtifactsPaths) GeneratorBase.GenerateCode(BuildPartition, ArtifactsPaths) GeneratorBase.GetExecutablePath(string, string) Methods GenerateBuildScript(BuildPartition, ArtifactsPaths) generates a script can be used when debugging compilation issues protected override void GenerateBuildScript(BuildPartition buildPartition, ArtifactsPaths artifactsPaths) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths GenerateNuGetConfig(ArtifactsPaths) generates NuGet.Config file to make sure that BDN is using the right NuGet feeds protected override void GenerateNuGetConfig(ArtifactsPaths artifactsPaths) Parameters artifactsPaths ArtifactsPaths GenerateProject(BuildPartition, ArtifactsPaths, ILogger) generates .csproj file with a reference to the project with benchmarks protected override void GenerateProject(BuildPartition buildPartition, ArtifactsPaths artifactsPaths, ILogger logger) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths logger ILogger GetArtifactsToCleanup(ArtifactsPaths) returns a list of artifacts that should be removed after running the benchmarks protected override string[] GetArtifactsToCleanup(ArtifactsPaths artifactsPaths) Parameters artifactsPaths ArtifactsPaths Returns string[] GetBinariesDirectoryPath(string, string) returns a path where executable should be found after the build (usually \\bin) protected override string GetBinariesDirectoryPath(string buildArtifactsDirectoryPath, string configuration) Parameters buildArtifactsDirectoryPath string configuration string Returns string GetBuildArtifactsDirectoryPath(BuildPartition, string) we need our folder to be on the same level as the project that we want to reference we are limited by xprojs (by default compiles all .cs files in all subfolders, Program.cs could be doubled and fail the build) and also by NuGet internal implementation like looking for global.json file in parent folders protected override string GetBuildArtifactsDirectoryPath(BuildPartition buildPartition, string programName) Parameters buildPartition BuildPartition programName string Returns string GetExecutableExtension() returns OS-specific executable extension protected override string GetExecutableExtension() Returns string GetRdXmlFiles(Type, ILogger) public IEnumerable<string> GetRdXmlFiles(Type benchmarkTarget, ILogger logger) Parameters benchmarkTarget Type logger ILogger Returns IEnumerable<string>"
  },
  "api/BenchmarkDotNet.Toolchains.NativeAot.html": {
    "href": "api/BenchmarkDotNet.Toolchains.NativeAot.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.NativeAot | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.NativeAot Classes Generator generates new csproj file for self-contained NativeAOT app based on https://github.com/dotnet/corert/blob/7f902d4d8b1c3280e60f5e06c71951a60da173fb/Documentation/how-to-build-and-run-ilcompiler-in-console-shell-prompt.md#compiling-source-to-native-code-using-the-ilcompiler-you-built and https://github.com/dotnet/corert/tree/7f902d4d8b1c3280e60f5e06c71951a60da173fb/samples/HelloWorld#add-corert-to-your-project NativeAotToolchain NativeAotToolchainBuilder"
  },
  "api/BenchmarkDotNet.Toolchains.NativeAot.NativeAotToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.NativeAot.NativeAotToolchain.html",
    "title": "Class NativeAotToolchain | BenchmarkDotNet",
    "summary": "Class NativeAotToolchain Namespace BenchmarkDotNet.Toolchains.NativeAot Assembly BenchmarkDotNet.dll public class NativeAotToolchain : Toolchain, IToolchain Inheritance object Toolchain NativeAotToolchain Implements IToolchain Inherited Members Toolchain.ToString() Toolchain.Name Toolchain.Generator Toolchain.Builder Toolchain.Executor Toolchain.IsInProcess Fields Net10_0 compiled as net10.0, targets latest NativeAOT build from the .NET 10 feed: https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet10/nuget/v3/index.json public static readonly IToolchain Net10_0 Field Value IToolchain Net60 compiled as net6.0, targets experimental 6.0.0-* NativeAOT build from the https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-experimental/nuget/v3/index.json public static readonly IToolchain Net60 Field Value IToolchain Net70 compiled as net7.0, targets latest NativeAOT build from the NuGet.org feed public static readonly IToolchain Net70 Field Value IToolchain Net80 compiled as net8.0, targets latest NativeAOT build from the NuGet.org feed: \"https://api.nuget.org/v3/index.json\" public static readonly IToolchain Net80 Field Value IToolchain Net90 compiled as net9.0, targets latest NativeAOT build from the .NET 9 feed: https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet9/nuget/v3/index.json public static readonly IToolchain Net90 Field Value IToolchain Methods CreateBuilder() public static NativeAotToolchainBuilder CreateBuilder() Returns NativeAotToolchainBuilder GetExtraArguments(string) public static string GetExtraArguments(string runtimeIdentifier) Parameters runtimeIdentifier string Returns string Validate(BenchmarkCase, IResolver) public override IEnumerable<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver) Parameters benchmarkCase BenchmarkCase resolver IResolver Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Toolchains.NativeAot.NativeAotToolchainBuilder.html": {
    "href": "api/BenchmarkDotNet.Toolchains.NativeAot.NativeAotToolchainBuilder.html",
    "title": "Class NativeAotToolchainBuilder | BenchmarkDotNet",
    "summary": "Class NativeAotToolchainBuilder Namespace BenchmarkDotNet.Toolchains.NativeAot Assembly BenchmarkDotNet.dll public class NativeAotToolchainBuilder : CustomDotNetCliToolchainBuilder Inheritance object CustomDotNetCliToolchainBuilder NativeAotToolchainBuilder Inherited Members CustomDotNetCliToolchainBuilder.Feeds CustomDotNetCliToolchainBuilder.runtimeIdentifier CustomDotNetCliToolchainBuilder.customDotNetCliPath CustomDotNetCliToolchainBuilder.displayName CustomDotNetCliToolchainBuilder.runtimeFrameworkVersion CustomDotNetCliToolchainBuilder.useNuGetClearTag CustomDotNetCliToolchainBuilder.useTempFolderForRestore CustomDotNetCliToolchainBuilder.AdditionalNuGetFeed(string, string) CustomDotNetCliToolchainBuilder.UseNuGetClearTag(bool) CustomDotNetCliToolchainBuilder.TargetFrameworkMoniker(string) CustomDotNetCliToolchainBuilder.GetTargetFrameworkMoniker() CustomDotNetCliToolchainBuilder.DotNetCli(string) CustomDotNetCliToolchainBuilder.RuntimeIdentifier(string) CustomDotNetCliToolchainBuilder.RuntimeFrameworkVersion(string) CustomDotNetCliToolchainBuilder.DisplayName(string) CustomDotNetCliToolchainBuilder.UseTempFolderForRestore(bool) Constructors NativeAotToolchainBuilder() public NativeAotToolchainBuilder() Methods Create() public static NativeAotToolchainBuilder Create() Returns NativeAotToolchainBuilder IlcGenerateCompleteTypeMetadata(bool) This controls the generation of complete type metadata. This option is enabled by default. This is a compilation mode that prevents a situation where some members of a type are visible to reflection at runtime, but others aren't, because they weren't compiled. public NativeAotToolchainBuilder IlcGenerateCompleteTypeMetadata(bool value) Parameters value bool Returns NativeAotToolchainBuilder IlcGenerateStackTraceData(bool) This controls generation of stack trace metadata that provides textual names in stack traces. This option is enabled by default. This is for example the text string one gets by calling Exception.ToString() on a caught exception. With this option disabled, stack traces will still be generated, but will be based on reflection metadata alone (they might be less complete). public NativeAotToolchainBuilder IlcGenerateStackTraceData(bool value) Parameters value bool Returns NativeAotToolchainBuilder IlcInstructionSet(string) By default, the compiler targets the minimum instruction set supported by the target OS and architecture. This option allows targeting newer instruction sets for better performance. The native binary will require the instruction sets to be supported by the hardware in order to run. For example, avx2,bmi2,fma,pclmul,popcnt,aes will produce binary that takes advantage of instruction sets that are typically present on current Intel and AMD processors. public NativeAotToolchainBuilder IlcInstructionSet(string value) Parameters value string Specify empty string (\"\", not null) to use the defaults. Returns NativeAotToolchainBuilder IlcOptimizationPreference(string) Options related to code generation. public NativeAotToolchainBuilder IlcOptimizationPreference(string value = \"Speed\") Parameters value string \"Speed\" to favor code execution speed (default), \"Size\" to favor smaller code size Returns NativeAotToolchainBuilder PackagesRestorePath(string) The directory to restore packages to (optional). public NativeAotToolchainBuilder PackagesRestorePath(string packagesRestorePath) Parameters packagesRestorePath string Returns NativeAotToolchainBuilder RootAllApplicationAssemblies(bool) This controls the compiler behavior where all code in the application assemblies is considered dynamically reachable. This option is disabled by default. Enabling this option (true) has a significant effect on the size of the resulting executable because it prevents removal of unused code that would otherwise happen. public NativeAotToolchainBuilder RootAllApplicationAssemblies(bool value) Parameters value bool Returns NativeAotToolchainBuilder ToToolchain() public override IToolchain ToToolchain() Returns IToolchain UseLocalBuild(DirectoryInfo) creates a NativeAOT toolchain targeting local build of ILCompiler Based on https://github.com/dotnet/runtime/blob/main/docs/workflow/building/coreclr/nativeaot.md public NativeAotToolchainBuilder UseLocalBuild(DirectoryInfo ilcPackages) Parameters ilcPackages DirectoryInfo the path to shipping packages, example: \"C:\\runtime\\artifacts\\packages\\Release\\Shipping\" Returns NativeAotToolchainBuilder UseNuGet(string, string) creates a NativeAOT toolchain targeting NuGet build of Microsoft.DotNet.ILCompiler Based on https://github.com/dotnet/runtimelab/blob/d0a37893a67c125f9b0cd8671846ff7d867df241/samples/HelloWorld/README.md#add-corert-to-your-project public NativeAotToolchainBuilder UseNuGet(string microsoftDotNetILCompilerVersion = \"\", string nuGetFeedUrl = \"https://api.nuget.org/v3/index.json\") Parameters microsoftDotNetILCompilerVersion string the version of Microsoft.DotNet.ILCompiler which should be used. The default is empty which maps to latest version. nuGetFeedUrl string url to NuGet feed, The default is: \"https://api.nuget.org/v3/index.json\" Returns NativeAotToolchainBuilder"
  },
  "api/BenchmarkDotNet.Toolchains.Parameters.ExecuteParameters.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Parameters.ExecuteParameters.html",
    "title": "Class ExecuteParameters | BenchmarkDotNet",
    "summary": "Class ExecuteParameters Namespace BenchmarkDotNet.Toolchains.Parameters Assembly BenchmarkDotNet.dll public class ExecuteParameters Inheritance object ExecuteParameters Constructors ExecuteParameters(BuildResult, BenchmarkCase, BenchmarkId, ILogger, IResolver, int, IDiagnoser?) public ExecuteParameters(BuildResult buildResult, BenchmarkCase benchmarkCase, BenchmarkId benchmarkId, ILogger logger, IResolver resolver, int launchIndex, IDiagnoser? diagnoser = null) Parameters buildResult BuildResult benchmarkCase BenchmarkCase benchmarkId BenchmarkId logger ILogger resolver IResolver launchIndex int diagnoser IDiagnoser Properties BenchmarkCase public BenchmarkCase BenchmarkCase { get; } Property Value BenchmarkCase BenchmarkId public BenchmarkId BenchmarkId { get; } Property Value BenchmarkId BuildResult public BuildResult BuildResult { get; } Property Value BuildResult Diagnoser public IDiagnoser Diagnoser { get; } Property Value IDiagnoser LaunchIndex public int LaunchIndex { get; } Property Value int Logger public ILogger Logger { get; } Property Value ILogger Resolver public IResolver Resolver { get; } Property Value IResolver"
  },
  "api/BenchmarkDotNet.Toolchains.Parameters.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Parameters.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.Parameters | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.Parameters Classes ExecuteParameters"
  },
  "api/BenchmarkDotNet.Toolchains.Results.BuildResult.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Results.BuildResult.html",
    "title": "Class BuildResult | BenchmarkDotNet",
    "summary": "Class BuildResult Namespace BenchmarkDotNet.Toolchains.Results Assembly BenchmarkDotNet.dll public class BuildResult : GenerateResult Inheritance object GenerateResult BuildResult Inherited Members GenerateResult.Success(ArtifactsPaths, IReadOnlyCollection<string>) GenerateResult.Failure(ArtifactsPaths, IReadOnlyCollection<string>, Exception) GenerateResult.ArtifactsPaths GenerateResult.IsGenerateSuccess GenerateResult.GenerateException GenerateResult.ArtifactsToCleanup Properties ErrorMessage public string ErrorMessage { get; } Property Value string IsBuildSuccess public bool IsBuildSuccess { get; } Property Value bool Methods Failure(GenerateResult, Exception) public static BuildResult Failure(GenerateResult generateResult, Exception exception) Parameters generateResult GenerateResult exception Exception Returns BuildResult Failure(GenerateResult, string) public static BuildResult Failure(GenerateResult generateResult, string errorMessage) Parameters generateResult GenerateResult errorMessage string Returns BuildResult Success(GenerateResult) public static BuildResult Success(GenerateResult generateResult) Parameters generateResult GenerateResult Returns BuildResult ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Toolchains.Results.ExecuteResult.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Results.ExecuteResult.html",
    "title": "Class ExecuteResult | BenchmarkDotNet",
    "summary": "Class ExecuteResult Namespace BenchmarkDotNet.Toolchains.Results Assembly BenchmarkDotNet.dll public class ExecuteResult Inheritance object ExecuteResult Constructors ExecuteResult(bool, int?, int?, IReadOnlyList<string>, IReadOnlyList<string>, IReadOnlyList<string>, int) public ExecuteResult(bool foundExecutable, int? exitCode, int? processId, IReadOnlyList<string> results, IReadOnlyList<string> prefixedLines, IReadOnlyList<string> standardOutput, int launchIndex) Parameters foundExecutable bool exitCode int? processId int? results IReadOnlyList<string> prefixedLines IReadOnlyList<string> standardOutput IReadOnlyList<string> launchIndex int Properties Errors public IReadOnlyList<string> Errors { get; } Property Value IReadOnlyList<string> ExitCode public int? ExitCode { get; } Property Value int? FoundExecutable public bool FoundExecutable { get; } Property Value bool IsSuccess public bool IsSuccess { get; } Property Value bool Measurements public IReadOnlyList<Measurement> Measurements { get; } Property Value IReadOnlyList<Measurement> PrefixedLines Lines reported by the Benchmark process that are starting with \"//\" public IReadOnlyList<string> PrefixedLines { get; } Property Value IReadOnlyList<string> ProcessId public int? ProcessId { get; } Property Value int? Results Lines reported by the Benchmark process that are not starting with \"//\" public IReadOnlyList<string> Results { get; } Property Value IReadOnlyList<string> StandardOutput All lines printed to standard output by the Benchmark process public IReadOnlyList<string> StandardOutput { get; } Property Value IReadOnlyList<string> Methods LogIssues(ILogger, BuildResult) public void LogIssues(ILogger logger, BuildResult buildResult) Parameters logger ILogger buildResult BuildResult ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Toolchains.Results.GenerateResult.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Results.GenerateResult.html",
    "title": "Class GenerateResult | BenchmarkDotNet",
    "summary": "Class GenerateResult Namespace BenchmarkDotNet.Toolchains.Results Assembly BenchmarkDotNet.dll public class GenerateResult Inheritance object GenerateResult Derived BuildResult Constructors GenerateResult(ArtifactsPaths, bool, Exception, IReadOnlyCollection<string>) public GenerateResult(ArtifactsPaths artifactsPaths, bool isGenerateSuccess, Exception generateException, IReadOnlyCollection<string> artifactsToCleanup) Parameters artifactsPaths ArtifactsPaths isGenerateSuccess bool generateException Exception artifactsToCleanup IReadOnlyCollection<string> Properties ArtifactsPaths public ArtifactsPaths ArtifactsPaths { get; } Property Value ArtifactsPaths ArtifactsToCleanup public IReadOnlyCollection<string> ArtifactsToCleanup { get; } Property Value IReadOnlyCollection<string> GenerateException public Exception GenerateException { get; } Property Value Exception IsGenerateSuccess public bool IsGenerateSuccess { get; } Property Value bool Methods Failure(ArtifactsPaths, IReadOnlyCollection<string>, Exception?) public static GenerateResult Failure(ArtifactsPaths artifactsPaths, IReadOnlyCollection<string> artifactsToCleanup, Exception? exception = null) Parameters artifactsPaths ArtifactsPaths artifactsToCleanup IReadOnlyCollection<string> exception Exception Returns GenerateResult Success(ArtifactsPaths, IReadOnlyCollection<string>) public static GenerateResult Success(ArtifactsPaths artifactsPaths, IReadOnlyCollection<string> artifactsToCleanup) Parameters artifactsPaths ArtifactsPaths artifactsToCleanup IReadOnlyCollection<string> Returns GenerateResult ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Toolchains.Results.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Results.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.Results | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.Results Classes BuildResult ExecuteResult GenerateResult"
  },
  "api/BenchmarkDotNet.Toolchains.Roslyn.Builder.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Roslyn.Builder.html",
    "title": "Class Builder | BenchmarkDotNet",
    "summary": "Class Builder Namespace BenchmarkDotNet.Toolchains.Roslyn Assembly BenchmarkDotNet.dll public class Builder : IBuilder Inheritance object Builder Implements IBuilder Constructors Builder() public Builder() Fields Instance public static readonly IBuilder Instance Field Value IBuilder Methods Build(GenerateResult, BuildPartition, ILogger) public BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger) Parameters generateResult GenerateResult buildPartition BuildPartition logger ILogger Returns BuildResult"
  },
  "api/BenchmarkDotNet.Toolchains.Roslyn.Generator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Roslyn.Generator.html",
    "title": "Class Generator | BenchmarkDotNet",
    "summary": "Class Generator Namespace BenchmarkDotNet.Toolchains.Roslyn Assembly BenchmarkDotNet.dll public class Generator : GeneratorBase, IGenerator Inheritance object GeneratorBase Generator Implements IGenerator Inherited Members GeneratorBase.GenerateProject(BuildPartition, ILogger, string) GeneratorBase.GetBinariesDirectoryPath(string, string) GeneratorBase.GetPublishDirectoryPath(string, string) GeneratorBase.GetExecutableExtension() GeneratorBase.GetProjectFilePath(string) GeneratorBase.CopyAllRequiredFiles(ArtifactsPaths) GeneratorBase.GenerateNuGetConfig(ArtifactsPaths) GeneratorBase.GenerateProject(BuildPartition, ArtifactsPaths, ILogger) GeneratorBase.GetPackagesDirectoryPath(string) GeneratorBase.GenerateAppConfig(BuildPartition, ArtifactsPaths) GeneratorBase.GenerateCode(BuildPartition, ArtifactsPaths) GeneratorBase.GetExecutablePath(string, string) Constructors Generator() public Generator() Methods GenerateBuildScript(BuildPartition, ArtifactsPaths) generates a script can be used when debugging compilation issues protected override void GenerateBuildScript(BuildPartition buildPartition, ArtifactsPaths artifactsPaths) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths GetArtifactsToCleanup(ArtifactsPaths) returns a list of artifacts that should be removed after running the benchmarks protected override string[] GetArtifactsToCleanup(ArtifactsPaths artifactsPaths) Parameters artifactsPaths ArtifactsPaths Returns string[] GetBuildArtifactsDirectoryPath(BuildPartition, string) returns a path to the folder where auto-generated project and code are going to be placed protected override string GetBuildArtifactsDirectoryPath(BuildPartition buildPartition, string programName) Parameters buildPartition BuildPartition programName string Returns string"
  },
  "api/BenchmarkDotNet.Toolchains.Roslyn.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Roslyn.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.Roslyn | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.Roslyn Classes Builder Generator RoslynToolchain Build a benchmark program with the Roslyn compiler."
  },
  "api/BenchmarkDotNet.Toolchains.Roslyn.RoslynToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Roslyn.RoslynToolchain.html",
    "title": "Class RoslynToolchain | BenchmarkDotNet",
    "summary": "Class RoslynToolchain Namespace BenchmarkDotNet.Toolchains.Roslyn Assembly BenchmarkDotNet.dll Build a benchmark program with the Roslyn compiler. public class RoslynToolchain : Toolchain, IToolchain Inheritance object Toolchain RoslynToolchain Implements IToolchain Inherited Members Toolchain.ToString() Toolchain.Name Toolchain.Generator Toolchain.Builder Toolchain.Executor Toolchain.IsInProcess Constructors RoslynToolchain() public RoslynToolchain() Fields Instance public static readonly IToolchain Instance Field Value IToolchain Methods Validate(BenchmarkCase, IResolver) public override IEnumerable<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver) Parameters benchmarkCase BenchmarkCase resolver IResolver Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Toolchains.Toolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Toolchain.html",
    "title": "Class Toolchain | BenchmarkDotNet",
    "summary": "Class Toolchain Namespace BenchmarkDotNet.Toolchains Assembly BenchmarkDotNet.dll public class Toolchain : IToolchain Inheritance object Toolchain Implements IToolchain Derived CsProjClassicNetToolchain CsProjCoreToolchain InProcessEmitToolchain MonoAotToolchain MonoAotLLVMToolChain WasmToolchain NativeAotToolchain RoslynToolchain Constructors Toolchain(string, IGenerator, IBuilder, IExecutor) public Toolchain(string name, IGenerator generator, IBuilder builder, IExecutor executor) Parameters name string generator IGenerator builder IBuilder executor IExecutor Properties Builder public IBuilder Builder { get; } Property Value IBuilder Executor public IExecutor Executor { get; } Property Value IExecutor Generator public IGenerator Generator { get; } Property Value IGenerator IsInProcess public virtual bool IsInProcess { get; } Property Value bool Name public string Name { get; } Property Value string Methods ToString() public override string ToString() Returns string Validate(BenchmarkCase, IResolver) public virtual IEnumerable<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver) Parameters benchmarkCase BenchmarkCase resolver IResolver Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.BaselineValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.BaselineValidator.html",
    "title": "Class BaselineValidator | BenchmarkDotNet",
    "summary": "Class BaselineValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class BaselineValidator : IValidator Inheritance object BaselineValidator Implements IValidator Fields FailOnError public static readonly BaselineValidator FailOnError Field Value BaselineValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters input) Parameters input ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.CompilationValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.CompilationValidator.html",
    "title": "Class CompilationValidator | BenchmarkDotNet",
    "summary": "Class CompilationValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class CompilationValidator : IValidator Inheritance object CompilationValidator Implements IValidator Fields FailOnError public static readonly IValidator FailOnError Field Value IValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.ConfigValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.ConfigValidator.html",
    "title": "Class ConfigValidator | BenchmarkDotNet",
    "summary": "Class ConfigValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class ConfigValidator : IValidator Inheritance object ConfigValidator Implements IValidator Fields DontFailOnError public static readonly IValidator DontFailOnError Field Value IValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.DeferredExecutionValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.DeferredExecutionValidator.html",
    "title": "Class DeferredExecutionValidator | BenchmarkDotNet",
    "summary": "Class DeferredExecutionValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class DeferredExecutionValidator : IValidator Inheritance object DeferredExecutionValidator Implements IValidator Fields DontFailOnError public static readonly IValidator DontFailOnError Field Value IValidator FailOnError public static readonly IValidator FailOnError Field Value IValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.DiagnosersValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.DiagnosersValidator.html",
    "title": "Class DiagnosersValidator | BenchmarkDotNet",
    "summary": "Class DiagnosersValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class DiagnosersValidator : IValidator Inheritance object DiagnosersValidator Implements IValidator Fields Composite public static readonly IValidator Composite Field Value IValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.ExecutionValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.ExecutionValidator.html",
    "title": "Class ExecutionValidator | BenchmarkDotNet",
    "summary": "Class ExecutionValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class ExecutionValidator : ExecutionValidatorBase, IValidator Inheritance object ExecutionValidatorBase ExecutionValidator Implements IValidator Inherited Members ExecutionValidatorBase.Validate(ValidationParameters) ExecutionValidatorBase.GetDisplayExceptionMessage(Exception) ExecutionValidatorBase.TreatsWarningsAsErrors Fields DontFailOnError public static readonly ExecutionValidator DontFailOnError Field Value ExecutionValidator FailOnError public static readonly ExecutionValidator FailOnError Field Value ExecutionValidator Methods ExecuteBenchmarks(object, IEnumerable<BenchmarkCase>, List<ValidationError>) protected override void ExecuteBenchmarks(object benchmarkTypeInstance, IEnumerable<BenchmarkCase> benchmarks, List<ValidationError> errors) Parameters benchmarkTypeInstance object benchmarks IEnumerable<BenchmarkCase> errors List<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.ExecutionValidatorBase.html": {
    "href": "api/BenchmarkDotNet.Validators.ExecutionValidatorBase.html",
    "title": "Class ExecutionValidatorBase | BenchmarkDotNet",
    "summary": "Class ExecutionValidatorBase Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public abstract class ExecutionValidatorBase : IValidator Inheritance object ExecutionValidatorBase Implements IValidator Derived ExecutionValidator ReturnValueValidator Constructors ExecutionValidatorBase(bool) protected ExecutionValidatorBase(bool failOnError) Parameters failOnError bool Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods ExecuteBenchmarks(object, IEnumerable<BenchmarkCase>, List<ValidationError>) protected abstract void ExecuteBenchmarks(object benchmarkTypeInstance, IEnumerable<BenchmarkCase> benchmarks, List<ValidationError> errors) Parameters benchmarkTypeInstance object benchmarks IEnumerable<BenchmarkCase> errors List<ValidationError> GetDisplayExceptionMessage(Exception) protected static string GetDisplayExceptionMessage(Exception ex) Parameters ex Exception Returns string Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.GenericBenchmarksValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.GenericBenchmarksValidator.html",
    "title": "Class GenericBenchmarksValidator | BenchmarkDotNet",
    "summary": "Class GenericBenchmarksValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class GenericBenchmarksValidator : IValidator Inheritance object GenericBenchmarksValidator Implements IValidator Constructors GenericBenchmarksValidator() public GenericBenchmarksValidator() Fields DontFailOnError public static readonly IValidator DontFailOnError Field Value IValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.html": {
    "href": "api/BenchmarkDotNet.Validators.html",
    "title": "Namespace BenchmarkDotNet.Validators | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Validators Classes BaselineValidator CompilationValidator ConfigValidator DeferredExecutionValidator DiagnosersValidator ExecutionValidator ExecutionValidatorBase GenericBenchmarksValidator JitOptimizationsValidator ParamsAllValuesValidator ParamsValidator ReturnValueValidator RunModeValidator RuntimeValidator Validator for runtime characteristic. https://github.com/dotnet/BenchmarkDotNet/issues/2609 SetupCleanupValidator ShadowCopyValidator ValidationError ValidationErrorReporter ValidationParameters Interfaces IValidator"
  },
  "api/BenchmarkDotNet.Validators.IValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.IValidator.html",
    "title": "Interface IValidator | BenchmarkDotNet",
    "summary": "Interface IValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public interface IValidator Properties TreatsWarningsAsErrors bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.JitOptimizationsValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.JitOptimizationsValidator.html",
    "title": "Class JitOptimizationsValidator | BenchmarkDotNet",
    "summary": "Class JitOptimizationsValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class JitOptimizationsValidator : IValidator Inheritance object JitOptimizationsValidator Implements IValidator Fields DontFailOnError public static readonly IValidator DontFailOnError Field Value IValidator FailOnError public static readonly IValidator FailOnError Field Value IValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.ParamsAllValuesValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.ParamsAllValuesValidator.html",
    "title": "Class ParamsAllValuesValidator | BenchmarkDotNet",
    "summary": "Class ParamsAllValuesValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class ParamsAllValuesValidator : IValidator Inheritance object ParamsAllValuesValidator Implements IValidator Fields FailOnError public static readonly ParamsAllValuesValidator FailOnError Field Value ParamsAllValuesValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters input) Parameters input ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.ParamsValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.ParamsValidator.html",
    "title": "Class ParamsValidator | BenchmarkDotNet",
    "summary": "Class ParamsValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class ParamsValidator : IValidator Inheritance object ParamsValidator Implements IValidator Constructors ParamsValidator() public ParamsValidator() Fields FailOnError public static readonly ParamsValidator FailOnError Field Value ParamsValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters input) Parameters input ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.ReturnValueValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.ReturnValueValidator.html",
    "title": "Class ReturnValueValidator | BenchmarkDotNet",
    "summary": "Class ReturnValueValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class ReturnValueValidator : ExecutionValidatorBase, IValidator Inheritance object ExecutionValidatorBase ReturnValueValidator Implements IValidator Inherited Members ExecutionValidatorBase.Validate(ValidationParameters) ExecutionValidatorBase.GetDisplayExceptionMessage(Exception) ExecutionValidatorBase.TreatsWarningsAsErrors Properties DontFailOnError public static ReturnValueValidator DontFailOnError { get; } Property Value ReturnValueValidator FailOnError public static ReturnValueValidator FailOnError { get; } Property Value ReturnValueValidator Methods ExecuteBenchmarks(object, IEnumerable<BenchmarkCase>, List<ValidationError>) protected override void ExecuteBenchmarks(object benchmarkTypeInstance, IEnumerable<BenchmarkCase> benchmarks, List<ValidationError> errors) Parameters benchmarkTypeInstance object benchmarks IEnumerable<BenchmarkCase> errors List<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.RunModeValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.RunModeValidator.html",
    "title": "Class RunModeValidator | BenchmarkDotNet",
    "summary": "Class RunModeValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class RunModeValidator : IValidator Inheritance object RunModeValidator Implements IValidator Fields FailOnError public static readonly IValidator FailOnError Field Value IValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.RuntimeValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.RuntimeValidator.html",
    "title": "Class RuntimeValidator | BenchmarkDotNet",
    "summary": "Class RuntimeValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll Validator for runtime characteristic. https://github.com/dotnet/BenchmarkDotNet/issues/2609 public class RuntimeValidator : IValidator Inheritance object RuntimeValidator Implements IValidator Fields DontFailOnError public static readonly IValidator DontFailOnError Field Value IValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters input) Parameters input ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.SetupCleanupValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.SetupCleanupValidator.html",
    "title": "Class SetupCleanupValidator | BenchmarkDotNet",
    "summary": "Class SetupCleanupValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class SetupCleanupValidator : IValidator Inheritance object SetupCleanupValidator Implements IValidator Fields FailOnError public static readonly SetupCleanupValidator FailOnError Field Value SetupCleanupValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters input) Parameters input ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.ShadowCopyValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.ShadowCopyValidator.html",
    "title": "Class ShadowCopyValidator | BenchmarkDotNet",
    "summary": "Class ShadowCopyValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class ShadowCopyValidator : IValidator Inheritance object ShadowCopyValidator Implements IValidator Fields DontFailOnError public static readonly IValidator DontFailOnError Field Value IValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.ValidationError.html": {
    "href": "api/BenchmarkDotNet.Validators.ValidationError.html",
    "title": "Class ValidationError | BenchmarkDotNet",
    "summary": "Class ValidationError Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class ValidationError : IEquatable<ValidationError> Inheritance object ValidationError Implements IEquatable<ValidationError> Constructors ValidationError(bool, string, BenchmarkCase?) public ValidationError(bool isCritical, string message, BenchmarkCase? benchmarkCase = null) Parameters isCritical bool message string benchmarkCase BenchmarkCase Properties BenchmarkCase public BenchmarkCase? BenchmarkCase { get; } Property Value BenchmarkCase IsCritical public bool IsCritical { get; } Property Value bool Message public string Message { get; } Property Value string Methods Equals(ValidationError?) public bool Equals(ValidationError? other) Parameters other ValidationError Returns bool Equals(object?) public override bool Equals(object? obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int ToString() public override string ToString() Returns string Operators operator ==(ValidationError, ValidationError) public static bool operator ==(ValidationError left, ValidationError right) Parameters left ValidationError right ValidationError Returns bool operator !=(ValidationError, ValidationError) public static bool operator !=(ValidationError left, ValidationError right) Parameters left ValidationError right ValidationError Returns bool"
  },
  "api/BenchmarkDotNet.Validators.ValidationErrorReporter.html": {
    "href": "api/BenchmarkDotNet.Validators.ValidationErrorReporter.html",
    "title": "Class ValidationErrorReporter | BenchmarkDotNet",
    "summary": "Class ValidationErrorReporter Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public static class ValidationErrorReporter Inheritance object ValidationErrorReporter Fields ConsoleErrorPrefix public const string ConsoleErrorPrefix = \"// ERROR: \" Field Value string Methods ReportIfAny(IEnumerable<ValidationError>, IHost) public static bool ReportIfAny(IEnumerable<ValidationError> validationErrors, IHost host) Parameters validationErrors IEnumerable<ValidationError> host IHost Returns bool"
  },
  "api/BenchmarkDotNet.Validators.ValidationParameters.html": {
    "href": "api/BenchmarkDotNet.Validators.ValidationParameters.html",
    "title": "Class ValidationParameters | BenchmarkDotNet",
    "summary": "Class ValidationParameters Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class ValidationParameters Inheritance object ValidationParameters Constructors ValidationParameters(IReadOnlyList<BenchmarkCase>, ImmutableConfig) public ValidationParameters(IReadOnlyList<BenchmarkCase> benchmarks, ImmutableConfig config) Parameters benchmarks IReadOnlyList<BenchmarkCase> config ImmutableConfig Properties Benchmarks public IReadOnlyList<BenchmarkCase> Benchmarks { get; } Property Value IReadOnlyList<BenchmarkCase> Config public ImmutableConfig Config { get; } Property Value ImmutableConfig Operators implicit operator ValidationParameters(BenchmarkCase[]) public static implicit operator ValidationParameters(BenchmarkCase[] benchmarksCase) Parameters benchmarksCase BenchmarkCase[] Returns ValidationParameters implicit operator ValidationParameters(BenchmarkRunInfo) public static implicit operator ValidationParameters(BenchmarkRunInfo benchmarkRunInfo) Parameters benchmarkRunInfo BenchmarkRunInfo Returns ValidationParameters"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "BenchmarkDotNet API Reference | BenchmarkDotNet",
    "summary": "BenchmarkDotNet API Reference"
  },
  "articles/configs/analysers.html": {
    "href": "articles/configs/analysers.html",
    "title": "Analysers | BenchmarkDotNet",
    "summary": "Analysers An analyser can analyse summary of your benchmarks and produce some useful warnings. For example, EnvironmentAnalyser warns you, if you build your application in the DEBUG mode or run it with an attached debugger."
  },
  "articles/configs/columns.html": {
    "href": "articles/configs/columns.html",
    "title": "Columns | BenchmarkDotNet",
    "summary": "Columns A column is a column in the summary table. Default columns In this section, default columns (which be added to the Summary table by default) are presented. Some of columns are optional, i.e. they can be omitted (it depends on the measurements from the summary). Target There are 3 default columns which describes the target benchmark: Namespace, Type, Method. Namespace and Type will be omitted when all the benchmarks have the same namespace or type name. Method column always be a part of the summary table. Job There are many different job characteristics, but the summary includes only characteristics which has at least one non-default value. Statistics There are also a lot of different statistics which can be considered. It will be really hard to analyse the summary table, if all of the available statistics will be shown. Fortunately, BenchmarkDotNet has some heuristics for statistics columns and shows only important columns. For example, if all of the standard deviations are zero (we run our benchmarks against Dry job), this column will be omitted. The standard error will be shown only for cases when we are failed to achieve required accuracy level. Only Mean will be always shown. If the distribution looks strange, BenchmarkDotNet could also print additional columns like Median or P95 (95th percentile). If you need specific statistics, you always could add them manually. Params If you have params, the corresponded columns will be automatically added. Diagnosers If you turned on diagnosers which providers additional columns, they will be also included in the summary page. Custom columns Of course, you can define own custom columns and use it everywhere. Here is the definition of TagColumn: using System; using BenchmarkDotNet.Reports; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Columns { public class TagColumn : IColumn { private readonly Func<string, string> getTag; public string Id { get; } public string ColumnName { get; } public TagColumn(string columnName, Func<string, string> getTag) { this.getTag = getTag; ColumnName = columnName; Id = nameof(TagColumn) + \".\" + ColumnName; } public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) => false; public string GetValue(Summary summary, BenchmarkCase benchmarkCase) => getTag(benchmarkCase.Descriptor?.WorkloadMethod?.Name ?? \"\"); public bool IsAvailable(Summary summary) => true; public bool AlwaysShow => true; public ColumnCategory Category => ColumnCategory.Custom; public int PriorityInCategory => 0; public bool IsNumeric => false; public UnitType UnitType => UnitType.Dimensionless; public string Legend => $\"Custom '{ColumnName}' tag column\"; public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) => GetValue(summary, benchmarkCase); public override string ToString() => ColumnName; } } Sample: IntroTagColumn In the following example, we introduce two new columns which contains a tag based on a benchmark method name. Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Columns; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { // You can add custom tags per each method using Columns [Config(typeof(Config))] public class IntroTagColumn { private class Config : ManualConfig { public Config() { AddJob(Job.Dry); AddColumn(new TagColumn(\"Kind\", name => name.Substring(0, 3))); AddColumn(new TagColumn(\"Number\", name => name.Substring(3))); } } [Benchmark] public void Foo1() => Thread.Sleep(10); [Benchmark] public void Foo12() => Thread.Sleep(10); [Benchmark] public void Bar3() => Thread.Sleep(10); [Benchmark] public void Bar34() => Thread.Sleep(10); } } Output | Method | Mean | Kind | Number | | ------ | ---------- | ---- | ------ | | Bar34 | 10.3636 ms | Bar | 34 | | Bar3 | 10.4662 ms | Bar | 3 | | Foo12 | 10.1377 ms | Foo | 12 | | Foo1 | 10.2814 ms | Foo | 1 | Links Columns The permanent link to this sample: BenchmarkDotNet.Samples.IntroTagColumn"
  },
  "articles/configs/configoptions.html": {
    "href": "articles/configs/configoptions.html",
    "title": "Config Options | BenchmarkDotNet",
    "summary": "Config Options The config options let you customize some behavior of BenchmarkDotNet - mainly regarding the output. Available config options are: ConfigOptions.Default - No configuration option is set - this is the default. ConfigOptions.KeepBenchmarkFiles - All auto-generated files should be kept after running the benchmarks (by default they are removed). ConfigOptions.JoinSummary - All benchmarks results should be joined into a single summary (by default we have a summary per type). ConfigOptions.StopOnFirstError - Benchmarking should be stopped after the first error (by default it's not). ConfigOptions.DisableOptimizationsValidator - Mandatory optimizations validator should be entirely turned off. ConfigOptions.DontOverwriteResults - The exported result files should not be overwritten (by default they are overwritten). ConfigOptions.DisableLogFile - Disables the log file written on disk. All of these options could be combined and are available as CLI (Comand Line Interface) option (except DisableOptimizationsValidator), see Console Arguments for further information how to use the CLI. Any of these options could be used either in object style config or fluent style config: Object style config public class Config : ManualConfig { public Config() { // Using the WithOptions() factory method: this.WithOptions(ConfigOptions.JoinSummary) .WithOptions(ConfigOptions.DisableLogFile); // Or (The ConfigOptions Enum is defined as a BitField) this.WithOptions(ConfigOptions.JoinSummary | ConfigOptions.DisableLogFile); } } Fluent style config public static void Run() { BenchmarkRunner .Run<Benchmarks>( ManualConfig .Create(DefaultConfig.Instance) .WithOptions(ConfigOptions.JoinSummary) .WithOptions(ConfigOptions.DisableLogFile) // or .WithOptions(ConfigOptions.JoinSummary | ConfigOptions.DisableLogFile)); }"
  },
  "articles/configs/configs.html": {
    "href": "articles/configs/configs.html",
    "title": "Configs | BenchmarkDotNet",
    "summary": "Configs Config is a set of so called jobs, columns, exporters, loggers, diagnosers, analysers, validators that help you to build your benchmark. Built-in configuration There are two built-in ways to set your config: Object style [Config(typeof(Config))] public class MyClassWithBenchmarks { private class Config : ManualConfig { public Config() { AddJob(new Job1(), new Job2()); AddColumn(new Column1(), new Column2()); AddColumnProvider(new ColumnProvider1(), new ColumnProvider2()); AddExporter(new Exporter1(), new Exporter2()); AddLogger(new Logger1(), new Logger2()); AddDiagnoser(new Diagnoser1(), new Diagnoser2()); AddAnalyser(new Analyser1(), new Analyser2()); AddValidator(new Validator2(),new Validator2()); AddHardwareCounters(HardwareCounter enum1, HardwareCounter enum2); AddFilter(new Filter1(), new Filter2()); AddLogicalGroupRules(BenchmarkLogicalGroupRule enum1, BenchmarkLogicalGroupRule enum2); } } [Benchmark] public void Benchmark1() { } [Benchmark] public void Benchmark2() { } } Sample: IntroConfigSource You can define own config attribute. Source code using System; using System.Linq; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [MyConfigSource(Jit.LegacyJit, Jit.RyuJit)] public class IntroConfigSource { /// <summary> /// Dry-x64 jobs for specific jits /// </summary> private class MyConfigSourceAttribute : Attribute, IConfigSource { public IConfig Config { get; } public MyConfigSourceAttribute(params Jit[] jits) { var jobs = jits .Select(jit => new Job(Job.Dry) { Environment = { Jit = jit, Platform = Platform.X64 } }) .ToArray(); Config = ManualConfig.CreateEmpty().AddJob(jobs); } } [Benchmark] public void Foo() { Thread.Sleep(10); } } } Links Configs The permanent link to this sample: BenchmarkDotNet.Samples.IntroConfigSource Sample: IntroConfigUnion Source code using System.Threading; using BenchmarkDotNet.Analysers; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Columns; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Exporters; using BenchmarkDotNet.Exporters.Csv; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Loggers; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] public class IntroConfigUnion { private class Config : ManualConfig { public Config() { AddJob(Job.Dry); AddLogger(ConsoleLogger.Default); AddColumn(TargetMethodColumn.Method, StatisticColumn.Max); AddExporter(RPlotExporter.Default, CsvExporter.Default); AddAnalyser(EnvironmentAnalyser.Default); UnionRule = ConfigUnionRule.AlwaysUseLocal; } } [Benchmark] public void Foo() { Thread.Sleep(10); } } } Links Configs The permanent link to this sample: BenchmarkDotNet.Samples.IntroConfigUnion Sample: IntroFluentConfigBuilder There is no need to create new Config type, you can simply use fluent interface. Source code using System; using System.Security.Cryptography; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; using BenchmarkDotNet.Validators; namespace BenchmarkDotNet.Samples { public class Algo_Md5VsSha256 { private const int N = 10000; private readonly byte[] data; private readonly MD5 md5 = MD5.Create(); private readonly SHA256 sha256 = SHA256.Create(); public Algo_Md5VsSha256() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark(Baseline = true)] public byte[] Md5() => md5.ComputeHash(data); [Benchmark] public byte[] Sha256() => sha256.ComputeHash(data); } public class IntroFluentConfigBuilder { public static void Run() { BenchmarkRunner .Run<Algo_Md5VsSha256>( DefaultConfig.Instance .AddJob(Job.Default.WithRuntime(ClrRuntime.Net462)) .AddJob(Job.Default.WithRuntime(CoreRuntime.Core80)) .AddValidator(ExecutionValidator.FailOnError)); } } } Links Configs The permanent link to this sample: BenchmarkDotNet.Samples.IntroFluentConfigBuilder"
  },
  "articles/configs/diagnosers.html": {
    "href": "articles/configs/diagnosers.html",
    "title": "Diagnosers | BenchmarkDotNet",
    "summary": "Diagnosers A diagnoser can attach to your benchmark and get some useful info. The current Diagnosers are: GC and Memory Allocation (MemoryDiagnoser) which is cross platform, built-in and is not enabled by default anymore. Please see Adam Sitnik's blog post for all the details. JIT Stats Diagnoser. You can find this diagnoser in a separate package with diagnosers for Windows (BenchmarkDotNet.Diagnostics.Windows): JIT Inlining Events (InliningDiagnoser). You can find this diagnoser in a separate package with diagnosers for Windows (BenchmarkDotNet.Diagnostics.Windows): JIT Tail Call Events (TailCallDiagnoser). You can find this diagnoser as well as the (InliningDiagnoser) in a separate package with diagnosers for Windows (BenchmarkDotNet.Diagnostics.Windows): Please see this post for all the details. Hardware Counter Diagnoser. You can find this diagnoser in a separate package with diagnosers for Windows (BenchmarkDotNet.Diagnostics.Windows): . Please see Adam Sitnik's blog post for all the details. Disassembly Diagnoser. It allows you to disassemble the benchmarked code to asm, IL and C#/F#. Please see Adam Sitnik's blog post for all the details. ETW Profiler (EtwProfiler). It allows you to not only benchmark, but also profile the code. It's using TraceEvent, which internally uses ETW and exports all the information to a trace file. The trace file contains all of the stack traces captured by the profiler, PDBs to resolve symbols for both native and managed code and captured GC, JIT and CLR events. Please use one of the free tools: PerfView or Windows Performance Analyzer to analyze and visualize the data from trace file. You can find this diagnoser in a separate package with diagnosers for Windows (BenchmarkDotNet.Diagnostics.Windows): Please see Adam Sitnik's blog post for all the details. Concurrency Visualizer Profiler (ConcurrencyVisualizerProfiler) It uses EtwProfiler to profile the code using ETW and create not only .etl file but also a CVTrace file which can be opened by Concurrency Visualizer plugin from Visual Studio. Please see Adam Sitnik's blog post for all the details. Native Memory Profiler (NativeMemoryProfiler) It uses EtwProfiler to profile the code using ETW and adds the extra columns Allocated native memory and Native memory leak. Please see Wojciech Nagrski's blog post for all the details. Event Pipe Profiler (EventPipeProfiler). It is a cross-platform profiler that allows profile .NET code on every platform - Windows, Linux, macOS. Please see Wojciech Nagrski's blog post for all the details. Threading Diagnoser (ThreadingDiagnoser) - .NET Core 3.0+ diagnoser that reports some Threading statistics. Exception Diagnoser (ExceptionDiagnoser) - a diagnoser that reports the frequency of exceptions thrown during the operation. Usage Below is a sample output from the GC and Memory Allocation diagnoser, note the extra columns on the right-hand side (\"Gen 0\", \"Gen 1\", \"Gen 2\" and \"Allocated\"): Method | Mean | StdErr | Median | Gen 0 | Allocated | ----------------- |------------ |----------- |------------ |------- |---------- | 'new byte[10kB]' | 884.4896 ns | 46.3528 ns | 776.4237 ns | 0.1183 | 10 kB | A config example: private class Config : ManualConfig { public Config() { AddDiagnoser(MemoryDiagnoser.Default); AddDiagnoser(new InliningDiagnoser()); AddDiagnoser(new EtwProfiler()); AddDiagnoser(ThreadingDiagnoser.Default); AddDiagnoser(ExceptionDiagnoser.Default); } } You can also use one of the following attributes (apply it on a class that contains Benchmarks): [MemoryDiagnoser] [InliningDiagnoser] [TailCallDiagnoser] [EtwProfiler] [ConcurrencyVisualizerProfiler] [NativeMemoryProfiler] [ThreadingDiagnoser] [ExceptionDiagnoser] In BenchmarkDotNet, 1kB = 1024B, 1MB = 1024kB, and so on. The column Gen X means number of GC collections per 1000 operations for that generation. Restrictions In order to not affect main results we perform a separate run if any diagnoser is used. That's why it might take more time to execute benchmarks. MemoryDiagnoser: In order to get the number of allocated bytes in cross platform way we are using GC.GetAllocatedBytesForCurrentThread which recently got exposed for netcoreapp1.1. That's why BenchmarkDotNet does not support netcoreapp1.0 from version 0.10.1. MemoryDiagnoser is 99.5% accurate about allocated memory when using default settings or Job.ShortRun (or any longer job than it). Threading Diagnoser: Works only for .NET Core 3.0+ HardwareCounters: Windows 8+ only (we plan to add Unix support in the future) No Hyper-V (Virtualization) support Requires running as Admin (ETW Kernel Session) No InProcessToolchain support (#394) EtwProfiler, ConcurrencyVisualizerProfiler and NativeMemoryProfiler: Windows only Requires running as Admin (ETW Kernel Session) No InProcessToolchain support (#394) Disassembly Diagnoser: .NET Core disassembler works only on Windows Mono disassembler does not support recursive disassembling and produces output without IL and C#. Indirect calls are not tracked. To be able to compare different platforms, you need to target AnyCPU <PlatformTarget>AnyCPU</PlatformTarget> To get the corresponding C#/F# code from disassembler you need to configure your project in following way: <DebugType>pdbonly</DebugType> <DebugSymbols>true</DebugSymbols> Sample: IntroHardwareCounters This diagnoser is not enabled in explicit way as the other diagnosers. You need to specify [HardwareCounters] and we choose the right diagnoser in the runtime. Source code using System; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnosers; namespace BenchmarkDotNet.Samples { [HardwareCounters( HardwareCounter.BranchMispredictions, HardwareCounter.BranchInstructions)] public class IntroHardwareCounters { private const int N = 32767; private readonly int[] sorted, unsorted; public IntroHardwareCounters() { var random = new Random(0); unsorted = new int[N]; sorted = new int[N]; for (int i = 0; i < N; i++) sorted[i] = unsorted[i] = random.Next(256); Array.Sort(sorted); } private static int Branch(int[] data) { int sum = 0; for (int i = 0; i < N; i++) if (data[i] >= 128) sum += data[i]; return sum; } private static int Branchless(int[] data) { int sum = 0; for (int i = 0; i < N; i++) { int t = (data[i] - 128) >> 31; sum += ~t & data[i]; } return sum; } [Benchmark] public int SortedBranch() => Branch(sorted); [Benchmark] public int UnsortedBranch() => Branch(unsorted); [Benchmark] public int SortedBranchless() => Branchless(sorted); [Benchmark] public int UnsortedBranchless() => Branchless(unsorted); } } Output Method Mean Mispredict rate BranchInstructions/Op BranchMispredictions/Op SortedBranch 21.4539 us 0,04% 70121 24 UnsortedBranch 136.1139 us 23,70% 68788 16301 SortedBranchless 28.6705 us 0,06% 35711 22 UnsortedBranchless 28.9336 us 0,05% 35578 17 Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroHardwareCounters Sample: IntroDisassemblyRyuJit Source code using System.Linq; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(printSource: true)] [RyuJitX64Job] public class IntroDisassemblyRyuJit { private int[] field = Enumerable.Range(0, 100).ToArray(); [Benchmark] public int SumLocal() { var local = field; // we use local variable that points to the field int sum = 0; for (int i = 0; i < local.Length; i++) sum += local[i]; return sum; } [Benchmark] public int SumField() { int sum = 0; for (int i = 0; i < field.Length; i++) sum += field[i]; return sum; } } } Output Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassemblyRyuJit Sample: IntroDisassembly Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnosers; using System.Linq; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(printInstructionAddresses: true, syntax: DisassemblySyntax.Masm)] public class IntroDisassembly { private int[] field = Enumerable.Range(0, 100).ToArray(); [Benchmark] public int SumLocal() { var local = field; // we use local variable that points to the field int sum = 0; for (int i = 0; i < local.Length; i++) sum += local[i]; return sum; } [Benchmark] public int SumField() { int sum = 0; for (int i = 0; i < field.Length; i++) sum += field[i]; return sum; } } } Output ; .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.7.3110.0 05452718 BenchmarkDotNet.Samples.IntroDisassembly.Sum() IL_0000: ldc.r8 0 IL_0009: stloc.0 0545271c d9ee fldz IL_000a: ldc.i4.0 IL_000b: stloc.1 IL_000c: br.s IL_0017 0545271e 33c0 xor eax,eax IL_000e: ldloc.0 IL_000f: ldloc.1 IL_0010: conv.r8 IL_0011: add IL_0012: stloc.0 05452720 8945fc mov dword ptr [ebp-4],eax 05452723 db45fc fild dword ptr [ebp-4] 05452726 dec1 faddp st(1),st IL_0013: ldloc.1 IL_0014: ldc.i4.1 IL_0015: add IL_0016: stloc.1 05452728 40 inc eax IL_0017: ldloc.1 IL_0018: ldc.i4.s 64 IL_001a: blt.s IL_000e 05452729 83f840 cmp eax,40h 0545272c 7cf2 jl 05452720 IL_001c: ldloc.0 IL_001d: ret 0545272e 8be5 mov esp,ebp ; .NET Core 2.1.0 (CoreCLR 4.6.26515.07, CoreFX 4.6.26515.06), 64bit RyuJIT 00007ffa`6c621320 BenchmarkDotNet.Samples.IntroDisassembly.Sum() IL_0000: ldc.r8 0 IL_0009: stloc.0 00007ffa`6c621323 c4e17857c0 vxorps xmm0,xmm0,xmm0 IL_000a: ldc.i4.0 IL_000b: stloc.1 IL_000c: br.s IL_0017 00007ffa`6c621328 33c0 xor eax,eax IL_000e: ldloc.0 IL_000f: ldloc.1 IL_0010: conv.r8 IL_0011: add IL_0012: stloc.0 00007ffa`6c62132a c4e17057c9 vxorps xmm1,xmm1,xmm1 00007ffa`6c62132f c4e1732ac8 vcvtsi2sd xmm1,xmm1,eax 00007ffa`6c621334 c4e17b58c1 vaddsd xmm0,xmm0,xmm1 IL_0013: ldloc.1 IL_0014: ldc.i4.1 IL_0015: add IL_0016: stloc.1 00007ffa`6c621339 ffc0 inc eax IL_0017: ldloc.1 IL_0018: ldc.i4.s 64 IL_001a: blt.s IL_000e 00007ffa`6c62133b 83f840 cmp eax,40h 00007ffa`6c62133e 7cea jl 00007ffa`6c62132a IL_001c: ldloc.0 IL_001d: ret 00007ffa`6c621340 c3 ret Mono 5.12.0 (Visual Studio), 64bit Sum sub $0x18,%rsp mov %rsi,(%rsp) xorpd %xmm0,%xmm0 movsd %xmm0,0x8(%rsp) xor %esi,%esi jmp 2e xchg %ax,%ax movsd 0x8(%rsp),%xmm0 cvtsi2sd %esi,%xmm1 addsd %xmm1,%xmm0 movsd %xmm0,0x8(%rsp) inc %esi cmp $0x40,%esi jl 18 movsd 0x8(%rsp),%xmm0 mov (%rsp),%rsi add $0x18,%rsp retq Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassembly Sample: IntroDisassemblyAllJits You can use a single config to compare the generated assembly code for ALL JITs. But to allow benchmarking any target platform architecture the project which defines benchmarks has to target AnyCPU. <PropertyGroup> <PlatformTarget>AnyCPU</PlatformTarget> </PropertyGroup> Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Diagnosers; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [Config(typeof(MultipleJits))] public class IntroDisassemblyAllJits { public class MultipleJits : ManualConfig { public MultipleJits() { AddJob(Job.ShortRun.WithPlatform(Platform.X86).WithRuntime(new MonoRuntime(name: \"Mono x86\", customPath: @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithPlatform(Platform.X64).WithRuntime(new MonoRuntime(name: \"Mono x64\", customPath: @\"C:\\Program Files\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithJit(Jit.LegacyJit).WithPlatform(Platform.X86).WithRuntime(ClrRuntime.Net462)); AddJob(Job.ShortRun.WithJit(Jit.LegacyJit).WithPlatform(Platform.X64).WithRuntime(ClrRuntime.Net462)); AddJob(Job.ShortRun.WithJit(Jit.RyuJit).WithPlatform(Platform.X64).WithRuntime(ClrRuntime.Net462)); // RyuJit for .NET Core 5.0 AddJob(Job.ShortRun.WithJit(Jit.RyuJit).WithPlatform(Platform.X64).WithRuntime(CoreRuntime.Core50)); AddDiagnoser(new DisassemblyDiagnoser(new DisassemblyDiagnoserConfig(maxDepth: 3, exportDiff: true))); } } private Increment increment = new Increment(); [Benchmark] public int CallVirtualMethod() => increment.OperateTwice(10); public abstract class Operation // abstract unary integer operation { public abstract int Operate(int input); public int OperateTwice(int input) => Operate(Operate(input)); // two virtual calls to Operate } public sealed class Increment : Operation // concrete, sealed operation: increment by fixed amount { public readonly int Amount; public Increment(int amount = 1) { Amount = amount; } public override int Operate(int input) => input + Amount; } } } Output The disassembly result can be obtained here. The file was too big to embed it in this doc page. Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassemblyAllJits Sample: IntroDisassemblyDry Getting only the Disassembly without running the benchmarks for a long time. Sometimes you might be interested only in the disassembly, not the results of the benchmarks. In that case you can use Job.Dry which runs the benchmark only once. Source code using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(maxDepth: 3)] [DryJob] public class IntroDisassemblyDry { [Benchmark] public void Foo() { } } } Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassemblyDry Sample: IntroTailcall You need to use the TailcallDiagnoser attribute to configure it. The available options are: logFailuresOnly: Track only the methods that failed to get tail called. True by default. filterByNamespace : Track only the methods from declaring type's namespace. Set to false if you want to see all Jit tail events. True by default. Restrictions Windows only x64 Source code using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [Diagnostics.Windows.Configs.TailCallDiagnoser] [LegacyJitX86Job, LegacyJitX64Job, RyuJitX64Job] public class IntroTailcall { [Benchmark] public long Calc() => FactorialWithoutTailing(7) - FactorialWithTailing(7); private static long FactorialWithoutTailing(int depth) => depth == 0 ? 1 : depth * FactorialWithoutTailing(depth - 1); private static long FactorialWithTailing(int pos, int depth) => pos == 0 ? depth : FactorialWithTailing(pos - 1, depth * pos); private static long FactorialWithTailing(int depth) => FactorialWithTailing(depth - 1, depth); } } Output // * Diagnostic Output - TailCallDiagnoser * -------------------- -------------------- Jit_TailCalling.Calc: LegacyJitX64(Jit=LegacyJit, Platform=X64, Runtime=Clr) -------------------- -------------------- Jit_TailCalling.Calc: LegacyJitX86(Jit=LegacyJit, Platform=X86, Runtime=Clr) -------------------- -------------------- Jit_TailCalling.Calc: RyuJitX64(Jit=RyuJit, Platform=X64) -------------------- Caller: <null>.<null> - <null> Callee: BenchmarkDotNet.Samples.JIT.Jit_TailCalling.FactorialWithTailing - int64 (int32,int32) Tail prefix: False Tail call type: RecursiveLoop ------------------- Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroTailcall Sample: IntroJitStatsDiagnoser This diagnoser shows various stats from the JIT compiler that were collected during entire benchmark run (warmup phase and BenchmarkDotNet-generated boilerplate code are included): Amount of JITted methods. Amount of tiered methods. How much memory JIT allocated during the benchmark. Restrictions Windows only Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [Diagnostics.Windows.Configs.JitStatsDiagnoser] public class IntroJitStatsDiagnoser { [Benchmark] public void Sleep() => Thread.Sleep(10); } } Output Method Mean Error StdDev Methods JITted Methods Tiered JIT allocated memory Sleep 15.50 ms 0.052 ms 0.048 ms 1,102 214 221,736 B Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroJitStatsDiagnoser Sample: IntroNativeMemory The NativeMemoryProfiler uses EtwProfiler to profile the code using ETW and adds the extra columns Allocated native memory and Native memory leak to the benchmark results table. Source code using System; using System.Drawing; using System.Runtime.InteropServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnostics.Windows.Configs; using BenchmarkDotNet.Filters; namespace BenchmarkDotNet.Samples { [ShortRunJob] [NativeMemoryProfiler] [MemoryDiagnoser] public class IntroNativeMemory { #pragma warning disable CA1416 [Benchmark, WindowsOnly] public void BitmapWithLeaks() { var flag = new Bitmap(200, 100); var graphics = Graphics.FromImage(flag); var blackPen = new Pen(Color.Black, 3); graphics.DrawLine(blackPen, 100, 100, 500, 100); } [Benchmark, WindowsOnly] public void Bitmap() { using (var flag = new Bitmap(200, 100)) { using (var graphics = Graphics.FromImage(flag)) { using (var blackPen = new Pen(Color.Black, 3)) { graphics.DrawLine(blackPen, 100, 100, 500, 100); } } } } #pragma warning restore CA1416 private const int Size = 20; // Greater value could cause System.OutOfMemoryException for test with memory leaks. private int ArraySize = Size * Marshal.SizeOf(typeof(int)); [Benchmark] public unsafe void AllocHGlobal() { IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize); Span<byte> unmanaged = new Span<byte>(unmanagedHandle.ToPointer(), ArraySize); Marshal.FreeHGlobal(unmanagedHandle); } [Benchmark] public unsafe void AllocHGlobalWithLeaks() { IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize); Span<byte> unmanaged = new Span<byte>(unmanagedHandle.ToPointer(), ArraySize); } private class WindowsOnlyAttribute : FilterConfigBaseAttribute { public WindowsOnlyAttribute() : base(new SimpleFilter(_ => RuntimeInformation.IsOSPlatform(OSPlatform.Windows))) { } } } } Output Method Mean Error StdDev Gen 0 Gen 1 Gen 2 Allocated Allocated native memory Native memory leak BitmapWithLeaks 73,456.43 ns 22,498.10 ns 1,233.197 ns - - - 177 B 13183 B 11615 B Bitmap 91,590.08 ns 101,468.12 ns 5,561.810 ns - - - 180 B 12624 B - AllocHGlobal 79.91 ns 43.93 ns 2.408 ns - - - - 80 B - AllocHGlobalWithLeaks 103.50 ns 153.21 ns 8.398 ns - - - - 80 B 80 B Profiling memory leaks The BenchmarkDotNet repeats benchmarking function many times. Sometimes it can cause a memory overflow. In this case, the BenchmarkDotNet shows the message: OutOfMemoryException! BenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects. If your benchmark allocates memory and keeps it alive, you are creating a memory leak. You should redesign your benchmark and remove the side-effects. You can use `OperationsPerInvoke`, `IterationSetup` and `IterationCleanup` to do that. In this case, you should try to reduce the number of invocation, by adding [ShortRunJob] attribute or using Job.Short for custom configuration. Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroNativeMemory Sample: IntroThreadingDiagnoser The ThreadingDiagnoser uses new APIs exposed in .NET Core 3.0 to report: Completed Work Items: The number of work items that have been processed in ThreadPool (per single operation) Lock Contentions: The number of times there was contention upon trying to take a Monitor's lock (per single operation) Source code using BenchmarkDotNet.Attributes; using System.Threading; namespace BenchmarkDotNet.Samples { [ThreadingDiagnoser] // ENABLE the diagnoser public class IntroThreadingDiagnoser { [Benchmark] public void CompleteOneWorkItem() { ManualResetEvent done = new ManualResetEvent(initialState: false); ThreadPool.QueueUserWorkItem(m => (m as ManualResetEvent).Set(), done); done.WaitOne(); } } } Output Method Mean StdDev Median Completed Work Items Lock Contentions CompleteOneWorkItem 8,073.5519 ns 69.7261 ns 8,111.6074 ns 1.0000 - Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroThreadingDiagnoser Sample: IntroExceptionDiagnoser The ExceptionDiagnoser uses AppDomain.FirstChanceException API to report: Exception frequency: The number of exceptions thrown during the operations divided by the number of operations. Source code using BenchmarkDotNet.Attributes; using System; namespace BenchmarkDotNet.Samples { [ExceptionDiagnoser] public class IntroExceptionDiagnoser { [Benchmark] public void ThrowExceptionRandomly() { try { if (new Random().Next(0, 5) > 1) { throw new Exception(); } } catch { // ignored } } } } Output Method Mean Error StdDev Exception frequency ThrowExceptionRandomly 4.936 us 0.1542 us 0.4499 us 0.1381 Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroExceptionDiagnoser"
  },
  "articles/configs/exporters.html": {
    "href": "articles/configs/exporters.html",
    "title": "Exporters | BenchmarkDotNet",
    "summary": "Exporters An exporter allows you to export results of your benchmark in different formats. By default, files with results will be located in .\\BenchmarkDotNet.Artifacts\\results directory, but this can be changed via the ArtifactsPath property in the IConfig. Default exporters are: csv, html and markdown. Sample: IntroExport BenchmarkDotNet has a lot of predefined exporters. Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [ShortRunJob] [MediumRunJob] [KeepBenchmarkFiles] [AsciiDocExporter] [CsvExporter] [CsvMeasurementsExporter] [HtmlExporter] [PlainExporter] [RPlotExporter] [JsonExporterAttribute.Brief] [JsonExporterAttribute.BriefCompressed] [JsonExporterAttribute.Full] [JsonExporterAttribute.FullCompressed] [MarkdownExporterAttribute.Default] [MarkdownExporterAttribute.GitHub] [MarkdownExporterAttribute.StackOverflow] [MarkdownExporterAttribute.Atlassian] [XmlExporterAttribute.Brief] [XmlExporterAttribute.BriefCompressed] [XmlExporterAttribute.Full] [XmlExporterAttribute.FullCompressed] public class IntroExport { private Random random = new Random(42); [Benchmark(Baseline = true)] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep50Noisy() => Thread.Sleep(random.Next(100)); } } Links Exporters The permanent link to this sample: BenchmarkDotNet.Samples.IntroExport Sample: IntroExportJson BenchmarkDotNet has a set of json exporters. You can customize the following properties of these exporters: fileNameSuffix: a string which be placed in the end of target file name. indentJson=false/true: should we format json or not. excludeMeasurements=false/true: should we exclude detailed information about measurements or not (the final summary with statistics will be in the json file anyway). Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Exporters.Json; namespace BenchmarkDotNet.Samples { // *** Attribute style *** [DryJob] [JsonExporterAttribute.Brief] [JsonExporterAttribute.Full] [JsonExporterAttribute.BriefCompressed] [JsonExporterAttribute.FullCompressed] [JsonExporter(\"-custom\", indentJson: true, excludeMeasurements: true)] public class IntroExportJson { [Benchmark] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep20() => Thread.Sleep(20); } // *** Object style *** [Config(typeof(Config))] public class IntroJsonExportObjectStyle { private class Config : ManualConfig { public Config() { AddExporter(JsonExporter.Brief); AddExporter(JsonExporter.Brief); AddExporter(JsonExporter.Full); AddExporter(JsonExporter.BriefCompressed); AddExporter(JsonExporter.FullCompressed); AddExporter(JsonExporter.Custom(\"-custom\", indentJson: true, excludeMeasurements: true)); } } [Benchmark] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep20() => Thread.Sleep(20); } } Output Example of IntroJsonExport-report-brief.json: { \"Title\":\"IntroJsonExport\", \"HostEnvironmentInfo\":{ \"BenchmarkDotNetCaption\":\"BenchmarkDotNet-Dev.Core\", \"BenchmarkDotNetVersion\":\"0.9.9.0\", \"OsVersion\":\"Microsoft Windows NT 6.2.9200.0\", \"ProcessorName\":{ \"IsValueCreated\":true, \"Value\":\"Intel(R) Core(TM) i7-4702MQ CPU 2.20GHz\" }, \"ProcessorCount\":8, \"ClrVersion\":\"MS.NET 4.0.30319.42000\", \"Architecture\":\"64-bit\", \"HasAttachedDebugger\":false, \"HasRyuJit\":true, \"Configuration\":\"RELEASE\", \"JitModules\":\"clrjit-v4.6.1586.0\", \"DotNetCliVersion\":\"1.0.0-preview2-003121\", \"ChronometerFrequency\":2143474, \"HardwareTimerKind\":\"Tsc\" }, \"Benchmarks\":[ { \"ShortInfo\":\"IntroJsonExport_Sleep10\", \"Namespace\":\"BenchmarkDotNet.Samples.Intro\", \"Type\":\"IntroJsonExport\", \"Method\":\"Sleep10\", \"MethodTitle\":\"Sleep10\", \"Parameters\":\"\", \"Properties\":{ \"Mode\":\"Throughput\", \"Platform\":\"Host\", \"Jit\":\"Host\", \"Runtime\":\"Host\", \"GcMode\":\"Host\", \"WarmupCount\":\"Auto\", \"IterationCount\":\"Auto\", \"LaunchCount\":\"Auto\", \"IterationTime\":\"Auto\", \"Affinity\":\"Auto\" }, \"Statistics\":{ \"N\":20, \"Min\":10265993.7209375, \"LowerFence\":10255329.082734371, \"Q1\":10337369.528437499, \"Median\":10360382.6953125, \"Mean\":10362283.085796878, \"Q3\":10392063.158906251, \"UpperFence\":10474103.60460938, \"Max\":10436008.3209375, \"InterquartileRange\":54693.630468752235, \"Outliers\":[ ], \"StandardError\":10219.304338928456, \"Variance\":2088683623.4328396, \"StandardDeviation\":45702.118369205156, \"Skewness\":-0.1242777170069375, \"Kurtosis\":2.31980277935226, \"ConfidenceInterval\":{ \"Mean\":10362283.085796878, \"Error\":10219.304338928456, \"Level\":6, \"Margin\":20029.836504299772, \"Lower\":10342253.249292579, \"Upper\":10382312.922301177 }, \"Percentiles\":{ \"P0\":10265993.7209375, \"P25\":10338555.905625, \"P50\":10360382.6953125, \"P67\":10373496.555659376, \"P80\":10400703.4841875, \"P85\":10417280.326718749, \"P90\":10424125.595812501, \"P95\":10435620.51609375, \"P100\":10436008.3209375 } } },{ \"ShortInfo\":\"IntroJsonExport_Sleep20\", \"Namespace\":\"BenchmarkDotNet.Samples.Intro\", \"Type\":\"IntroJsonExport\", \"Method\":\"Sleep20\", \"MethodTitle\":\"Sleep20\", \"Parameters\":\"\", \"Properties\":{ \"Mode\":\"Throughput\", \"Platform\":\"Host\", \"Jit\":\"Host\", \"Runtime\":\"Host\", \"GcMode\":\"Host\", \"WarmupCount\":\"Auto\", \"IterationCount\":\"Auto\", \"LaunchCount\":\"Auto\", \"IterationTime\":\"Auto\", \"Affinity\":\"Auto\" }, \"Statistics\":{ \"N\":20, \"Min\":20258672.37, \"LowerFence\":20206333.269843742, \"Q1\":20325342.761249997, \"Median\":20362636.192500003, \"Mean\":20360791.931687497, \"Q3\":20404682.4221875, \"UpperFence\":20523691.913593754, \"Max\":20422396.073125, \"InterquartileRange\":79339.66093750298, \"Outliers\":[ ], \"StandardError\":10728.817907277158, \"Variance\":2302150673.7502208, \"StandardDeviation\":47980.732317777525, \"Skewness\":-0.50826238372439869, \"Kurtosis\":2.11050327966268, \"ConfidenceInterval\":{ \"Mean\":20360791.931687497, \"Error\":10728.817907277158, \"Level\":6, \"Margin\":21028.48309826323, \"Lower\":20339763.448589232, \"Upper\":20381820.414785761 }, \"Percentiles\":{ \"P0\":20258672.37, \"P25\":20327638.975312497, \"P50\":20362636.192500003, \"P67\":20391669.3762875, \"P80\":20406370.68625, \"P85\":20412542.034406248, \"P90\":20414412.5376875, \"P95\":20416606.697718751, \"P100\":20422396.073125 } } } ] } Links Exporters The permanent link to this sample: BenchmarkDotNet.Samples.IntroExportJson Sample: IntroExportXml BenchmarkDotNet has a set of XML exporters. You can customize the following properties of these exporters: fileNameSuffix: a string which be placed in the end of target file name. indentXml=false/true: should we format xml or not. excludeMeasurements=false/true: should we exclude detailed information about measurements or not (the final summary with statistics will be in the XML file anyway). Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DryJob] [XmlExporterAttribute.Brief] [XmlExporterAttribute.Full] [XmlExporterAttribute.BriefCompressed] [XmlExporterAttribute.FullCompressed] [XmlExporter(\"-custom\", indentXml: true, excludeMeasurements: true)] public class IntroExportXml { [Benchmark] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep20() => Thread.Sleep(20); } } Output Example of IntroXmlExport-report-brief.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <Summary> <Title>IntroXmlExport</Title> <HostEnvironmentInfo> <BenchmarkDotNetCaption>BenchmarkDotNet</BenchmarkDotNetCaption> <BenchmarkDotNetVersion>0.10.9.20170805-develop</BenchmarkDotNetVersion> <OsVersion>Windows 10 Redstone 2 (10.0.15063)</OsVersion> <ProcessorName>Intel Core i7-3770K CPU 3.50GHz (Ivy Bridge)</ProcessorName> <ProcessorCount>8</ProcessorCount> <RuntimeVersion>.NET Framework 4.7 (CLR 4.0.30319.42000)</RuntimeVersion> <Architecture>64bit</Architecture> <HasAttachedDebugger>False</HasAttachedDebugger> <HasRyuJit>True</HasRyuJit> <Configuration>RELEASE</Configuration> <JitModules>clrjit-v4.7.2101.1</JitModules> <DotNetSdkVersion>1.0.4</DotNetSdkVersion> <ChronometerFrequency> <Hertz>3410220</Hertz> </ChronometerFrequency> <HardwareTimerKind>Tsc</HardwareTimerKind> </HostEnvironmentInfo> <Benchmarks> <Benchmark> <DisplayInfo>IntroXmlExport.Sleep10: DefaultJob</DisplayInfo> <Namespace>BenchmarkDotNet.Samples.Intro</Namespace> <Type>IntroXmlExport</Type> <Method>Sleep10</Method> <MethodTitle>Sleep10</MethodTitle> <Statistics> <N>15</N> <Min>10989865.8785938</Min> <LowerFence>10989836.0967969</LowerFence> <Q1>10990942.6053125</Q1> <Median>10991249.5870313</Median> <Mean>10991270.0524583</Mean> <Q3>10991680.2776563</Q3> <UpperFence>10992786.7861719</UpperFence> <Max>10992115.5501563</Max> <InterquartileRange>737.672343749553</InterquartileRange> <StandardError>148.484545262958</StandardError> <Variance>330714.902729213</Variance> <StandardDeviation>575.07817097262</StandardDeviation> <Skewness>-0.67759778074187</Skewness> <Kurtosis>3.14296703520386</Kurtosis> <ConfidenceInterval> <N>15</N> <Mean>10991270.0524583</Mean> <StandardError>148.484545262958</StandardError> <Level>L999</Level> <Margin>614.793505974065</Margin> <Lower>10990655.2589524</Lower> <Upper>10991884.8459643</Upper> </ConfidenceInterval> <Percentiles> <P0>10989865.8785938</P0> <P25>10991027.3689063</P25> <P50>10991249.5870313</P50> <P67>10991489.490875</P67> <P80>10991696.7722187</P80> <P85>10991754.5031875</P85> <P90>10991933.1939688</P90> <P95>10992067.441125</P95> <P100>10992115.5501563</P100> </Percentiles> </Statistics> </Benchmark> </Benchmarks> </Summary> Links Exporters The permanent link to this sample: BenchmarkDotNet.Samples.IntroExportXml Plots You can install R to automatically get nice plots of your benchmark results. First, make sure Rscript.exe or Rscript is in your path, or define an R_HOME environment variable pointing to the R installation directory. eg: If Rscript is located in /path/to/R/R-1.2.3/bin/Rscript, then R_HOME must point to /path/to/R/R-1.2.3/, it should not point to /path/to/R/R-1.2.3/bin Use RPlotExporter.Default and CsvMeasurementsExporter.Default in your config, and the BuildPlots.R script in your bin directory will take care of the rest. Examples: <BenchmarkName>-barplot.png <BenchmarkName>-boxplot.png <BenchmarkName>-<MethodName>-density.png <BenchmarkName>-<MethodName>-facetTimeline.png <BenchmarkName>-<MethodName>-facetTimelineSmooth.png <BenchmarkName>-<MethodName>-<JobName>-timelineSmooth.png <BenchmarkName>-<MethodName>-<JobName>-timelineSmooth.png A config example in C#: public class Config : ManualConfig { public Config() { Add(CsvMeasurementsExporter.Default); Add(RPlotExporter.Default); } } A config example in F#: module MyBenchmark open BenchmarkDotNet.Attributes open BenchmarkDotNet.Configs open BenchmarkDotNet.Exporters open BenchmarkDotNet.Exporters.Csv open MyProjectUnderTest type MyConfig() as this = inherit ManualConfig() do this.Add(CsvMeasurementsExporter.Default) this.Add(RPlotExporter.Default) [< MemoryDiagnoser; Config(typeof<MyConfig>); RPlotExporter >] type MyPerformanceTests() = let someTestData = getTestDataAsList () [<Benchmark>] member __.SomeTestCase() = someTestData |> myFunctionUnderTest CSV The CSV file format is often used to graph the output or to analyze the results programmatically. The CSV exporter may be configured to produce sanitized output, where cell values are numerals and their units are predefined. The CSV exporter and other compatible exporters may consume an instance of ISummaryStyle that defines how the output should look like: Property Remarks Default PrintUnitsInHeader If true, units will be displayed in the header row false PrintUnitsInContent If true, units will be appended to the value true TimeUnit If null, unit will be automatically selected null SizeUnit If null, unit will be automatically selected null Example of CSV exporter configured to always use microseconds, kilobytes, and to render units only in column headers: var exporter = new CsvExporter( CsvSeparator.CurrentCulture, new SummaryStyle( cultureInfo: System.Globalization.CultureInfo.CurrentCulture, printUnitsInHeader: true, printUnitsInContent: false, timeUnit: Perfolizer.Horology.TimeUnit.Microsecond, sizeUnit: SizeUnit.KB )); var config = ManualConfig.CreateMinimumViable().AddExporter(exporter); Excerpt from the resulting CSV file: Method,...,Mean [us],Error [us],StdDev [us],Min [us],Max [us],Allocated [KB] Benchmark,...,\"37,647.6\",\"32,717.9\",\"21,640.9\",\"11,209.2\",\"59,492.6\",1.58"
  },
  "articles/configs/filters.html": {
    "href": "articles/configs/filters.html",
    "title": "Filters | BenchmarkDotNet",
    "summary": "Filters Sometimes you don't want to run all of your benchmarks. In this case, you can filter some of them with the help of filters. Predefined filters: Filter Type Filters benchmarks by Console argument Console example GlobFilter Provided glob pattern filter --filter Serializer.ToStream AttributesFilter Provided attribute names attribute --attribute STAThread AllCategoriesFilter All Provided category names categories --allCategories Priority1 CoreFX AnyCategoriesFilter Any provided category names anycategories --anyCategories Json Xml SimpleFilter Provided lambda predicate - NameFilter Provided lambda predicate - UnionFilter Logical AND - DisjunctionFilter Logical OR - Sample: IntroFilters You can either use one of the predefined Filter types or create a custom type which implements IFilter interface. Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Filters; namespace BenchmarkDotNet.Samples { [DryJob] [Config(typeof(Config))] public class IntroFilters { private class Config : ManualConfig { // We will benchmark ONLY method with // names (which contains \"A\" OR \"1\") AND (have length < 3) public Config() { // benchmark with names which contains \"A\" OR \"1\" AddFilter(new DisjunctionFilter( new NameFilter(name => name.Contains(\"A\")), new NameFilter(name => name.Contains(\"1\")) )); // benchmark with names with length < 3 AddFilter(new NameFilter(name => name.Length < 3)); } } [Benchmark] public void A1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void A2() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void A3() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void B1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void B2() => Thread.Sleep(10); [Benchmark] public void B3() => Thread.Sleep(10); [Benchmark] public void C1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void C2() => Thread.Sleep(10); [Benchmark] public void C3() => Thread.Sleep(10); [Benchmark] public void Aaa() => Thread.Sleep(10); } } Links Filters The permanent link to this sample: BenchmarkDotNet.Samples.IntroFilters Sample: IntroCategories Combined together with [BenchmarkCategory] attribute, you can group the benchmarks into categories and filter them by categories. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DryJob] [CategoriesColumn] [BenchmarkCategory(\"Awesome\")] [AnyCategoriesFilter(\"A\", \"1\")] public class IntroCategories { [Benchmark] [BenchmarkCategory(\"A\", \"1\")] public void A1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] [BenchmarkCategory(\"A\", \"2\")] public void A2() => Thread.Sleep(10); // Will be benchmarked [Benchmark] [BenchmarkCategory(\"B\", \"1\")] public void B1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] [BenchmarkCategory(\"B\", \"2\")] public void B2() => Thread.Sleep(10); } } Command line examples: --allCategories=A,B --anyCategories=A,B Links Filters The permanent link to this sample: BenchmarkDotNet.Samples.IntroCategories Sample: IntroJoin If you are using BenchmarkSwitcher and want to run all the benchmarks with a category from all types and join them into one summary table, use the --join option (or BenchmarkSwitcher.RunAllJoined): Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { // Run BenchmarkSwitcher with arguments: \"--join --category=IntroJoinA\" [DryJob] public class IntroJoin1 { [Benchmark] [BenchmarkCategory(\"IntroJoinA\")] public void A() => Thread.Sleep(10); [Benchmark] [BenchmarkCategory(\"IntroJoinB\")] public void B() => Thread.Sleep(10); } [DryJob] public class IntroJoin2 { [Benchmark] [BenchmarkCategory(\"IntroJoinA\")] public void A() => Thread.Sleep(10); [Benchmark] [BenchmarkCategory(\"IntroJoinB\")] public void B() => Thread.Sleep(10); } } Command line --join --allCategories=IntroJoinA Output | Type | Method | Mean | Error | |----------- |------- |---------:|------:| | IntroJoin1 | A | 10.99 ms | NA | | IntroJoin2 | A | 12.50 ms | NA | Links Filters The permanent link to this sample: BenchmarkDotNet.Samples.IntroJoin"
  },
  "articles/configs/jobs.html": {
    "href": "articles/configs/jobs.html",
    "title": "Jobs | BenchmarkDotNet",
    "summary": "Jobs Basically, a job describes how to run your benchmark. Practically, it's a set of characteristics which can be specified. You can specify one or several jobs for your benchmarks. Characteristics There are several categories of characteristics which you can specify. Let's consider each category in detail. Id It's a single string characteristic. It allows to name your job. This name will be used in logs and a part of a folder name with generated files for this job. Id doesn't affect benchmark results, but it can be useful for diagnostics. If you don't specify Id, random value will be chosen based on other characteristics Environment Environment specifies an environment of the job. You can specify the following characteristics: Platform: x86 or x64 Runtime: Clr: Full .NET Framework (available only on Windows) Core: CoreCLR (x-plat) Mono: Mono (x-plat) Jit: LegacyJit (available only for Runtime.Clr) RyuJit (available only for Runtime.Clr and Runtime.Core) Llvm (available only for Runtime.Mono) Affinity: Affinity of a benchmark process GcMode: settings of Garbage Collector Server: true (Server mode) or false (Workstation mode) Concurrent: true (Concurrent mode) or false (NonConcurrent mode) CpuGroups: Specifies whether garbage collection supports multiple CPU groups Force: Specifies whether the BenchmarkDotNet's benchmark runner forces full garbage collection after each benchmark invocation AllowVeryLargeObjects: On 64-bit platforms, enables arrays that are greater than 2 gigabytes (GB) in total size LargeAddressAware: Specifies that benchmark can handle addresses larger than 2 gigabytes. See also: Sample: IntroLargeAddressAware and LARGEADDRESSAWARE false: Benchmark uses the defaults (64-bit: enabled; 32-bit: disabled). true: Explicitly specify that benchmark can handle addresses larger than 2 gigabytes. EnvironmentVariables: customized environment variables for target benchmark. See also: BenchmarkDotNet.Samples.IntroEnvVars BenchmarkDotNet will use host process environment characteristics for non specified values. Run In this category, you can specify how to benchmark each method. RunStrategy: Throughput: default strategy which allows to get good precision level ColdStart: should be used only for measuring cold start of the application or testing purpose Monitoring: A mode without overhead evaluating, with several target iterations LaunchCount: how many times we should launch process with target benchmark WarmupCount: how many warmup iterations should be performed IterationCount: how many target iterations should be performed (if specified, BenchmarkDotNet.Jobs.RunMode.MinIterationCount and BenchmarkDotNet.Jobs.RunMode.MaxIterationCount will be ignored) IterationTime: desired time of a single iteration UnrollFactor: how many times the benchmark method will be invoked per one iteration of a generated loop InvocationCount: count of invocation in a single iteration (if specified, IterationTime will be ignored), must be a multiple of UnrollFactor MinIterationCount: Minimum count of target iterations that should be performed, the default value is 15 MaxIterationCount: Maximum count of target iterations that should be performed, the default value is 100 MinWarmupIterationCount: Minimum count of warmup iterations that should be performed, the default value is 6 MaxWarmupIterationCount: Maximum count of warmup iterations that should be performed, the default value is 50 Usually, you shouldn't specify such characteristics like LaunchCount, WarmupCount, IterationCount, or IterationTime because BenchmarkDotNet has a smart algorithm to choose these values automatically based on received measurements. You can specify it for testing purposes or when you are damn sure that you know the right characteristics for your benchmark (when you set IterationCount = 20 you should understand why 20 is a good value for your case). Accuracy If you want to change the accuracy level, you should use the following characteristics instead of manually adjusting values of WarmupCount, IterationCount, and so on. MaxRelativeError, MaxAbsoluteError: Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error). In these two characteristics, the error means half of 99.9% confidence interval. MaxAbsoluteError is an absolute TimeInterval; doesn't have a default value. MaxRelativeError defines max acceptable ((<half of CI 99.9%>) / Mean). MinIterationTime: Minimum time of a single iteration. Unlike Run.IterationTime, this characteristic specifies only the lower limit. In case of need, BenchmarkDotNet can increase this value. MinInvokeCount: Minimum about of target method invocation. Default value if 4 but you can decrease this value for cases when single invocations takes a lot of time. EvaluateOverhead: if your benchmark method takes nanoseconds, BenchmarkDotNet overhead can significantly affect measurements. If this characteristic is enabled, the overhead will be evaluated and subtracted from the result measurements. Default value is true. WithOutlierMode: sometimes you could have outliers in your measurements. Usually these are unexpected outliers which arose because of other processes activities. By default (OutlierMode.RemoveUpper), all upper outliers (which is larger than Q3) will be removed from the result measurements. However, some of benchmarks have expected outliers. In these situation, you expect that some of invocation can produce outliers measurements (e.g. in case of network activities, cache operations, and so on). If you want to see result statistics with these outliers, you should use OutlierMode.DontRemove. If you can also choose OutlierMode.RemoveLower (outliers which are smaller than Q1 will be removed) or OutlierMode.RemoveAll (all outliers will be removed). See also: @BenchmarkDotNet.Mathematics.OutlierMode AnalyzeLaunchVariance: this characteristic makes sense only if Run.LaunchCount is default. If this mode is enabled and, BenchmarkDotNet will try to perform several launches and detect if there is a variance between launches. If this mode is disable, only one launch will be performed. Infrastructure Usually, you shouldn't specify any characteristics from this section, it can be used for advanced cases only. Toolchain: a toolchain which generates source code for target benchmark methods, builds it, and executes it. BenchmarkDotNet has own toolchains for .NET, .NET Core, Mono and CoreRT projects. If you want, you can define own toolchain. Clock: a clock which will be used for measurements. BenchmarkDotNet automatically choose the best available clock source, but you can specify own clock source. EngineFactory: a provider for measurement engine which performs all the measurement magic. If you don't trust BenchmarkDotNet, you can define own engine and implement all the measurement stages manually. Usage There are several ways to specify a job. Object style You can create own jobs directly from the source code via a custom config: [Config(typeof(Config))] public class MyBenchmarks { private class Config : ManualConfig { public Config() { AddJob( new Job(\"MySuperJob\", RunMode.Dry, EnvironmentMode.RyuJitX64) { Environment = { Runtime = CoreRuntime.Core90 }, Run = { LaunchCount = 5, IterationTime = TimeInterval.Millisecond * 200 }, Accuracy = { MaxRelativeError = 0.01 } }); // The same, using the .With() factory methods: AddJob( Job.Dry .WithPlatform(Platform.X64) .WithJit(Jit.RyuJit) .WithRuntime(CoreRuntime.Core90) .WithLaunchCount(5) .WithIterationTime(TimeInterval.Millisecond * 200) .WithMaxRelativeError(0.01) .WithId(\"MySuperJob\")); } } // Benchmarks } Basically, it's a good idea to start with predefined values (e.g. EnvironmentMode.RyuJitX64 and RunMode.Dry passed as constructor args) and modify rest of the properties using property setters or with help of object initializer syntax. Note that the job cannot be modified after it's added into config. Trying to set a value on property of the frozen job will throw an InvalidOperationException. Use the Job.Frozen property to determine if the code properties can be altered. If you do want to create a new job based on frozen one (all predefined job values are frozen) you can use the .With() extension method var newJob = Job.Dry.WithPlatform(Platform.X64); or pass the frozen value as a constructor argument var newJob = new Job(Job.Dry) { Environment = { Platform = Platform.X64 } }; or use the .Apply() method on unfrozen job var newJob = new Job() { Environment = { Platform = Platform.X64 } }.Apply(Job.Dry); in any case the Id property will not be transfered and you must pass it explicitly (using the .ctor id argument or the .WithId() extension method). Attribute style You can also add new jobs via attributes. Examples: [DryJob] [MonoJob] [SimpleJob(RuntimeMoniker.Net90)] [SimpleJob(RuntimeMoniker.NetCoreApp31)] [LegacyJitX86Job, LegacyJitX64Job, RyuJitX64Job] [SimpleJob(RunStrategy.ColdStart, launchCount: 1, warmupCount: 5, iterationCount: 5, id: \"FastAndDirtyJob\")] public class MyBenchmarkClass Note that each of the attributes identifies a separate job, the sample above will result in 8 different jobs, not a single merged job. Attribute style for merging jobs Sometimes you want to apply some changes to other jobs, without adding a new job to a config (which results in one extra benchmark run). To do that you can use following predefined job mutator attributes: [EvaluateOverhead] [GcConcurrent] [GcForce] [GcServer] [InnerIterationCount] [InvocationCount] [IterationCount] [IterationTime] [MaxAbsoluteError] [MaxIterationCount] [MaxRelativeError] [MinInvokeCount] [MinIterationCount] [MinIterationTime] [Outliers] [ProcessCount] [RunOncePerIteration] [WarmupCount] [MinWarmupCount] [MaxWarmupCount] So following example: [ClrJob, CoreJob] [GcServer(true)] public class MyBenchmarkClass Is going to be merged to a config with two jobs: CoreJob with GcServer=true ClrJob with GcServer=true Custom attributes You can also create your own custom attributes with your favourite set of jobs. Example: [AttributeUsage(AttributeTargets.Class | AttributeTargets.Assembly)] public class MySuperJobAttribute : Attribute, IConfigSource { protected MySuperJobAttribute() { var job = new Job(\"MySuperJob\", RunMode.Core); job.Env.Platform = Platform.X64; Config = ManualConfig.CreateEmpty().AddJob(job); } public IConfig Config { get; } } [MySuperJob] public class MyBenchmarks Sample: IntroGcMode Source code using System.Runtime.CompilerServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Order; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [MemoryDiagnoser] public class IntroGcMode { private class Config : ManualConfig { public Config() { AddJob(Job.MediumRun.WithGcServer(true).WithGcForce(true).WithId(\"ServerForce\")); AddJob(Job.MediumRun.WithGcServer(true).WithGcForce(false).WithId(\"Server\")); AddJob(Job.MediumRun.WithGcServer(false).WithGcForce(true).WithId(\"Workstation\")); AddJob(Job.MediumRun.WithGcServer(false).WithGcForce(false).WithId(\"WorkstationForce\")); } } [Benchmark(Description = \"new byte[10kB]\")] public byte[] Allocate() { return new byte[10000]; } [Benchmark(Description = \"stackalloc byte[10kB]\")] public unsafe void AllocateWithStackalloc() { var array = stackalloc byte[10000]; Consume(array); } [MethodImpl(MethodImplOptions.NoInlining)] private static unsafe void Consume(byte* input) { } } } Output Links Jobs The permanent link to this sample: BenchmarkDotNet.Samples.IntroGcMode"
  },
  "articles/configs/loggers.html": {
    "href": "articles/configs/loggers.html",
    "title": "Loggers | BenchmarkDotNet",
    "summary": "Loggers A logger allows you to log results of your benchmark. By default, you can see log on console and in a file (<BenchmarkName>.log)."
  },
  "articles/configs/orderers.html": {
    "href": "articles/configs/orderers.html",
    "title": "Orderers | BenchmarkDotNet",
    "summary": "Orderers Orderers allows customizing the order of benchmark results in the summary table. Sample: IntroOrderAttr Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Order; namespace BenchmarkDotNet.Samples { [Orderer(SummaryOrderPolicy.FastestToSlowest, MethodOrderPolicy.Declared)] [DryJob] public class IntroOrderAttr { [Params(1, 2, 3)] public int X { get; set; } [Benchmark] public void Slow() => Thread.Sleep(X * 100); [Benchmark] public void Fast() => Thread.Sleep(X * 50); } } Links Orderers The permanent link to this sample: BenchmarkDotNet.Samples.IntroOrderAttr Sample: IntroOrderManual Source code using System.Collections.Generic; using System.Collections.Immutable; using System.Linq; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Order; using BenchmarkDotNet.Reports; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [DryJob] [RankColumn] public class IntroOrderManual { private class Config : ManualConfig { public Config() => Orderer = new FastestToSlowestOrderer(); private class FastestToSlowestOrderer : IOrderer { public IEnumerable<BenchmarkCase> GetExecutionOrder(ImmutableArray<BenchmarkCase> benchmarksCase, IEnumerable<BenchmarkLogicalGroupRule>? order = null) => from benchmark in benchmarksCase orderby benchmark.Parameters[\"X\"] descending, benchmark.Descriptor.WorkloadMethodDisplayInfo select benchmark; public IEnumerable<BenchmarkCase> GetSummaryOrder(ImmutableArray<BenchmarkCase> benchmarksCase, Summary summary) => from benchmark in benchmarksCase orderby summary[benchmark].ResultStatistics.Mean select benchmark; public string GetHighlightGroupKey(BenchmarkCase benchmarkCase) => null; public string GetLogicalGroupKey(ImmutableArray<BenchmarkCase> allBenchmarksCases, BenchmarkCase benchmarkCase) => benchmarkCase.Job.DisplayInfo + \"_\" + benchmarkCase.Parameters.DisplayInfo; public IEnumerable<IGrouping<string, BenchmarkCase>> GetLogicalGroupOrder(IEnumerable<IGrouping<string, BenchmarkCase>> logicalGroups, IEnumerable<BenchmarkLogicalGroupRule>? order = null) => logicalGroups.OrderBy(it => it.Key); public bool SeparateLogicalGroups => true; } } [Params(1, 2, 3)] public int X { get; set; } [Benchmark] public void Fast() => Thread.Sleep(X * 50); [Benchmark] public void Slow() => Thread.Sleep(X * 100); } } Links Orderers The permanent link to this sample: BenchmarkDotNet.Samples.IntroOrderManual"
  },
  "articles/configs/powerplans.html": {
    "href": "articles/configs/powerplans.html",
    "title": "Power Plans | BenchmarkDotNet",
    "summary": "Power Plans BenchmarkDotNet forces Windows OS to execute on the High-Performance power plan. You can disable this feature by modify PowerPlanMode property. You can see it in the BenchmarkDotNet.Samples.IntroPowerPlan. Please note. During an execution, BenchmarkDotNet saves the current power plan and applies it according to the PowerPlanMode property. When all of the benchmarks finish, a previous power plan comes back. However, if someone killed process or energy was plugged off, we could stay with the High-Performance power plan. In this situation, we should return it manually in Windows Control Panel or by powercfg command. Links Power policy settings: https://learn.microsoft.com/windows/win32/power/power-policy-settings Powercfg command: https://learn.microsoft.com/windows-hardware/design/device-experiences/powercfg-command-line-options BenchmarkDotNet.Samples.IntroPowerPlan"
  },
  "articles/configs/toolchains.html": {
    "href": "articles/configs/toolchains.html",
    "title": "Toolchains | BenchmarkDotNet",
    "summary": "Toolchains To achieve process-level isolation, BenchmarkDotNet generates, builds and executes a new console app per every benchmark. A toolchain contains generator, builder, and executor. When you run your benchmarks without specifying the toolchain in an explicit way, the default one is used: Roslyn for Full .NET Framework and Mono dotnet cli for .NET Core and NativeAOT Multiple frameworks support If you want to test multiple frameworks, your project file MUST target all of them and you MUST install the corresponding SDKs: <TargetFrameworks>netcoreapp3.1;net8.0;net48</TargetFrameworks> If you run your benchmarks without specifying any custom settings, BenchmarkDotNet is going to run the benchmarks using the same framework as the host process: dotnet run -c Release -f netcoreapp3.1 # is going to run the benchmarks using .NET Core 3.1 dotnet run -c Release -f net8.0 # is going to run the benchmarks using .NET 8.0 dotnet run -c Release -f net48 # is going to run the benchmarks using .NET 4.8 mono $pathToExe # is going to run the benchmarks using Mono from your PATH To run the benchmarks for multiple runtimes with a single command, you need to specify the target framework moniker names via --runtimes|-r console argument: dotnet run -c Release -f net8.0 --runtimes net8.0 netcoreapp3.1 # is going to run the benchmarks using .NET 8.0 and .NET Core 3.1 dotnet run -c Release -f net8.0 --runtimes net8.0 net48 # is going to run the benchmarks using .NET 8.0 and .NET 4.8 What is going to happen if you provide multiple Full .NET Framework monikers? Let's say: dotnet run -c Release -f net461 net472 net48 Full .NET Framework always runs every .NET executable using the latest .NET Framework available on a given machine. If you try to run the benchmarks for a few .NET TFMs, they are all going to be executed using the latest .NET Framework from your machine. The only difference is that they are all going to have different features enabled depending on target version they were compiled for. You can read more about this here and here. This is .NET Framework behavior which can not be controlled by BenchmarkDotNet or any other tool. Note: Console arguments support works only if you pass the args to BenchmarkSwitcher: class Program { static void Main(string[] args) => BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args); // crucial to make it work } You can achieve the same thing using [SimpleJobAttribute]: using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [SimpleJob(RuntimeMoniker.Net48)] [SimpleJob(RuntimeMoniker.Mono)] [SimpleJob(RuntimeMoniker.NetCoreApp31)] [SimpleJob(RuntimeMoniker.Net80)] public class TheClassWithBenchmarks Or using a custom config: using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { class Program { static void Main(string[] args) { var config = DefaultConfig.Instance .AddJob(Job.Default.WithRuntime(CoreRuntime.Core80)) .AddJob(Job.Default.WithRuntime(ClrRuntime.Net48)) .AddJob(Job.Default.WithRuntime(MonoRuntime.Default)); BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args, config); } } } The recommended way of running the benchmarks for multiple runtimes is to use the --runtimes console line argument. By using the console line argument you don't need to edit the source code anytime you want to change the list of runtimes. Moreover, if you share the source code of the benchmark other people can run it even if they don't have the exact same framework version installed. Custom .NET Core Runtime We can run your benchmarks for custom <RuntimeFrameworkVersion> if you want. All you need to do is to create custom toolchain by calling CsProjCoreToolchain.From method, which accepts NetCoreAppSettings. public class MyConfig : ManualConfig { public MyConfig() { Add(Job.Default.With( CsProjCoreToolchain.From( new NetCoreAppSettings( targetFrameworkMoniker: \"net8.0-windows\", runtimeFrameworkVersion: \"8.0.101\", name: \".NET 8.0 Windows\")))); } } Custom .NET Runtime It's possible to benchmark a private build of .NET Runtime. All you need to do is to define a job with the right version of ClrRuntime. BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args, DefaultConfig.Instance.AddJob( Job.ShortRun.WithRuntime(ClrRuntime.CreateForLocalFullNetFrameworkBuild(version: \"4.0\")))); This sends the provided version as a COMPLUS_Version env var to the benchmarked process. Custom dotnet cli path We internally use dotnet cli to build and run .NET Core executables. Sometimes it might be mandatory to use non-default dotnet cli path. An example scenario could be a comparison of RyuJit 32bit vs 64 bit. It required due this limitation of dotnet cli public class CustomPathsConfig : ManualConfig { public CustomPathsConfig() { var dotnetCli32bit = NetCoreAppSettings .NetCoreApp31 .WithCustomDotNetCliPath(@\"C:\\Program Files (x86)\\dotnet\\dotnet.exe\", \"32 bit cli\"); var dotnetCli64bit = NetCoreAppSettings .NetCoreApp31 .WithCustomDotNetCliPath(@\"C:\\Program Files\\dotnet\\dotnet.exe\", \"64 bit cli\"); AddJob(Job.RyuJitX86.WithToolchain(CsProjCoreToolchain.From(dotnetCli32bit)).WithId(\"32 bit cli\")); AddJob(Job.RyuJitX64.WithToolchain(CsProjCoreToolchain.From(dotnetCli64bit)).WithId(\"64 bit cli\")); } } BenchmarkDotNet=v0.10.9.20170910-develop, OS=Windows 10 Redstone 1 (10.0.14393) Processor=Intel Core i7-6600U CPU 2.60GHz (Skylake), ProcessorCount=4 Frequency=2742185 Hz, Resolution=364.6727 ns, Timer=TSC .NET Core SDK=2.1.0-preview1-007074 [Host] : .NET Core 2.0.0 (Framework 4.6.00001.0), 64bit RyuJIT 32 bit cli : .NET Core 2.0.0 (Framework 4.6.00001.0), 32bit RyuJIT 64 bit cli : .NET Core 2.0.0 (Framework 4.6.00001.0), 64bit RyuJIT Jit=RyuJit This feature is now also exposed with the --cli console argument. Example: dotnet run -c Release -- --cli \"C:\\Projects\\machinelearning\\Tools\\dotnetcli\\dotnet.exe\" CoreRun To use CoreRun for running the benchmarks you need to use --coreRun command line argument. You can combine it with --cli described above. This is most probably the easiest and most reliable way of running benchmarks against local CoreFX/CoreCLR builds. Example: dotnet run -c Release -- --coreRun \"C:\\Projects\\corefx\\bin\\testhost\\netcoreapp-Windows_NT-Release-x64\\shared\\Microsoft.NETCore.App\\9.9.9\\CoreRun.exe\" Sample: IntroInProcess InProcessEmitToolchain is our toolchain which does not generate any new executable. It emits IL on the fly and runs it from within the process itself. It can be useful if want to run the benchmarks very fast or if you want to run them for framework which we don't support. An example could be a local build of CoreCLR. Usage [InProcessAttribute] public class TypeWithBenchmarks { } Source code using System.Runtime.CompilerServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Order; using BenchmarkDotNet.Toolchains.InProcess.Emit; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [MemoryDiagnoser] public class IntroInProcess { private class Config : ManualConfig { public Config() { AddJob(Job.MediumRun .WithLaunchCount(1) .WithId(\"OutOfProc\")); AddJob(Job.MediumRun .WithLaunchCount(1) .WithToolchain(InProcessEmitToolchain.Instance) .WithId(\"InProcess\")); } } [Benchmark(Description = \"new byte[10kB]\")] public byte[] Allocate() { return new byte[10000]; } [Benchmark(Description = \"stackalloc byte[10kB]\")] public unsafe void AllocateWithStackalloc() { var array = stackalloc byte[10000]; Consume(array); } [MethodImpl(MethodImplOptions.NoInlining)] private static unsafe void Consume(byte* input) { } } } Output Links Toolchains The permanent link to this sample: BenchmarkDotNet.Samples.IntroInProcess Sample: IntroInProcessWrongEnv Source code using System; using System.Runtime.CompilerServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Order; using BenchmarkDotNet.Toolchains.InProcess; using BenchmarkDotNet.Toolchains.InProcess.Emit; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [MemoryDiagnoser] public class IntroInProcessWrongEnv { private class Config : ManualConfig { public Config() { var wrongPlatform = Environment.Is64BitProcess ? Platform.X64 : Platform.X86; AddJob(Job.MediumRun .WithLaunchCount(1) .WithPlatform(wrongPlatform) .WithToolchain(InProcessEmitToolchain.Instance) .WithId(\"InProcess\")); AddValidator(InProcessValidator.DontFailOnError); } } [Benchmark(Description = \"new byte[10kB]\")] public byte[] Allocate() { return new byte[10000]; } [Benchmark(Description = \"stackalloc byte[10kB]\")] public unsafe void AllocateWithStackalloc() { var array = stackalloc byte[10000]; Consume(array); } [MethodImpl(MethodImplOptions.NoInlining)] private static unsafe void Consume(byte* input) { } } } Output Links Toolchains The permanent link to this sample: BenchmarkDotNet.Samples.IntroInProcessWrongEnv NativeAOT BenchmarkDotNet supports NativeAOT! However, you might want to know how it works to get a better understanding of the results that you get. As every AOT solution, NativeAOT has some limitations like limited reflection support or lack of dynamic assembly loading. Because of that, the host process (what you run from command line) is never an AOT process, but just a regular .NET process. This process (called Host process) uses reflection to read benchmarks metadata (find all [Benchmark] methods etc), generates a new project that references the benchmarks and compiles it using ILCompiler. Such compilation produces a native executable, which is later started by the Host process. This process (called Benchmark or Child process) performs the actual benchmarking and reports the results back to the Host process. By default BenchmarkDotNet uses the latest version of Microsoft.DotNet.ILCompiler to build the NativeAOT benchmark according to this instructions. This is why you need to: install pre-requisites required by NativeAOT compiler target .NET to be able to run NativeAOT benchmarks (example: <TargetFramework>net7.0</TargetFramework> in the .csproj file) run the app as a .NET process (example: dotnet run -c Release -f net7.0). specify the NativeAOT runtime in an explicit way, either by using console line arguments --runtimes nativeaot7.0 (the recommended approach), or by using[SimpleJob] attribute or by using the fluent Job config API Job.ShortRun.With(NativeAotRuntime.Net70): dotnet run -c Release -f net7.0 --runtimes nativeaot7.0 or: var config = DefaultConfig.Instance .AddJob(Job.Default.WithRuntime(NativeAotRuntime.Net70)); // compiles the benchmarks as net7.0 and uses the latest NativeAOT to build a native app BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args, config); or: [SimpleJob(RuntimeMoniker.NativeAot70)] // compiles the benchmarks as net7.0 and uses the latest NativeAOT to build a native app public class TheTypeWithBenchmarks { [Benchmark] // the benchmarks go here } Customization If you want to benchmark some particular version of NativeAOT (or from a different NuGet feed) you have to specify it in an explicit way: var config = DefaultConfig.Instance .AddJob(Job.ShortRun .WithToolchain(NativeAotToolchain.CreateBuilder() .UseNuGet( microsoftDotNetILCompilerVersion: \"7.0.0-*\", // the version goes here nuGetFeedUrl: \"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet7/nuget/v3/index.json\") // this address might change over time .DisplayName(\"NativeAOT NuGet\") .TargetFrameworkMoniker(\"net7.0\") .ToToolchain())); The builder allows to configure more settings: specify packages restore path by using PackagesRestorePath($path) rooting all application assemblies by using RootAllApplicationAssemblies($bool). This is disabled by default. generating complete type metadata by using IlcGenerateCompleteTypeMetadata($bool). This option is enabled by default. generating stack trace metadata by using IlcGenerateStackTraceData($bool). This option is enabled by default. set optimization preference by using IlcOptimizationPreference($value). The default is Speed, you can configure it to Size or nothing set instruction set for the target OS, architecture and hardware by using IlcInstructionSet($value). By default BDN recognizes most of the instruction sets on your machine and enables them. BenchmarkDotNet supports rd.xml files. To get given file respected by BenchmarkDotNet you need to place it in the same folder as the project that defines benchmarks and name it rd.xml or in case of multiple files give them .rd.xml extension. The alternative to rd.xml files is annotating types with DynamicallyAccessedMembers attribute. If given benchmark is not supported by NativeAOT, you need to apply [AotFilter] attribute for it. Example: [Benchmark] [AotFilter(\"Not supported by design.\")] public object CreateInstanceNames() => System.Activator.CreateInstance(_assemblyName, _typeName); Generated files By default BenchmarkDotNet removes the generates files after finishing the run. To keep them on the disk you need to pass --keepFiles true command line argument or apply [KeepBenchmarkFiles] attribute to the class which defines benchmark(s). Then, read the folder from the tool output. In the example below it's D:\\projects\\performance\\artifacts\\bin\\MicroBenchmarks\\Release\\net7.0\\Job-KRLVKQ: // ***** Building 1 exe(s) in Parallel: Start ***** // start dotnet restore -r win-x64 /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in D:\\projects\\performance\\artifacts\\bin\\MicroBenchmarks\\Release\\net7.0\\Job-KRLVKQ // command took 2.74s and exited with 0 // start dotnet build -c Release -r win-x64 --no-restore /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in D:\\projects\\performance\\artifacts\\bin\\MicroBenchmarks\\Release\\net7.0\\Job-KRLVKQ // command took 3.82s and exited with 0 If you go to D:\\projects\\performance\\artifacts\\bin\\MicroBenchmarks\\Release\\net7.0\\Job-KRLVKQ, you can see the generated project file (named BenchmarkDotNet.Autogenerated.csproj), code (file name ends with .notcs) and find the native executable (in the bin\\**\\native subfolder). Example: cd D:\\projects\\performance\\artifacts\\bin\\MicroBenchmarks\\Release\\net7.0\\Job-KRLVKQ cat .\\BenchmarkDotNet.Autogenerated.csproj <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <ImportDirectoryBuildProps>false</ImportDirectoryBuildProps> <ImportDirectoryBuildTargets>false</ImportDirectoryBuildTargets> <OutputType>Exe</OutputType> <TargetFramework>net7.0</TargetFramework> <RuntimeIdentifier>win-x64</RuntimeIdentifier> <RuntimeFrameworkVersion></RuntimeFrameworkVersion> <AssemblyName>Job-KRLVKQ</AssemblyName> <AssemblyTitle>Job-KRLVKQ</AssemblyTitle> <AllowUnsafeBlocks>true</AllowUnsafeBlocks> <PlatformTarget>x64</PlatformTarget> <TreatWarningsAsErrors>False</TreatWarningsAsErrors> <DebugSymbols>false</DebugSymbols> <UseSharedCompilation>false</UseSharedCompilation> <Deterministic>true</Deterministic> <RunAnalyzers>false</RunAnalyzers> <IlcOptimizationPreference>Speed</IlcOptimizationPreference> <TrimMode>link</TrimMode><TrimmerDefaultAction>link</TrimmerDefaultAction> <IlcGenerateCompleteTypeMetadata>True</IlcGenerateCompleteTypeMetadata> <IlcGenerateStackTraceData>True</IlcGenerateStackTraceData> <EnsureNETCoreAppRuntime>false</EnsureNETCoreAppRuntime> <ValidateExecutableReferencesMatchSelfContained>false</ValidateExecutableReferencesMatchSelfContained> </PropertyGroup> <PropertyGroup> <ServerGarbageCollection>false</ServerGarbageCollection> <ConcurrentGarbageCollection>true</ConcurrentGarbageCollection> </PropertyGroup> <ItemGroup> <Compile Include=\"Job-KRLVKQ.notcs\" Exclude=\"bin\\**;obj\\**;**\\*.xproj;packages\\**\" /> </ItemGroup> <ItemGroup> <PackageReference Include=\"Microsoft.DotNet.ILCompiler\" Version=\"7.0.0-*\" /> <ProjectReference Include=\"D:\\projects\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj\" /> </ItemGroup> <ItemGroup> <RdXmlFile Include=\"bdn_generated.rd.xml\" /> </ItemGroup> <ItemGroup> <IlcArg Include=\"--instructionset:base,sse,sse2,sse3,sse4.1,sse4.2,avx,avx2,aes,bmi,bmi2,fma,lzcnt,pclmul,popcnt\" /> </ItemGroup> </Project> Compiling source to native code using the ILCompiler you built If you are a NativeAOT contributor and you want to benchmark your local build of NativeAOT you have to provide necessary info (path to shipping packages). You can do that from command line: dotnet run -c Release -f net7.0 --runtimes nativeaot7.0 --ilcPackages D:\\projects\\runtime\\artifacts\\packages\\Release\\Shipping\\ or explicitly in the code: var config = DefaultConfig.Instance .AddJob(Job.ShortRun .WithToolchain(NativeAotToolchain.CreateBuilder() .UseLocalBuild(@\"C:\\Projects\\runtime\\artifacts\\packages\\Release\\Shipping\\\") .DisplayName(\"NativeAOT local build\") .TargetFrameworkMoniker(\"net7.0\") .ToToolchain())); BenchmarkDotNet is going to follow these instructrions to get it working for you. Note: BenchmarkDotNet is going to run dotnet restore on the auto-generated project and restore the packages to a temporary folder. It might take some time, but the next time you rebuild dotnet/runtime repo and run the same command BenchmarkDotNet is going to use the new ILCompiler package. Wasm BenchmarkDotNet supports Web Assembly on Unix! However, currently you need to build the dotnet runtime yourself to be able to run the benchmarks. For up-to-date docs, you should visit dotnet/runtime repository. The docs below are specific to Ubuntu 18.04 at the moment of writing this document (16/07/2020). Firs of all, you need to install.... npm 10+: curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash - sudo apt install nodejs After this, you need to install jsvu: npm install jsvu -g Add it to PATH: export PATH=\"${HOME}/.jsvu:${PATH}\" And use it to install V8, JavaScriptCore and SpiderMonkey: jsvu --os=linux64 --engines=javascriptcore,spidermonkey,v8 Now you need to install Emscripten: git clone https://github.com/emscripten-core/emsdk.git cd emsdk ./emsdk install latest ./emsdk activate latest source ./emsdk_env.sh The last thing before cloning dotnet/runtime repository is creation of EMSDK_PATH env var used by Mono build scripts: export EMSDK_PATH=$EMSDK Now you need to clone dotnet/runtime repository: git clone https://github.com/dotnet/runtime cd runtime Install all Mono prerequisites: sudo apt-get install cmake llvm-9 clang-9 autoconf automake libtool build-essential python curl git lldb-6.0 liblldb-6.0-dev libunwind8 libunwind8-dev gettext libicu-dev liblttng-ust-dev libssl-dev libnuma-dev libkrb5-dev zlib1g-dev And FINALLY build Mono Runtime with Web Assembly support: ./build.sh --arch wasm --os Browser -c release And that you have .NET 5 feed added to your nuget.config file: <add key=\"dotnet5\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5/nuget/v3/index.json\" /> Now you should be able to run the Wasm benchmarks! Sample: IntroWasm WasmToolchain uses a local Mono Runtime build to run the benchmarks compiled as WebAssembly using V8 JavaScript Engine. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; using BenchmarkDotNet.Toolchains; using BenchmarkDotNet.Toolchains.DotNetCli; using BenchmarkDotNet.Toolchains.MonoWasm; namespace BenchmarkDotNet.Samples { // *** Command Line Arguments *** public class IntroWasmCmdConfig { // the args must contain: // an information that we want to run benchmark as Wasm: // --runtimes Wasm // path to dotnet cli // --cli /home/adam/projects/runtime/dotnet.sh public static void Run(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(IntroWasmCmdConfig).Assembly).Run(args); [Benchmark] public void Foo() { // Benchmark body } } // *** Fluent Config *** public class IntroWasmFluentConfig { public static void Run() { // the Wasm Toolchain requires two mandatory arguments: const string cliPath = @\"/home/adam/projects/runtime/dotnet.sh\"; WasmRuntime runtime = new WasmRuntime(msBuildMoniker: \"net5.0\"); NetCoreAppSettings netCoreAppSettings = new NetCoreAppSettings( targetFrameworkMoniker: \"net5.0\", runtimeFrameworkVersion: null, name: \"Wasm\", customDotNetCliPath: cliPath); IToolchain toolChain = WasmToolchain.From(netCoreAppSettings); BenchmarkRunner.Run<IntroCustomMonoFluentConfig>(DefaultConfig.Instance .AddJob(Job.ShortRun.WithRuntime(runtime).WithToolchain(toolChain))); } [Benchmark] public void Foo() { // Benchmark body } } } Links Toolchains The permanent link to this sample: BenchmarkDotNet.Samples.IntroWasm MonoAotLLVM BenchmarkDotNet supports doing Mono AOT runs with both the Mono-Mini compiler and the Mono-LLVM compiler (which uses llvm on the back end). Using this tool chain requires the following flags: --runtimes monoaotllvm --aotcompilerpath <path to mono aot compiler> --customruntimepack <path to runtime pack> and optionally (defaults to mini) --aotcompilermode <mini|llvm> As of this writing, the mono aot compiler is not available as a seperate download or nuget package. Therefore, it is required to build the compiler in the [dotnet/runtime repository]. The compiler binary (mono-sgen) is built as part of the mono subset, so it can be built (along with the runtime pack) like so (in the root of [dotnet/runtime]). ./build.sh -subset mono+libs -c Release The compiler binary should be generated here (modify for your platform): <runtime root>/artifacts/obj/mono/OSX.x64.Release/mono/mini/mono-sgen And the runtime pack should be generated here: <runtimeroot>artifacts/bin/microsoft.netcore.app.runtime.osx-x64/Release/"
  },
  "articles/configs/validators.html": {
    "href": "articles/configs/validators.html",
    "title": "Validators | BenchmarkDotNet",
    "summary": "Validators A validator can validate your benchmarks before they are executed and produce validation errors. If any of the validation errors is critical, then none of the benchmarks will get executed. Available validators are: BaselineValidator.FailOnError - it checks if more than 1 Benchmark per class has Baseline = true applied. This validator is mandatory. JitOptimizationsValidator.(Dont)FailOnError - it checks whether any of the referenced assemblies is non-optimized. DontFailOnError version is enabled by default. ExecutionValidator.(Dont)FailOnError - it checks if it is possible to run your benchmarks by executing each of them once. Optional. ReturnValueValidator.(Dont)FailOnError - it checks if non-void benchmarks return equal values. Optional."
  },
  "articles/contributing/building.html": {
    "href": "articles/contributing/building.html",
    "title": "Building | BenchmarkDotNet",
    "summary": "Building There are two recommended options to build BenchmarkDotNet from source: Visual Studio Visual Studio (Community, Professional, Enterprise) with .NET 4.6.2 SDK and F# support. .NET 7 SDK. Once all the necessary tools are in place, building is trivial. Simply open solution file BenchmarkDotNet.sln that lives at the base of the repository and run Build action. Command-line Cake (C# Make) is a cross platform build automation system with a C# DSL to do things like compiling code, copy files/folders, running unit tests, compress files and build NuGet packages. The build currently depends on the following prerequisites: Windows: PowerShell version 5 or higher MSBuild version 15.1 or higher .NET Framework 4.6 or higher Linux: Install Mono version 5 or higher Install fsharp package Install packages required to .NET Core SDK gettext libcurl4-openssl-dev libicu-dev libssl-dev libunwind8 macOS Install Mono version 5 or higher Install fsharp package Install the latest version of OpenSSL. In order to run various build tasks from terminal, use build.cmd file in the repository root. build.cmd is a cross-platform script that can be used the same way on Windows, Linux, and macOS. When executed without arguments, it prints help information with list of all available build tasks."
  },
  "articles/contributing/debugging.html": {
    "href": "articles/contributing/debugging.html",
    "title": "Debugging | BenchmarkDotNet",
    "summary": "Debugging There should be two debug profiles available in VS drop down"
  },
  "articles/contributing/disassembler.html": {
    "href": "articles/contributing/disassembler.html",
    "title": "Contributing to Disassembler | BenchmarkDotNet",
    "summary": "Contributing to Disassembler The disassembler might looks scarry, but once you know how it works and how to debug it, it's very easy to develop it. How it works We have 3 disassemblers: Mono x64 for Windows and Linux x86 for Windows The MonoDisassembler is very simple: it spawns Mono with the right arguments to get the asm, Mono prints the output to the console and we just parse it. Single class does the job: MonoDisassembler. When it comes to Windows disassemblers it's not so easy. To obtain the disassm we are using ClrMD. ClrMD can attach only to the process of same bitness (architecture). This is why we have two disassemblers: x64 and x86. The code is the same (single class, linked in two projects) but compiled for two different architectures. We keep both disassemblers in the resources of the BenchmarkDotNet.dll. When we need the disassembler, we search for it in the resources, copy it to the disk and run (it's an exe). On Linux it's simpler (only x64 is supported) and we don't spawn a new process (everything is done in-proc). How to debug the disassembler You need to create a new console app project which executes the code that you would like to disassemble. In this app, you need to run the desired code (to get it jitted) and just don't exit before attaching the disassembler and getting the disassembly. Disassembler requires some arguments to run: id of the process to attach, full type name of the type which contains desired method, name of desired method and few other (see the example below). Personally I use following code to run the console app and print arguments that are required to attach to it: namespace Sample { class Program { static void Main(string[] args) { var result = Benchmark(); // execute the benchmark do method gets jitted Console.WriteLine( $\"{Process.GetCurrentProcess().Id} \" + // process Id $\"\\\"{typeof(Program).FullName}\\\" \" + // full type name $\"{nameof(Benchmark)} \" + // benchmarked method name $\"{bool.FalseString} \" + // print Source \"2 \" + // recursive depth $\"{Path.GetTempFileName()}.xml\"); // result xml file path while(true) { Console.WriteLine(\"Press Ctrl+C to kill the process\"); Console.ReadLine(); // block the exe, attach with Disassembler now } GC.KeepAlive(result); } public static IntPtr Benchmark() { return new IntPtr(42).Multiply(4); } } public static class IntPtrHelper { [MethodImpl(MethodImplOptions.AggressiveInlining)] public unsafe static IntPtr Multiply(this IntPtr a, int factor) { return (sizeof(IntPtr) == sizeof(int)) ? new IntPtr((int)a * factor) : new IntPtr((long)a * factor); } } } Important: Please remember that every new classic .NET project in VS compiles as 32 bit. If you want to check the asm produced for x64 you need to go to the properties of the console app (Alt+Enter) and uncheck \"Prefer 32 bit\" in the \"Build\" tab. Once you configure your app, you should run it. It will give you an output similar to this: 13672 Sample.Program Benchmark True 7 C:\\Users\\adsitnik\\AppData\\Local\\Temp\\tmpDCB9.tmp.xml Now you go to BenchmarkDotNet solution, select desired Disassembler project in the Solution Explorer and Set it as Startup project. After this you go to the project's properties and in the Debug tab copy-paste the arguments for the disassembler. Now when you start debugging, your IDE will spawn new process of the disassembler with the right arguments to attach to the desired exe. You should be able to debug it like any other app. Please keep in mind that you should always use the disassembler for the correct processor architecture. If you fail to debug it, you are most probably using the wrong one."
  },
  "articles/contributing/documentation.html": {
    "href": "articles/contributing/documentation.html",
    "title": "Documentation | BenchmarkDotNet",
    "summary": "Documentation BenchmarkDotNet uses DocFX as a documentation generation tool. Hints If you want to provide a link to API, you can use cross references by UID. For example, [SimpleJobAttribute](xref:BenchmarkDotNet.Attributes.SimpleJobAttribute) and @BenchmarkDotNet.Attributes.SimpleJobAttribute will be transformed to SimpleJobAttribute. Notes DocFX uses the following syntax inside block quote for different types of notes: > [!NOTE] > note content > [!TIP] > tip content > [!WARNING] > warning content > [!IMPORTANT] > important content > [!Caution] > caution content It will be transformed to: Note note content Tip tip content Warning warning content Important important content Caution caution content Building documentation locally You can build documentation locally with the help of the docs-build build task: build.cmd docs-build See also DocFX User Manual DocFX Tutorials: Links and Cross References DocFX Flavored Markdown"
  },
  "articles/contributing/miscellaneous.html": {
    "href": "articles/contributing/miscellaneous.html",
    "title": "| BenchmarkDotNet",
    "summary": "#Miscellaneous topics F# We have full F# support, all you have to do is to run dotnet restore to download the compilers etc. Chat room How can I help? Here is a list of up-for-grabs issues"
  },
  "articles/contributing/running-tests.html": {
    "href": "articles/contributing/running-tests.html",
    "title": "Running Tests | BenchmarkDotNet",
    "summary": "Running Tests To run all tests just run the following command in the repo root: dotnet test -c Release BenchmarkDotNet.sln Most of the tests projects target net461 and net5.0. If the change that you want to test is not specific to any particular runtime, you can run the tests for one of them. dotnet test -c Release -f net5.0 BenchmarkDotNet.sln You should be able to run all of tests from your IDE as well. Verify Tests For some unit tests (e.g. for exporter tests) BenchmarkDotNet uses Verify. The expected value for each test is stored in a *.verified.txt file located near the test source file in the repository. Verify generates verified file's names automatically according test name and its parameters. This files must be added under the source control. It also creates a *.received file for each failed test. You can use diff tools for convenient file comparison. By default you can find test run results on the test runner console as usual. You can comment out the line result.DisableDiff() in VerifySettingsFactory.Create method and then Verify will open KDiff for each failed test. This way you can easily understand what's the difference between verified and received values and choose the correct one."
  },
  "articles/faq.html": {
    "href": "articles/faq.html",
    "title": "FAQ (Frequently asked questions) | BenchmarkDotNet",
    "summary": "FAQ (Frequently asked questions) Q Why can't I install BenchmarkDotNet in Visual Studio 2010/2012/2013? A BenchmarkDotNet requires NuGet 3.x+ and can't be installed in old versions of Visual Studio which use NuGet 2.x. Consider to use Visual Studio 2015/2017 or Rider. See also: BenchmarkDotNet#237, roslyn#12780. Q Why can't I install BenchmarkDotNet in a new .NET Core Console App in Visual Studio 2017? A BenchmarkDotNet supports only netcoreapp2.0+. Some old Visual Studio 2017 can create a new application which targets netcoreapp1.0. You should upgrade it up to 2.0. If you want to target netcoreapp1.0 in your main assembly, it's recommended to create a separated project for benchmarks. Q I created a new .NET Core Console App in Visual Studio 2017. Now I want to run my code on CoreCLR, full .NET Framework, and Mono. How can I do it? A Use the following lines in your .csproj file: <TargetFrameworks>netcoreapp2.0;net46</TargetFrameworks> <PlatformTarget>AnyCPU</PlatformTarget> And mark your benchmark class with the following attributes: [CoreJob, ClrJob, MonoJob] Q My source code targets old versions of .NET Framework or .NET Core, but BenchmarkDotNet requires net461 and netcoreapp2.0. How can I run benchmarks in this case? A It's a good practice to introduce an additional console application (e.g. MyAwesomeLibrary.Benchmarks) which will depend on your code and BenchmarkDotNet. Due to the fact that users usually run benchmarks in a develop environment and don't distribute benchmarks for users, it shouldn't be a problem. Q I wrote a small benchmark, but BenchmarkDotNet requires a lot of time for time measurements. How can I reduce this time? A By default, BenchmarkDotNet automatically chooses a number of iterations which allows achieving the best precision. If you don't need such level of precision and just want to have a quick way to get approximated results, you can specify all parameters manually. For example, you can use the SimpleJob or ShortRunJob attributes: [SimpleJob(launchCount: 1, warmupCount: 3, iterationCount: 5, invocationCount:100, id: \"QuickJob\")] [ShortRunJob] Q My benchmark unexpectedly stopped and I saw the information about error code. What can I do? A BenchmarkDotNet generates, builds and runs new process for every benchmark. This behavior is sometimes interpreted by anti-virus as dangerous, and the process is killed. Use EnvironmentAnalyser to detect antivirus software and configure your benchmark to use InProcessToolchain. Q Can I run benchmark on the virtual machine? A Yes, of course. However, it can affect results because of the shared, physical machine, virtualization process and incorrect Stopwatch.Frequency. If you are unsure whether an application is running on virtual environment, use EnvironmentAnalyser to detect VM hypervisor. Q I have failed to run my benchmarks, I am getting following errors about non-optimized dll. What can I do? Assembly BenchmarkDotNet.Samples which defines benchmarks references non-optimized BenchmarkDotNet If you own this dependency, please, build it in RELEASE. If you don't, you can create custom config with DontFailOnError to disable our custom policy and allow this b Assembly BenchmarkDotNet.Samples which defines benchmarks is non-optimized Benchmark was built without optimization enabled (most probably a DEBUG configuration). Please, build it in RELEASE. A You should always run your benchmarks in RELEASE mode with optimizations enabled (default setting for RELEASE). However if you have to use non-optimized 3rd party assembly you have to create custom config to disable our default policy. public class AllowNonOptimized : ManualConfig { public AllowNonOptimized() { Add(JitOptimizationsValidator.DontFailOnError); // ALLOW NON-OPTIMIZED DLLS Add(DefaultConfig.Instance.GetLoggers().ToArray()); // manual config has no loggers by default Add(DefaultConfig.Instance.GetExporters().ToArray()); // manual config has no exporters by default Add(DefaultConfig.Instance.GetColumnProviders().ToArray()); // manual config has no columns by default } } Q I have failed to run my benchmarks from LINQPad. How can I fix this problem? Assembly LINQPadQuery which defines benchmarks references non-optimized LINQPad Assembly LINQPadQuery which defines benchmarks is non-optimized Benchmark was built without optimization enabled (most probably a DEBUG configuration). Please, build it in RELEASE. A You need to make sure that you are using AnyCPU 5.22.05+ build of LINQPad with optimizations enabled. To enable the optimizations you need to go to Preferences -> Query and select compile with /optimize+ Q I'm trying to use RPlotExporter but there are no any images in the results folder A Try to specify R_LIBS_USER (e.g. R_LIBS_USER=/usr/local/lib/R/ on Linux/macOS, see also: #692) Q My benchmark failed with OutOfMemoryException. How can I fix this problem? A BenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects. If your benchmark allocates memory and keeps it alive, you are creating a memory leak. You should redesign your benchmark and remove the side-effects. You can use OperationsPerInvoke, IterationSetup and IterationCleanup to do that. An example: public class OOM { private StringBuilder buffer = new StringBuilder(); [Benchmark] public void HasSideEffects() { // This method is growing the buffer to infinity // because it's executed millions of times buffer.Append('a'); } [Benchmark(OperationsPerInvoke = 16)] public void HasNoSideEffects() { buffer.Clear(); for (int i = 0; i < 1024; i++) buffer.Append('a'); } }"
  },
  "articles/features/baselines.html": {
    "href": "articles/features/baselines.html",
    "title": "Benchmark and Job Baselines | BenchmarkDotNet",
    "summary": "Benchmark and Job Baselines In order to scale your results, you can mark a benchmark method or a job as a baseline. Let's learn this feature by examples. Sample: IntroBenchmarkBaseline You can mark a method as a baseline with the help of [Benchmark(Baseline = true)]. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroBenchmarkBaseline { [Benchmark] public void Time50() => Thread.Sleep(50); [Benchmark(Baseline = true)] public void Time100() => Thread.Sleep(100); [Benchmark] public void Time150() => Thread.Sleep(150); } } Output As a result, you will have additional Ratio column in the summary table: | Method | Mean | Error | StdDev | Ratio | |-------- |----------:|----------:|----------:|------:| | Time50 | 50.46 ms | 0.0779 ms | 0.0729 ms | 0.50 | | Time100 | 100.39 ms | 0.0762 ms | 0.0713 ms | 1.00 | | Time150 | 150.48 ms | 0.0986 ms | 0.0922 ms | 1.50 | This column contains the mean value of the ratio distribution. For example, in the case of Time50, we divide the first measurement of Time50 into the first measurement of Time100 (it's the baseline), the second measurement of Time50 into the second measurement of Time100, and so on. Next, we calculate the mean of all these values and display it in the Ratio column. For Time50, we have 0.50. The Ratio column was formerly known as Scaled. The old title was a source of misunderstanding and confusion because many developers interpreted it as the ratio of means (e.g., 50.46/100.39 for Time50). The ratio of distribution means and the mean of the ratio distribution are pretty close to each other in most cases, but they are not equal. In @BenchmarkDotNet.Samples.IntroRatioStdDev, you can find an example of how this value can be spoiled by outliers. Links Benchmark and Job Baselines The permanent link to this sample: BenchmarkDotNet.Samples.IntroBenchmarkBaseline Sample: IntroRatioSD The ratio of two benchmarks is not a single number, it's a distribution. In most simple cases, the range of the ratio distribution is narrow, and BenchmarkDotNet displays a single column Ratio with the mean value. However, it also adds the RatioSD column (the standard deviation of the ratio distribution) in complex situations. In the below example, the baseline benchmark is spoiled by a single outlier Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; using Perfolizer.Mathematics.OutlierDetection; namespace BenchmarkDotNet.Samples { // Don't remove outliers [Outliers(OutlierMode.DontRemove)] // Skip jitting, pilot, warmup; measure 10 iterations [SimpleJob(RunStrategy.Monitoring, iterationCount: 10, invocationCount: 1)] public class IntroRatioSD { private int counter; [GlobalSetup] public void Setup() => counter = 0; [Benchmark(Baseline = true)] public void Base() { Thread.Sleep(100); if (++counter % 7 == 0) Thread.Sleep(5000); // Emulate outlier } [Benchmark] public void Slow() => Thread.Sleep(200); [Benchmark] public void Fast() => Thread.Sleep(50); } } Output Here are statistics details for the baseline benchmark: Mean = 600.6054 ms, StdErr = 500.0012 ms (83.25%); N = 10, StdDev = 1,581.1428 ms Min = 100.2728 ms, Q1 = 100.3127 ms, Median = 100.4478 ms, Q3 = 100.5011 ms, Max = 5,100.6163 ms IQR = 0.1884 ms, LowerFence = 100.0301 ms, UpperFence = 100.7837 ms ConfidenceInterval = [-1,789.8568 ms; 2,991.0677 ms] (CI 99.9%), Margin = 2,390.4622 ms (398.01% of Mean) Skewness = 2.28, Kurtosis = 6.57, MValue = 2 -------------------- Histogram -------------------- [-541.891 ms ; 743.427 ms) | @@@@@@@@@ [ 743.427 ms ; 2027.754 ms) | [2027.754 ms ; 3312.082 ms) | [3312.082 ms ; 4458.453 ms) | [4458.453 ms ; 5742.780 ms) | @ --------------------------------------------------- As you can see, a single outlier significantly affected the metrics. Because of this, BenchmarkDotNet adds the Median and the RatioSD columns in the summary table: Method | Mean | Error | StdDev | Median | Ratio | RatioSD | ------- |----------:|--------------:|--------------:|----------:|------:|--------:| Base | 600.61 ms | 2,390.4622 ms | 1,581.1428 ms | 100.45 ms | 1.00 | 0.00 | Slow | 200.50 ms | 0.4473 ms | 0.2959 ms | 200.42 ms | 1.80 | 0.62 | Fast | 50.54 ms | 0.3435 ms | 0.2272 ms | 50.48 ms | 0.45 | 0.16 | Let's look at the Base and Slow benchmarks. The Mean values are 600 and 200 milliseconds; the \"Scaled Mean\" value is 0.3. The Median values are 100 and 200 milliseconds; the \"Scaled Median\" value is 2. Both values are misleading. BenchmarkDotNet evaluates the ratio distribution and displays the mean (1.80) and the standard deviation (0.62). Links Benchmark and Job Baselines The permanent link to this sample: BenchmarkDotNet.Samples.IntroRatioSD Sample: IntroCategoryBaseline The only way to have several baselines in the same class is to separate them by categories and mark the class with [GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)]. Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; namespace BenchmarkDotNet.Samples { [GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)] [CategoriesColumn] public class IntroCategoryBaseline { [BenchmarkCategory(\"Fast\"), Benchmark(Baseline = true)] public void Time50() => Thread.Sleep(50); [BenchmarkCategory(\"Fast\"), Benchmark] public void Time100() => Thread.Sleep(100); [BenchmarkCategory(\"Slow\"), Benchmark(Baseline = true)] public void Time550() => Thread.Sleep(550); [BenchmarkCategory(\"Slow\"), Benchmark] public void Time600() => Thread.Sleep(600); } } Output | Method | Categories | Mean | Error | StdDev | Ratio | |-------- |----------- |----------:|----------:|----------:|------:| | Time50 | Fast | 50.46 ms | 0.0745 ms | 0.0697 ms | 1.00 | | Time100 | Fast | 100.47 ms | 0.0955 ms | 0.0893 ms | 1.99 | | | | | | | | | Time550 | Slow | 550.48 ms | 0.0525 ms | 0.0492 ms | 1.00 | | Time600 | Slow | 600.45 ms | 0.0396 ms | 0.0331 ms | 1.09 | Links Benchmark and Job Baselines The permanent link to this sample: BenchmarkDotNet.Samples.IntroCategoryBaseline Sample: IntroJobBaseline If you want to compare several runtime configuration, you can mark one of your jobs with baseline = true. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [SimpleJob(runtimeMoniker: RuntimeMoniker.Net462, baseline: true)] [SimpleJob(runtimeMoniker: RuntimeMoniker.Mono)] [SimpleJob(runtimeMoniker: RuntimeMoniker.Net50)] public class IntroJobBaseline { [Benchmark] public int SplitJoin() => string.Join(\",\", new string[1000]).Split(',').Length; } } Output BenchmarkDotNet=v0.10.12, OS=Windows 10 Redstone 3 [1709, Fall Creators Update] (10.0.16299.192) Processor=Intel Core i7-6700HQ CPU 2.60GHz (Skylake), ProcessorCount=8 Frequency=2531249 Hz, Resolution=395.0619 ns, Timer=TSC .NET Core SDK=2.0.3 [Host] : .NET Core 2.0.3 (Framework 4.6.25815.02), 64bit RyuJIT Job-MXFYPZ : .NET Framework 4.7 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.2600.0 Core : .NET Core 2.0.3 (Framework 4.6.25815.02), 64bit RyuJIT Mono : Mono 5.4.0 (Visual Studio), 64bit Method | Runtime | Mean | Error | StdDev | Ratio | RatioSD | ---------- |-------- |---------:|----------:|----------:|------:|--------:| SplitJoin | Clr | 19.42 us | 0.2447 us | 0.1910 us | 1.00 | 0.00 | SplitJoin | Core | 13.00 us | 0.2183 us | 0.1935 us | 0.67 | 0.01 | SplitJoin | Mono | 39.14 us | 0.7763 us | 1.3596 us | 2.02 | 0.07 | Links Benchmark and Job Baselines The permanent link to this sample: BenchmarkDotNet.Samples.IntroJobBaseline"
  },
  "articles/features/disassembler.html": {
    "href": "articles/features/disassembler.html",
    "title": "Disassembler | BenchmarkDotNet",
    "summary": "Disassembler Can be enabled by using [DisassemblyDiagnoser] or command line args: -d or --disasm. The configuration options available from code level are: maxDepth: Includes called methods to given level. 1 by default, indexed from 1. To print just the benchmark set it to 0. This option is also available from the console arguments level --disasmDepth. printSource: C#|F#|VB source code will be printed. False by default. printInstructionAddresses: Print instruction addresses. False by default. exportGithubMarkdown: Exports to GitHub markdown. True by default. exportHtml: Exports to HTML with clickable links. False by default. exportCombinedDisassemblyReport: Exports all benchmarks to a single HTML report. Makes it easy to compare different runtimes or methods (each becomes a column in HTML table). exportDiff: Exports a diff of the assembly code to the Github markdown format. False by default. Requirements Disassembly Diagnoser requires following settings in your .csproj file: <PropertyGroup> <PlatformTarget>AnyCPU</PlatformTarget> <DebugType>pdbonly</DebugType> <DebugSymbols>true</DebugSymbols> </PropertyGroup> To get the source code we need to locate and read the .pdb files. This is why we need DebugType and DebugSymbols settings. To compare different platforms the project which defines benchmarks has to target AnyCPU. Disassembly Diagnoser for Mono on Windows If you want to get a disassembly listing for Mono on Windows, you need as and x86_64-w64-mingw32-objdump.exe tools. If you don't have it, you will get a warning like follows: It's impossible to get Mono disasm because you don't have some required tools: 'as' is not recognized as an internal or external command 'x86_64-w64-mingw32-objdump.exe' is not recognized as an internal or external command The easiest way to get these tools: Download and install Cygwin On the \"Select Packages\" screen, search for binutils Install binutils and mingw64-x86_64-binutils Add cygwin64\\bin\\ (or cygwin\\bin\\) in %PATH% Sample: IntroDisassembly Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnosers; using System.Linq; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(printInstructionAddresses: true, syntax: DisassemblySyntax.Masm)] public class IntroDisassembly { private int[] field = Enumerable.Range(0, 100).ToArray(); [Benchmark] public int SumLocal() { var local = field; // we use local variable that points to the field int sum = 0; for (int i = 0; i < local.Length; i++) sum += local[i]; return sum; } [Benchmark] public int SumField() { int sum = 0; for (int i = 0; i < field.Length; i++) sum += field[i]; return sum; } } } Output ; .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.7.3110.0 05452718 BenchmarkDotNet.Samples.IntroDisassembly.Sum() IL_0000: ldc.r8 0 IL_0009: stloc.0 0545271c d9ee fldz IL_000a: ldc.i4.0 IL_000b: stloc.1 IL_000c: br.s IL_0017 0545271e 33c0 xor eax,eax IL_000e: ldloc.0 IL_000f: ldloc.1 IL_0010: conv.r8 IL_0011: add IL_0012: stloc.0 05452720 8945fc mov dword ptr [ebp-4],eax 05452723 db45fc fild dword ptr [ebp-4] 05452726 dec1 faddp st(1),st IL_0013: ldloc.1 IL_0014: ldc.i4.1 IL_0015: add IL_0016: stloc.1 05452728 40 inc eax IL_0017: ldloc.1 IL_0018: ldc.i4.s 64 IL_001a: blt.s IL_000e 05452729 83f840 cmp eax,40h 0545272c 7cf2 jl 05452720 IL_001c: ldloc.0 IL_001d: ret 0545272e 8be5 mov esp,ebp ; .NET Core 2.1.0 (CoreCLR 4.6.26515.07, CoreFX 4.6.26515.06), 64bit RyuJIT 00007ffa`6c621320 BenchmarkDotNet.Samples.IntroDisassembly.Sum() IL_0000: ldc.r8 0 IL_0009: stloc.0 00007ffa`6c621323 c4e17857c0 vxorps xmm0,xmm0,xmm0 IL_000a: ldc.i4.0 IL_000b: stloc.1 IL_000c: br.s IL_0017 00007ffa`6c621328 33c0 xor eax,eax IL_000e: ldloc.0 IL_000f: ldloc.1 IL_0010: conv.r8 IL_0011: add IL_0012: stloc.0 00007ffa`6c62132a c4e17057c9 vxorps xmm1,xmm1,xmm1 00007ffa`6c62132f c4e1732ac8 vcvtsi2sd xmm1,xmm1,eax 00007ffa`6c621334 c4e17b58c1 vaddsd xmm0,xmm0,xmm1 IL_0013: ldloc.1 IL_0014: ldc.i4.1 IL_0015: add IL_0016: stloc.1 00007ffa`6c621339 ffc0 inc eax IL_0017: ldloc.1 IL_0018: ldc.i4.s 64 IL_001a: blt.s IL_000e 00007ffa`6c62133b 83f840 cmp eax,40h 00007ffa`6c62133e 7cea jl 00007ffa`6c62132a IL_001c: ldloc.0 IL_001d: ret 00007ffa`6c621340 c3 ret Mono 5.12.0 (Visual Studio), 64bit Sum sub $0x18,%rsp mov %rsi,(%rsp) xorpd %xmm0,%xmm0 movsd %xmm0,0x8(%rsp) xor %esi,%esi jmp 2e xchg %ax,%ax movsd 0x8(%rsp),%xmm0 cvtsi2sd %esi,%xmm1 addsd %xmm1,%xmm0 movsd %xmm0,0x8(%rsp) inc %esi cmp $0x40,%esi jl 18 movsd 0x8(%rsp),%xmm0 mov (%rsp),%rsi add $0x18,%rsp retq Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassembly Sample: IntroDisassemblyRyuJit Source code using System.Linq; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(printSource: true)] [RyuJitX64Job] public class IntroDisassemblyRyuJit { private int[] field = Enumerable.Range(0, 100).ToArray(); [Benchmark] public int SumLocal() { var local = field; // we use local variable that points to the field int sum = 0; for (int i = 0; i < local.Length; i++) sum += local[i]; return sum; } [Benchmark] public int SumField() { int sum = 0; for (int i = 0; i < field.Length; i++) sum += field[i]; return sum; } } } Output Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassemblyRyuJit Sample: IntroDisassemblyAllJits You can use a single config to compare the generated assembly code for ALL JITs. But to allow benchmarking any target platform architecture the project which defines benchmarks has to target AnyCPU. <PropertyGroup> <PlatformTarget>AnyCPU</PlatformTarget> </PropertyGroup> Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Diagnosers; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [Config(typeof(MultipleJits))] public class IntroDisassemblyAllJits { public class MultipleJits : ManualConfig { public MultipleJits() { AddJob(Job.ShortRun.WithPlatform(Platform.X86).WithRuntime(new MonoRuntime(name: \"Mono x86\", customPath: @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithPlatform(Platform.X64).WithRuntime(new MonoRuntime(name: \"Mono x64\", customPath: @\"C:\\Program Files\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithJit(Jit.LegacyJit).WithPlatform(Platform.X86).WithRuntime(ClrRuntime.Net462)); AddJob(Job.ShortRun.WithJit(Jit.LegacyJit).WithPlatform(Platform.X64).WithRuntime(ClrRuntime.Net462)); AddJob(Job.ShortRun.WithJit(Jit.RyuJit).WithPlatform(Platform.X64).WithRuntime(ClrRuntime.Net462)); // RyuJit for .NET Core 5.0 AddJob(Job.ShortRun.WithJit(Jit.RyuJit).WithPlatform(Platform.X64).WithRuntime(CoreRuntime.Core50)); AddDiagnoser(new DisassemblyDiagnoser(new DisassemblyDiagnoserConfig(maxDepth: 3, exportDiff: true))); } } private Increment increment = new Increment(); [Benchmark] public int CallVirtualMethod() => increment.OperateTwice(10); public abstract class Operation // abstract unary integer operation { public abstract int Operate(int input); public int OperateTwice(int input) => Operate(Operate(input)); // two virtual calls to Operate } public sealed class Increment : Operation // concrete, sealed operation: increment by fixed amount { public readonly int Amount; public Increment(int amount = 1) { Amount = amount; } public override int Operate(int input) => input + Amount; } } } Output The disassembly result can be obtained here. The file was too big to embed it in this doc page. Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassemblyAllJits Sample: IntroDisassemblyDry Getting only the Disassembly without running the benchmarks for a long time. Sometimes you might be interested only in the disassembly, not the results of the benchmarks. In that case you can use Job.Dry which runs the benchmark only once. Source code using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(maxDepth: 3)] [DryJob] public class IntroDisassemblyDry { [Benchmark] public void Foo() { } } } Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassemblyDry"
  },
  "articles/features/etwprofiler.html": {
    "href": "articles/features/etwprofiler.html",
    "title": "EtwProfiler | BenchmarkDotNet",
    "summary": "EtwProfiler EtwProfiler allows to profile the benchmarked .NET code on Windows and exports the data to a trace file which can be opened with PerfView or Windows Performance Analyzer. How it works EtwProfiler uses TraceEvent library which internally uses Event Tracing for Windows (ETW) to capture stack traces and important .NET Runtime events. Before the process with benchmarked code is started, EtwProfiler starts User and Kernel ETW sessions. Every session writes data to it's own file and captures different data. User session listens for the .NET Runtime events (GC, JIT etc) while the Kernel session gets CPU stacks and Hardware Counter events. After this, the process with benchmarked code is started. During the benchmark execution all the data is captured and written to a trace file. Moreover, BenchmarkDotNet Engine emits it's own events to be able to differentiate jitting, warmup, pilot and actual workload when analyzing the trace file. When the benchmarking is over, both sessions are closed and the two trace files are merged into one. Limitations What we have today comes with following limitations: EtwProfiler works only on Windows (one day we might implement similar thing for Unix using EventPipe) Requires to run as Admin (to create ETW Kernel Session) No InProcessToolchain support To get the best possible managed code symbols you should configure your project in following way: <DebugType>pdbonly</DebugType> <DebugSymbols>true</DebugSymbols> Note On certain machines Intel TDT and Windows Defender can cause CPU samples to be captured with no value. You can correct this problem by disabling the feature using powershell.exe Set-MpPreference -DisableTDTFeature $true. WARNING: Disabling security features will make your machine less secure; do so at your own risk. How to use it? You need to install BenchmarkDotNet.Diagnostics.Windows package. It can be enabled in few ways, some of them: Use the new attribute (apply it on a class that contains Benchmarks): using BenchmarkDotNet.Diagnostics.Windows.Configs; [EtwProfiler] public class TheClassThatContainsBenchmarks { /* benchmarks go here */ } Extend the DefaultConfig.Instance with new instance of EtwProfiler: class Program { static void Main(string[] args) => BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args, DefaultConfig.Instance .AddDiagnoser(new EtwProfiler())); // HERE } Passing -p ETW or --profiler ETW command line argument to BenchmarkSwitcher Configuration To configure the new diagnoser you need to create an instance of EtwProfilerConfig class and pass it to the EtwProfiler constructor. The parameters that EtwProfilerConfig ctor takes are: performExtraBenchmarksRun - if set to true, benchmarks will be executed one more time with the profiler attached. If set to false, there will be no extra run but the results will contain overhead. True by default. bufferSizeInMb - ETW session buffer size, in MB. 256 by default. intervalSelectors - interval per hardware counter, if not provided then default values will be used. kernelKeywords - kernel session keywords, ImageLoad (for native stack frames) and Profile (for CPU Stacks) are the defaults. providers - providers that should be enabled, if not provided then default values will be used. Using PerfView to work with trace files PerfView is a free .NET profiler from Microsoft. If you don't know how to use it you should watch these instructional videos first. If you are familiar with PerfView, then the only thing you need to know is that BenchmarkDotNet performs Jitting by running the code once, Pilot Experiment to determine how many times benchmark should be executed per iteration, non-trivial Warmup and Actual Workload. This is why when you open your trace file in PerfView you will see your benchmark in a few different places of the StackTrace. The simplest way to filter the data to the actual benchmarks runs is to open the CallTree tab, put \"EngineActualStage\" in the Find box, press enter and when PerfView selects EngineActualStage in the CallTree press Alt+R to Set Time Range. If you want to filter the trace to single iteration, then you must go to the Events panel and search for the WorkloadActual/Start and WorkloadActual/Stop events. Open Events window Put \"WorkloadActual\" in the Filter box and hit enter. Press control or shift and choose the Start and Stop events from the left panel. Hit enter. Choose iteration that you want to investigate (events are sorted by time). Select two or more cells from the \"Time MSec\" column. Right click, choose \"Open Cpu Stacks\". Choose the process with benchmarks, right-click, choose \"Drill Into\""
  },
  "articles/features/event-pipe-profiler.html": {
    "href": "articles/features/event-pipe-profiler.html",
    "title": "EventPipeProfiler | BenchmarkDotNet",
    "summary": "EventPipeProfiler EventPipeProfiler is a cross-platform profiler that allows profile .NET code on every platform - Windows, Linux, macOS. Collected data are exported to trace files (.speedscope.json and .nettrace) which can be analyzed using SpeedScope, PerfView, and Visual Studio Profiler. This new profiler is available from the 0.12.1 version. Configuration EventPipeProfiler can be enabled in three ways: Using parameter -p EP or --profiler EP from the console line. Marking the benchmarked class with [EventPipeProfiler(...)] attribute. You can find an example below. Using a custom configuration. You can find an example below. Sample: EventPipeProfiler The EventPipeProfiler can be enabled using the [EventPipeProfiler(...)] attribute. This attribute takes the following profiles: CpuSampling - Useful for tracking CPU usage and general .NET runtime information. This is the default option. GcVerbose - Tracks GC collections and samples object allocations. GcCollect - Tracks GC collections only at very low overhead. Jit - Logging when Just in time (JIT) compilation occurs. Logging of the internal workings of the Just In Time compiler. This is fairly verbose. It details decisions about interesting optimization (like inlining and tail call) Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnosers; namespace BenchmarkDotNet.Samples { [ShortRunJob] [EventPipeProfiler(EventPipeProfile.CpuSampling)] public class IntroEventPipeProfiler { [Benchmark] public void Sleep() => Thread.Sleep(2000); } } Output The output should contain information about the exported trace file which can be analyzed using SpeedScope. // * Diagnostic Output - EventPipeProfiler * Exported 1 trace file(s). Example: C:\\Work\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\BenchmarkDotNet.Artifacts\\BenchmarkDotNet.Samples.IntroEventPipeProfiler.Sleep-20200406-090113.speedscope.json Sample: EventPipeProfilerAdvanced The most advanced and powerful way to use EventPipeProfiler is a custom configuration. As you can see the below configuration adds EventPipeProfiler that constructor can take the profile and/or a list of providers. Both EventPipeProfiler and dotnet trace use the Microsoft.Diagnostics.NETCore.Client package internally. So before you start using the custom configuration of this profiler, it is worth reading the documentation here and here where you can find more information about how to configure provider list. Source code using System.Buffers; using System.Diagnostics.Tracing; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Diagnosers; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using Microsoft.Diagnostics.NETCore.Client; using Microsoft.Diagnostics.Tracing.Parsers; namespace BenchmarkDotNet.Samples { [Config(typeof(CustomConfig))] public class IntroEventPipeProfilerAdvanced { private class CustomConfig : ManualConfig { public CustomConfig() { AddJob(Job.ShortRun.WithRuntime(CoreRuntime.Core50)); var providers = new[] { new EventPipeProvider(ClrTraceEventParser.ProviderName, EventLevel.Verbose, (long) (ClrTraceEventParser.Keywords.Exception | ClrTraceEventParser.Keywords.GC | ClrTraceEventParser.Keywords.Jit | ClrTraceEventParser.Keywords.JitTracing // for the inlining events | ClrTraceEventParser.Keywords.Loader | ClrTraceEventParser.Keywords.NGen)), new EventPipeProvider(\"System.Buffers.ArrayPoolEventSource\", EventLevel.Informational, long.MaxValue), }; AddDiagnoser(new EventPipeProfiler(providers: providers)); } } [Benchmark] public void RentAndReturn_Shared() { var pool = ArrayPool<byte>.Shared; byte[] array = pool.Rent(10000); pool.Return(array); } } } Output The output should contain information about the exported trace file which can be analyzed using SpeedScope. // * Diagnostic Output - EventPipeProfiler * Exported 1 trace file(s). Example: C:\\Work\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\BenchmarkDotNet.Artifacts\\BenchmarkDotNet.Samples.IntroEventPipeProfilerAdvanced.RentAndReturn_Shared-20200406-090136.speedscope.json"
  },
  "articles/features/parameterization.html": {
    "href": "articles/features/parameterization.html",
    "title": "Parameterization | BenchmarkDotNet",
    "summary": "Parameterization Sample: IntroParams You can mark one or several fields or properties in your class by the [Params] attribute. In this attribute, you can specify set of values. Every value must be a compile-time constant. As a result, you will get results for each combination of params values. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroParams { [Params(100, 200)] public int A { get; set; } [Params(10, 20)] public int B { get; set; } [Benchmark] public void Benchmark() => Thread.Sleep(A + B + 5); } } Output | Method | A | B | Mean | Error | StdDev | |---------- |---- |--- |---------:|--------:|--------:| | Benchmark | 100 | 10 | 115.3 ms | 0.13 ms | 0.12 ms | | Benchmark | 100 | 20 | 125.4 ms | 0.14 ms | 0.12 ms | | Benchmark | 200 | 10 | 215.5 ms | 0.19 ms | 0.18 ms | | Benchmark | 200 | 20 | 225.4 ms | 0.17 ms | 0.16 ms | Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroParams Sample: IntroParamsSource In case you want to use a lot of values, you should use [ParamsSource] You can mark one or several fields or properties in your class by the [Params] attribute. In this attribute, you have to specify the name of public method/property which is going to provide the values (something that implements IEnumerable). The source may be instance or static. If the source is not in the same type as the benchmark, the type containing the source must be specified in the attribute constructor. Source code using System.Collections.Generic; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroParamsSource { // property with public setter [ParamsSource(nameof(ValuesForA))] public int A { get; set; } // public field [ParamsSource(nameof(ValuesForB))] public int B; // public property public IEnumerable<int> ValuesForA => new[] { 100, 200 }; // public static method public static IEnumerable<int> ValuesForB() => new[] { 10, 20 }; // public field getting its params from a method in another type [ParamsSource(typeof(ParamsValues), nameof(ParamsValues.ValuesForC))] public int C; [Benchmark] public void Benchmark() => Thread.Sleep(A + B + C + 5); } public static class ParamsValues { public static IEnumerable<int> ValuesForC() => new[] { 1000, 2000 }; } } Output | Method | B | A | Mean | Error | StdDev | |---------- |--- |---- |---------:|--------:|--------:| | Benchmark | 10 | 100 | 115.5 ms | 0.17 ms | 0.16 ms | | Benchmark | 10 | 200 | 215.6 ms | 0.15 ms | 0.14 ms | | Benchmark | 20 | 100 | 125.5 ms | 0.19 ms | 0.18 ms | | Benchmark | 20 | 200 | 225.5 ms | 0.23 ms | 0.22 ms | Remarks A remark about IParam. You don't need to use IParam anymore since 0.11.0. Just use complex types as you wish and override ToString method to change the display names used in the results. Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroParamsSource Sample: IntroParamsAllValues If you want to use all possible values of an enum or another type with a small number of values, you can use the [ParamsAllValues] attribute, instead of listing all the values by hand. The types supported by the attribute are: bool any enum that is not marked with [Flags] Nullable<T>, where T is an enum or boolean Source code using BenchmarkDotNet.Attributes; using System.Threading; namespace BenchmarkDotNet.Samples { [DryJob] public class IntroParamsAllValues { public enum CustomEnum { One = 1, Two, Three } [ParamsAllValues] public CustomEnum E { get; set; } [ParamsAllValues] public bool? B { get; set; } [Benchmark] public void Benchmark() { Thread.Sleep( (int)E * 100 + (B == true ? 20 : B == false ? 10 : 0)); } } } Output Method | E | B | Mean | Error | ---------- |------ |------ |---------:|------:| Benchmark | One | ? | 101.4 ms | NA | Benchmark | One | False | 111.1 ms | NA | Benchmark | One | True | 122.0 ms | NA | Benchmark | Two | ? | 201.3 ms | NA | Benchmark | Two | False | 212.1 ms | NA | Benchmark | Two | True | 221.3 ms | NA | Benchmark | Three | ? | 301.4 ms | NA | Benchmark | Three | False | 311.5 ms | NA | Benchmark | Three | True | 320.8 ms | NA | Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroParamsAllValues Sample: IntroParamsPriority In order to sort columns of parameters in the results table you can use the Property Priority inside the params attribute. The priority range is [Int32.MinValue;Int32.MaxValue], lower priorities will appear earlier in the column order. The default priority is set to 0. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroParamsPriority { [Params(100)] public int A { get; set; } [Params(10, Priority = -100)] public int B { get; set; } [Benchmark] public void Benchmark() => Thread.Sleep(A + B + 5); } } Output | Method | B | A | Mean | Error | StdDev | |---------- |--- |---- |---------:|--------:|--------:| | Benchmark | 10 | 100 | 115.4 ms | 0.12 ms | 0.11 ms | Links Priority BaseClass PriorityAttribute.cs Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroParamsPriority Sample: IntroArguments As an alternative to using [Params], you can specify arguments for your benchmarks. There are several ways to do it (described below). The [Arguments] allows you to provide a set of values. Every value must be a compile-time constant (it's C# language limitation for attributes in general). You can also combine [Arguments] with [Params]. As a result, you will get results for each combination of params values. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArguments { [Params(true, false)] // Arguments can be combined with Params public bool AddExtra5Milliseconds; [Benchmark] [Arguments(100, 10)] [Arguments(100, 20)] [Arguments(200, 10)] [Arguments(200, 20)] public void Benchmark(int a, int b) { if (AddExtra5Milliseconds) Thread.Sleep(a + b + 5); else Thread.Sleep(a + b); } } } Output | Method | AddExtra5Miliseconds | a | b | Mean | Error | StdDev | |---------- |--------------------- |---- |--- |---------:|----------:|----------:| | Benchmark | False | 100 | 10 | 110.1 ms | 0.0056 ms | 0.0044 ms | | Benchmark | False | 100 | 20 | 120.1 ms | 0.0155 ms | 0.0138 ms | | Benchmark | False | 200 | 10 | 210.2 ms | 0.0187 ms | 0.0175 ms | | Benchmark | False | 200 | 20 | 220.3 ms | 0.1055 ms | 0.0986 ms | | Benchmark | True | 100 | 10 | 115.3 ms | 0.1375 ms | 0.1286 ms | | Benchmark | True | 100 | 20 | 125.3 ms | 0.1212 ms | 0.1134 ms | | Benchmark | True | 200 | 10 | 215.4 ms | 0.0779 ms | 0.0691 ms | | Benchmark | True | 200 | 20 | 225.4 ms | 0.0775 ms | 0.0725 ms | Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroArguments Sample: IntroArgumentsSource In case you want to use a lot of values, you should use [ArgumentsSource]. You can mark one or several fields or properties in your class by the [ArgumentsSource] attribute. In this attribute, you have to specify the name of public method/property which is going to provide the values (something that implements IEnumerable). The source may be instance or static. If the source is not in the same type as the benchmark, the type containing the source must be specified in the attribute constructor. Source code using System; using System.Collections.Generic; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArgumentsSource { [Benchmark] [ArgumentsSource(nameof(Numbers))] public double ManyArguments(double x, double y) => Math.Pow(x, y); public IEnumerable<object[]> Numbers() // for multiple arguments it's an IEnumerable of array of objects (object[]) { yield return new object[] { 1.0, 1.0 }; yield return new object[] { 2.0, 2.0 }; yield return new object[] { 4.0, 4.0 }; yield return new object[] { 10.0, 10.0 }; } [Benchmark] [ArgumentsSource(typeof(BenchmarkArguments), nameof(BenchmarkArguments.TimeSpans))] // when the arguments come from a different type, specify that type here public void SingleArgument(TimeSpan time) => Thread.Sleep(time); } public static class BenchmarkArguments { public static IEnumerable<object> TimeSpans() // for single argument it's an IEnumerable of objects (object) { yield return TimeSpan.FromMilliseconds(10); yield return TimeSpan.FromMilliseconds(100); } } } Output | Method | x | y | Mean | Error | StdDev | |------- |--- |--- |----------:|----------:|----------:| | Pow | 1 | 1 | 9.360 ns | 0.0190 ns | 0.0149 ns | | Pow | 2 | 2 | 40.624 ns | 0.3413 ns | 0.3192 ns | | Pow | 4 | 4 | 40.537 ns | 0.0560 ns | 0.0524 ns | | Pow | 10 | 10 | 40.395 ns | 0.3274 ns | 0.3063 ns | Another example If the values are complex types you need to override ToString method to change the display names used in the results. [DryJob] public class WithNonPrimitiveArgumentsSource { [Benchmark] [ArgumentsSource(nameof(NonPrimitive))] public void Simple(SomeClass someClass, SomeStruct someStruct) { for (int i = 0; i < someStruct.RangeEnd; i++) Console.WriteLine($\"// array.Values[{i}] = {someClass.Values[i]}\"); } public IEnumerable<object[]> NonPrimitive() { yield return new object[] { new SomeClass(Enumerable.Range(0, 10).ToArray()), new SomeStruct(10) }; yield return new object[] { new SomeClass(Enumerable.Range(0, 15).ToArray()), new SomeStruct(15) }; } public class SomeClass { public SomeClass(int[] initialValues) => Values = initialValues.Select(val => val * 2).ToArray(); public int[] Values { get; } public override string ToString() => $\"{Values.Length} items\"; } public struct SomeStruct { public SomeStruct(int rangeEnd) => RangeEnd = rangeEnd; public int RangeEnd { get; } public override string ToString() => $\"{RangeEnd}\"; } } | Method | someClass | someStruct | Mean | Error | |------- |---------- |----------- |---------:|------:| | Simple | 10 items | 10 | 887.2 us | NA | | Simple | 15 items | 15 | 963.1 us | NA | Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroArgumentsSource Sample: IntroArrayParam Warning The cost of creating the arguments is not included in the benchmark. So if you want to pass an array as an argument, we are going to allocate it before running the benchmark, and the benchmark will not include this operation. Source code using System; using System.Collections.Generic; using System.Linq; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArrayParam { [Benchmark] [ArgumentsSource(nameof(Data))] public int ArrayIndexOf(int[] array, int value) => Array.IndexOf(array, value); [Benchmark] [ArgumentsSource(nameof(Data))] public int ManualIndexOf(int[] array, int value) { for (int i = 0; i < array.Length; i++) if (array[i] == value) return i; return -1; } public IEnumerable<object[]> Data() { yield return new object[] { new int[] { 1, 2, 3 }, 4 }; yield return new object[] { Enumerable.Range(0, 100).ToArray(), 4 }; yield return new object[] { Enumerable.Range(0, 100).ToArray(), 101 }; } } } Output | Method | array | value | Mean | Error | StdDev | Allocated | |-------------- |----------- |------ |----------:|----------:|----------:|----------:| | ArrayIndexOf | Array[100] | 4 | 15.558 ns | 0.0638 ns | 0.0597 ns | 0 B | | ManualIndexOf | Array[100] | 4 | 5.345 ns | 0.0668 ns | 0.0625 ns | 0 B | | ArrayIndexOf | Array[3] | 4 | 14.334 ns | 0.1758 ns | 0.1558 ns | 0 B | | ManualIndexOf | Array[3] | 4 | 2.758 ns | 0.0905 ns | 0.1208 ns | 0 B | | ArrayIndexOf | Array[100] | 101 | 78.359 ns | 1.8853 ns | 2.0955 ns | 0 B | | ManualIndexOf | Array[100] | 101 | 80.421 ns | 0.6391 ns | 0.5978 ns | 0 B | Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroArrayParam Sample: IntroArgumentsPriority Like Params also Argument columns can be sorted in the table result through their Priority. The priority should be defined only once for multiple Arguments and will keep their inner order as they are defined in the method. Source code using System.Collections.Generic; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArgumentsPriority { [Params(100, Priority = 0)] // Argument priority can be combined with Params priority public int A { get; set; } [Arguments(5, Priority = -10)] // Define priority just once for multiple argument attributes [Arguments(10)] [Arguments(20)] [Benchmark] public void Benchmark(int b) => Thread.Sleep(A + b); [Benchmark] [ArgumentsSource(nameof(Numbers), Priority = 10)] public void ManyArguments(int c, int d) => Thread.Sleep(A + c + d); public IEnumerable<object[]> Numbers() { yield return new object[] { 1, 2 }; } } } Output | Method | b | A | c | d | Mean | Error | StdDev | |-------------- |--- |---- |-- |-- |---------:|--------:|--------:| | ManyArguments | ? | 100 | 1 | 2 | 103.4 ms | 0.09 ms | 0.08 ms | | Benchmark | 5 | 100 | ? | ? | 105.5 ms | 0.21 ms | 0.19 ms | | Benchmark | 10 | 100 | ? | ? | 110.5 ms | 0.14 ms | 0.14 ms | | Benchmark | 20 | 100 | ? | ? | 120.4 ms | 0.16 ms | 0.15 ms | Links Priority BaseClass PriorityAttribute.cs Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroArgumentsPriority"
  },
  "articles/features/setup-and-cleanup.html": {
    "href": "articles/features/setup-and-cleanup.html",
    "title": "Setup And Cleanup | BenchmarkDotNet",
    "summary": "Setup And Cleanup Sometimes we want to write some logic which should be executed before or after a benchmark, but we don't want to measure it. For this purpose, BenchmarkDotNet provides a set of attributes: [GlobalSetup], [GlobalCleanup], [IterationSetup], [IterationCleanup]. Sample: IntroSetupCleanupGlobal A method which is marked by the [GlobalSetup] attribute will be executed only once per a benchmarked method after initialization of benchmark parameters and before all the benchmark method invocations. A method which is marked by the [GlobalCleanup] attribute will be executed only once per a benchmarked method after all the benchmark method invocations. If you are using some unmanaged resources (e.g., which were created in the GlobalSetup method), they can be disposed in the GlobalCleanup method. Source code using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroSetupCleanupGlobal { [Params(10, 100, 1000)] public int N; private int[] data; [GlobalSetup] public void GlobalSetup() { data = new int[N]; // executed once per each N value } [Benchmark] public int Logic() { int res = 0; for (int i = 0; i < N; i++) res += data[i]; return res; } [GlobalCleanup] public void GlobalCleanup() { // Disposing logic } } } Links Setup And Cleanup The permanent link to this sample: BenchmarkDotNet.Samples.IntroSetupCleanupGlobal Sample: IntroSetupCleanupIteration A method which is marked by the [IterationSetup] attribute will be executed exactly once before each benchmark invocation, forcing UnrollFactor=1 and InvocationCount=1 (we have changed that in 0.11.0). It's not recommended to use this attribute in microbenchmarks because it can spoil the results. However, if you are writing a macrobenchmark (e.g. a benchmark which takes at least 100ms) and you want to prepare some data before each invocation, [IterationSetup] can be useful. A method which is marked by the [IterationCleanup] attribute will be executed exactly once after each invocation. This attribute has the same set of constraint with [IterationSetup]: it's not recommended to use [IterationCleanup] in microbenchmarks. Source code using System; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.Monitoring, launchCount: 1, warmupCount: 2, iterationCount: 3)] public class IntroSetupCleanupIteration { private int setupCounter; private int cleanupCounter; [IterationSetup] public void IterationSetup() => Console.WriteLine($\"// IterationSetup ({++setupCounter})\"); [IterationCleanup] public void IterationCleanup() => Console.WriteLine($\"// IterationCleanup ({++cleanupCounter})\"); [GlobalSetup] public void GlobalSetup() => Console.WriteLine(\"// \" + \"GlobalSetup\"); [GlobalCleanup] public void GlobalCleanup() => Console.WriteLine(\"// \" + \"GlobalCleanup\"); [Benchmark] public void Benchmark() => Console.WriteLine(\"// \" + \"Benchmark\"); } } The order of method calls // GlobalSetup // IterationSetup (1) // IterationSetup Jitting // IterationCleanup (1) // IterationCleanup Jitting // IterationSetup (2) // MainWarmup1 // Benchmark // MainWarmup1 // IterationCleanup (2) // MainWarmup1 // IterationSetup (3) // MainWarmup2 // Benchmark // MainWarmup2 // IterationCleanup (3) // MainWarmup2 // IterationSetup (4) // MainTarget1 // Benchmark // MainTarget1 // IterationCleanup (4) // MainTarget1 // IterationSetup (5) // MainTarget2 // Benchmark // MainTarget2 // IterationCleanup (5) // MainTarget2 // IterationSetup (6) // MainTarget3 // Benchmark // MainTarget3 // IterationCleanup (6) // MainTarget3 // GlobalCleanup Links Setup And Cleanup The permanent link to this sample: BenchmarkDotNet.Samples.IntroSetupCleanupIteration Sample: IntroSetupCleanupTarget Sometimes it's useful to run setup or cleanups for specific benchmarks. All four setup and cleanup attributes have a Target property that allow the setup/cleanup method to be run for one or more specific benchmark methods. Source code using System; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.Monitoring, launchCount: 0, warmupCount: 0, iterationCount: 1)] public class IntroSetupCleanupTarget { [GlobalSetup(Target = nameof(BenchmarkA))] public void GlobalSetupA() => Console.WriteLine(\"// \" + \"GlobalSetup A\"); [Benchmark] public void BenchmarkA() => Console.WriteLine(\"// \" + \"Benchmark A\"); [GlobalSetup(Targets = new[] { nameof(BenchmarkB), nameof(BenchmarkC) })] public void GlobalSetupB() => Console.WriteLine(\"// \" + \"GlobalSetup B\"); [Benchmark] public void BenchmarkB() => Console.WriteLine(\"// \" + \"Benchmark B\"); [Benchmark] public void BenchmarkC() => Console.WriteLine(\"// \" + \"Benchmark C\"); [Benchmark] public void BenchmarkD() => Console.WriteLine(\"// \" + \"Benchmark D\"); } } The order of method calls // GlobalSetup A // Benchmark A // GlobalSetup B // Benchmark B // GlobalSetup B // Benchmark C // Benchmark D Links Setup And Cleanup The permanent link to this sample: BenchmarkDotNet.Samples.IntroSetupCleanupTarget"
  },
  "articles/features/statistics.html": {
    "href": "articles/features/statistics.html",
    "title": "Statistics | BenchmarkDotNet",
    "summary": "Statistics Sample: IntroStatisticsColumns Source code using System; using System.Security.Cryptography; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [MediumRunJob, SkewnessColumn, KurtosisColumn] public class IntroStatisticsColumns { private const int N = 10000; private readonly byte[] data; private readonly MD5 md5 = MD5.Create(); private readonly SHA256 sha256 = SHA256.Create(); public IntroStatisticsColumns() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark(Baseline = true)] public byte[] Md5A() => md5.ComputeHash(data); [Benchmark] public byte[] Md5B() => md5.ComputeHash(data); [Benchmark] public byte[] Sha256() => sha256.ComputeHash(data); } } Output Method Mean Error StdDev Skewness Kurtosis Ratio RatioSD Md5A 15.91 us 0.0807 us 0.1209 us 0.4067 1.646 1.00 0.00 Md5B 15.89 us 0.0709 us 0.1062 us 0.5893 2.141 1.00 0.01 Sha256 36.62 us 0.6390 us 0.9564 us 1.1363 4.014 2.30 0.06 Links Statistics The permanent link to this sample: BenchmarkDotNet.Samples.IntroStatisticsColumns Sample: IntroPercentiles The percentile represents a higher boundary for specified percentage of the measurements. For example, 95th percentile = 500ms means that 95% of all samples are not slower than 500ms. This metric is not very useful in microbenchmarks, as the values from consequent runs have a very narrow distribution. However, real-world scenarios often have so-called long tail distribution (due to IO delays, locks, memory access latency and so on), so the average execution time cannot be trusted. The percentiles allow to include the tail of distribution into the comparison. However, it requires some preparations steps. At first, you should have enough runs to count percentiles from. The IterationCount in the config should be set to 10-20 runs at least. Second, the count of iterations for each run should not be very high, or the peak timings will be averaged. The IterationTime = 25 works fine for most cases; for long-running benchmarks the Mode = Mode.SingleRun will be the best choice. However, feel free to experiment with the config values. Third, if you want to be sure that measurements are repeatable, set the LaunchCount to 3 or higher. And last, don't forget to include the columns into the config. They are not included by default (as said above, these are not too useful for most of the benchmarks). There're predefined StatisticColumn.P0..StatisticColumn.P100 for absolute timing percentiles. Example Run the IntroPercentiles sample. It contains three benchmark methods. First delays for 20 ms constantly. The second has random delays for 10..30 ms. And the third delays for 10ms 85 times of 100 and delays for 40ms 15 times of 100. Here's the output from the benchmark (some columns removed for brevity): Method Median StdDev Ratio P0 P50 P80 P85 P95 P100 ConstantDelays 20.3813 ms 0.2051 ms 1.00 20.0272 ms 20.3813 ms 20.4895 ms 20.4954 ms 20.5869 ms 21.1471 ms RandomDelays 19.8055 ms 5.7556 ms 0.97 10.0793 ms 19.8055 ms 25.4173 ms 26.5187 ms 29.0313 ms 29.4550 ms RareDelays 10.3385 ms 11.4828 ms 0.51 10.0157 ms 10.3385 ms 10.5211 ms 40.0560 ms 40.3992 ms 40.4674 ms Also, it's very easy to screw the results with incorrect setup. For example, the same code being run with new Job { IterationCount = 5, IterationTime = 500 } completely hides the peak values: Method Median StdDev Ratio P0 P50 P80 P85 P95 P100 ConstantDelays 20.2692 ms 0.0308 ms 1.00 20.1986 ms 20.2692 ms 20.2843 ms 20.2968 ms 20.3097 ms 20.3122 ms RandomDelays 18.9965 ms 0.8601 ms 0.94 18.1339 ms 18.9965 ms 19.8126 ms 19.8278 ms 20.4485 ms 20.9466 ms RareDelays 14.0912 ms 2.8619 ms 0.70 10.2606 ms 14.0912 ms 15.7653 ms 17.3862 ms 18.6728 ms 18.6940 ms Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Columns; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { // Using percentiles for adequate timings representation [Config(typeof(Config))] [SimpleJob(RunStrategy.ColdStart, launchCount: 4, warmupCount: 3, iterationCount: 20, id: \"MyJob\")] public class IntroPercentiles { // To share between runs. // DO NOT do this in production code. The System.Random IS NOT thread safe. private static readonly Random Rnd = new Random(); private class Config : ManualConfig { public Config() { AddColumn( StatisticColumn.P0, StatisticColumn.P25, StatisticColumn.P50, StatisticColumn.P67, StatisticColumn.P80, StatisticColumn.P85, StatisticColumn.P90, StatisticColumn.P95, StatisticColumn.P100); } } [Benchmark(Baseline = true)] public void ConstantDelays() => Thread.Sleep(20); [Benchmark] public void RandomDelays() => Thread.Sleep(10 + (int) (20 * Rnd.NextDouble())); [Benchmark] public void RareDelays() { int rndTime = 10; // Bigger delays for 15% of the runs if (Rnd.NextDouble() > 0.85) { rndTime += 30; } Thread.Sleep(rndTime); } } } Links Statistics The permanent link to this sample: BenchmarkDotNet.Samples.IntroPercentiles Sample: IntroRankColumn Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Mathematics; using BenchmarkDotNet.Order; namespace BenchmarkDotNet.Samples { [ShortRunJob] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [RankColumn(NumeralSystem.Arabic)] [RankColumn(NumeralSystem.Roman)] [RankColumn(NumeralSystem.Stars)] public class IntroRankColumn { [Params(1, 2)] public int Factor; [Benchmark] public void Foo() => Thread.Sleep(Factor * 100); [Benchmark] public void Bar() => Thread.Sleep(Factor * 200); } } Output Method | Factor | Mean | Error | StdDev | Rank | Rank | Rank | ------- |------- |---------:|---------:|----------:|-----:|-----:|-----:| Foo | 1 | 100.8 ms | 2.250 ms | 0.1272 ms | 1 | I | * | Foo | 2 | 200.8 ms | 4.674 ms | 0.2641 ms | 2 | II | ** | Bar | 1 | 200.9 ms | 2.012 ms | 0.1137 ms | 2 | II | ** | Bar | 2 | 400.7 ms | 4.509 ms | 0.2548 ms | 3 | III | *** | Links Statistics The permanent link to this sample: BenchmarkDotNet.Samples.IntroRankColumn Sample: IntroMultimodal Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [MValueColumn] [SimpleJob(RunStrategy.Throughput, 1, 0, -1, 1, \"MyJob\")] public class IntroMultimodal { private readonly Random rnd = new Random(42); private void Multimodal(int n) => Thread.Sleep((rnd.Next(n) + 1) * 100); [Benchmark] public void Unimodal() => Multimodal(1); [Benchmark] public void Bimodal() => Multimodal(2); [Benchmark] public void Trimodal() => Multimodal(3); [Benchmark] public void Quadrimodal() => Multimodal(4); } } Output Method | Mean | Error | StdDev | Median | MValue | ------------ |---------:|-----------:|------------:|---------:|-------:| Unimodal | 100.5 ms | 0.0713 ms | 0.0667 ms | 100.5 ms | 2.000 | Bimodal | 144.5 ms | 16.9165 ms | 49.8787 ms | 100.6 ms | 3.571 | Trimodal | 182.5 ms | 27.4285 ms | 80.8734 ms | 200.5 ms | 4.651 | Quadrimodal | 226.6 ms | 37.2269 ms | 109.7644 ms | 200.7 ms | 5.882 | // * Warnings * MultimodalDistribution IntroMultimodal.Bimodal: MainJob -> It seems that the distribution is bimodal (mValue = 3.57) IntroMultimodal.Trimodal: MainJob -> It seems that the distribution is multimodal (mValue = 4.65) IntroMultimodal.Quadrimodal: MainJob -> It seems that the distribution is multimodal (mValue = 5.88) Links Statistics The permanent link to this sample: BenchmarkDotNet.Samples.IntroMultimodal Sample: IntroOutliers Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; using Perfolizer.Mathematics.OutlierDetection; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] public class IntroOutliers { private class Config : ManualConfig { public Config() { var jobBase = Job.Default.WithWarmupCount(0).WithIterationCount(10).WithInvocationCount(1).WithUnrollFactor(1); AddJob(jobBase.WithOutlierMode(OutlierMode.DontRemove).WithId(\"DontRemoveOutliers\")); AddJob(jobBase.WithOutlierMode(OutlierMode.RemoveUpper).WithId(\"RemoveUpperOutliers\")); } } private int counter; [Benchmark] public void Foo() { counter++; int noise = counter % 10 == 0 ? 500 : 0; Thread.Sleep(100 + noise); } } } Output Method | Job | OutlierMode | Mean | Error | StdDev | ------- |-------------------- |------------ |---------:|------------:|------------:| Foo | DontRemoveOutliers | DontRemove | 150.5 ms | 239.1911 ms | 158.2101 ms | Foo | RemoveUpperOutliers | RemoveUpper | 100.5 ms | 0.1931 ms | 0.1149 ms | // * Hints * Outliers IntroOutliers.Foo: DontRemoveOutliers -> 1 outlier was detected IntroOutliers.Foo: RemoveUpperOutliers -> 1 outlier was removed Links Statistics The permanent link to this sample: BenchmarkDotNet.Samples.IntroOutliers"
  },
  "articles/features/vsprofiler.html": {
    "href": "articles/features/vsprofiler.html",
    "title": "Running with Visual Studio profiler | BenchmarkDotNet",
    "summary": "Running with Visual Studio profiler Visual Studio supports profiler integration with BenchmarkDotNet on Windows through its Microsoft.VisualStudio.BenchmarkDotNetDiagnosers NuGet package. Once installed, Visual Studio specific diagnosers will capture performance data in runs and automatically open traces if launched through Visual Studio How it works First, install the Microsoft.VisualStudio.BenchmarkDotNetDiagnosers NuGet package in your benchmarking project. Next add one or more of the Visual Studio diagnosers to your benchmark to capture the relevant profiling information while benchmarking. Lastly, run your benchmarks and a diagsession will be generated. If run from Visual Studio the diagsession will automatically be opened. Available Diagnosers [CPUUsageDiagnoser] - Enables the CPU Usage tool. [DatabaseDiagnoser] - Enables the Database tool [DotNetCountersDiagnoser] - Enables the .NET Counters tool [DotNetObjectAllocDiagnoser] - Enables the .NET Object Allocation tool. When using this tool, you must also specify [DotNetObjectAllocJobConfiguration] on the benchmark. If this is missing the run will fail and you will receive an error indicating you need to add it. [EventsDiagnoser] - Enables the Events tool [FileIODiagnoser] - Enables the File IO tool How to use it? After installing the Microsoft.VisualStudio.BenchmarkDotNetDiagnosers NuGet package add the following code as a benchmark: using System; using System.Security.Cryptography; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using Microsoft.VSDiagnostics; namespace MyBenchmarks { [CPUUsageDiagnoser] public class Md5VsSha256 { private const int N = 10000; private readonly byte[] data; private readonly SHA256 sha256 = SHA256.Create(); private readonly MD5 md5 = MD5.Create(); public Md5VsSha256() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark] public byte[] Sha256() => sha256.ComputeHash(data); [Benchmark] public byte[] Md5() => md5.ComputeHash(data); } public class Program { public static void Main(string[] args) { var summary = BenchmarkRunner.Run(typeof(Program).Assembly); } } } In this case we have added the [CpuUsageDiagnoser] to capture a CPU sampling trace. From here run the benchmark in Visual Studio (Ctrl+F5), and after the benchmark run the resulting diagsession will be displayed. Double clicking on one of the benchmark rows shown under the Benchmarks tab will filter the time selection to the specific benchmark allowing you to better isolate and investigate."
  },
  "articles/features/vstest.html": {
    "href": "articles/features/vstest.html",
    "title": "Running with VSTest | BenchmarkDotNet",
    "summary": "Running with VSTest BenchmarkDotNet supports discovering and executing benchmarks through VSTest. This provides an alternative user experience to running benchmarks with the CLI and may be preferable for those who like their IDE's VSTest integrations that they may have used when running unit tests. Below is an example of running some benchmarks from the BenchmarkDotNet samples project in Visual Studio's Test Explorer. About VSTest VSTest is one of the most popular test platforms in use in the .NET ecosystem, with test frameworks such as MSTest, xUnit, and NUnit providing support for it. Many IDEs, including Visual Studio and Rider, provide UIs for running tests through VSTest which some users may find more accessible than running them through the command line. It may seem counterintuitive to run performance tests on a platform that is designed for unit tests that expect a boolean outcome of \"Passed\" or \"Failed\". However, VSTest provides good value as a protocol for discovering and executing tests. In addition, we can still make use of this boolean output to indicate if the benchmark had validation errors that caused it to fail to run. Caveats and things to know The benchmark measurements may be affected by the VSTest host and your IDE! If you want to have accurate measurements, it is recommended to run benchmarks through the CLI without other processes on the machine impacting performance. This does not mean that the measurements are useless though, it will still be able to provide useful measurements during development when comparing different approaches. The test adapter will not display or execute benchmarks if optimizations are disabled. Please ensure you are compiling in Release mode or with Optimize set to true. Using an InProcess toolchain will let you run your benchmarks with optimizations disabled and will let you attach the debugger as well. The VSTest adapter will not call your application's entry point. If you use the entry point to customize how your benchmarks are run, you will need to do this through other means such as an assembly-level IConfigSource, as shown here. The test adapter will generate an entry point for you automatically. The generated entry point will pass the command line arguments and the current assembly into BenchmarkSwitcher, so you can still use it in your CLI as well as in VSTest. This means you can delete your entry point and only need to define your benchmarks. If you want to use a custom entry point, you can still do so by setting GenerateProgramFile to false in your project file. Getting started Step 1. Install the NuGet packages. You need to install two packages into your benchmark project: BenchmarkDotNet.TestAdapter: Implements the VSTest protocol for BenchmarkDotNet Microsoft.NET.Test.Sdk: Includes all the pieces needed for the VSTest host to run and load the VSTest adapter. Step 2. Make sure that the entry point is configured correctly. As mentioned in the caveats section, BenchmarkDotNet.TestAdapter will generate an entry point for you automatically. So, if you have an entry point already, you will either need to delete it or set GenerateProgramFile to false in your project file to continue using your existing one. Here is an example of a .csproj file based on the default Console Application template: <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <OutputType>Exe</OutputType> <TargetFramework>net8.0</TargetFramework> <ImplicitUsings>enable</ImplicitUsings> <Nullable>enable</Nullable> <!-- Disable entry point generation as this project has it's own entry point --> <GenerateProgramFile>false</GenerateProgramFile> </PropertyGroup> <ItemGroup> <PackageReference Include=\"BenchmarkDotNet.TestAdapter\" Version=\"0.13.12\" /> <PackageReference Include=\"Microsoft.NET.Test.Sdk\" Version=\"17.8.0\" /> </ItemGroup> </Project> Step 3. Make sure that your IDE supports VSTest integration. In Visual Studio, everything works out of the box. In Rider/R# 2023.3, the VSTest integration should be activated: Go to the \"Unit Testing\" settings page. Rider: Settings -> Build, Execution, Deployment -> Unit Testing -> VSTest R#: Extensions -> ReSharper -> Options -> Tools -> Unit Testing -> Test Frameworks -> VSTest Make sure that the \"Enable VSTest adapter support\" checkbox is checked. In future versions of Rider, this should be enabled by default. Step 4. Switch to the Release configuration. As mentioned above, the TestAdapter is not able to discover and run benchmarks with optimizations disabled (by design). Step 5. Build the project. In order to discover the benchmarks, the VSTest adapter needs to be able to find the assembly. Once you build the project, you should observe the discovered benchmarks in your IDE's Unit Test Explorer. If you correctly performed all the steps above, you should be able to run your benchmarks in your IDE using embedded unit testing features. If this doesn't work for you, don't hesitate to file a new GitHub issue. Setting a default configuration Previously, it was common for the default configuration to be defined inside the entry point. Since the entry point is not used when running benchmarks through VSTest, the default configuration must be specified using a Config attribute that is set on the assembly instead. First, create a class that extends ManualConfig or IConfig which sets the default configuration you want: class MyDefaultConfig : ManualConfig { public MyDefaultConfig() { AddJob(Job.Dry); AddLogger(Loggers.ConsoleLogger.Default); AddValidator(JitOptimizationsValidator.DontFailOnError); } } Then, set an assembly attribute with the following. [assembly: Config(typeof(MyDefaultConfig))] By convention, assembly attributes are usually defined inside AssemblyInfo.cs in a directory called Properties. Viewing the results The full output from BenchmarkDotNet that you would have been used to seeing in the past will be sent to the \"Tests\" output of your IDE. Use this view if you want to see the tabular view that compares multiple benchmarks with each other or if you want to see the results for each individual iteration. One more place where you can view the results is in each individual test's output messages. In Visual Studio, this can be viewed by clicking on the test in the Test Explorer after running it and looking at the Test Detail Summary. Since this only displays statistics for a single benchmark case, it does not show the tabulated view that compares multiple benchmark cases. Instead, it displays a histogram and various other useful statistics. Not all IDEs support displaying these output messages, so you may only be able to view the results using the \"Tests\" output."
  },
  "articles/guides/choosing-run-strategy.html": {
    "href": "articles/guides/choosing-run-strategy.html",
    "title": "Choosing RunStrategy | BenchmarkDotNet",
    "summary": "Choosing RunStrategy If you run a benchmark, you always (explicitly or implicitly) use a job. Each Job has the RunStrategy parameter which allows switching between different benchmark modes. The default RunStrategy is Throughput, and it works fine for most cases. However, other strategies are also useful in some specific cases. Throughput Throughput is the default RunStrategy, works perfectly for microbenchmarking. It's automatically choosing the amount of operation in main iterations based on a set of pilot iterations. The amount of iterations will also be chosen automatically based on accuracy job settings. A benchmark method should have a steady state. Of course, you can manually set all the characteristics. An example: [SimpleJob(launchCount: 3, warmupCount: 10, iterationCount: 30)] public class MyBenchmarkClass Sample: IntroColdStart If you want to measure cold start (without the pilot and warmup stage), the ColdStart strategy is your choice. Usage [SimpleJob(RunStrategy.ColdStart, launchCount:50)] public class MyBenchmarkClass Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.ColdStart, iterationCount: 5)] [MinColumn, MaxColumn, MeanColumn, MedianColumn] public class IntroColdStart { private bool firstCall; [Benchmark] public void Foo() { if (firstCall == false) { firstCall = true; Console.WriteLine(\"// First call\"); Thread.Sleep(1000); } else Thread.Sleep(10); } } } Output Result 1: 1 op, 1002034900.00 ns, 1.0020 s/op Result 2: 1 op, 10219700.00 ns, 10.2197 ms/op Result 3: 1 op, 10406200.00 ns, 10.4062 ms/op Result 4: 1 op, 10473900.00 ns, 10.4739 ms/op Result 5: 1 op, 10449400.00 ns, 10.4494 ms/op Method | Mean | Error | StdDev | Min | Max | Median | ------- |---------:|-----------:|---------:|---------:|-----------:|---------:| Foo | 208.7 ms | 1,707.4 ms | 443.5 ms | 10.22 ms | 1,002.0 ms | 10.45 ms | Links Choosing RunStrategy The permanent link to this sample: BenchmarkDotNet.Samples.IntroColdStart Sample: IntroMonitoring If a benchmark method takes at least 100ms, you can also use the Monitoring strategy. In this case, the pilot stage will be omitted, by default you get 1 iteration = 1 operation (or you can manually set amount of operation in an iteration). Also you can use [IterationSetup] and [IterationCleanup] in this case: it shouldn't affect time measurements (but it can affect results of MemoryDiagnoser). It's a perfect mode for benchmarks which doesn't have a steady state and the performance distribution is tricky: Monitoring will help you to collect a set of measurements and get statistics. Usage [SimpleJob(RunStrategy.Monitoring, launchCount: 10, warmupCount: 0, iterationCount: 100)] public class MyBenchmarkClass Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.Monitoring, iterationCount: 10, id: \"MonitoringJob\")] [MinColumn, Q1Column, Q3Column, MaxColumn] public class IntroMonitoring { private Random random = new Random(42); [Benchmark] public void Foo() { Thread.Sleep(random.Next(10) * 10); } } } Output Result 1: 1 op, 61552600.00 ns, 61.5526 ms/op Result 2: 1 op, 10141700.00 ns, 10.1417 ms/op Result 3: 1 op, 10482900.00 ns, 10.4829 ms/op Result 4: 1 op, 50410900.00 ns, 50.4109 ms/op Result 5: 1 op, 10421400.00 ns, 10.4214 ms/op Result 6: 1 op, 20556100.00 ns, 20.5561 ms/op Result 7: 1 op, 70473200.00 ns, 70.4732 ms/op Result 8: 1 op, 50581700.00 ns, 50.5817 ms/op Result 9: 1 op, 10559000.00 ns, 10.5590 ms/op Result 10: 1 op, 70496300.00 ns, 70.4963 ms/op Method Mean Error StdDev Min Q1 Q3 Max Foo 36.57 ms 40.03 ms 26.47 ms 10.14 ms 10.48 ms 61.55 ms 70.50 ms Links Choosing RunStrategy The permanent link to this sample: BenchmarkDotNet.Samples.IntroMonitoring"
  },
  "articles/guides/console-args.html": {
    "href": "articles/guides/console-args.html",
    "title": "How to use console arguments | BenchmarkDotNet",
    "summary": "How to use console arguments BenchmarkSwitcher supports various console arguments, to make it work you need to pass the args to switcher: class Program { static void Main(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args); } Note: the docs that you are currently reading might get outdated, to get the most up-to-date info about supported console arguments run the benchmarks with --help. Filter The --filter or just -f allows you to filter the benchmarks by their full name (namespace.typeName.methodName) using glob patterns. Examples: Run all benchmarks from System.Memory namespace: -f 'System.Memory*' Run all benchmarks: -f '*' Run all benchmarks from ClassA and ClassB -f '*ClassA*' '*ClassB*' Note: If you would like to join all the results into a single summary, you need to put --join. For example: -f '*ClassA*' '*ClassB*' --join List of benchmarks The --list allows you to print all of the available benchmark names. Available options are: flat - prints list of the available benchmarks: --list flat BenchmarkDotNet.Samples.Algo_Md5VsSha256.Md5 BenchmarkDotNet.Samples.Algo_Md5VsSha256.Sha256 BenchmarkDotNet.Samples.IntroArguments.Benchmark BenchmarkDotNet.Samples.IntroArgumentsSource.SingleArgument BenchmarkDotNet.Samples.IntroArgumentsSource.ManyArguments BenchmarkDotNet.Samples.IntroArrayParam.ArrayIndexOf BenchmarkDotNet.Samples.IntroArrayParam.ManualIndexOf BenchmarkDotNet.Samples.IntroBasic.Sleep [...] tree - prints tree of the available benchmarks: --list tree BenchmarkDotNet Samples Algo_Md5VsSha256  Md5  Sha256 IntroArguments  Benchmark IntroArgumentsSource  SingleArgument  ManyArguments IntroArrayParam  ArrayIndexOf  ManualIndexOf IntroBasic  Sleep [...] The --list option works with the --filter option. Examples: --list flat --filter *IntroSetupCleanup* prints: BenchmarkDotNet.Samples.IntroSetupCleanupGlobal.Logic BenchmarkDotNet.Samples.IntroSetupCleanupIteration.Benchmark BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkA BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkB BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkC BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkD --list tree --filter *IntroSetupCleanup* prints: BenchmarkDotNet Samples IntroSetupCleanupGlobal  Logic IntroSetupCleanupIteration  Benchmark IntroSetupCleanupTarget BenchmarkA BenchmarkB BenchmarkC BenchmarkD Categories You can also filter the benchmarks by categories: --anyCategories - runs all benchmarks that belong to any of the provided categories --allCategories- runs all benchmarks that belong to all provided categories Diagnosers -m, --memory - enables MemoryDiagnoser and prints memory statistics -t, --threading - enables ThreadingDiagnoser and prints threading statistics -d, --disasm- enables DisassemblyDiagnoser and exports diassembly of benchmarked code. When you enable this option, you can use: --disasmDepth - Sets the recursive depth for the disassembler. --disasmDiff - Generates diff reports for the disassembler. Runtimes The --runtimes or just -r allows you to run the benchmarks for selected Runtimes. Available options are: Clr - BDN will either use Roslyn (if you run it as .NET app) or latest installed .NET SDK to build the benchmarks (if you run it as .NET Core app). Core - if you run it as .NET Core app, BDN will use the same target framework moniker, if you run it as .NET app it's going to use net8.0. Mono - it's going to use the Mono from $Path, you can override it with --monoPath. net46, net461, net462, net47, net471, net472, net48, net481 - to build and run benchmarks against specific .NET Framework version. netcoreapp3.1, net5.0, net6.0, net7.0, net8.0 - to build and run benchmarks against specific .NET (Core) version. nativeaot5.0, nativeaot6.0, nativeaot7.0, nativeaot8.0 - to build and run benchmarks using NativeAOT. Can be customized with additional options: --ilcPackages, --ilCompilerVersion. mono6.0, mono7.0, mono8.0 - to build and run benchmarks with .Net 6+ using MonoVM. Example: run the benchmarks for .NET 4.7.2 and .NET 8.0: dotnet run -c Release -- --runtimes net472 net8.0 Example: run the benchmarks for .NET Core 3.1 and latest .NET SDK installed on your PC: dotnet run -c Release -f netcoreapp3.1 -- --runtimes clr core But same command executed with -f net6.0 is going to run the benchmarks for .NET 6.0: dotnet run -c Release -f net6.0 -- --runtimes clr core Number of invocations and iterations --launchCount - how many times we should launch process with target benchmark. The default is 1. --warmupCount - how many warmup iterations should be performed. If you set it, the minWarmupCount and maxWarmupCount are ignored. By default calculated by the heuristic. --minWarmupCount - minimum count of warmup iterations that should be performed. The default is 6. --maxWarmupCount - maximum count of warmup iterations that should be performed. The default is 50. --iterationTime - desired time of execution of an iteration. Used by Pilot stage to estimate the number of invocations per iteration. 500ms by default. --iterationCount - how many target iterations should be performed. By default calculated by the heuristic. --minIterationCount - minimum number of iterations to run. The default is 15. --maxIterationCount - maximum number of iterations to run. The default is 100. --invocationCount - invocation count in a single iteration. By default calculated by the heuristic. --unrollFactor - how many times the benchmark method will be invoked per one iteration of a generated loop. 16 by default --runOncePerIteration - run the benchmark exactly once per iteration. False by default. Example: run single warmup iteration, from 9 to 12 actual workload iterations. dotnet run -c Release -- --warmupCount 1 --minIterationCount 9 --maxIterationCount 12 Specifying custom default settings for console argument parser If you want to have a possibility to specify custom default Job settings programmatically and optionally overwrite it with console line arguments, then you should create a global config with single job marked as .AsDefault and pass it to BenchmarkSwitcher together with the console line arguments. Example: run single warmup iteration by default. static void Main(string[] args) => BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args, GetGlobalConfig()); static IConfig GetGlobalConfig() => DefaultConfig.Instance .With(Job.Default .WithWarmupCount(1) .AsDefault()); // the KEY to get it working Now, the default settings are: WarmupCount=1 but you might still overwrite it from console args like in the example below: dotnet run -c Release -- --warmupCount 2 Response files support Benchmark.NET supports parsing parameters via response files. for example you can create file run.rsp with following content --warmupCount 1 --minIterationCount 9 --maxIterationCount 12 and run it using dotnet run -c Release -- @run.rsp. It would be equivalent to running following command line dotnet run -c Release -- --warmupCount 1 --minIterationCount 9 --maxIterationCount 12 Statistical Test To perform a MannWhitney U Test and display the results in a dedicated column you need to provide the Threshold: --statisticalTest- Threshold for MannWhitney U Test. Examples: 5%, 10ms, 100ns, 1s Example: run MannWhitney U test with relative ratio of 5% for all benchmarks for .NET 6.0 (base) vs .NET 8.0 (diff). .NET 6.0 will be baseline because it was first. dotnet run -c Release -- --filter * --runtimes net6.0 net8.0 --statisticalTest 5% More -j, --job (Default: Default) Dry/Short/Medium/Long or Default. -e, --exporters GitHub/StackOverflow/RPlot/CSV/JSON/HTML/XML. -i, --inProcess (default: false) run benchmarks in the same process, without spawning child process per benchmark. -a, --artifacts valid path to an accessible directory where output artifacts will be stored. --outliers (default: RemoveUpper) DontRemove/RemoveUpper/RemoveLower/RemoveAll. --affinity affinity mask to set for the benchmark process. --allStats (default: false) Displays all statistics (min, max & more). --allCategories categories to run. If few are provided, only the benchmarks which belong to all of them are going to be executed. --attribute run all methods with given attribute (applied to class or method). --monoPath optional path to Mono which should be used for running benchmarks. --cli path to dotnet cli (optional). --packages the directory to restore packages to (optional). --coreRun path(s) to CoreRun (optional). --ilcPackages path to ILCompiler for NativeAOT. --info prints environment configuration including BenchmarkDotNet, OS, CPU and .NET version --stopOnFirstError stop on first error. --help display this help screen. --version display version information. --keepFiles (default: false) determines if all auto-generated files should be kept or removed after running the benchmarks. --noOverwrite (default: false) determines if the exported result files should not be overwritten. --disableLogFile disables the log file. --maxWidth max parameter column width, the default is 20. --envVars colon separated environment variables (key:value). --strategy the RunStrategy that should be used. Throughput/ColdStart/Monitoring. --platform the Platform that should be used. If not specified, the host process platform is used (default). AnyCpu/X86/X64/Arm/Arm64/LoongArch64. --runOncePerIteration run the benchmark exactly once per iteration. --buildTimeout build timeout in seconds. --wakeLock prevents the system from entering sleep or turning off the display. None/System/Display. --wasmEngine full path to a java script engine used to run the benchmarks, used by Wasm toolchain. --wasmMainJS path to the test-main.js file used by Wasm toolchain. Mandatory when using \"--runtimes wasm\" --expose_wasm arguments for the JavaScript engine used by Wasm toolchain. --customRuntimePack specify the path to a custom runtime pack. Only used for wasm currently."
  },
  "articles/guides/customizing-runtime.html": {
    "href": "articles/guides/customizing-runtime.html",
    "title": "Customizing Runtime | BenchmarkDotNet",
    "summary": "Customizing Runtime Currently, we have only information about customizing Mono in this section. If you want to customize .NET Core, read an article about Toolchains. Sample: IntroCustomMono BenchmarkDotNet allows you to compare different runtimes, including Mono. If you apply [MonoJob] attribute to your class we use your default mono runtime. If you want to compare different versions of Mono you need to provide use the custom paths. You can do this today by using the overloaded ctor of MonoJob attribute or by specifying the runtime in a fluent way. The mono runtime can also operate as an ahead-of-time compiler. Using mono's AOT mode requires providing the AOT compilation arguments, as well as the path to mono's corlib. (See IntroCustomMonoObjectStyleAot in the below example). Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { // *** Attribute Style *** [MonoJob(\"Mono x64\", @\"C:\\Program Files\\Mono\\bin\\mono.exe\")] [MonoJob(\"Mono x86\", @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\")] public class IntroCustomMono { [Benchmark] public void Foo() { // Benchmark body } } // *** Object Style *** [Config(typeof(Config))] public class IntroCustomMonoObjectStyle { private class Config : ManualConfig { public Config() { AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x64\", @\"C:\\Program Files\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x86\", @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\"))); } } [Benchmark] public void Foo() { // Benchmark body } } // ** Object Style, Using AOT ** [Config(typeof(Config))] public class IntroCustomMonoObjectStyleAot { private class Config : ManualConfig { public void AddMono (string name, string mono_top_dir) { var aot_compile_args = \"--aot=llvm\"; var mono_bcl = $@\"{mono_top_dir}\\lib\\mono\\4.5\"; var mono_bin = $@\"{mono_top_dir}\\bin\\mono.exe\"; AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( name, mono_bin, aot_compile_args, mono_bcl))); } public Config() { AddMono(\"Mono x64\", @\"C:\\Program Files\\Mono\"); AddMono(\"Mono x86\", @\"C:\\Program Files (x86)\\Mono\"); } } [Benchmark] public void Foo() { // Benchmark body } } // *** Fluent Config *** public class IntroCustomMonoFluentConfig { public static void Run() { BenchmarkRunner.Run<IntroCustomMonoFluentConfig>(ManualConfig .CreateMinimumViable() .AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x64\", @\"C:\\Program Files\\Mono\\bin\\mono.exe\"))) .AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x86\", @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\")))); } [Benchmark] public void Foo() { // Benchmark body } } } Links Customizing Runtime The permanent link to this sample: BenchmarkDotNet.Samples.IntroCustomMono Sample: IntroCustomMonoArguments Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [Config(typeof(ConfigWithCustomArguments))] public class IntroCustomMonoArguments { public class ConfigWithCustomArguments : ManualConfig { public ConfigWithCustomArguments() { // --optimize=MODE , -O=mode // MODE is a comma separated list of optimizations. They also allow // optimizations to be turned off by prefixing the optimization // name with a minus sign. AddJob(Job.Default .WithRuntime(MonoRuntime.Default) .WithArguments(new[] { new MonoArgument(\"--optimize=inline\") }) .WithId(\"Inlining enabled\")); AddJob(Job.Default .WithRuntime(MonoRuntime.Default) .WithArguments(new[] { new MonoArgument(\"--optimize=-inline\") }) .WithId(\"Inlining disabled\")); } } [Benchmark] public void Sample() { ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); } private void ShouldGetInlined() { } } } Output | Method | Job | Arguments | Mean | StdDev | |------- |------------------ |------------------- |-----------:|----------:| | Sample | Inlining disabled | --optimize=-inline | 19.4252 ns | 0.4525 ns | | Sample | Inlining enabled | --optimize=inline | 0.0000 ns | 0.0000 ns | Links Customizing Runtime The permanent link to this sample: BenchmarkDotNet.Samples.IntroCustomMonoArguments Sample: IntroEnvVars You can configure custom environment variables for the process that is running your benchmarks. One reason for doing this might be checking out how different compilation, threading, garbage collector settings affect the performance of .NET Core. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [Config(typeof(ConfigWithCustomEnvVars))] public class IntroEnvVars { private class ConfigWithCustomEnvVars : ManualConfig { public ConfigWithCustomEnvVars() { AddJob(Job.Default.WithRuntime(CoreRuntime.Core80).WithId(\"Inlining enabled\")); AddJob(Job.Default.WithRuntime(CoreRuntime.Core80) .WithEnvironmentVariables([ new EnvironmentVariable(\"DOTNET_JitNoInline\", \"1\"), new EnvironmentVariable(\"COMPlus_JitNoInline\", \"1\") ]) .WithId(\"Inlining disabled\")); } } [Benchmark] public void Foo() { // Benchmark body } } } Links Customizing Runtime Configs Jobs The permanent link to this sample: BenchmarkDotNet.Samples.IntroEnvVars Sample: IntroStaThread If the code you want to benchmark requires [System.STAThread] then you need to apply this attribute to the benchmarked method. BenchmarkDotNet will generate an executable with [STAThread] applied to its Main method. Using this feature on .NET Core requires .NET Core 2.1 or newer. Older versions will not work due to this bug. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroStaThread { [Benchmark, System.STAThread] public void CheckForSTA() { if (Thread.CurrentThread.GetApartmentState() != ApartmentState.STA) { throw new ThreadStateException( \"The current threads apartment state is not STA\"); } } } } Links Customizing Runtime The permanent link to this sample: BenchmarkDotNet.Samples.IntroStaThread"
  },
  "articles/guides/dotnet-new-templates.html": {
    "href": "articles/guides/dotnet-new-templates.html",
    "title": "BenchmarkDotNet templates | BenchmarkDotNet",
    "summary": "BenchmarkDotNet templates BenchmarkDotNet provides project templates to setup your benchmarks easily. The template exists for each major .NET language (C#, F# and VB) with equivalent features and structure. How to install the templates The templates requires the .NET Core SDK. Once installed, run the following command to install the templates: dotnet new install BenchmarkDotNet.Templates If you want to uninstall all BenchmarkDotNet templates: dotnet new uninstall BenchmarkDotNet.Templates The template is a nuget package distributed over nuget: BenchmarkDotNet.Templates. Basic usage To create a new C# benchmark library project from the template, run: dotnet new benchmark If you'd like to create F# or VB project, you can specify project language with -lang option: dotnet new benchmark -lang F# dotnet new benchmark -lang VB Project template specific options The template projects has five additional options - all of them are optional. By default a console app project targeting net6.0 is created. This lets you run the benchmarks from console (dotnet run) or from your favorite IDE. The option -f or --framework changes the target framework: dotnet new benchmark -f net472 You can specify --console-app=false to create a class library project targeting netstandard2.0 by default: dotnet new benchmark --console-app=false The option -b or --benchmarkName sets the name of the benchmark class: dotnet new benchmark -b Md5VsSha256 BenchmarkDotNet lets you create a dedicated configuration class (see Configs) to customize the execution of your benchmarks. To create a benchmark project with a configuration class, use the option -c or --config: dotnet new benchmark -c The option --no-restore if specified, skips the automatic nuget restore after the project is created: dotnet new benchmark --no-restore Use the -h or --help option to display all possible arguments with a description and the default values: dotnet new benchmark --help How to run the benchmarks Please read how to run your benchmarks. The relationship of BenchmarkDotNet and BenchmarkDotNet.Templates The version of the template nuget package is synced with the BenchmarkDotNet package. For instance, the template version 0.11.5 is referencing BenchmarkDotnet 0.11.15 - there is no floating version behavior. Note: This will maybe change when BenchmarkDotNet reaches 1.x. References For more info about the dotnet new CLI, please read the documentation."
  },
  "articles/guides/getting-started.html": {
    "href": "articles/guides/getting-started.html",
    "title": "Getting started | BenchmarkDotNet",
    "summary": "Getting started To get started with BenchmarkDotNet, please follow these steps. Step 1. Create a project Create a new console application. Step 2. Installation Install BenchmarkDotNet via the NuGet package: BenchmarkDotNet > dotnet add package BenchmarkDotNet Read more about BenchmarkDotNet NuGet packages: Installing NuGet packages Step 3. Design a benchmark Write a class with methods that you want to measure and mark them with the Benchmark attribute. In the following example, we compare MD5 and SHA256 cryptographic hash functions: using System; using System.Security.Cryptography; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; namespace MyBenchmarks { public class Md5VsSha256 { private const int N = 10000; private readonly byte[] data; private readonly SHA256 sha256 = SHA256.Create(); private readonly MD5 md5 = MD5.Create(); public Md5VsSha256() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark] public byte[] Sha256() => sha256.ComputeHash(data); [Benchmark] public byte[] Md5() => md5.ComputeHash(data); } public class Program { public static void Main(string[] args) { var summary = BenchmarkRunner.Run<Md5VsSha256>(); } } } The BenchmarkRunner.Run<Md5VsSha256>() call runs your benchmarks and prints results to the console. Step 4. Run benchmarks Start your console application to run the benchmarks. The application must be built in the Release configuration. > dotnet run -c Release Step 5. View results View the results. Here is an example of output from the above benchmark: BenchmarkDotNet=v0.13.2, OS=Windows 10 (10.0.19045.2251) Intel Core i7-4770HQ CPU 2.20GHz (Haswell), 1 CPU, 8 logical and 4 physical cores .NET SDK=7.0.100 [Host] : .NET 7.0.0 (7.0.22.51805), X64 RyuJIT AVX2 DefaultJob : .NET 7.0.0 (7.0.22.51805), X64 RyuJIT AVX2 | Method | Mean | Error | StdDev | |------- |---------:|---------:|---------:| | Sha256 | 51.57 us | 0.311 us | 0.291 us | | Md5 | 21.91 us | 0.138 us | 0.129 us | Step 6. Analyze results BenchmarkDotNet will automatically create basic reports in the .\\BenchmarkDotNet.Artifacts\\results folder that can be shared and analyzed. To help analyze performance in further depth, you can configure your benchmark to collect and output more detailed information. Benchmark configuration can be conveniently changed by adding attributes to the class containing your benchmarks. For example: Diagnosers GC allocations: [MemoryDiagnoser] Code size and disassembly: [DisassemblyDiagnoser] Threading statistics: [ThreadingDiagnoser] Exporters CSV reports with raw data: [CsvMeasurementsExporter] JSON reports with raw data: [JsonExporter] Plots (if you have installed R): [RPlotExporter] For more information, see Configs. Next steps BenchmarkDotNet provides features which aid high-quality performance research. If you want to know more about BenchmarkDotNet features, check out the Overview page. If you have any questions, check out the FAQ page. If you didn't find an answer for your question on this page, ask it on Gitter or create an issue on GitHub."
  },
  "articles/guides/good-practices.html": {
    "href": "articles/guides/good-practices.html",
    "title": "Good Practices | BenchmarkDotNet",
    "summary": "Good Practices Use the Release build without an attached debugger Never use the Debug build for benchmarking. Never. The debug version of the target method can run 10100 times slower. The release mode means that you should have <Optimize>true</Optimize> in your csproj file or use /optimize for csc. Also, never use an attached debugger (e.g. Visual Studio or WinDbg) during the benchmarking. The best way is build our benchmark in the Release mode and run it from the command line. Try different environments Please, don't extrapolate your results. Or do it very carefully. I remind you again: the results in different environments may vary significantly. If a Foo1 method is faster than a Foo2 method for CLR4, .NET Framework 4.5, x64, RyuJIT, Windows, it means that the Foo1 method is faster than the Foo2 method for CLR4, .NET Framework 4.5, x64, RyuJIT, Windows and nothing else. And you can not say anything about methods performance for CLR 2 or .NET Framework 4.6 or LegacyJIT-x64 or x86 or Linux+Mono until you try it. Avoid dead code elimination You should also use the result of calculation. For example, if you run the following code: void Foo() { Math.Exp(1); } then JIT can eliminate this code because the result of Math.Exp is not used. The better way is use it like this: double Foo() { return Math.Exp(1); } Power settings and other applications Turn off all of the applications except the benchmark process and the standard OS processes. If you run benchmark and work in the Visual Studio at the same time, it can negatively affect to benchmark results. If you use laptop for benchmarking, keep it plugged in and use the maximum performance mode."
  },
  "articles/guides/how-it-works.html": {
    "href": "articles/guides/how-it-works.html",
    "title": "How it works | BenchmarkDotNet",
    "summary": "How it works BenchmarkDotNet follows the following steps to run your benchmarks: BenchmarkRunner generates an isolated project per each runtime settings and builds it in Release mode. Next, we take each method/job/params combination and try to measure its performance by launching benchmark process several times (LaunchCount). An invocation of the workload method is an operation. A bunch of operation is an iteration. If you have an IterationSetup method, it will be invoked before each iteration, but not between operations. We have the following type of iterations: Pilot: The best operation count will be chosen. OverheadWarmup, OverheadWorkload: BenchmarkDotNet overhead will be evaluated. ActualWarmup: Warmup of the workload method. ActualWorkload: Actual measurements. Result = ActualWorkload - <MedianOverhead> After all of the measurements, BenchmarkDotNet creates: An instance of the Summary class that contains all information about benchmark runs. A set of files that contains summary in human-readable and machine-readable formats. A set of plots. Pseudocode If you don't understand our \"count terminology\", then you might find following pseudocode useful: IEnumerable<Results> Run(Benchmark benchmark) { var toolchain = benchmark.GetToolchain(); var autoGeneratedProject = toolchain.Generate(benchmark); var exe = toolchain.Build(autoGeneratedProject); foreach (var runIndex in LaunchCount) // LaunchCount = 1 by default yield return ParseResults(Process.Start(exe).Output); // calls ActualRun in a separate process } Result ActualRun(Method method, Job job) { GlobalSetup(); int unrollFactor = job.Run.UnrollFactor; // 16 by default long perfectInvocationCount = Pilot(method, unrollFactor); WarmupStage(EMPTY_METHOD, perfectInvocationCount, unrollFactor); // EMPTY_METHOD has same return type and arguments as benchmark var overhead = ActualStage(EMPTY_METHOD, perfectInvocationCount, unrollFactor); WarmupStage(method, perfectInvocationCount, unrollFactor); var result = ActualStage(method, perfectInvocationCount); if (MemoryDiagnoser.IsEnabled) var gcStats = MeasureGcStats(method, perfectInvocationCount, unrollFactor); GlobalCleanup(); return (result - Median(overhead), gcStats); } long Pilot(Method method, int unrollFactor) { // invokeCount is the equivalent of InnerIterationCount from xunit-performance long invokeCount = minInvokeCount; while (true) { var measurement = RunIteration(method, invokeCount, unrollFactor); if (heuristic.IsPilotRequirementMet(measurement)) break; invokeCount *= 2; } return invokeCount; } void Warmup(Method method, long invokeCount, int unrollFactor) { while (true) { var measurement = RunIteration(method, invokeCount, unrollFactor); if (heuristic.IsWarmupRequirementMet(measurement)) break; } } IEnuberable<Measurement> Workload(Method method, long invokeCount, int unrollFactor) { while (true) { var measurement = RunIteration(method, invokeCount, unrollFactor); if (measurement.IsNotOutlier) yield return measurement; if (heuristic.IsWorkloadRequirementMet(measurement)) yield break; } } // every iteration invokes the method (invokeCount / unrollFactor) times Measurement RunIteration(Method method, long invokeCount, long unrollFactor) { IterationSetup(); MemoryCleanup(); var clock = Clock.Start(); for (long i = 0; i < invokeCount / unrollFactor; i++) { // we perform manual loop unrolling!! method(); // 1st call method(); // 2nd call method(); // (unrollFactor - 1)'th call method(); // unrollFactor'th call } var clockSpan = clock.GetElapsed(); IterationCleanup(); MemoryCleanup(); return Measurement(clockSpan); } GcStats MeasureGcStats(Method method, long invokeCount, long unrollFacto) { // we enable monitoring after workload actual run, for this single iteration which is executed at the end // so even if we enable AppDomain monitoring in separate process // it does not matter, because we have already obtained the results! EnableMonitoring(); IterationSetup(); var initialGcStats = GcStats.ReadInitial(); // we do NOT start any clock here, because the enabled monitoring might have some overhead // so we just get the gc stats and ignore the timing // it's last thing the process does before it dies, so also enabled monitoring is not an issue for next benchmarks // because each of them is going to be executed in a new process for (long i = 0; i < invokeCount / unrollFactor; i++) { // we perform manual loop unrolling!! method(); // 1st call method(); // 2nd call method(); // (unrollFactor - 1)'th call method(); // unrollFactor'th call } var finalGcStats = GcStats.ReadFinal(); IterationCleanup(); return finalGcStats - initialGcStats; // the result is the difference between the stats collected after and before running the extra iteration }"
  },
  "articles/guides/how-to-run.html": {
    "href": "articles/guides/how-to-run.html",
    "title": "How to run your benchmarks | BenchmarkDotNet",
    "summary": "How to run your benchmarks There are several ways to run your benchmarks. What is important is that BenchmarkDotNet works only with Console Apps. It does not support any other kind of application like ASP.NET, Azure WebJobs, etc. Types If you have just a few types with benchmarks, you can use BenchmarkRunner: var summary = BenchmarkRunner.Run<MyBenchmarkClass>(); var summary = BenchmarkRunner.Run(typeof(MyBenchmarkClass)); The disadvantage of BenchmarkRunner is that it always runs all benchmarks in a given type (or assembly) and to change the type you need to modify the source code. But it's great for a quick start. BenchmarkSwitcher If you have more types and you want to choose which benchmark to run (either by using console line arguments or console input) you should use BenchmarkSwitcher: static void Main(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args); Also you can use the config command style to specify some config from command line (more How to use console arguments): dotnet run -c Release -- --job short --runtimes net472 net7.0 --filter *BenchmarkClass1* The most important thing about BenchmarkSwitcher is that you need to pass the args from Main to the Run method. If you don't, it won't parse the arguments."
  },
  "articles/guides/nuget.html": {
    "href": "articles/guides/nuget.html",
    "title": "Installing NuGet packages | BenchmarkDotNet",
    "summary": "Installing NuGet packages Packages We have the following set of NuGet packages (you can install it directly from nuget.org): BenchmarkDotNet: BenchmarkDotNet infrastructure and logic. This is all you need to run benchmarks. BenchmarkDotNet.Annotations: Basic BenchmarkDotNet annotations for your benchmarks. BenchmarkDotNet.Diagnostics.Windows: an additional optional package that provides a set of Windows diagnosers. BenchmarkDotNet.Diagnostics.dotTrace: an additional optional package that provides DotTraceDiagnoser. BenchmarkDotNet.Diagnostics.dotMemory: an additional optional package that provides DotMemoryDiagnoser. BenchmarkDotNet.Templates: Templates for BenchmarkDotNet. You might find other NuGet packages that start with BenchmarkDotNet name, but they are internal BDN packages that should not be installed manually. All that matters are the three packages mentioned above. Versioning system and feeds We have 3 kinds of versions: stable, nightly, and develop. You can get the current version from the source code via BenchmarkDotNetInfo.FullVersion and the full title via BenchmarkDotNetInfo.FullTitle. Stable These versions are available from the official NuGet feed. <packageSources> <add key=\"api.nuget.org\" value=\"https://api.nuget.org/v3/index.json\" protocolVersion=\"3\" /> </packageSources> Nightly If you want to use a nightly version of the BenchmarkDotNet, add the https://www.myget.org/F/benchmarkdotnet/api/v3/index.json feed in the <packageSources> section of your NuGet.config: <packageSources> <add key=\"bdn-nightly\" value=\"https://www.myget.org/F/benchmarkdotnet/api/v3/index.json\" /> </packageSources> Now you can install the packages from the bdn-nightly feed. Develop You also can build BenchmarkDotNet from source code: build.cmd pack"
  },
  "articles/guides/troubleshooting.html": {
    "href": "articles/guides/troubleshooting.html",
    "title": "Troubleshooting | BenchmarkDotNet",
    "summary": "Troubleshooting BenchmarkDotNet You need to be aware of the fact that to ensure process-level isolation BenchmarkDotNet generates, builds and executes every benchmark in a dedicated process. For .NET and Mono we generate a C# file and compile it using Roslyn. For .NET Core and NativeAOT we generate not only C# file but also a project file which later is restored and build with dotnet cli. If your project has some non-trivial build settings like a .props and .target files or native dependencies things might not work well out of the box. How do you know that BenchmarkDotNet has failed to build the project? BDN is going to tell you about it. An example: // Validating benchmarks: // ***** BenchmarkRunner: Start ***** // ***** Found 1 benchmark(s) in total ***** // ***** Building 1 exe(s) in Parallel: Start ***** // start dotnet restore /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in C:\\Projects\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\bin\\Release\\netcoreapp2.1\\c6045772-d3c7-4dbe-ab37-4aca6dcb6ec4 // command took 0.51s and exited with 1 // ***** Done, took 00:00:00 (0.66 sec) ***** // Found 1 benchmarks: // IntroBasic.Sleep: DefaultJob // Build Error: Standard output: Standard error: C:\\Projects\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\bin\\Release\\netcoreapp2.1\\c6045772-d3c7-4dbe-ab37-4aca6dcb6ec4\\BenchmarkDotNet.Autogenerated.csproj(36,1): error MSB4025: The project file could not be loaded. Unexpected end of file while parsing Comment has occurred. Line 36, position 1. // BenchmarkDotNet has failed to build the auto-generated boilerplate code. // It can be found in C:\\Projects\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\bin\\Release\\netcoreapp2.1\\c6045772-d3c7-4dbe-ab37-4aca6dcb6ec4 // Please follow the troubleshooting guide: https://benchmarkdotnet.org/articles/guides/troubleshooting.html If the error message is not clear enough, you need to investigate it further. How to troubleshoot the build process: Run the benchmarks with --logBuildOutput command line argument. Read the error message. If it does not contain the answer to your problem, please continue to the next step. Go to the build artifacts folder (path printed by BDN). The folder should contain: a file with source code (ends with .notcs to make sure IDE don't include it in other projects by default) a project file (.csproj) a script file (.bat on Windows, .sh for other OSes) which should be doing exactly the same thing as BDN does: dotnet restore dotnet build (with some parameters like -c Release) Run the script, read the error message. From here you continue with the troubleshooting like it was a project in your solution. The recommended order of solving build issues: Change the right settings in your project file which defines benchmarks to get it working. Customize the Job settings using available options like job.WithCustomBuildConfiguration($name)or job.With(new Argument[] { new MsBuildArgument(\"/p:SomeProperty=Value\")}). Implement your own IToolchain and generate and build all the right things in your way (you can use existing Builders and Generators and just override some methods to change specific behaviour). Report a bug in BenchmarkDotNet repository. Debugging Benchmarks In the same process If your benchmark builds but fails to run, you can simply debug it. The first thing you should try is to do it in a single process (host process === runner process). Use DebugInProcessConfig static void Main(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args, new DebugInProcessConfig()); Set the breakpoints in your favorite IDE Start debugging the project with benchmarks In a different process Sometimes you won't be able to reproduce the problem in the same process. In this case, you have 3 options: Launch a debugger from the benchmark process using Debugger API [GlobalSetup] public void Setup() { System.Diagnostics.Debugger.Launch(); } Attach a debugger from IDE Modify your benchmark to sleep until the Debugger is not attached and use your favorite IDE to attach the debugger to benchmark process. Do attach to the process which is running the benchmark (the arguments of the process are going to be --benchmarkId $someNumber --benchmarkName $theName), not the host process. [GlobalSetup] public void Setup() { while(!System.Diagnostics.Debugger.IsAttached) Thread.Sleep(TimeSpan.FromMilliseconds(100)); } One of the above, but with a Debug build By default, BDN builds everything in Release. But debugging Release builds even with full symbols might be non-trivial. To enforce BDN to build the benchmark in Debug please use DebugBuildConfig and then attach the debugger."
  },
  "articles/license.html": {
    "href": "articles/license.html",
    "title": "| BenchmarkDotNet",
    "summary": "The MIT License Copyright (c) 20132025 .NET Foundation and contributors Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "articles/overview.html": {
    "href": "articles/overview.html",
    "title": "Overview | BenchmarkDotNet",
    "summary": "Overview Install Create new console application and install the BenchmarkDotNet NuGet package. We support: Projects: classic and modern with PackageReferences Runtimes: Full .NET Framework (4.6+), .NET Core (2.0+), Mono, NativeAOT OS: Windows, Linux, MacOS Languages: C#, F#, VB Design a benchmark Create a new console application, write a class with methods that you want to measure, and mark them with the Benchmark attribute. In the following example, we compare the MD5 and SHA256 cryptographic hash functions: using System; using System.Security.Cryptography; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; namespace MyBenchmarks { public class Md5VsSha256 { private const int N = 10000; private readonly byte[] data; private readonly SHA256 sha256 = SHA256.Create(); private readonly MD5 md5 = MD5.Create(); public Md5VsSha256() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark] public byte[] Sha256() => sha256.ComputeHash(data); [Benchmark] public byte[] Md5() => md5.ComputeHash(data); } public class Program { public static void Main(string[] args) { var summary = BenchmarkRunner.Run(typeof(Program).Assembly); } } } The BenchmarkRunner.Run<Md5VsSha256>() call runs your benchmarks and prints results to the console. Note that BenchmarkDotNet will only run benchmarks if the application is built in the Release configuration. This is to prevent unoptimized code from being benchmarked. BenchmarkDotNet will issue an error if you forget to change the configuration. Benchmark results BenchmarkDotNet=v0.13.2, OS=Windows 10 (10.0.19045.2251) Intel Core i7-4770HQ CPU 2.20GHz (Haswell), 1 CPU, 8 logical and 4 physical cores .NET SDK=7.0.100 [Host] : .NET 7.0.0 (7.0.22.51805), X64 RyuJIT AVX2 DefaultJob : .NET 7.0.0 (7.0.22.51805), X64 RyuJIT AVX2 | Method | Mean | Error | StdDev | |------- |---------:|---------:|---------:| | Sha256 | 51.57 us | 0.311 us | 0.291 us | | Md5 | 21.91 us | 0.138 us | 0.129 us | Jobs BenchmarkDotNet can benchmark your code in several environments at once. For example, to compare your benchmark's performance in .NET Framework, .NET Core, Mono and NativeAOT, you can add SimpleJob attributes to the benchmark class: [SimpleJob(RuntimeMoniker.Net481)] [SimpleJob(RuntimeMoniker.Net70)] [SimpleJob(RuntimeMoniker.NativeAot70)] [SimpleJob(RuntimeMoniker.Mono)] public class Md5VsSha256 Example of the result: BenchmarkDotNet=v0.13.2, OS=Windows 10 (10.0.19045.2251) Intel Core i7-4770HQ CPU 2.20GHz (Haswell), 1 CPU, 8 logical and 4 physical cores .NET SDK=7.0.100 [Host] : .NET 7.0.0 (7.0.22.51805), X64 RyuJIT AVX2 .NET 7.0 : .NET 7.0.0 (7.0.22.51805), X64 RyuJIT AVX2 .NET Framework 4.8.1 : .NET Framework 4.8.1 (4.8.9037.0), X64 RyuJIT VectorSize=256 Mono : Mono 6.12.0 (Visual Studio), X64 VectorSize=128 NativeAOT 7.0 : .NET 7.0.0 (7.0.22.51805), X64 RyuJIT AVX2 | Method | Job | Runtime | Mean | Error | StdDev | |------- |--------------------- |--------------------- |----------:|---------:|---------:| | Sha256 | .NET 7.0 | .NET 7.0 | 51.90 us | 0.341 us | 0.302 us | | Md5 | .NET 7.0 | .NET 7.0 | 21.96 us | 0.052 us | 0.049 us | | Sha256 | .NET Framework 4.8.1 | .NET Framework 4.8.1 | 206.33 us | 2.069 us | 1.834 us | | Md5 | .NET Framework 4.8.1 | .NET Framework 4.8.1 | 23.28 us | 0.094 us | 0.083 us | | Sha256 | Mono | Mono | 167.70 us | 1.216 us | 1.137 us | | Md5 | Mono | Mono | 42.12 us | 0.145 us | 0.136 us | | Sha256 | NativeAOT 7.0 | NativeAOT 7.0 | 51.45 us | 0.226 us | 0.200 us | | Md5 | NativeAOT 7.0 | NativeAOT 7.0 | 21.88 us | 0.050 us | 0.041 us | There are many predefined job attributes which you can use. For example, you can compare LegacyJitX86, LegacyJitX64, and RyuJitX64: [LegacyJitX86Job, LegacyJitX64Job, RyuJitX64Job] Or, you can define your own jobs: [Config(typeof(Config))] public class Md5VsSha256 { private class Config : ManualConfig { public Config() { AddJob(new Job(Job.Dry) { Environment = { Jit = Jit.LegacyJit, Platform = Platform.X64 }, Run = { LaunchCount = 3, WarmupCount = 5, IterationCount = 10 }, Accuracy = { MaxRelativeError = 0.01 } }); } } Read more: Jobs, Configs Columns You can add columns to the summary table: [MinColumn, MaxColumn] public class Md5VsSha256 Method Median StdDev Min Max Sha256 131.3200 us 4.6744 us 129.8216 us 147.7630 us Md5 26.2847 us 0.4424 us 25.8442 us 27.4258 us You can also define custom columns based on the full benchmark summary. Read more: Columns Exporters You can export the results of your benchmark in different formats: [MarkdownExporter, AsciiDocExporter, HtmlExporter, CsvExporter, RPlotExporter] public class Md5VsSha256 If you have installed R, RPlotExporter will generate a lot of nice plots: Read more: Exporters Baseline To view the relative performance of your benchmarks, mark one of your benchmark methods as the Baseline: public class Sleeps { [Benchmark] public void Time50() => Thread.Sleep(50); [Benchmark(Baseline = true)] public void Time100() => Thread.Sleep(100); [Benchmark] public void Time150() => Thread.Sleep(150); } A new column will be added to the summary table: Method Median StdDev Ratio Time100 100.2640 ms 0.1238 ms 1.00 Time150 150.2093 ms 0.1034 ms 1.50 Time50 50.2509 ms 0.1153 ms 0.50 Read more: Baselines Params You can mark one or several fields or properties in your class with the Params attribute. In this attribute, you can specify a set of values. BenchmarkDotNet will run benchmarks for each combination of params values. public class IntroParams { [Params(100, 200)] public int A { get; set; } [Params(10, 20)] public int B { get; set; } [Benchmark] public void Benchmark() { Thread.Sleep(A + B + 5); } } Method Median StdDev A B Benchmark 115.3325 ms 0.0242 ms 100 10 Benchmark 125.3282 ms 0.0245 ms 100 20 Benchmark 215.3024 ms 0.0375 ms 200 10 Benchmark 225.2710 ms 0.0434 ms 200 20 Read more: Parameterization Languages You can also write benchmarks in F# or VB. type StringKeyComparison () = let mutable arr : string [] = [||] let dict1 = ConcurrentDictionary<_,_>() let dict2 = ConcurrentDictionary<_,_>(StringComparer.Ordinal) [<Params (100, 500, 1000, 2000)>] member val public DictSize = 0 with get, set [<GlobalSetup>] member self.GlobalSetupData() = dict1.Clear(); dict2.Clear() arr <- getStrings self.DictSize arr |> Array.iter (fun x -> dict1.[x] <- true ; dict2.[x] <- true) [<Benchmark>] member self.StandardLookup () = lookup arr dict1 [<Benchmark>] member self.OrdinalLookup () = lookup arr dict2 Public Class Sample <Params(1, 2)> Public Property A As Integer <Params(3, 4)> Public Property B As Integer <Benchmark> Public Function Benchmark() As Integer return A + B End Function End Class Diagnostics A diagnoser can attach to your benchmarks and collect additional information. Examples of diagnosers built in to BenchmarkDotNet are: Garbge collection and allocation statistics (MemoryDiagnoser). Lock contention and thread pool statistics (ThreadingDiagnoser), which is only available on .NET Core 3.0+. JIT inlining events (InliningDiagnoser). You can find this diagnoser in a separated package with diagnosers for Windows (BenchmarkDotNet.Diagnostics.Windows): Below is a sample benchmark using MemoryDiagnoser. Note the extra columns on the right-hand side (Gen 0 and Allocated): Method | Mean | StdDev | Gen 0 | Allocated | ---------- |----------- |---------- |------- |---------- | Iterative | 31.0739 ns | 0.1091 ns | - | 0 B | LINQ | 83.0435 ns | 1.0103 ns | 0.0069 | 32 B | Read more: Diagnosers BenchmarkRunner There are several ways to run your benchmarks. var summary = BenchmarkRunner.Run<MyBenchmarkClass>(); var summary = BenchmarkRunner.Run(typeof(MyBenchmarkClass)); var summaries = BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args); Read more: How to run your benchmarks"
  },
  "articles/samples/IntroArguments.html": {
    "href": "articles/samples/IntroArguments.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroArguments As an alternative to using [Params], you can specify arguments for your benchmarks. There are several ways to do it (described below). The [Arguments] allows you to provide a set of values. Every value must be a compile-time constant (it's C# language limitation for attributes in general). You can also combine [Arguments] with [Params]. As a result, you will get results for each combination of params values. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArguments { [Params(true, false)] // Arguments can be combined with Params public bool AddExtra5Milliseconds; [Benchmark] [Arguments(100, 10)] [Arguments(100, 20)] [Arguments(200, 10)] [Arguments(200, 20)] public void Benchmark(int a, int b) { if (AddExtra5Milliseconds) Thread.Sleep(a + b + 5); else Thread.Sleep(a + b); } } } Output | Method | AddExtra5Miliseconds | a | b | Mean | Error | StdDev | |---------- |--------------------- |---- |--- |---------:|----------:|----------:| | Benchmark | False | 100 | 10 | 110.1 ms | 0.0056 ms | 0.0044 ms | | Benchmark | False | 100 | 20 | 120.1 ms | 0.0155 ms | 0.0138 ms | | Benchmark | False | 200 | 10 | 210.2 ms | 0.0187 ms | 0.0175 ms | | Benchmark | False | 200 | 20 | 220.3 ms | 0.1055 ms | 0.0986 ms | | Benchmark | True | 100 | 10 | 115.3 ms | 0.1375 ms | 0.1286 ms | | Benchmark | True | 100 | 20 | 125.3 ms | 0.1212 ms | 0.1134 ms | | Benchmark | True | 200 | 10 | 215.4 ms | 0.0779 ms | 0.0691 ms | | Benchmark | True | 200 | 20 | 225.4 ms | 0.0775 ms | 0.0725 ms | Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroArguments"
  },
  "articles/samples/IntroArgumentsPriority.html": {
    "href": "articles/samples/IntroArgumentsPriority.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroArgumentsPriority Like Params also Argument columns can be sorted in the table result through their Priority. The priority should be defined only once for multiple Arguments and will keep their inner order as they are defined in the method. Source code using System.Collections.Generic; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArgumentsPriority { [Params(100, Priority = 0)] // Argument priority can be combined with Params priority public int A { get; set; } [Arguments(5, Priority = -10)] // Define priority just once for multiple argument attributes [Arguments(10)] [Arguments(20)] [Benchmark] public void Benchmark(int b) => Thread.Sleep(A + b); [Benchmark] [ArgumentsSource(nameof(Numbers), Priority = 10)] public void ManyArguments(int c, int d) => Thread.Sleep(A + c + d); public IEnumerable<object[]> Numbers() { yield return new object[] { 1, 2 }; } } } Output | Method | b | A | c | d | Mean | Error | StdDev | |-------------- |--- |---- |-- |-- |---------:|--------:|--------:| | ManyArguments | ? | 100 | 1 | 2 | 103.4 ms | 0.09 ms | 0.08 ms | | Benchmark | 5 | 100 | ? | ? | 105.5 ms | 0.21 ms | 0.19 ms | | Benchmark | 10 | 100 | ? | ? | 110.5 ms | 0.14 ms | 0.14 ms | | Benchmark | 20 | 100 | ? | ? | 120.4 ms | 0.16 ms | 0.15 ms | Links Priority BaseClass PriorityAttribute.cs Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroArgumentsPriority"
  },
  "articles/samples/IntroArgumentsSource.html": {
    "href": "articles/samples/IntroArgumentsSource.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroArgumentsSource In case you want to use a lot of values, you should use [ArgumentsSource]. You can mark one or several fields or properties in your class by the [ArgumentsSource] attribute. In this attribute, you have to specify the name of public method/property which is going to provide the values (something that implements IEnumerable). The source may be instance or static. If the source is not in the same type as the benchmark, the type containing the source must be specified in the attribute constructor. Source code using System; using System.Collections.Generic; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArgumentsSource { [Benchmark] [ArgumentsSource(nameof(Numbers))] public double ManyArguments(double x, double y) => Math.Pow(x, y); public IEnumerable<object[]> Numbers() // for multiple arguments it's an IEnumerable of array of objects (object[]) { yield return new object[] { 1.0, 1.0 }; yield return new object[] { 2.0, 2.0 }; yield return new object[] { 4.0, 4.0 }; yield return new object[] { 10.0, 10.0 }; } [Benchmark] [ArgumentsSource(typeof(BenchmarkArguments), nameof(BenchmarkArguments.TimeSpans))] // when the arguments come from a different type, specify that type here public void SingleArgument(TimeSpan time) => Thread.Sleep(time); } public static class BenchmarkArguments { public static IEnumerable<object> TimeSpans() // for single argument it's an IEnumerable of objects (object) { yield return TimeSpan.FromMilliseconds(10); yield return TimeSpan.FromMilliseconds(100); } } } Output | Method | x | y | Mean | Error | StdDev | |------- |--- |--- |----------:|----------:|----------:| | Pow | 1 | 1 | 9.360 ns | 0.0190 ns | 0.0149 ns | | Pow | 2 | 2 | 40.624 ns | 0.3413 ns | 0.3192 ns | | Pow | 4 | 4 | 40.537 ns | 0.0560 ns | 0.0524 ns | | Pow | 10 | 10 | 40.395 ns | 0.3274 ns | 0.3063 ns | Another example If the values are complex types you need to override ToString method to change the display names used in the results. [DryJob] public class WithNonPrimitiveArgumentsSource { [Benchmark] [ArgumentsSource(nameof(NonPrimitive))] public void Simple(SomeClass someClass, SomeStruct someStruct) { for (int i = 0; i < someStruct.RangeEnd; i++) Console.WriteLine($\"// array.Values[{i}] = {someClass.Values[i]}\"); } public IEnumerable<object[]> NonPrimitive() { yield return new object[] { new SomeClass(Enumerable.Range(0, 10).ToArray()), new SomeStruct(10) }; yield return new object[] { new SomeClass(Enumerable.Range(0, 15).ToArray()), new SomeStruct(15) }; } public class SomeClass { public SomeClass(int[] initialValues) => Values = initialValues.Select(val => val * 2).ToArray(); public int[] Values { get; } public override string ToString() => $\"{Values.Length} items\"; } public struct SomeStruct { public SomeStruct(int rangeEnd) => RangeEnd = rangeEnd; public int RangeEnd { get; } public override string ToString() => $\"{RangeEnd}\"; } } | Method | someClass | someStruct | Mean | Error | |------- |---------- |----------- |---------:|------:| | Simple | 10 items | 10 | 887.2 us | NA | | Simple | 15 items | 15 | 963.1 us | NA | Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroArgumentsSource"
  },
  "articles/samples/IntroArrayParam.html": {
    "href": "articles/samples/IntroArrayParam.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroArrayParam Warning The cost of creating the arguments is not included in the benchmark. So if you want to pass an array as an argument, we are going to allocate it before running the benchmark, and the benchmark will not include this operation. Source code using System; using System.Collections.Generic; using System.Linq; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArrayParam { [Benchmark] [ArgumentsSource(nameof(Data))] public int ArrayIndexOf(int[] array, int value) => Array.IndexOf(array, value); [Benchmark] [ArgumentsSource(nameof(Data))] public int ManualIndexOf(int[] array, int value) { for (int i = 0; i < array.Length; i++) if (array[i] == value) return i; return -1; } public IEnumerable<object[]> Data() { yield return new object[] { new int[] { 1, 2, 3 }, 4 }; yield return new object[] { Enumerable.Range(0, 100).ToArray(), 4 }; yield return new object[] { Enumerable.Range(0, 100).ToArray(), 101 }; } } } Output | Method | array | value | Mean | Error | StdDev | Allocated | |-------------- |----------- |------ |----------:|----------:|----------:|----------:| | ArrayIndexOf | Array[100] | 4 | 15.558 ns | 0.0638 ns | 0.0597 ns | 0 B | | ManualIndexOf | Array[100] | 4 | 5.345 ns | 0.0668 ns | 0.0625 ns | 0 B | | ArrayIndexOf | Array[3] | 4 | 14.334 ns | 0.1758 ns | 0.1558 ns | 0 B | | ManualIndexOf | Array[3] | 4 | 2.758 ns | 0.0905 ns | 0.1208 ns | 0 B | | ArrayIndexOf | Array[100] | 101 | 78.359 ns | 1.8853 ns | 2.0955 ns | 0 B | | ManualIndexOf | Array[100] | 101 | 80.421 ns | 0.6391 ns | 0.5978 ns | 0 B | Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroArrayParam"
  },
  "articles/samples/IntroBasic.html": {
    "href": "articles/samples/IntroBasic.html",
    "title": "Sample: IntroBasic | BenchmarkDotNet",
    "summary": "Sample: IntroBasic Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { // It is very easy to use BenchmarkDotNet. You should just create a class public class IntroBasic { // And define a method with the Benchmark attribute [Benchmark] public void Sleep() => Thread.Sleep(10); // You can write a description for your method. [Benchmark(Description = \"Thread.Sleep(10)\")] public void SleepWithDescription() => Thread.Sleep(10); } } Links The permanent link to this sample: Sample: IntroBasic"
  },
  "articles/samples/IntroBenchmarkBaseline.html": {
    "href": "articles/samples/IntroBenchmarkBaseline.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroBenchmarkBaseline You can mark a method as a baseline with the help of [Benchmark(Baseline = true)]. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroBenchmarkBaseline { [Benchmark] public void Time50() => Thread.Sleep(50); [Benchmark(Baseline = true)] public void Time100() => Thread.Sleep(100); [Benchmark] public void Time150() => Thread.Sleep(150); } } Output As a result, you will have additional Ratio column in the summary table: | Method | Mean | Error | StdDev | Ratio | |-------- |----------:|----------:|----------:|------:| | Time50 | 50.46 ms | 0.0779 ms | 0.0729 ms | 0.50 | | Time100 | 100.39 ms | 0.0762 ms | 0.0713 ms | 1.00 | | Time150 | 150.48 ms | 0.0986 ms | 0.0922 ms | 1.50 | This column contains the mean value of the ratio distribution. For example, in the case of Time50, we divide the first measurement of Time50 into the first measurement of Time100 (it's the baseline), the second measurement of Time50 into the second measurement of Time100, and so on. Next, we calculate the mean of all these values and display it in the Ratio column. For Time50, we have 0.50. The Ratio column was formerly known as Scaled. The old title was a source of misunderstanding and confusion because many developers interpreted it as the ratio of means (e.g., 50.46/100.39 for Time50). The ratio of distribution means and the mean of the ratio distribution are pretty close to each other in most cases, but they are not equal. In @BenchmarkDotNet.Samples.IntroRatioStdDev, you can find an example of how this value can be spoiled by outliers. Links Benchmark and Job Baselines The permanent link to this sample: BenchmarkDotNet.Samples.IntroBenchmarkBaseline"
  },
  "articles/samples/IntroCategories.html": {
    "href": "articles/samples/IntroCategories.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroCategories Combined together with [BenchmarkCategory] attribute, you can group the benchmarks into categories and filter them by categories. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DryJob] [CategoriesColumn] [BenchmarkCategory(\"Awesome\")] [AnyCategoriesFilter(\"A\", \"1\")] public class IntroCategories { [Benchmark] [BenchmarkCategory(\"A\", \"1\")] public void A1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] [BenchmarkCategory(\"A\", \"2\")] public void A2() => Thread.Sleep(10); // Will be benchmarked [Benchmark] [BenchmarkCategory(\"B\", \"1\")] public void B1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] [BenchmarkCategory(\"B\", \"2\")] public void B2() => Thread.Sleep(10); } } Command line examples: --allCategories=A,B --anyCategories=A,B Links Filters The permanent link to this sample: BenchmarkDotNet.Samples.IntroCategories"
  },
  "articles/samples/IntroCategoryBaseline.html": {
    "href": "articles/samples/IntroCategoryBaseline.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroCategoryBaseline The only way to have several baselines in the same class is to separate them by categories and mark the class with [GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)]. Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; namespace BenchmarkDotNet.Samples { [GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)] [CategoriesColumn] public class IntroCategoryBaseline { [BenchmarkCategory(\"Fast\"), Benchmark(Baseline = true)] public void Time50() => Thread.Sleep(50); [BenchmarkCategory(\"Fast\"), Benchmark] public void Time100() => Thread.Sleep(100); [BenchmarkCategory(\"Slow\"), Benchmark(Baseline = true)] public void Time550() => Thread.Sleep(550); [BenchmarkCategory(\"Slow\"), Benchmark] public void Time600() => Thread.Sleep(600); } } Output | Method | Categories | Mean | Error | StdDev | Ratio | |-------- |----------- |----------:|----------:|----------:|------:| | Time50 | Fast | 50.46 ms | 0.0745 ms | 0.0697 ms | 1.00 | | Time100 | Fast | 100.47 ms | 0.0955 ms | 0.0893 ms | 1.99 | | | | | | | | | Time550 | Slow | 550.48 ms | 0.0525 ms | 0.0492 ms | 1.00 | | Time600 | Slow | 600.45 ms | 0.0396 ms | 0.0331 ms | 1.09 | Links Benchmark and Job Baselines The permanent link to this sample: BenchmarkDotNet.Samples.IntroCategoryBaseline"
  },
  "articles/samples/IntroCategoryDiscoverer.html": {
    "href": "articles/samples/IntroCategoryDiscoverer.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroCategoryDiscoverer The category discovery strategy can be overridden using an instance of ICategoryDiscoverer. Source code using System; using System.Collections.Generic; using System.Reflection; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { [DryJob] [CategoriesColumn] [CustomCategoryDiscoverer] public class IntroCategoryDiscoverer { private class CustomCategoryDiscoverer : DefaultCategoryDiscoverer { public override string[] GetCategories(MethodInfo method) { var categories = new List<string>(); categories.AddRange(base.GetCategories(method)); categories.Add(\"All\"); categories.Add(method.Name.Substring(0, 1)); return categories.ToArray(); } } [AttributeUsage(AttributeTargets.Class)] private class CustomCategoryDiscovererAttribute : Attribute, IConfigSource { public CustomCategoryDiscovererAttribute() { Config = ManualConfig.CreateEmpty() .WithCategoryDiscoverer(new CustomCategoryDiscoverer()); } public IConfig Config { get; } } [Benchmark] public void Foo() { } [Benchmark] public void Bar() { } } } Output | Method | Categories | Mean | Error | |------- |----------- |---------:|------:| | Bar | All,B | 126.5 us | NA | | Foo | All,F | 114.0 us | NA | Links The permanent link to this sample: BenchmarkDotNet.Samples.IntroCategoryDiscoverer"
  },
  "articles/samples/IntroColdStart.html": {
    "href": "articles/samples/IntroColdStart.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroColdStart If you want to measure cold start (without the pilot and warmup stage), the ColdStart strategy is your choice. Usage [SimpleJob(RunStrategy.ColdStart, launchCount:50)] public class MyBenchmarkClass Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.ColdStart, iterationCount: 5)] [MinColumn, MaxColumn, MeanColumn, MedianColumn] public class IntroColdStart { private bool firstCall; [Benchmark] public void Foo() { if (firstCall == false) { firstCall = true; Console.WriteLine(\"// First call\"); Thread.Sleep(1000); } else Thread.Sleep(10); } } } Output Result 1: 1 op, 1002034900.00 ns, 1.0020 s/op Result 2: 1 op, 10219700.00 ns, 10.2197 ms/op Result 3: 1 op, 10406200.00 ns, 10.4062 ms/op Result 4: 1 op, 10473900.00 ns, 10.4739 ms/op Result 5: 1 op, 10449400.00 ns, 10.4494 ms/op Method | Mean | Error | StdDev | Min | Max | Median | ------- |---------:|-----------:|---------:|---------:|-----------:|---------:| Foo | 208.7 ms | 1,707.4 ms | 443.5 ms | 10.22 ms | 1,002.0 ms | 10.45 ms | Links Choosing RunStrategy The permanent link to this sample: BenchmarkDotNet.Samples.IntroColdStart"
  },
  "articles/samples/IntroComparableComplexParam.html": {
    "href": "articles/samples/IntroComparableComplexParam.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroComparableComplexParam You can implement IComparable (the non generic version) on your complex parameter class if you want custom ordering behavior for your parameter. One use case for this is having a parameter class that overrides ToString(), but also providing a custom ordering behavior that isn't the alphabetical order of the result of ToString(). Source code using System; using System.Collections.Generic; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroComparableComplexParam { [ParamsSource(nameof(ValuesForA))] public ComplexParam? A { get; set; } public IEnumerable<ComplexParam> ValuesForA => new[] { new ComplexParam(1, \"First\"), new ComplexParam(2, \"Second\") }; [Benchmark] public object? Benchmark() => A; // Only non generic IComparable is required to provide custom order behavior, but implementing IComparable<> too is customary. public class ComplexParam : IComparable<ComplexParam>, IComparable { public ComplexParam(int value, string name) { Value = value; Name = name; } public int Value { get; set; } public string Name { get; set; } public override string ToString() => Name; public int CompareTo(ComplexParam? other) => other == null ? 1 : Value.CompareTo(other.Value); public int CompareTo(object obj) => obj is ComplexParam other ? CompareTo(other) : throw new ArgumentException(); } } } Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroComparableComplexParam"
  },
  "articles/samples/IntroConfigSource.html": {
    "href": "articles/samples/IntroConfigSource.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroConfigSource You can define own config attribute. Source code using System; using System.Linq; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [MyConfigSource(Jit.LegacyJit, Jit.RyuJit)] public class IntroConfigSource { /// <summary> /// Dry-x64 jobs for specific jits /// </summary> private class MyConfigSourceAttribute : Attribute, IConfigSource { public IConfig Config { get; } public MyConfigSourceAttribute(params Jit[] jits) { var jobs = jits .Select(jit => new Job(Job.Dry) { Environment = { Jit = jit, Platform = Platform.X64 } }) .ToArray(); Config = ManualConfig.CreateEmpty().AddJob(jobs); } } [Benchmark] public void Foo() { Thread.Sleep(10); } } } Links Configs The permanent link to this sample: BenchmarkDotNet.Samples.IntroConfigSource"
  },
  "articles/samples/IntroConfigUnion.html": {
    "href": "articles/samples/IntroConfigUnion.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroConfigUnion Source code using System.Threading; using BenchmarkDotNet.Analysers; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Columns; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Exporters; using BenchmarkDotNet.Exporters.Csv; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Loggers; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] public class IntroConfigUnion { private class Config : ManualConfig { public Config() { AddJob(Job.Dry); AddLogger(ConsoleLogger.Default); AddColumn(TargetMethodColumn.Method, StatisticColumn.Max); AddExporter(RPlotExporter.Default, CsvExporter.Default); AddAnalyser(EnvironmentAnalyser.Default); UnionRule = ConfigUnionRule.AlwaysUseLocal; } } [Benchmark] public void Foo() { Thread.Sleep(10); } } } Links Configs The permanent link to this sample: BenchmarkDotNet.Samples.IntroConfigUnion"
  },
  "articles/samples/IntroCustomMono.html": {
    "href": "articles/samples/IntroCustomMono.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroCustomMono BenchmarkDotNet allows you to compare different runtimes, including Mono. If you apply [MonoJob] attribute to your class we use your default mono runtime. If you want to compare different versions of Mono you need to provide use the custom paths. You can do this today by using the overloaded ctor of MonoJob attribute or by specifying the runtime in a fluent way. The mono runtime can also operate as an ahead-of-time compiler. Using mono's AOT mode requires providing the AOT compilation arguments, as well as the path to mono's corlib. (See IntroCustomMonoObjectStyleAot in the below example). Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { // *** Attribute Style *** [MonoJob(\"Mono x64\", @\"C:\\Program Files\\Mono\\bin\\mono.exe\")] [MonoJob(\"Mono x86\", @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\")] public class IntroCustomMono { [Benchmark] public void Foo() { // Benchmark body } } // *** Object Style *** [Config(typeof(Config))] public class IntroCustomMonoObjectStyle { private class Config : ManualConfig { public Config() { AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x64\", @\"C:\\Program Files\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x86\", @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\"))); } } [Benchmark] public void Foo() { // Benchmark body } } // ** Object Style, Using AOT ** [Config(typeof(Config))] public class IntroCustomMonoObjectStyleAot { private class Config : ManualConfig { public void AddMono (string name, string mono_top_dir) { var aot_compile_args = \"--aot=llvm\"; var mono_bcl = $@\"{mono_top_dir}\\lib\\mono\\4.5\"; var mono_bin = $@\"{mono_top_dir}\\bin\\mono.exe\"; AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( name, mono_bin, aot_compile_args, mono_bcl))); } public Config() { AddMono(\"Mono x64\", @\"C:\\Program Files\\Mono\"); AddMono(\"Mono x86\", @\"C:\\Program Files (x86)\\Mono\"); } } [Benchmark] public void Foo() { // Benchmark body } } // *** Fluent Config *** public class IntroCustomMonoFluentConfig { public static void Run() { BenchmarkRunner.Run<IntroCustomMonoFluentConfig>(ManualConfig .CreateMinimumViable() .AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x64\", @\"C:\\Program Files\\Mono\\bin\\mono.exe\"))) .AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x86\", @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\")))); } [Benchmark] public void Foo() { // Benchmark body } } } Links Customizing Runtime The permanent link to this sample: BenchmarkDotNet.Samples.IntroCustomMono"
  },
  "articles/samples/IntroCustomMonoArguments.html": {
    "href": "articles/samples/IntroCustomMonoArguments.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroCustomMonoArguments Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [Config(typeof(ConfigWithCustomArguments))] public class IntroCustomMonoArguments { public class ConfigWithCustomArguments : ManualConfig { public ConfigWithCustomArguments() { // --optimize=MODE , -O=mode // MODE is a comma separated list of optimizations. They also allow // optimizations to be turned off by prefixing the optimization // name with a minus sign. AddJob(Job.Default .WithRuntime(MonoRuntime.Default) .WithArguments(new[] { new MonoArgument(\"--optimize=inline\") }) .WithId(\"Inlining enabled\")); AddJob(Job.Default .WithRuntime(MonoRuntime.Default) .WithArguments(new[] { new MonoArgument(\"--optimize=-inline\") }) .WithId(\"Inlining disabled\")); } } [Benchmark] public void Sample() { ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); } private void ShouldGetInlined() { } } } Output | Method | Job | Arguments | Mean | StdDev | |------- |------------------ |------------------- |-----------:|----------:| | Sample | Inlining disabled | --optimize=-inline | 19.4252 ns | 0.4525 ns | | Sample | Inlining enabled | --optimize=inline | 0.0000 ns | 0.0000 ns | Links Customizing Runtime The permanent link to this sample: BenchmarkDotNet.Samples.IntroCustomMonoArguments"
  },
  "articles/samples/IntroDeferredExecution.html": {
    "href": "articles/samples/IntroDeferredExecution.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroDeferredExecution In LINQ, execution of a query is usually deferred until the moment when you actually request the data. If your benchmark just returns IEnumerable or IQueryable it's not measuring the execution of the query, just the creation. This is why we decided to warn you about this issue whenever it happens: Benchmark IntroDeferredExecution.Wrong returns a deferred execution result (IEnumerable<Int32>). You need to either change the method declaration to return a materialized result or consume it on your own. You can use .Consume() extension method to do that. Don't worry! We are also providing you with a Consume extension method which can execute given IEnumerable or IQueryable and consume its results. All you need to do is to create a Consumer instance, preferably store it in a field (to exclude the cost of creating Consumer from the benchmark itself) and pass it to Consume extension method. Do not call .ToArray() because it's an expensive operation and it might dominate given benchmark! Source code using System.Collections.Generic; using System.Linq; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { public class IntroDeferredExecution { private readonly int[] numbers = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; private readonly Consumer consumer = new Consumer(); /// <summary> /// this benchmark returns a deferred LINQ query which is NOT executed /// so the benchmark measures the cost of creating the query, not the actual execution /// this is WRONG /// You can read more about LINQ and Deferred Execution <see href=\"https://blogs.msdn.microsoft.com/charlie/2007/12/10/linq-and-deferred-execution/\">here</see> /// </summary> /// <returns>deferred LINQ query</returns> [Benchmark] public IEnumerable<int> Wrong() => from number in numbers orderby number descending select number; /// <summary> /// this benchmark uses .Consume extension method which executes given deferred query and consumes its result /// so the benchmark measures the cost of creating the query and executing it /// </summary> [Benchmark] public void Ok() => (from number in numbers orderby number descending select number).Consume(consumer); } } Links The permanent link to this sample: BenchmarkDotNet.Samples.IntroDeferredExecution"
  },
  "articles/samples/IntroDisassembly.html": {
    "href": "articles/samples/IntroDisassembly.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroDisassembly Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnosers; using System.Linq; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(printInstructionAddresses: true, syntax: DisassemblySyntax.Masm)] public class IntroDisassembly { private int[] field = Enumerable.Range(0, 100).ToArray(); [Benchmark] public int SumLocal() { var local = field; // we use local variable that points to the field int sum = 0; for (int i = 0; i < local.Length; i++) sum += local[i]; return sum; } [Benchmark] public int SumField() { int sum = 0; for (int i = 0; i < field.Length; i++) sum += field[i]; return sum; } } } Output ; .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.7.3110.0 05452718 BenchmarkDotNet.Samples.IntroDisassembly.Sum() IL_0000: ldc.r8 0 IL_0009: stloc.0 0545271c d9ee fldz IL_000a: ldc.i4.0 IL_000b: stloc.1 IL_000c: br.s IL_0017 0545271e 33c0 xor eax,eax IL_000e: ldloc.0 IL_000f: ldloc.1 IL_0010: conv.r8 IL_0011: add IL_0012: stloc.0 05452720 8945fc mov dword ptr [ebp-4],eax 05452723 db45fc fild dword ptr [ebp-4] 05452726 dec1 faddp st(1),st IL_0013: ldloc.1 IL_0014: ldc.i4.1 IL_0015: add IL_0016: stloc.1 05452728 40 inc eax IL_0017: ldloc.1 IL_0018: ldc.i4.s 64 IL_001a: blt.s IL_000e 05452729 83f840 cmp eax,40h 0545272c 7cf2 jl 05452720 IL_001c: ldloc.0 IL_001d: ret 0545272e 8be5 mov esp,ebp ; .NET Core 2.1.0 (CoreCLR 4.6.26515.07, CoreFX 4.6.26515.06), 64bit RyuJIT 00007ffa`6c621320 BenchmarkDotNet.Samples.IntroDisassembly.Sum() IL_0000: ldc.r8 0 IL_0009: stloc.0 00007ffa`6c621323 c4e17857c0 vxorps xmm0,xmm0,xmm0 IL_000a: ldc.i4.0 IL_000b: stloc.1 IL_000c: br.s IL_0017 00007ffa`6c621328 33c0 xor eax,eax IL_000e: ldloc.0 IL_000f: ldloc.1 IL_0010: conv.r8 IL_0011: add IL_0012: stloc.0 00007ffa`6c62132a c4e17057c9 vxorps xmm1,xmm1,xmm1 00007ffa`6c62132f c4e1732ac8 vcvtsi2sd xmm1,xmm1,eax 00007ffa`6c621334 c4e17b58c1 vaddsd xmm0,xmm0,xmm1 IL_0013: ldloc.1 IL_0014: ldc.i4.1 IL_0015: add IL_0016: stloc.1 00007ffa`6c621339 ffc0 inc eax IL_0017: ldloc.1 IL_0018: ldc.i4.s 64 IL_001a: blt.s IL_000e 00007ffa`6c62133b 83f840 cmp eax,40h 00007ffa`6c62133e 7cea jl 00007ffa`6c62132a IL_001c: ldloc.0 IL_001d: ret 00007ffa`6c621340 c3 ret Mono 5.12.0 (Visual Studio), 64bit Sum sub $0x18,%rsp mov %rsi,(%rsp) xorpd %xmm0,%xmm0 movsd %xmm0,0x8(%rsp) xor %esi,%esi jmp 2e xchg %ax,%ax movsd 0x8(%rsp),%xmm0 cvtsi2sd %esi,%xmm1 addsd %xmm1,%xmm0 movsd %xmm0,0x8(%rsp) inc %esi cmp $0x40,%esi jl 18 movsd 0x8(%rsp),%xmm0 mov (%rsp),%rsi add $0x18,%rsp retq Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassembly"
  },
  "articles/samples/IntroDisassemblyAllJits.html": {
    "href": "articles/samples/IntroDisassemblyAllJits.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroDisassemblyAllJits You can use a single config to compare the generated assembly code for ALL JITs. But to allow benchmarking any target platform architecture the project which defines benchmarks has to target AnyCPU. <PropertyGroup> <PlatformTarget>AnyCPU</PlatformTarget> </PropertyGroup> Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Diagnosers; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [Config(typeof(MultipleJits))] public class IntroDisassemblyAllJits { public class MultipleJits : ManualConfig { public MultipleJits() { AddJob(Job.ShortRun.WithPlatform(Platform.X86).WithRuntime(new MonoRuntime(name: \"Mono x86\", customPath: @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithPlatform(Platform.X64).WithRuntime(new MonoRuntime(name: \"Mono x64\", customPath: @\"C:\\Program Files\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithJit(Jit.LegacyJit).WithPlatform(Platform.X86).WithRuntime(ClrRuntime.Net462)); AddJob(Job.ShortRun.WithJit(Jit.LegacyJit).WithPlatform(Platform.X64).WithRuntime(ClrRuntime.Net462)); AddJob(Job.ShortRun.WithJit(Jit.RyuJit).WithPlatform(Platform.X64).WithRuntime(ClrRuntime.Net462)); // RyuJit for .NET Core 5.0 AddJob(Job.ShortRun.WithJit(Jit.RyuJit).WithPlatform(Platform.X64).WithRuntime(CoreRuntime.Core50)); AddDiagnoser(new DisassemblyDiagnoser(new DisassemblyDiagnoserConfig(maxDepth: 3, exportDiff: true))); } } private Increment increment = new Increment(); [Benchmark] public int CallVirtualMethod() => increment.OperateTwice(10); public abstract class Operation // abstract unary integer operation { public abstract int Operate(int input); public int OperateTwice(int input) => Operate(Operate(input)); // two virtual calls to Operate } public sealed class Increment : Operation // concrete, sealed operation: increment by fixed amount { public readonly int Amount; public Increment(int amount = 1) { Amount = amount; } public override int Operate(int input) => input + Amount; } } } Output The disassembly result can be obtained here. The file was too big to embed it in this doc page. Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassemblyAllJits"
  },
  "articles/samples/IntroDisassemblyDry.html": {
    "href": "articles/samples/IntroDisassemblyDry.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroDisassemblyDry Getting only the Disassembly without running the benchmarks for a long time. Sometimes you might be interested only in the disassembly, not the results of the benchmarks. In that case you can use Job.Dry which runs the benchmark only once. Source code using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(maxDepth: 3)] [DryJob] public class IntroDisassemblyDry { [Benchmark] public void Foo() { } } } Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassemblyDry"
  },
  "articles/samples/IntroDisassemblyRyuJit.html": {
    "href": "articles/samples/IntroDisassemblyRyuJit.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroDisassemblyRyuJit Source code using System.Linq; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(printSource: true)] [RyuJitX64Job] public class IntroDisassemblyRyuJit { private int[] field = Enumerable.Range(0, 100).ToArray(); [Benchmark] public int SumLocal() { var local = field; // we use local variable that points to the field int sum = 0; for (int i = 0; i < local.Length; i++) sum += local[i]; return sum; } [Benchmark] public int SumField() { int sum = 0; for (int i = 0; i < field.Length; i++) sum += field[i]; return sum; } } } Output Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassemblyRyuJit"
  },
  "articles/samples/IntroDotMemoryDiagnoser.html": {
    "href": "articles/samples/IntroDotMemoryDiagnoser.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroDotMemoryDiagnoser If you want to get a memory allocation profile of your benchmarks, just add the [DotMemoryDiagnoser] attribute, as shown below. As a result, BenchmarkDotNet performs bonus benchmark runs using attached dotMemory Command-Line Profiler. The obtained dotMemory workspaces are saved to the artifacts folder. These dotMemory workspaces can be opened using the standalone dotMemory, or dotMemory in Rider. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnostics.dotMemory; using System.Collections.Generic; namespace BenchmarkDotNet.Samples { // Profile benchmarks via dotMemory SelfApi profiling for all jobs [DotMemoryDiagnoser] [SimpleJob] // external-process execution [InProcess] // in-process execution public class IntroDotMemoryDiagnoser { [Params(1024)] public int Size; private byte[] dataArray; private IEnumerable<byte> dataEnumerable; [GlobalSetup] public void Setup() { dataArray = new byte[Size]; dataEnumerable = dataArray; } [Benchmark] public int IterateArray() { var count = 0; foreach (var _ in dataArray) count++; return count; } [Benchmark] public int IterateEnumerable() { var count = 0; foreach (var _ in dataEnumerable) count++; return count; } } } Links The permanent link to this sample: BenchmarkDotNet.Samples.IntroDotMemoryDiagnoser"
  },
  "articles/samples/IntroDotTraceDiagnoser.html": {
    "href": "articles/samples/IntroDotTraceDiagnoser.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroDotTraceDiagnoser If you want to get a performance profile of your benchmarks, just add the [DotTraceDiagnoser] attribute, as shown below. As a result, BenchmarkDotNet performs bonus benchmark runs using attached dotTrace Command-Line Profiler. The obtained snapshots are saved to the artifacts folder. These snapshots can be opened using the standalone dotTrace, or dotTrace in Rider. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnostics.dotTrace; namespace BenchmarkDotNet.Samples { // Profile benchmarks via dotTrace SelfApi profiling for all jobs // See: https://www.nuget.org/packages/JetBrains.Profiler.SelfApi [DotTraceDiagnoser] [SimpleJob] // external-process execution [InProcess] // in-process execution public class IntroDotTraceDiagnoser { [Benchmark] public void Fibonacci() => Fibonacci(30); private static int Fibonacci(int n) { return n <= 1 ? n : Fibonacci(n - 1) + Fibonacci(n - 2); } } } Links The permanent link to this sample: BenchmarkDotNet.Samples.IntroDotTraceDiagnoser"
  },
  "articles/samples/IntroEnvVars.html": {
    "href": "articles/samples/IntroEnvVars.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroEnvVars You can configure custom environment variables for the process that is running your benchmarks. One reason for doing this might be checking out how different compilation, threading, garbage collector settings affect the performance of .NET Core. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [Config(typeof(ConfigWithCustomEnvVars))] public class IntroEnvVars { private class ConfigWithCustomEnvVars : ManualConfig { public ConfigWithCustomEnvVars() { AddJob(Job.Default.WithRuntime(CoreRuntime.Core80).WithId(\"Inlining enabled\")); AddJob(Job.Default.WithRuntime(CoreRuntime.Core80) .WithEnvironmentVariables([ new EnvironmentVariable(\"DOTNET_JitNoInline\", \"1\"), new EnvironmentVariable(\"COMPlus_JitNoInline\", \"1\") ]) .WithId(\"Inlining disabled\")); } } [Benchmark] public void Foo() { // Benchmark body } } } Links Customizing Runtime Configs Jobs The permanent link to this sample: BenchmarkDotNet.Samples.IntroEnvVars"
  },
  "articles/samples/IntroEventPipeProfiler.html": {
    "href": "articles/samples/IntroEventPipeProfiler.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: EventPipeProfiler The EventPipeProfiler can be enabled using the [EventPipeProfiler(...)] attribute. This attribute takes the following profiles: CpuSampling - Useful for tracking CPU usage and general .NET runtime information. This is the default option. GcVerbose - Tracks GC collections and samples object allocations. GcCollect - Tracks GC collections only at very low overhead. Jit - Logging when Just in time (JIT) compilation occurs. Logging of the internal workings of the Just In Time compiler. This is fairly verbose. It details decisions about interesting optimization (like inlining and tail call) Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnosers; namespace BenchmarkDotNet.Samples { [ShortRunJob] [EventPipeProfiler(EventPipeProfile.CpuSampling)] public class IntroEventPipeProfiler { [Benchmark] public void Sleep() => Thread.Sleep(2000); } } Output The output should contain information about the exported trace file which can be analyzed using SpeedScope. // * Diagnostic Output - EventPipeProfiler * Exported 1 trace file(s). Example: C:\\Work\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\BenchmarkDotNet.Artifacts\\BenchmarkDotNet.Samples.IntroEventPipeProfiler.Sleep-20200406-090113.speedscope.json"
  },
  "articles/samples/IntroEventPipeProfilerAdvanced.html": {
    "href": "articles/samples/IntroEventPipeProfilerAdvanced.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: EventPipeProfilerAdvanced The most advanced and powerful way to use EventPipeProfiler is a custom configuration. As you can see the below configuration adds EventPipeProfiler that constructor can take the profile and/or a list of providers. Both EventPipeProfiler and dotnet trace use the Microsoft.Diagnostics.NETCore.Client package internally. So before you start using the custom configuration of this profiler, it is worth reading the documentation here and here where you can find more information about how to configure provider list. Source code using System.Buffers; using System.Diagnostics.Tracing; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Diagnosers; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using Microsoft.Diagnostics.NETCore.Client; using Microsoft.Diagnostics.Tracing.Parsers; namespace BenchmarkDotNet.Samples { [Config(typeof(CustomConfig))] public class IntroEventPipeProfilerAdvanced { private class CustomConfig : ManualConfig { public CustomConfig() { AddJob(Job.ShortRun.WithRuntime(CoreRuntime.Core50)); var providers = new[] { new EventPipeProvider(ClrTraceEventParser.ProviderName, EventLevel.Verbose, (long) (ClrTraceEventParser.Keywords.Exception | ClrTraceEventParser.Keywords.GC | ClrTraceEventParser.Keywords.Jit | ClrTraceEventParser.Keywords.JitTracing // for the inlining events | ClrTraceEventParser.Keywords.Loader | ClrTraceEventParser.Keywords.NGen)), new EventPipeProvider(\"System.Buffers.ArrayPoolEventSource\", EventLevel.Informational, long.MaxValue), }; AddDiagnoser(new EventPipeProfiler(providers: providers)); } } [Benchmark] public void RentAndReturn_Shared() { var pool = ArrayPool<byte>.Shared; byte[] array = pool.Rent(10000); pool.Return(array); } } } Output The output should contain information about the exported trace file which can be analyzed using SpeedScope. // * Diagnostic Output - EventPipeProfiler * Exported 1 trace file(s). Example: C:\\Work\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\BenchmarkDotNet.Artifacts\\BenchmarkDotNet.Samples.IntroEventPipeProfilerAdvanced.RentAndReturn_Shared-20200406-090136.speedscope.json"
  },
  "articles/samples/IntroExceptionDiagnoser.html": {
    "href": "articles/samples/IntroExceptionDiagnoser.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroExceptionDiagnoser The ExceptionDiagnoser uses AppDomain.FirstChanceException API to report: Exception frequency: The number of exceptions thrown during the operations divided by the number of operations. Source code using BenchmarkDotNet.Attributes; using System; namespace BenchmarkDotNet.Samples { [ExceptionDiagnoser] public class IntroExceptionDiagnoser { [Benchmark] public void ThrowExceptionRandomly() { try { if (new Random().Next(0, 5) > 1) { throw new Exception(); } } catch { // ignored } } } } Output Method Mean Error StdDev Exception frequency ThrowExceptionRandomly 4.936 us 0.1542 us 0.4499 us 0.1381 Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroExceptionDiagnoser"
  },
  "articles/samples/IntroExport.html": {
    "href": "articles/samples/IntroExport.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroExport BenchmarkDotNet has a lot of predefined exporters. Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [ShortRunJob] [MediumRunJob] [KeepBenchmarkFiles] [AsciiDocExporter] [CsvExporter] [CsvMeasurementsExporter] [HtmlExporter] [PlainExporter] [RPlotExporter] [JsonExporterAttribute.Brief] [JsonExporterAttribute.BriefCompressed] [JsonExporterAttribute.Full] [JsonExporterAttribute.FullCompressed] [MarkdownExporterAttribute.Default] [MarkdownExporterAttribute.GitHub] [MarkdownExporterAttribute.StackOverflow] [MarkdownExporterAttribute.Atlassian] [XmlExporterAttribute.Brief] [XmlExporterAttribute.BriefCompressed] [XmlExporterAttribute.Full] [XmlExporterAttribute.FullCompressed] public class IntroExport { private Random random = new Random(42); [Benchmark(Baseline = true)] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep50Noisy() => Thread.Sleep(random.Next(100)); } } Links Exporters The permanent link to this sample: BenchmarkDotNet.Samples.IntroExport"
  },
  "articles/samples/IntroExportJson.html": {
    "href": "articles/samples/IntroExportJson.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroExportJson BenchmarkDotNet has a set of json exporters. You can customize the following properties of these exporters: fileNameSuffix: a string which be placed in the end of target file name. indentJson=false/true: should we format json or not. excludeMeasurements=false/true: should we exclude detailed information about measurements or not (the final summary with statistics will be in the json file anyway). Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Exporters.Json; namespace BenchmarkDotNet.Samples { // *** Attribute style *** [DryJob] [JsonExporterAttribute.Brief] [JsonExporterAttribute.Full] [JsonExporterAttribute.BriefCompressed] [JsonExporterAttribute.FullCompressed] [JsonExporter(\"-custom\", indentJson: true, excludeMeasurements: true)] public class IntroExportJson { [Benchmark] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep20() => Thread.Sleep(20); } // *** Object style *** [Config(typeof(Config))] public class IntroJsonExportObjectStyle { private class Config : ManualConfig { public Config() { AddExporter(JsonExporter.Brief); AddExporter(JsonExporter.Brief); AddExporter(JsonExporter.Full); AddExporter(JsonExporter.BriefCompressed); AddExporter(JsonExporter.FullCompressed); AddExporter(JsonExporter.Custom(\"-custom\", indentJson: true, excludeMeasurements: true)); } } [Benchmark] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep20() => Thread.Sleep(20); } } Output Example of IntroJsonExport-report-brief.json: { \"Title\":\"IntroJsonExport\", \"HostEnvironmentInfo\":{ \"BenchmarkDotNetCaption\":\"BenchmarkDotNet-Dev.Core\", \"BenchmarkDotNetVersion\":\"0.9.9.0\", \"OsVersion\":\"Microsoft Windows NT 6.2.9200.0\", \"ProcessorName\":{ \"IsValueCreated\":true, \"Value\":\"Intel(R) Core(TM) i7-4702MQ CPU 2.20GHz\" }, \"ProcessorCount\":8, \"ClrVersion\":\"MS.NET 4.0.30319.42000\", \"Architecture\":\"64-bit\", \"HasAttachedDebugger\":false, \"HasRyuJit\":true, \"Configuration\":\"RELEASE\", \"JitModules\":\"clrjit-v4.6.1586.0\", \"DotNetCliVersion\":\"1.0.0-preview2-003121\", \"ChronometerFrequency\":2143474, \"HardwareTimerKind\":\"Tsc\" }, \"Benchmarks\":[ { \"ShortInfo\":\"IntroJsonExport_Sleep10\", \"Namespace\":\"BenchmarkDotNet.Samples.Intro\", \"Type\":\"IntroJsonExport\", \"Method\":\"Sleep10\", \"MethodTitle\":\"Sleep10\", \"Parameters\":\"\", \"Properties\":{ \"Mode\":\"Throughput\", \"Platform\":\"Host\", \"Jit\":\"Host\", \"Runtime\":\"Host\", \"GcMode\":\"Host\", \"WarmupCount\":\"Auto\", \"IterationCount\":\"Auto\", \"LaunchCount\":\"Auto\", \"IterationTime\":\"Auto\", \"Affinity\":\"Auto\" }, \"Statistics\":{ \"N\":20, \"Min\":10265993.7209375, \"LowerFence\":10255329.082734371, \"Q1\":10337369.528437499, \"Median\":10360382.6953125, \"Mean\":10362283.085796878, \"Q3\":10392063.158906251, \"UpperFence\":10474103.60460938, \"Max\":10436008.3209375, \"InterquartileRange\":54693.630468752235, \"Outliers\":[ ], \"StandardError\":10219.304338928456, \"Variance\":2088683623.4328396, \"StandardDeviation\":45702.118369205156, \"Skewness\":-0.1242777170069375, \"Kurtosis\":2.31980277935226, \"ConfidenceInterval\":{ \"Mean\":10362283.085796878, \"Error\":10219.304338928456, \"Level\":6, \"Margin\":20029.836504299772, \"Lower\":10342253.249292579, \"Upper\":10382312.922301177 }, \"Percentiles\":{ \"P0\":10265993.7209375, \"P25\":10338555.905625, \"P50\":10360382.6953125, \"P67\":10373496.555659376, \"P80\":10400703.4841875, \"P85\":10417280.326718749, \"P90\":10424125.595812501, \"P95\":10435620.51609375, \"P100\":10436008.3209375 } } },{ \"ShortInfo\":\"IntroJsonExport_Sleep20\", \"Namespace\":\"BenchmarkDotNet.Samples.Intro\", \"Type\":\"IntroJsonExport\", \"Method\":\"Sleep20\", \"MethodTitle\":\"Sleep20\", \"Parameters\":\"\", \"Properties\":{ \"Mode\":\"Throughput\", \"Platform\":\"Host\", \"Jit\":\"Host\", \"Runtime\":\"Host\", \"GcMode\":\"Host\", \"WarmupCount\":\"Auto\", \"IterationCount\":\"Auto\", \"LaunchCount\":\"Auto\", \"IterationTime\":\"Auto\", \"Affinity\":\"Auto\" }, \"Statistics\":{ \"N\":20, \"Min\":20258672.37, \"LowerFence\":20206333.269843742, \"Q1\":20325342.761249997, \"Median\":20362636.192500003, \"Mean\":20360791.931687497, \"Q3\":20404682.4221875, \"UpperFence\":20523691.913593754, \"Max\":20422396.073125, \"InterquartileRange\":79339.66093750298, \"Outliers\":[ ], \"StandardError\":10728.817907277158, \"Variance\":2302150673.7502208, \"StandardDeviation\":47980.732317777525, \"Skewness\":-0.50826238372439869, \"Kurtosis\":2.11050327966268, \"ConfidenceInterval\":{ \"Mean\":20360791.931687497, \"Error\":10728.817907277158, \"Level\":6, \"Margin\":21028.48309826323, \"Lower\":20339763.448589232, \"Upper\":20381820.414785761 }, \"Percentiles\":{ \"P0\":20258672.37, \"P25\":20327638.975312497, \"P50\":20362636.192500003, \"P67\":20391669.3762875, \"P80\":20406370.68625, \"P85\":20412542.034406248, \"P90\":20414412.5376875, \"P95\":20416606.697718751, \"P100\":20422396.073125 } } } ] } Links Exporters The permanent link to this sample: BenchmarkDotNet.Samples.IntroExportJson"
  },
  "articles/samples/IntroExportXml.html": {
    "href": "articles/samples/IntroExportXml.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroExportXml BenchmarkDotNet has a set of XML exporters. You can customize the following properties of these exporters: fileNameSuffix: a string which be placed in the end of target file name. indentXml=false/true: should we format xml or not. excludeMeasurements=false/true: should we exclude detailed information about measurements or not (the final summary with statistics will be in the XML file anyway). Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DryJob] [XmlExporterAttribute.Brief] [XmlExporterAttribute.Full] [XmlExporterAttribute.BriefCompressed] [XmlExporterAttribute.FullCompressed] [XmlExporter(\"-custom\", indentXml: true, excludeMeasurements: true)] public class IntroExportXml { [Benchmark] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep20() => Thread.Sleep(20); } } Output Example of IntroXmlExport-report-brief.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <Summary> <Title>IntroXmlExport</Title> <HostEnvironmentInfo> <BenchmarkDotNetCaption>BenchmarkDotNet</BenchmarkDotNetCaption> <BenchmarkDotNetVersion>0.10.9.20170805-develop</BenchmarkDotNetVersion> <OsVersion>Windows 10 Redstone 2 (10.0.15063)</OsVersion> <ProcessorName>Intel Core i7-3770K CPU 3.50GHz (Ivy Bridge)</ProcessorName> <ProcessorCount>8</ProcessorCount> <RuntimeVersion>.NET Framework 4.7 (CLR 4.0.30319.42000)</RuntimeVersion> <Architecture>64bit</Architecture> <HasAttachedDebugger>False</HasAttachedDebugger> <HasRyuJit>True</HasRyuJit> <Configuration>RELEASE</Configuration> <JitModules>clrjit-v4.7.2101.1</JitModules> <DotNetSdkVersion>1.0.4</DotNetSdkVersion> <ChronometerFrequency> <Hertz>3410220</Hertz> </ChronometerFrequency> <HardwareTimerKind>Tsc</HardwareTimerKind> </HostEnvironmentInfo> <Benchmarks> <Benchmark> <DisplayInfo>IntroXmlExport.Sleep10: DefaultJob</DisplayInfo> <Namespace>BenchmarkDotNet.Samples.Intro</Namespace> <Type>IntroXmlExport</Type> <Method>Sleep10</Method> <MethodTitle>Sleep10</MethodTitle> <Statistics> <N>15</N> <Min>10989865.8785938</Min> <LowerFence>10989836.0967969</LowerFence> <Q1>10990942.6053125</Q1> <Median>10991249.5870313</Median> <Mean>10991270.0524583</Mean> <Q3>10991680.2776563</Q3> <UpperFence>10992786.7861719</UpperFence> <Max>10992115.5501563</Max> <InterquartileRange>737.672343749553</InterquartileRange> <StandardError>148.484545262958</StandardError> <Variance>330714.902729213</Variance> <StandardDeviation>575.07817097262</StandardDeviation> <Skewness>-0.67759778074187</Skewness> <Kurtosis>3.14296703520386</Kurtosis> <ConfidenceInterval> <N>15</N> <Mean>10991270.0524583</Mean> <StandardError>148.484545262958</StandardError> <Level>L999</Level> <Margin>614.793505974065</Margin> <Lower>10990655.2589524</Lower> <Upper>10991884.8459643</Upper> </ConfidenceInterval> <Percentiles> <P0>10989865.8785938</P0> <P25>10991027.3689063</P25> <P50>10991249.5870313</P50> <P67>10991489.490875</P67> <P80>10991696.7722187</P80> <P85>10991754.5031875</P85> <P90>10991933.1939688</P90> <P95>10992067.441125</P95> <P100>10992115.5501563</P100> </Percentiles> </Statistics> </Benchmark> </Benchmarks> </Summary> Links Exporters The permanent link to this sample: BenchmarkDotNet.Samples.IntroExportXml"
  },
  "articles/samples/IntroFilters.html": {
    "href": "articles/samples/IntroFilters.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroFilters You can either use one of the predefined Filter types or create a custom type which implements IFilter interface. Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Filters; namespace BenchmarkDotNet.Samples { [DryJob] [Config(typeof(Config))] public class IntroFilters { private class Config : ManualConfig { // We will benchmark ONLY method with // names (which contains \"A\" OR \"1\") AND (have length < 3) public Config() { // benchmark with names which contains \"A\" OR \"1\" AddFilter(new DisjunctionFilter( new NameFilter(name => name.Contains(\"A\")), new NameFilter(name => name.Contains(\"1\")) )); // benchmark with names with length < 3 AddFilter(new NameFilter(name => name.Length < 3)); } } [Benchmark] public void A1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void A2() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void A3() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void B1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void B2() => Thread.Sleep(10); [Benchmark] public void B3() => Thread.Sleep(10); [Benchmark] public void C1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void C2() => Thread.Sleep(10); [Benchmark] public void C3() => Thread.Sleep(10); [Benchmark] public void Aaa() => Thread.Sleep(10); } } Links Filters The permanent link to this sample: BenchmarkDotNet.Samples.IntroFilters"
  },
  "articles/samples/IntroFluentConfigBuilder.html": {
    "href": "articles/samples/IntroFluentConfigBuilder.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroFluentConfigBuilder There is no need to create new Config type, you can simply use fluent interface. Source code using System; using System.Security.Cryptography; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; using BenchmarkDotNet.Validators; namespace BenchmarkDotNet.Samples { public class Algo_Md5VsSha256 { private const int N = 10000; private readonly byte[] data; private readonly MD5 md5 = MD5.Create(); private readonly SHA256 sha256 = SHA256.Create(); public Algo_Md5VsSha256() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark(Baseline = true)] public byte[] Md5() => md5.ComputeHash(data); [Benchmark] public byte[] Sha256() => sha256.ComputeHash(data); } public class IntroFluentConfigBuilder { public static void Run() { BenchmarkRunner .Run<Algo_Md5VsSha256>( DefaultConfig.Instance .AddJob(Job.Default.WithRuntime(ClrRuntime.Net462)) .AddJob(Job.Default.WithRuntime(CoreRuntime.Core80)) .AddValidator(ExecutionValidator.FailOnError)); } } } Links Configs The permanent link to this sample: BenchmarkDotNet.Samples.IntroFluentConfigBuilder"
  },
  "articles/samples/IntroGcMode.html": {
    "href": "articles/samples/IntroGcMode.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroGcMode Source code using System.Runtime.CompilerServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Order; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [MemoryDiagnoser] public class IntroGcMode { private class Config : ManualConfig { public Config() { AddJob(Job.MediumRun.WithGcServer(true).WithGcForce(true).WithId(\"ServerForce\")); AddJob(Job.MediumRun.WithGcServer(true).WithGcForce(false).WithId(\"Server\")); AddJob(Job.MediumRun.WithGcServer(false).WithGcForce(true).WithId(\"Workstation\")); AddJob(Job.MediumRun.WithGcServer(false).WithGcForce(false).WithId(\"WorkstationForce\")); } } [Benchmark(Description = \"new byte[10kB]\")] public byte[] Allocate() { return new byte[10000]; } [Benchmark(Description = \"stackalloc byte[10kB]\")] public unsafe void AllocateWithStackalloc() { var array = stackalloc byte[10000]; Consume(array); } [MethodImpl(MethodImplOptions.NoInlining)] private static unsafe void Consume(byte* input) { } } } Output Links Jobs The permanent link to this sample: BenchmarkDotNet.Samples.IntroGcMode"
  },
  "articles/samples/IntroGenericTypeArguments.html": {
    "href": "articles/samples/IntroGenericTypeArguments.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroGenericTypeArguments Source code using System; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [GenericTypeArguments(typeof(int))] [GenericTypeArguments(typeof(char))] public class IntroGenericTypeArguments<T> { [Benchmark] public T Create() => Activator.CreateInstance<T>(); } } Links The permanent link to this sample: BenchmarkDotNet.Samples.IntroGenericTypeArguments"
  },
  "articles/samples/IntroHardwareCounters.html": {
    "href": "articles/samples/IntroHardwareCounters.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroHardwareCounters This diagnoser is not enabled in explicit way as the other diagnosers. You need to specify [HardwareCounters] and we choose the right diagnoser in the runtime. Source code using System; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnosers; namespace BenchmarkDotNet.Samples { [HardwareCounters( HardwareCounter.BranchMispredictions, HardwareCounter.BranchInstructions)] public class IntroHardwareCounters { private const int N = 32767; private readonly int[] sorted, unsorted; public IntroHardwareCounters() { var random = new Random(0); unsorted = new int[N]; sorted = new int[N]; for (int i = 0; i < N; i++) sorted[i] = unsorted[i] = random.Next(256); Array.Sort(sorted); } private static int Branch(int[] data) { int sum = 0; for (int i = 0; i < N; i++) if (data[i] >= 128) sum += data[i]; return sum; } private static int Branchless(int[] data) { int sum = 0; for (int i = 0; i < N; i++) { int t = (data[i] - 128) >> 31; sum += ~t & data[i]; } return sum; } [Benchmark] public int SortedBranch() => Branch(sorted); [Benchmark] public int UnsortedBranch() => Branch(unsorted); [Benchmark] public int SortedBranchless() => Branchless(sorted); [Benchmark] public int UnsortedBranchless() => Branchless(unsorted); } } Output Method Mean Mispredict rate BranchInstructions/Op BranchMispredictions/Op SortedBranch 21.4539 us 0,04% 70121 24 UnsortedBranch 136.1139 us 23,70% 68788 16301 SortedBranchless 28.6705 us 0,06% 35711 22 UnsortedBranchless 28.9336 us 0,05% 35578 17 Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroHardwareCounters"
  },
  "articles/samples/IntroInliningDiagnoser.html": {
    "href": "articles/samples/IntroInliningDiagnoser.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroInliningDiagnoser This sample shows how to add InliningDiagnoser with events from only one namespace (BenchmarkDotNet.Samples). Source code using BenchmarkDotNet.Attributes; using System.Runtime.CompilerServices; namespace BenchmarkDotNet.Samples { [Diagnostics.Windows.Configs.InliningDiagnoser(logFailuresOnly: false, allowedNamespaces: new[] { \"BenchmarkDotNet.Samples\" })] public class IntroInliningDiagnoser { [Benchmark] public int IterationTest() { int j = 0; for (int i = 0; i < short.MaxValue; ++i) { j = i + AddThree(i); } return j + ReturnFive() + AddThree(ReturnFive()); } [Benchmark] public int SplitJoin() => string.Join(\",\", new string[1000]).Split(',').Length; private int ReturnFive() { return 5; } [MethodImpl(MethodImplOptions.AggressiveInlining)] private int AddThree(int a) { return a + 3; } } }"
  },
  "articles/samples/IntroInProcess.html": {
    "href": "articles/samples/IntroInProcess.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroInProcess InProcessEmitToolchain is our toolchain which does not generate any new executable. It emits IL on the fly and runs it from within the process itself. It can be useful if want to run the benchmarks very fast or if you want to run them for framework which we don't support. An example could be a local build of CoreCLR. Usage [InProcessAttribute] public class TypeWithBenchmarks { } Source code using System.Runtime.CompilerServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Order; using BenchmarkDotNet.Toolchains.InProcess.Emit; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [MemoryDiagnoser] public class IntroInProcess { private class Config : ManualConfig { public Config() { AddJob(Job.MediumRun .WithLaunchCount(1) .WithId(\"OutOfProc\")); AddJob(Job.MediumRun .WithLaunchCount(1) .WithToolchain(InProcessEmitToolchain.Instance) .WithId(\"InProcess\")); } } [Benchmark(Description = \"new byte[10kB]\")] public byte[] Allocate() { return new byte[10000]; } [Benchmark(Description = \"stackalloc byte[10kB]\")] public unsafe void AllocateWithStackalloc() { var array = stackalloc byte[10000]; Consume(array); } [MethodImpl(MethodImplOptions.NoInlining)] private static unsafe void Consume(byte* input) { } } } Output Links Toolchains The permanent link to this sample: BenchmarkDotNet.Samples.IntroInProcess"
  },
  "articles/samples/IntroInProcessWrongEnv.html": {
    "href": "articles/samples/IntroInProcessWrongEnv.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroInProcessWrongEnv Source code using System; using System.Runtime.CompilerServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Order; using BenchmarkDotNet.Toolchains.InProcess; using BenchmarkDotNet.Toolchains.InProcess.Emit; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [MemoryDiagnoser] public class IntroInProcessWrongEnv { private class Config : ManualConfig { public Config() { var wrongPlatform = Environment.Is64BitProcess ? Platform.X64 : Platform.X86; AddJob(Job.MediumRun .WithLaunchCount(1) .WithPlatform(wrongPlatform) .WithToolchain(InProcessEmitToolchain.Instance) .WithId(\"InProcess\")); AddValidator(InProcessValidator.DontFailOnError); } } [Benchmark(Description = \"new byte[10kB]\")] public byte[] Allocate() { return new byte[10000]; } [Benchmark(Description = \"stackalloc byte[10kB]\")] public unsafe void AllocateWithStackalloc() { var array = stackalloc byte[10000]; Consume(array); } [MethodImpl(MethodImplOptions.NoInlining)] private static unsafe void Consume(byte* input) { } } } Output Links Toolchains The permanent link to this sample: BenchmarkDotNet.Samples.IntroInProcessWrongEnv"
  },
  "articles/samples/IntroJitStatsDiagnoser.html": {
    "href": "articles/samples/IntroJitStatsDiagnoser.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroJitStatsDiagnoser This diagnoser shows various stats from the JIT compiler that were collected during entire benchmark run (warmup phase and BenchmarkDotNet-generated boilerplate code are included): Amount of JITted methods. Amount of tiered methods. How much memory JIT allocated during the benchmark. Restrictions Windows only Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [Diagnostics.Windows.Configs.JitStatsDiagnoser] public class IntroJitStatsDiagnoser { [Benchmark] public void Sleep() => Thread.Sleep(10); } } Output Method Mean Error StdDev Methods JITted Methods Tiered JIT allocated memory Sleep 15.50 ms 0.052 ms 0.048 ms 1,102 214 221,736 B Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroJitStatsDiagnoser"
  },
  "articles/samples/IntroJobBaseline.html": {
    "href": "articles/samples/IntroJobBaseline.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroJobBaseline If you want to compare several runtime configuration, you can mark one of your jobs with baseline = true. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [SimpleJob(runtimeMoniker: RuntimeMoniker.Net462, baseline: true)] [SimpleJob(runtimeMoniker: RuntimeMoniker.Mono)] [SimpleJob(runtimeMoniker: RuntimeMoniker.Net50)] public class IntroJobBaseline { [Benchmark] public int SplitJoin() => string.Join(\",\", new string[1000]).Split(',').Length; } } Output BenchmarkDotNet=v0.10.12, OS=Windows 10 Redstone 3 [1709, Fall Creators Update] (10.0.16299.192) Processor=Intel Core i7-6700HQ CPU 2.60GHz (Skylake), ProcessorCount=8 Frequency=2531249 Hz, Resolution=395.0619 ns, Timer=TSC .NET Core SDK=2.0.3 [Host] : .NET Core 2.0.3 (Framework 4.6.25815.02), 64bit RyuJIT Job-MXFYPZ : .NET Framework 4.7 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.2600.0 Core : .NET Core 2.0.3 (Framework 4.6.25815.02), 64bit RyuJIT Mono : Mono 5.4.0 (Visual Studio), 64bit Method | Runtime | Mean | Error | StdDev | Ratio | RatioSD | ---------- |-------- |---------:|----------:|----------:|------:|--------:| SplitJoin | Clr | 19.42 us | 0.2447 us | 0.1910 us | 1.00 | 0.00 | SplitJoin | Core | 13.00 us | 0.2183 us | 0.1935 us | 0.67 | 0.01 | SplitJoin | Mono | 39.14 us | 0.7763 us | 1.3596 us | 2.02 | 0.07 | Links Benchmark and Job Baselines The permanent link to this sample: BenchmarkDotNet.Samples.IntroJobBaseline"
  },
  "articles/samples/IntroJoin.html": {
    "href": "articles/samples/IntroJoin.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroJoin If you are using BenchmarkSwitcher and want to run all the benchmarks with a category from all types and join them into one summary table, use the --join option (or BenchmarkSwitcher.RunAllJoined): Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { // Run BenchmarkSwitcher with arguments: \"--join --category=IntroJoinA\" [DryJob] public class IntroJoin1 { [Benchmark] [BenchmarkCategory(\"IntroJoinA\")] public void A() => Thread.Sleep(10); [Benchmark] [BenchmarkCategory(\"IntroJoinB\")] public void B() => Thread.Sleep(10); } [DryJob] public class IntroJoin2 { [Benchmark] [BenchmarkCategory(\"IntroJoinA\")] public void A() => Thread.Sleep(10); [Benchmark] [BenchmarkCategory(\"IntroJoinB\")] public void B() => Thread.Sleep(10); } } Command line --join --allCategories=IntroJoinA Output | Type | Method | Mean | Error | |----------- |------- |---------:|------:| | IntroJoin1 | A | 10.99 ms | NA | | IntroJoin2 | A | 12.50 ms | NA | Links Filters The permanent link to this sample: BenchmarkDotNet.Samples.IntroJoin"
  },
  "articles/samples/IntroLargeAddressAware.html": {
    "href": "articles/samples/IntroLargeAddressAware.html",
    "title": "Sample: IntroLargeAddressAware | BenchmarkDotNet",
    "summary": "Sample: IntroLargeAddressAware Source code using System; using System.Runtime.InteropServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [MemoryDiagnoser] [Config(typeof(Config))] public class IntroLargeAddressAware { private class Config : ManualConfig { public Config() { AddJob(Job.Default .WithRuntime(ClrRuntime.Net462) .WithPlatform(Platform.X86) .WithLargeAddressAware(value: RuntimeInformation.IsOSPlatform(OSPlatform.Windows)) .WithId(\"Framework\")); } } [Benchmark] public void AllocateMoreThan2GB() { const int oneGB = 1024 * 1024 * 1024; const int halfGB = oneGB / 2; byte[] bytes1 = new byte[oneGB]; byte[] bytes2 = new byte[oneGB]; byte[] bytes3 = new byte[halfGB]; GC.KeepAlive(bytes1); GC.KeepAlive(bytes2); GC.KeepAlive(bytes3); } } } Links The permanent link to this sample: Sample: IntroLargeAddressAware"
  },
  "articles/samples/IntroMonitoring.html": {
    "href": "articles/samples/IntroMonitoring.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroMonitoring If a benchmark method takes at least 100ms, you can also use the Monitoring strategy. In this case, the pilot stage will be omitted, by default you get 1 iteration = 1 operation (or you can manually set amount of operation in an iteration). Also you can use [IterationSetup] and [IterationCleanup] in this case: it shouldn't affect time measurements (but it can affect results of MemoryDiagnoser). It's a perfect mode for benchmarks which doesn't have a steady state and the performance distribution is tricky: Monitoring will help you to collect a set of measurements and get statistics. Usage [SimpleJob(RunStrategy.Monitoring, launchCount: 10, warmupCount: 0, iterationCount: 100)] public class MyBenchmarkClass Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.Monitoring, iterationCount: 10, id: \"MonitoringJob\")] [MinColumn, Q1Column, Q3Column, MaxColumn] public class IntroMonitoring { private Random random = new Random(42); [Benchmark] public void Foo() { Thread.Sleep(random.Next(10) * 10); } } } Output Result 1: 1 op, 61552600.00 ns, 61.5526 ms/op Result 2: 1 op, 10141700.00 ns, 10.1417 ms/op Result 3: 1 op, 10482900.00 ns, 10.4829 ms/op Result 4: 1 op, 50410900.00 ns, 50.4109 ms/op Result 5: 1 op, 10421400.00 ns, 10.4214 ms/op Result 6: 1 op, 20556100.00 ns, 20.5561 ms/op Result 7: 1 op, 70473200.00 ns, 70.4732 ms/op Result 8: 1 op, 50581700.00 ns, 50.5817 ms/op Result 9: 1 op, 10559000.00 ns, 10.5590 ms/op Result 10: 1 op, 70496300.00 ns, 70.4963 ms/op Method Mean Error StdDev Min Q1 Q3 Max Foo 36.57 ms 40.03 ms 26.47 ms 10.14 ms 10.48 ms 61.55 ms 70.50 ms Links Choosing RunStrategy The permanent link to this sample: BenchmarkDotNet.Samples.IntroMonitoring"
  },
  "articles/samples/IntroMultimodal.html": {
    "href": "articles/samples/IntroMultimodal.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroMultimodal Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [MValueColumn] [SimpleJob(RunStrategy.Throughput, 1, 0, -1, 1, \"MyJob\")] public class IntroMultimodal { private readonly Random rnd = new Random(42); private void Multimodal(int n) => Thread.Sleep((rnd.Next(n) + 1) * 100); [Benchmark] public void Unimodal() => Multimodal(1); [Benchmark] public void Bimodal() => Multimodal(2); [Benchmark] public void Trimodal() => Multimodal(3); [Benchmark] public void Quadrimodal() => Multimodal(4); } } Output Method | Mean | Error | StdDev | Median | MValue | ------------ |---------:|-----------:|------------:|---------:|-------:| Unimodal | 100.5 ms | 0.0713 ms | 0.0667 ms | 100.5 ms | 2.000 | Bimodal | 144.5 ms | 16.9165 ms | 49.8787 ms | 100.6 ms | 3.571 | Trimodal | 182.5 ms | 27.4285 ms | 80.8734 ms | 200.5 ms | 4.651 | Quadrimodal | 226.6 ms | 37.2269 ms | 109.7644 ms | 200.7 ms | 5.882 | // * Warnings * MultimodalDistribution IntroMultimodal.Bimodal: MainJob -> It seems that the distribution is bimodal (mValue = 3.57) IntroMultimodal.Trimodal: MainJob -> It seems that the distribution is multimodal (mValue = 4.65) IntroMultimodal.Quadrimodal: MainJob -> It seems that the distribution is multimodal (mValue = 5.88) Links Statistics The permanent link to this sample: BenchmarkDotNet.Samples.IntroMultimodal"
  },
  "articles/samples/IntroNativeMemory.html": {
    "href": "articles/samples/IntroNativeMemory.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroNativeMemory The NativeMemoryProfiler uses EtwProfiler to profile the code using ETW and adds the extra columns Allocated native memory and Native memory leak to the benchmark results table. Source code using System; using System.Drawing; using System.Runtime.InteropServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnostics.Windows.Configs; using BenchmarkDotNet.Filters; namespace BenchmarkDotNet.Samples { [ShortRunJob] [NativeMemoryProfiler] [MemoryDiagnoser] public class IntroNativeMemory { #pragma warning disable CA1416 [Benchmark, WindowsOnly] public void BitmapWithLeaks() { var flag = new Bitmap(200, 100); var graphics = Graphics.FromImage(flag); var blackPen = new Pen(Color.Black, 3); graphics.DrawLine(blackPen, 100, 100, 500, 100); } [Benchmark, WindowsOnly] public void Bitmap() { using (var flag = new Bitmap(200, 100)) { using (var graphics = Graphics.FromImage(flag)) { using (var blackPen = new Pen(Color.Black, 3)) { graphics.DrawLine(blackPen, 100, 100, 500, 100); } } } } #pragma warning restore CA1416 private const int Size = 20; // Greater value could cause System.OutOfMemoryException for test with memory leaks. private int ArraySize = Size * Marshal.SizeOf(typeof(int)); [Benchmark] public unsafe void AllocHGlobal() { IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize); Span<byte> unmanaged = new Span<byte>(unmanagedHandle.ToPointer(), ArraySize); Marshal.FreeHGlobal(unmanagedHandle); } [Benchmark] public unsafe void AllocHGlobalWithLeaks() { IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize); Span<byte> unmanaged = new Span<byte>(unmanagedHandle.ToPointer(), ArraySize); } private class WindowsOnlyAttribute : FilterConfigBaseAttribute { public WindowsOnlyAttribute() : base(new SimpleFilter(_ => RuntimeInformation.IsOSPlatform(OSPlatform.Windows))) { } } } } Output Method Mean Error StdDev Gen 0 Gen 1 Gen 2 Allocated Allocated native memory Native memory leak BitmapWithLeaks 73,456.43 ns 22,498.10 ns 1,233.197 ns - - - 177 B 13183 B 11615 B Bitmap 91,590.08 ns 101,468.12 ns 5,561.810 ns - - - 180 B 12624 B - AllocHGlobal 79.91 ns 43.93 ns 2.408 ns - - - - 80 B - AllocHGlobalWithLeaks 103.50 ns 153.21 ns 8.398 ns - - - - 80 B 80 B Profiling memory leaks The BenchmarkDotNet repeats benchmarking function many times. Sometimes it can cause a memory overflow. In this case, the BenchmarkDotNet shows the message: OutOfMemoryException! BenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects. If your benchmark allocates memory and keeps it alive, you are creating a memory leak. You should redesign your benchmark and remove the side-effects. You can use `OperationsPerInvoke`, `IterationSetup` and `IterationCleanup` to do that. In this case, you should try to reduce the number of invocation, by adding [ShortRunJob] attribute or using Job.Short for custom configuration. Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroNativeMemory"
  },
  "articles/samples/IntroNuGet.html": {
    "href": "articles/samples/IntroNuGet.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroNuGet You can set specific versions of NuGet dependencies for each job using MsBuild properties in your csproj. It allows comparing different versions of the same package (if there are no breaking changes in API). Source code using System; using System.Collections.Immutable; using System.Linq; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { /// <summary> /// Benchmarks between various versions of a NuGet package /// </summary> /// <remarks> /// Only supported with CsProj toolchains. /// </remarks> [Config(typeof(Config))] public class IntroNuGet { // Setup your csproj like this: /* <PropertyGroup> <!-- Use 9.0.0 as default package version if not specified --> <SciVersion Condition=\"'$(SciVersion)' == ''\">9.0.0</SciVersion> </PropertyGroup> <ItemGroup> <PackageReference Include=\"System.Collections.Immutable\" Version=\"$(SciVersion)\" /> </ItemGroup> */ // All versions of the package must be source-compatible with your benchmark code. private class Config : ManualConfig { public Config() { string[] targetVersions = [ \"9.0.0\", \"9.0.3\", \"9.0.5\", ]; foreach (var version in targetVersions) { AddJob(Job.MediumRun .WithMsBuildArguments($\"/p:SciVersion={version}\") .WithId($\"v{version}\") ); } } } private static readonly Random rand = new Random(Seed: 0); private static readonly double[] values = Enumerable.Range(1, 10_000).Select(x => rand.NextDouble()).ToArray(); [Benchmark] public void ToImmutableArrayBenchmark() { var results = values.ToImmutableArray(); } } } Output Method Job Arguments Mean Error StdDev ToImmutableArrayBenchmark v9.0.0 /p:SciVersion=9.0.0 1.173 s 0.0057 s 0.0086 s ToImmutableArrayBenchmark v9.0.3 /p:SciVersion=9.0.3 1.173 s 0.0038 s 0.0058 s ToImmutableArrayBenchmark v9.0.5 /p:SciVersion=9.0.5 1.172 s 0.0107 s 0.0157 s Links The permanent link to this sample: BenchmarkDotNet.Samples.IntroNuGet"
  },
  "articles/samples/IntroOrderAttr.html": {
    "href": "articles/samples/IntroOrderAttr.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroOrderAttr Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Order; namespace BenchmarkDotNet.Samples { [Orderer(SummaryOrderPolicy.FastestToSlowest, MethodOrderPolicy.Declared)] [DryJob] public class IntroOrderAttr { [Params(1, 2, 3)] public int X { get; set; } [Benchmark] public void Slow() => Thread.Sleep(X * 100); [Benchmark] public void Fast() => Thread.Sleep(X * 50); } } Links Orderers The permanent link to this sample: BenchmarkDotNet.Samples.IntroOrderAttr"
  },
  "articles/samples/IntroOrderManual.html": {
    "href": "articles/samples/IntroOrderManual.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroOrderManual Source code using System.Collections.Generic; using System.Collections.Immutable; using System.Linq; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Order; using BenchmarkDotNet.Reports; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [DryJob] [RankColumn] public class IntroOrderManual { private class Config : ManualConfig { public Config() => Orderer = new FastestToSlowestOrderer(); private class FastestToSlowestOrderer : IOrderer { public IEnumerable<BenchmarkCase> GetExecutionOrder(ImmutableArray<BenchmarkCase> benchmarksCase, IEnumerable<BenchmarkLogicalGroupRule>? order = null) => from benchmark in benchmarksCase orderby benchmark.Parameters[\"X\"] descending, benchmark.Descriptor.WorkloadMethodDisplayInfo select benchmark; public IEnumerable<BenchmarkCase> GetSummaryOrder(ImmutableArray<BenchmarkCase> benchmarksCase, Summary summary) => from benchmark in benchmarksCase orderby summary[benchmark].ResultStatistics.Mean select benchmark; public string GetHighlightGroupKey(BenchmarkCase benchmarkCase) => null; public string GetLogicalGroupKey(ImmutableArray<BenchmarkCase> allBenchmarksCases, BenchmarkCase benchmarkCase) => benchmarkCase.Job.DisplayInfo + \"_\" + benchmarkCase.Parameters.DisplayInfo; public IEnumerable<IGrouping<string, BenchmarkCase>> GetLogicalGroupOrder(IEnumerable<IGrouping<string, BenchmarkCase>> logicalGroups, IEnumerable<BenchmarkLogicalGroupRule>? order = null) => logicalGroups.OrderBy(it => it.Key); public bool SeparateLogicalGroups => true; } } [Params(1, 2, 3)] public int X { get; set; } [Benchmark] public void Fast() => Thread.Sleep(X * 50); [Benchmark] public void Slow() => Thread.Sleep(X * 100); } } Links Orderers The permanent link to this sample: BenchmarkDotNet.Samples.IntroOrderManual"
  },
  "articles/samples/IntroOutliers.html": {
    "href": "articles/samples/IntroOutliers.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroOutliers Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; using Perfolizer.Mathematics.OutlierDetection; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] public class IntroOutliers { private class Config : ManualConfig { public Config() { var jobBase = Job.Default.WithWarmupCount(0).WithIterationCount(10).WithInvocationCount(1).WithUnrollFactor(1); AddJob(jobBase.WithOutlierMode(OutlierMode.DontRemove).WithId(\"DontRemoveOutliers\")); AddJob(jobBase.WithOutlierMode(OutlierMode.RemoveUpper).WithId(\"RemoveUpperOutliers\")); } } private int counter; [Benchmark] public void Foo() { counter++; int noise = counter % 10 == 0 ? 500 : 0; Thread.Sleep(100 + noise); } } } Output Method | Job | OutlierMode | Mean | Error | StdDev | ------- |-------------------- |------------ |---------:|------------:|------------:| Foo | DontRemoveOutliers | DontRemove | 150.5 ms | 239.1911 ms | 158.2101 ms | Foo | RemoveUpperOutliers | RemoveUpper | 100.5 ms | 0.1931 ms | 0.1149 ms | // * Hints * Outliers IntroOutliers.Foo: DontRemoveOutliers -> 1 outlier was detected IntroOutliers.Foo: RemoveUpperOutliers -> 1 outlier was removed Links Statistics The permanent link to this sample: BenchmarkDotNet.Samples.IntroOutliers"
  },
  "articles/samples/IntroParams.html": {
    "href": "articles/samples/IntroParams.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroParams You can mark one or several fields or properties in your class by the [Params] attribute. In this attribute, you can specify set of values. Every value must be a compile-time constant. As a result, you will get results for each combination of params values. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroParams { [Params(100, 200)] public int A { get; set; } [Params(10, 20)] public int B { get; set; } [Benchmark] public void Benchmark() => Thread.Sleep(A + B + 5); } } Output | Method | A | B | Mean | Error | StdDev | |---------- |---- |--- |---------:|--------:|--------:| | Benchmark | 100 | 10 | 115.3 ms | 0.13 ms | 0.12 ms | | Benchmark | 100 | 20 | 125.4 ms | 0.14 ms | 0.12 ms | | Benchmark | 200 | 10 | 215.5 ms | 0.19 ms | 0.18 ms | | Benchmark | 200 | 20 | 225.4 ms | 0.17 ms | 0.16 ms | Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroParams"
  },
  "articles/samples/IntroParamsAllValues.html": {
    "href": "articles/samples/IntroParamsAllValues.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroParamsAllValues If you want to use all possible values of an enum or another type with a small number of values, you can use the [ParamsAllValues] attribute, instead of listing all the values by hand. The types supported by the attribute are: bool any enum that is not marked with [Flags] Nullable<T>, where T is an enum or boolean Source code using BenchmarkDotNet.Attributes; using System.Threading; namespace BenchmarkDotNet.Samples { [DryJob] public class IntroParamsAllValues { public enum CustomEnum { One = 1, Two, Three } [ParamsAllValues] public CustomEnum E { get; set; } [ParamsAllValues] public bool? B { get; set; } [Benchmark] public void Benchmark() { Thread.Sleep( (int)E * 100 + (B == true ? 20 : B == false ? 10 : 0)); } } } Output Method | E | B | Mean | Error | ---------- |------ |------ |---------:|------:| Benchmark | One | ? | 101.4 ms | NA | Benchmark | One | False | 111.1 ms | NA | Benchmark | One | True | 122.0 ms | NA | Benchmark | Two | ? | 201.3 ms | NA | Benchmark | Two | False | 212.1 ms | NA | Benchmark | Two | True | 221.3 ms | NA | Benchmark | Three | ? | 301.4 ms | NA | Benchmark | Three | False | 311.5 ms | NA | Benchmark | Three | True | 320.8 ms | NA | Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroParamsAllValues"
  },
  "articles/samples/IntroParamsPriority.html": {
    "href": "articles/samples/IntroParamsPriority.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroParamsPriority In order to sort columns of parameters in the results table you can use the Property Priority inside the params attribute. The priority range is [Int32.MinValue;Int32.MaxValue], lower priorities will appear earlier in the column order. The default priority is set to 0. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroParamsPriority { [Params(100)] public int A { get; set; } [Params(10, Priority = -100)] public int B { get; set; } [Benchmark] public void Benchmark() => Thread.Sleep(A + B + 5); } } Output | Method | B | A | Mean | Error | StdDev | |---------- |--- |---- |---------:|--------:|--------:| | Benchmark | 10 | 100 | 115.4 ms | 0.12 ms | 0.11 ms | Links Priority BaseClass PriorityAttribute.cs Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroParamsPriority"
  },
  "articles/samples/IntroParamsSource.html": {
    "href": "articles/samples/IntroParamsSource.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroParamsSource In case you want to use a lot of values, you should use [ParamsSource] You can mark one or several fields or properties in your class by the [Params] attribute. In this attribute, you have to specify the name of public method/property which is going to provide the values (something that implements IEnumerable). The source may be instance or static. If the source is not in the same type as the benchmark, the type containing the source must be specified in the attribute constructor. Source code using System.Collections.Generic; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroParamsSource { // property with public setter [ParamsSource(nameof(ValuesForA))] public int A { get; set; } // public field [ParamsSource(nameof(ValuesForB))] public int B; // public property public IEnumerable<int> ValuesForA => new[] { 100, 200 }; // public static method public static IEnumerable<int> ValuesForB() => new[] { 10, 20 }; // public field getting its params from a method in another type [ParamsSource(typeof(ParamsValues), nameof(ParamsValues.ValuesForC))] public int C; [Benchmark] public void Benchmark() => Thread.Sleep(A + B + C + 5); } public static class ParamsValues { public static IEnumerable<int> ValuesForC() => new[] { 1000, 2000 }; } } Output | Method | B | A | Mean | Error | StdDev | |---------- |--- |---- |---------:|--------:|--------:| | Benchmark | 10 | 100 | 115.5 ms | 0.17 ms | 0.16 ms | | Benchmark | 10 | 200 | 215.6 ms | 0.15 ms | 0.14 ms | | Benchmark | 20 | 100 | 125.5 ms | 0.19 ms | 0.18 ms | | Benchmark | 20 | 200 | 225.5 ms | 0.23 ms | 0.22 ms | Remarks A remark about IParam. You don't need to use IParam anymore since 0.11.0. Just use complex types as you wish and override ToString method to change the display names used in the results. Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroParamsSource"
  },
  "articles/samples/IntroPercentiles.html": {
    "href": "articles/samples/IntroPercentiles.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroPercentiles The percentile represents a higher boundary for specified percentage of the measurements. For example, 95th percentile = 500ms means that 95% of all samples are not slower than 500ms. This metric is not very useful in microbenchmarks, as the values from consequent runs have a very narrow distribution. However, real-world scenarios often have so-called long tail distribution (due to IO delays, locks, memory access latency and so on), so the average execution time cannot be trusted. The percentiles allow to include the tail of distribution into the comparison. However, it requires some preparations steps. At first, you should have enough runs to count percentiles from. The IterationCount in the config should be set to 10-20 runs at least. Second, the count of iterations for each run should not be very high, or the peak timings will be averaged. The IterationTime = 25 works fine for most cases; for long-running benchmarks the Mode = Mode.SingleRun will be the best choice. However, feel free to experiment with the config values. Third, if you want to be sure that measurements are repeatable, set the LaunchCount to 3 or higher. And last, don't forget to include the columns into the config. They are not included by default (as said above, these are not too useful for most of the benchmarks). There're predefined StatisticColumn.P0..StatisticColumn.P100 for absolute timing percentiles. Example Run the IntroPercentiles sample. It contains three benchmark methods. First delays for 20 ms constantly. The second has random delays for 10..30 ms. And the third delays for 10ms 85 times of 100 and delays for 40ms 15 times of 100. Here's the output from the benchmark (some columns removed for brevity): Method Median StdDev Ratio P0 P50 P80 P85 P95 P100 ConstantDelays 20.3813 ms 0.2051 ms 1.00 20.0272 ms 20.3813 ms 20.4895 ms 20.4954 ms 20.5869 ms 21.1471 ms RandomDelays 19.8055 ms 5.7556 ms 0.97 10.0793 ms 19.8055 ms 25.4173 ms 26.5187 ms 29.0313 ms 29.4550 ms RareDelays 10.3385 ms 11.4828 ms 0.51 10.0157 ms 10.3385 ms 10.5211 ms 40.0560 ms 40.3992 ms 40.4674 ms Also, it's very easy to screw the results with incorrect setup. For example, the same code being run with new Job { IterationCount = 5, IterationTime = 500 } completely hides the peak values: Method Median StdDev Ratio P0 P50 P80 P85 P95 P100 ConstantDelays 20.2692 ms 0.0308 ms 1.00 20.1986 ms 20.2692 ms 20.2843 ms 20.2968 ms 20.3097 ms 20.3122 ms RandomDelays 18.9965 ms 0.8601 ms 0.94 18.1339 ms 18.9965 ms 19.8126 ms 19.8278 ms 20.4485 ms 20.9466 ms RareDelays 14.0912 ms 2.8619 ms 0.70 10.2606 ms 14.0912 ms 15.7653 ms 17.3862 ms 18.6728 ms 18.6940 ms Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Columns; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { // Using percentiles for adequate timings representation [Config(typeof(Config))] [SimpleJob(RunStrategy.ColdStart, launchCount: 4, warmupCount: 3, iterationCount: 20, id: \"MyJob\")] public class IntroPercentiles { // To share between runs. // DO NOT do this in production code. The System.Random IS NOT thread safe. private static readonly Random Rnd = new Random(); private class Config : ManualConfig { public Config() { AddColumn( StatisticColumn.P0, StatisticColumn.P25, StatisticColumn.P50, StatisticColumn.P67, StatisticColumn.P80, StatisticColumn.P85, StatisticColumn.P90, StatisticColumn.P95, StatisticColumn.P100); } } [Benchmark(Baseline = true)] public void ConstantDelays() => Thread.Sleep(20); [Benchmark] public void RandomDelays() => Thread.Sleep(10 + (int) (20 * Rnd.NextDouble())); [Benchmark] public void RareDelays() { int rndTime = 10; // Bigger delays for 15% of the runs if (Rnd.NextDouble() > 0.85) { rndTime += 30; } Thread.Sleep(rndTime); } } } Links Statistics The permanent link to this sample: BenchmarkDotNet.Samples.IntroPercentiles"
  },
  "articles/samples/IntroPowerPlan.html": {
    "href": "articles/samples/IntroPowerPlan.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroPowerPlan This sample shows how we can manipulate with power plans. In BenchmarkDotNet we could change power plan in two ways. The first one is to set one from the list: PowerSaver, guid: a1841308-3541-4fab-bc81-f71556f20b4a Balanced, guid: 381b4222-f694-41f0-9685-ff5bb260df2e High-Performance, guid: 8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c (the default one) Ultimate Performance, guid: e9a42b02-d5df-448d-aa00-03f14749eb61 UserPowerPlan (a current power plan set in computer) The second one rely on guid string. We could easily found currently set GUIDs with cmd command powercfg /list If we set power plans in two ways at the same time, the second one will be used. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using System; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] public class IntroPowerPlan { private class Config : ManualConfig { public Config() { AddJob(Job.MediumRun.WithPowerPlan(new Guid(\"e9a42b02-d5df-448d-aa00-03f14749eb61\"))); AddJob(Job.MediumRun.WithPowerPlan(PowerPlan.UltimatePerformance)); AddJob(Job.MediumRun.WithPowerPlan(PowerPlan.UserPowerPlan)); AddJob(Job.MediumRun.WithPowerPlan(PowerPlan.HighPerformance)); AddJob(Job.MediumRun.WithPowerPlan(PowerPlan.Balanced)); AddJob(Job.MediumRun.WithPowerPlan(PowerPlan.PowerSaver)); } } [Benchmark] public int IterationTest() { int j = 0; for (int i = 0; i < short.MaxValue; ++i) { j = i; } return j; } [Benchmark] public int SplitJoin() => string.Join(\",\", new string[1000]).Split(',').Length; } } Links Power Plans The permanent link to this sample: BenchmarkDotNet.Samples.IntroPowerPlan"
  },
  "articles/samples/IntroRankColumn.html": {
    "href": "articles/samples/IntroRankColumn.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroRankColumn Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Mathematics; using BenchmarkDotNet.Order; namespace BenchmarkDotNet.Samples { [ShortRunJob] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [RankColumn(NumeralSystem.Arabic)] [RankColumn(NumeralSystem.Roman)] [RankColumn(NumeralSystem.Stars)] public class IntroRankColumn { [Params(1, 2)] public int Factor; [Benchmark] public void Foo() => Thread.Sleep(Factor * 100); [Benchmark] public void Bar() => Thread.Sleep(Factor * 200); } } Output Method | Factor | Mean | Error | StdDev | Rank | Rank | Rank | ------- |------- |---------:|---------:|----------:|-----:|-----:|-----:| Foo | 1 | 100.8 ms | 2.250 ms | 0.1272 ms | 1 | I | * | Foo | 2 | 200.8 ms | 4.674 ms | 0.2641 ms | 2 | II | ** | Bar | 1 | 200.9 ms | 2.012 ms | 0.1137 ms | 2 | II | ** | Bar | 2 | 400.7 ms | 4.509 ms | 0.2548 ms | 3 | III | *** | Links Statistics The permanent link to this sample: BenchmarkDotNet.Samples.IntroRankColumn"
  },
  "articles/samples/IntroRatioSD.html": {
    "href": "articles/samples/IntroRatioSD.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroRatioSD The ratio of two benchmarks is not a single number, it's a distribution. In most simple cases, the range of the ratio distribution is narrow, and BenchmarkDotNet displays a single column Ratio with the mean value. However, it also adds the RatioSD column (the standard deviation of the ratio distribution) in complex situations. In the below example, the baseline benchmark is spoiled by a single outlier Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; using Perfolizer.Mathematics.OutlierDetection; namespace BenchmarkDotNet.Samples { // Don't remove outliers [Outliers(OutlierMode.DontRemove)] // Skip jitting, pilot, warmup; measure 10 iterations [SimpleJob(RunStrategy.Monitoring, iterationCount: 10, invocationCount: 1)] public class IntroRatioSD { private int counter; [GlobalSetup] public void Setup() => counter = 0; [Benchmark(Baseline = true)] public void Base() { Thread.Sleep(100); if (++counter % 7 == 0) Thread.Sleep(5000); // Emulate outlier } [Benchmark] public void Slow() => Thread.Sleep(200); [Benchmark] public void Fast() => Thread.Sleep(50); } } Output Here are statistics details for the baseline benchmark: Mean = 600.6054 ms, StdErr = 500.0012 ms (83.25%); N = 10, StdDev = 1,581.1428 ms Min = 100.2728 ms, Q1 = 100.3127 ms, Median = 100.4478 ms, Q3 = 100.5011 ms, Max = 5,100.6163 ms IQR = 0.1884 ms, LowerFence = 100.0301 ms, UpperFence = 100.7837 ms ConfidenceInterval = [-1,789.8568 ms; 2,991.0677 ms] (CI 99.9%), Margin = 2,390.4622 ms (398.01% of Mean) Skewness = 2.28, Kurtosis = 6.57, MValue = 2 -------------------- Histogram -------------------- [-541.891 ms ; 743.427 ms) | @@@@@@@@@ [ 743.427 ms ; 2027.754 ms) | [2027.754 ms ; 3312.082 ms) | [3312.082 ms ; 4458.453 ms) | [4458.453 ms ; 5742.780 ms) | @ --------------------------------------------------- As you can see, a single outlier significantly affected the metrics. Because of this, BenchmarkDotNet adds the Median and the RatioSD columns in the summary table: Method | Mean | Error | StdDev | Median | Ratio | RatioSD | ------- |----------:|--------------:|--------------:|----------:|------:|--------:| Base | 600.61 ms | 2,390.4622 ms | 1,581.1428 ms | 100.45 ms | 1.00 | 0.00 | Slow | 200.50 ms | 0.4473 ms | 0.2959 ms | 200.42 ms | 1.80 | 0.62 | Fast | 50.54 ms | 0.3435 ms | 0.2272 ms | 50.48 ms | 0.45 | 0.16 | Let's look at the Base and Slow benchmarks. The Mean values are 600 and 200 milliseconds; the \"Scaled Mean\" value is 0.3. The Median values are 100 and 200 milliseconds; the \"Scaled Median\" value is 2. Both values are misleading. BenchmarkDotNet evaluates the ratio distribution and displays the mean (1.80) and the standard deviation (0.62). Links Benchmark and Job Baselines The permanent link to this sample: BenchmarkDotNet.Samples.IntroRatioSD"
  },
  "articles/samples/IntroRatioStyle.html": {
    "href": "articles/samples/IntroRatioStyle.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroRatioStyle Using RatioStyle, we can override the style of the \"Ratio\" column in SummaryStyle. Here are the possible values: Value: default value that shows the ration value between the current benchmark and the baseline benchmark (e.g., 0.15 or 1.15) Percentage: express the ration in percentage (e.g., -85% or +15%) Trend: shows how much the current benchmark is faster or slower than the base benchmark (e.g., 6.63x faster or 1.15x slower) Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Columns; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Reports; namespace BenchmarkDotNet.Samples { [ShortRunJob, Config(typeof(Config))] public class IntroRatioStyle { [Benchmark(Baseline = true)] public void Baseline() => Thread.Sleep(1000); [Benchmark] public void Bar() => Thread.Sleep(150); [Benchmark] public void Foo() => Thread.Sleep(1150); private class Config : ManualConfig { public Config() { SummaryStyle = SummaryStyle.Default.WithRatioStyle(RatioStyle.Trend); } } } } Output With the given RatioStyle.Trend, we have the following table: | Method | Mean | Error | StdDev | Ratio | RatioSD | |--------- |-----------:|--------:|--------:|-------------:|--------:| | Baseline | 1,000.6 ms | 2.48 ms | 0.14 ms | baseline | | | Bar | 150.9 ms | 1.30 ms | 0.07 ms | 6.63x faster | 0.00x | | Foo | 1,150.4 ms | 5.17 ms | 0.28 ms | 1.15x slower | 0.00x | With the default RatioStyle.Value, we get the following table: | Method | Mean | Error | StdDev | Ratio | |--------- |-----------:|--------:|--------:|------:| | Baseline | 1,000.3 ms | 2.71 ms | 0.15 ms | 1.00 | | Bar | 150.6 ms | 1.67 ms | 0.09 ms | 0.15 | | Foo | 1,150.6 ms | 7.41 ms | 0.41 ms | 1.15 | If we use RatioStyle.Percentage, we get the following table: | Method | Mean | Error | StdDev | Ratio | RatioSD | |--------- |-----------:|--------:|--------:|---------:|--------:| | Baseline | 1,000.3 ms | 4.69 ms | 0.26 ms | baseline | | | Bar | 150.7 ms | 1.42 ms | 0.08 ms | -85% | 0.1% | | Foo | 1,150.3 ms | 6.13 ms | 0.34 ms | +15% | 0.0% | Links Benchmark and Job Baselines The permanent link to this sample: BenchmarkDotNet.Samples.IntroRatioStyle"
  },
  "articles/samples/IntroSetupCleanupGlobal.html": {
    "href": "articles/samples/IntroSetupCleanupGlobal.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroSetupCleanupGlobal A method which is marked by the [GlobalSetup] attribute will be executed only once per a benchmarked method after initialization of benchmark parameters and before all the benchmark method invocations. A method which is marked by the [GlobalCleanup] attribute will be executed only once per a benchmarked method after all the benchmark method invocations. If you are using some unmanaged resources (e.g., which were created in the GlobalSetup method), they can be disposed in the GlobalCleanup method. Source code using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroSetupCleanupGlobal { [Params(10, 100, 1000)] public int N; private int[] data; [GlobalSetup] public void GlobalSetup() { data = new int[N]; // executed once per each N value } [Benchmark] public int Logic() { int res = 0; for (int i = 0; i < N; i++) res += data[i]; return res; } [GlobalCleanup] public void GlobalCleanup() { // Disposing logic } } } Links Setup And Cleanup The permanent link to this sample: BenchmarkDotNet.Samples.IntroSetupCleanupGlobal"
  },
  "articles/samples/IntroSetupCleanupIteration.html": {
    "href": "articles/samples/IntroSetupCleanupIteration.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroSetupCleanupIteration A method which is marked by the [IterationSetup] attribute will be executed exactly once before each benchmark invocation, forcing UnrollFactor=1 and InvocationCount=1 (we have changed that in 0.11.0). It's not recommended to use this attribute in microbenchmarks because it can spoil the results. However, if you are writing a macrobenchmark (e.g. a benchmark which takes at least 100ms) and you want to prepare some data before each invocation, [IterationSetup] can be useful. A method which is marked by the [IterationCleanup] attribute will be executed exactly once after each invocation. This attribute has the same set of constraint with [IterationSetup]: it's not recommended to use [IterationCleanup] in microbenchmarks. Source code using System; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.Monitoring, launchCount: 1, warmupCount: 2, iterationCount: 3)] public class IntroSetupCleanupIteration { private int setupCounter; private int cleanupCounter; [IterationSetup] public void IterationSetup() => Console.WriteLine($\"// IterationSetup ({++setupCounter})\"); [IterationCleanup] public void IterationCleanup() => Console.WriteLine($\"// IterationCleanup ({++cleanupCounter})\"); [GlobalSetup] public void GlobalSetup() => Console.WriteLine(\"// \" + \"GlobalSetup\"); [GlobalCleanup] public void GlobalCleanup() => Console.WriteLine(\"// \" + \"GlobalCleanup\"); [Benchmark] public void Benchmark() => Console.WriteLine(\"// \" + \"Benchmark\"); } } The order of method calls // GlobalSetup // IterationSetup (1) // IterationSetup Jitting // IterationCleanup (1) // IterationCleanup Jitting // IterationSetup (2) // MainWarmup1 // Benchmark // MainWarmup1 // IterationCleanup (2) // MainWarmup1 // IterationSetup (3) // MainWarmup2 // Benchmark // MainWarmup2 // IterationCleanup (3) // MainWarmup2 // IterationSetup (4) // MainTarget1 // Benchmark // MainTarget1 // IterationCleanup (4) // MainTarget1 // IterationSetup (5) // MainTarget2 // Benchmark // MainTarget2 // IterationCleanup (5) // MainTarget2 // IterationSetup (6) // MainTarget3 // Benchmark // MainTarget3 // IterationCleanup (6) // MainTarget3 // GlobalCleanup Links Setup And Cleanup The permanent link to this sample: BenchmarkDotNet.Samples.IntroSetupCleanupIteration"
  },
  "articles/samples/IntroSetupCleanupTarget.html": {
    "href": "articles/samples/IntroSetupCleanupTarget.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroSetupCleanupTarget Sometimes it's useful to run setup or cleanups for specific benchmarks. All four setup and cleanup attributes have a Target property that allow the setup/cleanup method to be run for one or more specific benchmark methods. Source code using System; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.Monitoring, launchCount: 0, warmupCount: 0, iterationCount: 1)] public class IntroSetupCleanupTarget { [GlobalSetup(Target = nameof(BenchmarkA))] public void GlobalSetupA() => Console.WriteLine(\"// \" + \"GlobalSetup A\"); [Benchmark] public void BenchmarkA() => Console.WriteLine(\"// \" + \"Benchmark A\"); [GlobalSetup(Targets = new[] { nameof(BenchmarkB), nameof(BenchmarkC) })] public void GlobalSetupB() => Console.WriteLine(\"// \" + \"GlobalSetup B\"); [Benchmark] public void BenchmarkB() => Console.WriteLine(\"// \" + \"Benchmark B\"); [Benchmark] public void BenchmarkC() => Console.WriteLine(\"// \" + \"Benchmark C\"); [Benchmark] public void BenchmarkD() => Console.WriteLine(\"// \" + \"Benchmark D\"); } } The order of method calls // GlobalSetup A // Benchmark A // GlobalSetup B // Benchmark B // GlobalSetup B // Benchmark C // Benchmark D Links Setup And Cleanup The permanent link to this sample: BenchmarkDotNet.Samples.IntroSetupCleanupTarget"
  },
  "articles/samples/IntroStaThread.html": {
    "href": "articles/samples/IntroStaThread.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroStaThread If the code you want to benchmark requires [System.STAThread] then you need to apply this attribute to the benchmarked method. BenchmarkDotNet will generate an executable with [STAThread] applied to its Main method. Using this feature on .NET Core requires .NET Core 2.1 or newer. Older versions will not work due to this bug. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroStaThread { [Benchmark, System.STAThread] public void CheckForSTA() { if (Thread.CurrentThread.GetApartmentState() != ApartmentState.STA) { throw new ThreadStateException( \"The current threads apartment state is not STA\"); } } } } Links Customizing Runtime The permanent link to this sample: BenchmarkDotNet.Samples.IntroStaThread"
  },
  "articles/samples/IntroStatisticalTesting.html": {
    "href": "articles/samples/IntroStatisticalTesting.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroStatisticalTesting Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [StatisticalTestColumn(\"500us\")] [StatisticalTestColumn(\"3%\")] [SimpleJob(warmupCount: 0, iterationCount: 5)] public class IntroStatisticalTesting { [Benchmark] public void Sleep50() => Thread.Sleep(50); [Benchmark] public void Sleep97() => Thread.Sleep(97); [Benchmark] public void Sleep99() => Thread.Sleep(99); [Benchmark(Baseline = true)] public void Sleep100() => Thread.Sleep(100); [Benchmark] public void Sleep101() => Thread.Sleep(101); [Benchmark] public void Sleep103() => Thread.Sleep(103); [Benchmark] public void Sleep150() => Thread.Sleep(150); } } Output | Method | Mean | Error | StdDev | Ratio | Welch(1us)/p-values | Welch(3%)/p-values | MannWhitney(1us)/p-values | MannWhitney(3%)/p-values | |--------- |----------:|----------:|----------:|------:|---------------------- |---------------------- |-------------------------- |------------------------- | | Sleep50 | 53.13 ms | 0.5901 ms | 0.1532 ms | 0.51 | Faster: 1.0000/0.0000 | Faster: 1.0000/0.0000 | Faster: 1.0000/0.0040 | Faster: 1.0000/0.0040 | | Sleep97 | 100.07 ms | 0.9093 ms | 0.2361 ms | 0.97 | Faster: 1.0000/0.0000 | Same: 1.0000/0.1290 | Faster: 1.0000/0.0040 | Same: 1.0000/0.1111 | | Sleep99 | 102.23 ms | 2.4462 ms | 0.6353 ms | 0.99 | Faster: 0.9928/0.0072 | Same: 1.0000/0.9994 | Faster: 0.9960/0.0079 | Same: 1.0000/1.0000 | | Sleep100 | 103.34 ms | 0.8180 ms | 0.2124 ms | 1.00 | Base: 0.5029/0.5029 | Base: 1.0000/1.0000 | Base: 0.7262/0.7262 | Base: 1.0000/1.0000 | | Sleep101 | 103.73 ms | 2.1591 ms | 0.5607 ms | 1.00 | Same: 0.1041/0.8969 | Same: 0.9999/1.0000 | Same: 0.1111/0.9246 | Same: 1.0000/1.0000 | | Sleep103 | 106.21 ms | 1.2511 ms | 0.3249 ms | 1.03 | Slower: 0.0000/1.0000 | Same: 0.9447/1.0000 | Slower: 0.0040/1.0000 | Same: 0.9246/1.0000 | | Sleep150 | 153.16 ms | 3.4929 ms | 0.9071 ms | 1.48 | Slower: 0.0000/1.0000 | Slower: 0.0000/1.0000 | Slower: 0.0040/1.0000 | Slower: 0.0040/1.0000 | // * Legends * Mean : Arithmetic mean of all measurements Error : Half of 99.9% confidence interval StdDev : Standard deviation of all measurements Ratio : Mean of the ratio distribution ([Current]/[Baseline]) Welch(1us)/p-values : Welch-based TOST equivalence test with 1 us threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' Welch(3%)/p-values : Welch-based TOST equivalence test with 3% threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' MannWhitney(1us)/p-values : MannWhitney-based TOST equivalence test with 1 us threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' MannWhitney(3%)/p-values : MannWhitney-based TOST equivalence test with 3% threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' 1 ms : 1 Millisecond (0.001 sec) Links The permanent link to this sample: BenchmarkDotNet.Samples.IntroStatisticalTesting"
  },
  "articles/samples/IntroStatisticsColumns.html": {
    "href": "articles/samples/IntroStatisticsColumns.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroStatisticsColumns Source code using System; using System.Security.Cryptography; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [MediumRunJob, SkewnessColumn, KurtosisColumn] public class IntroStatisticsColumns { private const int N = 10000; private readonly byte[] data; private readonly MD5 md5 = MD5.Create(); private readonly SHA256 sha256 = SHA256.Create(); public IntroStatisticsColumns() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark(Baseline = true)] public byte[] Md5A() => md5.ComputeHash(data); [Benchmark] public byte[] Md5B() => md5.ComputeHash(data); [Benchmark] public byte[] Sha256() => sha256.ComputeHash(data); } } Output Method Mean Error StdDev Skewness Kurtosis Ratio RatioSD Md5A 15.91 us 0.0807 us 0.1209 us 0.4067 1.646 1.00 0.00 Md5B 15.89 us 0.0709 us 0.1062 us 0.5893 2.141 1.00 0.01 Sha256 36.62 us 0.6390 us 0.9564 us 1.1363 4.014 2.30 0.06 Links Statistics The permanent link to this sample: BenchmarkDotNet.Samples.IntroStatisticsColumns"
  },
  "articles/samples/IntroStopOnFirstError.html": {
    "href": "articles/samples/IntroStopOnFirstError.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroStopOnFirstError BenchmarkDotNet can be configured to stop on first error. You just have to add StopOnFirstError attribute to your class or use --stopOnFirstError command line argument. Source code using System; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [StopOnFirstError] public class IntroStopOnFirstError { [Benchmark(Baseline = true)] public int FirstMethod() => throw new Exception(\"Example exception.\"); [Benchmark] public int SecondMethod() => 1; } } Links Configs How to use console arguments The permanent link to this sample: BenchmarkDotNet.Samples.IntroStopOnFirstError"
  },
  "articles/samples/IntroSummaryStyle.html": {
    "href": "articles/samples/IntroSummaryStyle.html",
    "title": "| BenchmarkDotNet",
    "summary": "SummaryStyle in BenchmarkDotNet SummaryStyle is a class in BenchmarkDotNet that allows customization of the summary reports of benchmark results. It offers several properties to fine-tune how the results are displayed. Usage You can customize the summary report by specifying various properties of SummaryStyle. These properties include formatting options like whether to print units in the header or content, setting the maximum width for parameter columns, and choosing units for size and time measurements. Source Code using System.Globalization; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Reports; using Perfolizer.Horology; using Perfolizer.Metrology; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] public class IntroSummaryStyle { private class Config : ManualConfig { public Config() { // Configure the summary style here var summaryStyle = new SummaryStyle ( cultureInfo: CultureInfo.InvariantCulture, printUnitsInHeader: true, printUnitsInContent: false, sizeUnit: SizeUnit.KB, timeUnit: TimeUnit.Nanosecond, maxParameterColumnWidth: 20 ); WithSummaryStyle(summaryStyle); } } [Params(10, 100)] public int N; [Benchmark] public void Sleep() => System.Threading.Thread.Sleep(N); } } Properties PrintUnitsInHeader: Boolean to indicate if units should be printed in the header. PrintUnitsInContent: Boolean to control unit printing in the content. PrintZeroValuesInContent: Determines if zero values should be printed. MaxParameterColumnWidth: Integer defining the max width for parameter columns. SizeUnit: Optional SizeUnit to specify the unit for size measurements. TimeUnit: Optional TimeUnit for time measurement units. CultureInfo: CultureInfo to define culture-specific formatting. Example Output Using SummaryStyle options: | Method | N | Mean [ns] | Error [ns] | StdDev [ns] | |------- |---- |--------------:|-----------:|------------:| | Sleep | 10 | 15,644,973.1 | 32,808.7 | 30,689.3 | | Sleep | 100 | 109,440,686.7 | 236,673.8 | 221,384.8 | Default: | Method | N | Mean | Error | StdDev | |------- |---- |----------:|---------:|---------:| | Sleep | 10 | 15.65 ms | 0.039 ms | 0.034 ms | | Sleep | 100 | 109.20 ms | 0.442 ms | 0.392 ms | Links @docs.SummaryStyle The permanent link to this sample: @BenchmarkDotNet.Samples.IntroSummaryStyle"
  },
  "articles/samples/IntroTagColumn.html": {
    "href": "articles/samples/IntroTagColumn.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroTagColumn In the following example, we introduce two new columns which contains a tag based on a benchmark method name. Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Columns; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { // You can add custom tags per each method using Columns [Config(typeof(Config))] public class IntroTagColumn { private class Config : ManualConfig { public Config() { AddJob(Job.Dry); AddColumn(new TagColumn(\"Kind\", name => name.Substring(0, 3))); AddColumn(new TagColumn(\"Number\", name => name.Substring(3))); } } [Benchmark] public void Foo1() => Thread.Sleep(10); [Benchmark] public void Foo12() => Thread.Sleep(10); [Benchmark] public void Bar3() => Thread.Sleep(10); [Benchmark] public void Bar34() => Thread.Sleep(10); } } Output | Method | Mean | Kind | Number | | ------ | ---------- | ---- | ------ | | Bar34 | 10.3636 ms | Bar | 34 | | Bar3 | 10.4662 ms | Bar | 3 | | Foo12 | 10.1377 ms | Foo | 12 | | Foo1 | 10.2814 ms | Foo | 1 | Links Columns The permanent link to this sample: BenchmarkDotNet.Samples.IntroTagColumn"
  },
  "articles/samples/IntroTailcall.html": {
    "href": "articles/samples/IntroTailcall.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroTailcall You need to use the TailcallDiagnoser attribute to configure it. The available options are: logFailuresOnly: Track only the methods that failed to get tail called. True by default. filterByNamespace : Track only the methods from declaring type's namespace. Set to false if you want to see all Jit tail events. True by default. Restrictions Windows only x64 Source code using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [Diagnostics.Windows.Configs.TailCallDiagnoser] [LegacyJitX86Job, LegacyJitX64Job, RyuJitX64Job] public class IntroTailcall { [Benchmark] public long Calc() => FactorialWithoutTailing(7) - FactorialWithTailing(7); private static long FactorialWithoutTailing(int depth) => depth == 0 ? 1 : depth * FactorialWithoutTailing(depth - 1); private static long FactorialWithTailing(int pos, int depth) => pos == 0 ? depth : FactorialWithTailing(pos - 1, depth * pos); private static long FactorialWithTailing(int depth) => FactorialWithTailing(depth - 1, depth); } } Output // * Diagnostic Output - TailCallDiagnoser * -------------------- -------------------- Jit_TailCalling.Calc: LegacyJitX64(Jit=LegacyJit, Platform=X64, Runtime=Clr) -------------------- -------------------- Jit_TailCalling.Calc: LegacyJitX86(Jit=LegacyJit, Platform=X86, Runtime=Clr) -------------------- -------------------- Jit_TailCalling.Calc: RyuJitX64(Jit=RyuJit, Platform=X64) -------------------- Caller: <null>.<null> - <null> Callee: BenchmarkDotNet.Samples.JIT.Jit_TailCalling.FactorialWithTailing - int64 (int32,int32) Tail prefix: False Tail call type: RecursiveLoop ------------------- Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroTailcall"
  },
  "articles/samples/IntroThreadingDiagnoser.html": {
    "href": "articles/samples/IntroThreadingDiagnoser.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroThreadingDiagnoser The ThreadingDiagnoser uses new APIs exposed in .NET Core 3.0 to report: Completed Work Items: The number of work items that have been processed in ThreadPool (per single operation) Lock Contentions: The number of times there was contention upon trying to take a Monitor's lock (per single operation) Source code using BenchmarkDotNet.Attributes; using System.Threading; namespace BenchmarkDotNet.Samples { [ThreadingDiagnoser] // ENABLE the diagnoser public class IntroThreadingDiagnoser { [Benchmark] public void CompleteOneWorkItem() { ManualResetEvent done = new ManualResetEvent(initialState: false); ThreadPool.QueueUserWorkItem(m => (m as ManualResetEvent).Set(), done); done.WaitOne(); } } } Output Method Mean StdDev Median Completed Work Items Lock Contentions CompleteOneWorkItem 8,073.5519 ns 69.7261 ns 8,111.6074 ns 1.0000 - Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroThreadingDiagnoser"
  },
  "articles/samples/IntroUnicode.html": {
    "href": "articles/samples/IntroUnicode.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroUnicode Some of the BenchmarkDotNet exporters use Unicode symbols that are not ASCII-compatible (e.g.,  or ). Unfortunately, some terminals are not supported such symbols. That's why BenchmarkDotNet prints only ASCII characters by default ( will be replaced by u). If you want to display Unicode symbols in your terminal, you should use [UnicodeConsoleLoggerAttribute] (see usage examples below). Warning This feature works only with terminal(s)|text editor(s) that support Unicode. On Windows, you may have some troubles with Unicode symbols if system default code page configured as non-English (in Control Panel + Regional and Language Options, Language for Non-Unicode Programs). Source code using System.Diagnostics; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Loggers; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { // *** Attribute Style *** [UnicodeConsoleLogger] public class IntroUnicode { [Benchmark] public long Foo() { long waitUntil = Stopwatch.GetTimestamp() + 1000; while (Stopwatch.GetTimestamp() < waitUntil) { } return waitUntil; } } // *** Object Style *** [Config(typeof(Config))] public class IntroUnicodeObjectStyle { private class Config : ManualConfig { public Config() => AddLogger(ConsoleLogger.Unicode); } [Benchmark] public long Foo() { long waitUntil = Stopwatch.GetTimestamp() + 1000; while (Stopwatch.GetTimestamp() < waitUntil) { } return waitUntil; } } // *** Fluent Config *** public class IntroUnicodeFluentConfig { public static void Run() { BenchmarkRunner.Run<IntroUnicodeFluentConfig>( DefaultConfig.Instance .AddLogger(ConsoleLogger.Unicode)); } [Benchmark] public long Foo() { long waitUntil = Stopwatch.GetTimestamp() + 1000; while (Stopwatch.GetTimestamp() < waitUntil) { } return waitUntil; } } } Output Mean = 1.0265 s, StdErr = 0.0005 s (0.05%); N = 15, StdDev = 0.0018 s Min = 1.0239 s, Q1 = 1.0248 s, Median = 1.0264 s, Q3 = 1.0280 s, Max = 1.0296 s IQR = 0.0033 s, LowerFence = 1.0199 s, UpperFence = 1.0329 s ConfidenceInterval = [1.0245 s; 1.0285 s] (CI 99.9%), Margin = 0.0020 s (0.19% of Mean) Skewness = 0.12, Kurtosis = 1.56, MValue = 2 -------------------- Histogram -------------------- [1.023 s ; 1.030 s) | @@@@@@@@@@@@@@@ --------------------------------------------------- Method | Mean | Error | StdDev | ------- |---------:|----------:|----------:| Foo | 1.027 s | 0.0020 s | 0.0018 s | Links UnicodeConsoleLoggerAttribute The permanent link to this sample: BenchmarkDotNet.Samples.IntroUnicode"
  },
  "articles/samples/IntroVisualStudioProfiler.html": {
    "href": "articles/samples/IntroVisualStudioProfiler.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: Visual Studio Profiler Using the Microsoft.VisualStudio.BenchmarkDotNetDiagnosers NuGet package you can capture performance profiles of your benchmarks that can be opened in Visual Studio. Source code using System; using BenchmarkDotNet.Attributes; using Microsoft.VSDiagnostics; namespace BenchmarkDotNet.Samples { // Enables profiling with the CPU Usage tool // See: https://learn.microsoft.com/visualstudio/profiling/profiling-with-benchmark-dotnet [CPUUsageDiagnoser] public class IntroVisualStudioProfiler { private readonly Random rand = new Random(42); [Benchmark] public void BurnCPU() { for (int i = 0; i < 100000; ++i) { rand.Next(1, 100); } } } } Output The output will contain a path to the collected diagsession and automatically open in Visual Studio when launched from it. // * Diagnostic Output - VSDiagnosticsDiagnoser * Collection result moved to 'C:\\Work\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\bin\\Release\\net8.0\\BenchmarkDotNet.Artifacts\\BenchmarkDotNet_IntroVisualStudioProfiler_20241205_192056.diagsession'. Session : {d54ebddb-2d6d-404f-b1da-10acbc89635f} Stopped Exported diagsession file: C:\\Work\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\bin\\Release\\net8.0\\BenchmarkDotNet.Artifacts\\BenchmarkDotNet_IntroVisualStudioProfiler_20241205_192056.diagsession. Opening diagsession in VisualStudio: 15296"
  },
  "articles/samples/IntroWakeLock.html": {
    "href": "articles/samples/IntroWakeLock.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroWakeLock Running benchmarks may sometimes take enough time such that the system enters sleep or turns off the display. Using a WakeLock prevents the Windows system doing so. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using System; using System.Threading; // *** Attribute Style applied to Assembly *** [assembly: WakeLock(WakeLockType.System)] namespace BenchmarkDotNet.Samples; // *** Attribute Style *** [WakeLock(WakeLockType.Display)] public class IntroWakeLock { [Benchmark] public void LongRunning() => Thread.Sleep(TimeSpan.FromSeconds(10)); } // *** Object Style *** [Config(typeof(Config))] public class IntroWakeLockObjectStyle { private class Config : ManualConfig { public Config() => WakeLock = WakeLockType.System; } [Benchmark] public void LongRunning() => Thread.Sleep(TimeSpan.FromSeconds(10)); } Command line --wakeLock None --wakeLock System --wakeLock Display Links WakeLockAttribute The permanent link to this sample: BenchmarkDotNet.Samples.IntroWakeLock"
  },
  "articles/samples/IntroWasm.html": {
    "href": "articles/samples/IntroWasm.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroWasm WasmToolchain uses a local Mono Runtime build to run the benchmarks compiled as WebAssembly using V8 JavaScript Engine. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; using BenchmarkDotNet.Toolchains; using BenchmarkDotNet.Toolchains.DotNetCli; using BenchmarkDotNet.Toolchains.MonoWasm; namespace BenchmarkDotNet.Samples { // *** Command Line Arguments *** public class IntroWasmCmdConfig { // the args must contain: // an information that we want to run benchmark as Wasm: // --runtimes Wasm // path to dotnet cli // --cli /home/adam/projects/runtime/dotnet.sh public static void Run(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(IntroWasmCmdConfig).Assembly).Run(args); [Benchmark] public void Foo() { // Benchmark body } } // *** Fluent Config *** public class IntroWasmFluentConfig { public static void Run() { // the Wasm Toolchain requires two mandatory arguments: const string cliPath = @\"/home/adam/projects/runtime/dotnet.sh\"; WasmRuntime runtime = new WasmRuntime(msBuildMoniker: \"net5.0\"); NetCoreAppSettings netCoreAppSettings = new NetCoreAppSettings( targetFrameworkMoniker: \"net5.0\", runtimeFrameworkVersion: null, name: \"Wasm\", customDotNetCliPath: cliPath); IToolchain toolChain = WasmToolchain.From(netCoreAppSettings); BenchmarkRunner.Run<IntroCustomMonoFluentConfig>(DefaultConfig.Instance .AddJob(Job.ShortRun.WithRuntime(runtime).WithToolchain(toolChain))); } [Benchmark] public void Foo() { // Benchmark body } } } Links Toolchains The permanent link to this sample: BenchmarkDotNet.Samples.IntroWasm"
  },
  "articles/samples/IntroXamarin.html": {
    "href": "articles/samples/IntroXamarin.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroXamarin To use BenchmarkDotNet with Xamarin, you will need to build a small UI for running Benchmarks and displaying the results so you can actually read them. Using Xamarin.Forms is a simple way to be able to run your benchmarks on iOS or Android. Other notes: Use Release builds when running actual benchmarks. Disable the linker via the Don't Link or None. Source code using BenchmarkDotNet.Analysers; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Exporters; using BenchmarkDotNet.Loggers; using BenchmarkDotNet.Running; using System; using System.Linq; using System.Threading.Tasks; using Xamarin.Forms; namespace BenchmarkDotNet.Samples.Forms { public partial class MainPage : ContentPage { public MainPage() { InitializeComponent(); } async void Button_Clicked(object sender, EventArgs e) { SetIsRunning(true); try { var logger = new AccumulationLogger(); await Task.Run(() => { var config = default(IConfig); #if DEBUG config = new DebugInProcessConfig(); #endif var summary = BenchmarkRunner.Run<IntroBasic>(config); MarkdownExporter.Console.ExportToLog(summary, logger); ConclusionHelper.Print(logger, summary.BenchmarksCases .SelectMany(benchmark => benchmark.Config.GetCompositeAnalyser().Analyse(summary)) .Distinct() .ToList()); }); SetSummary(logger.GetLog()); } catch (Exception exc) { await DisplayAlert(\"Error\", exc.Message, \"Ok\"); } finally { SetIsRunning(false); } } void SetIsRunning(bool isRunning) { Indicator.IsRunning = isRunning; Run.IsVisible = Summary.IsVisible = !isRunning; } void SetSummary(string text) { Summary.Text = text; var size = Summary.Measure(double.MaxValue, double.MaxValue).Request; Summary.WidthRequest = size.Width; Summary.HeightRequest = size.Height; } } } Output Links Xamarin.Android linker settings Xamarin.iOS linker settings The permanent link to this sample: BenchmarkDotNet.Samples.Xamarin"
  },
  "articles/team.html": {
    "href": "articles/team.html",
    "title": "Team | BenchmarkDotNet",
    "summary": "Team Maintainers: Andrey Akinshin (Project Lead), Adam Sitnik, Yegor Stepanov, Tim Cassell. All contributors on GitHub (200+) BenchmarkDotNet is a part of the .NET Foundation."
  },
  "changelog/full.html": {
    "href": "changelog/full.html",
    "title": "Full ChangeLog | BenchmarkDotNet",
    "summary": "Full ChangeLog BenchmarkDotNet v0.15.4 Milestone details In the v0.15.4 scope, 0 issues were resolved and 2 pull requests were merged. This release includes 3 commits by 3 contributors. Resolved issues (0) Merged pull requests (2) #2831 Fix condition for TestTfmsInParallel property (by @miniksa) #2832 Allow override method/property for ParamsSource (by @neuecc) Commits (3) f11522 Set next BenchmarkDotNet version: 0.15.4 (by @AndreyAkinshin) 4071ca Fix condition for TestTfmsInParallel property (#2831) (by @miniksa) 6a47e2 Allow override method/property for ParamsSource (#2832) (by @neuecc) Contributors (3) Andrey Akinshin (@AndreyAkinshin) Michael Niksa (@miniksa) Yoshifumi Kawai (@neuecc) Thank you very much! BenchmarkDotNet v0.15.3 BenchmarkDotNet v0.15.2 BenchmarkDotNet v0.15.1 BenchmarkDotNet v0.15.0 BenchmarkDotNet v0.14.0 BenchmarkDotNet v0.13.12 BenchmarkDotNet v0.13.11 BenchmarkDotNet v0.13.10 BenchmarkDotNet v0.13.9 BenchmarkDotNet v0.13.8 BenchmarkDotNet v0.13.7 BenchmarkDotNet v0.13.6 BenchmarkDotNet v0.13.5 BenchmarkDotNet v0.13.4 BenchmarkDotNet v0.13.3 BenchmarkDotNet v0.13.2 BenchmarkDotNet v0.13.1 BenchmarkDotNet v0.13.0 BenchmarkDotNet v0.12.1 BenchmarkDotNet v0.12.0 BenchmarkDotNet v0.11.5 BenchmarkDotNet v0.11.4 BenchmarkDotNet v0.11.3 BenchmarkDotNet v0.11.2 BenchmarkDotNet v0.11.1 BenchmarkDotNet v0.11.0 BenchmarkDotNet v0.10.14 BenchmarkDotNet v0.10.13 BenchmarkDotNet v0.10.12 BenchmarkDotNet v0.10.11 BenchmarkDotNet v0.10.10 BenchmarkDotNet v0.10.9 BenchmarkDotNet v0.10.8 BenchmarkDotNet v0.10.7 BenchmarkDotNet v0.10.6 BenchmarkDotNet v0.10.5 BenchmarkDotNet v0.10.4 BenchmarkDotNet v0.10.3 BenchmarkDotNet v0.10.2 BenchmarkDotNet v0.10.1 BenchmarkDotNet v0.10.0 BenchmarkDotNet v0.9.9 BenchmarkDotNet v0.9.8 BenchmarkDotNet v0.9.7 BenchmarkDotNet v0.9.6 BenchmarkDotNet v0.9.5 BenchmarkDotNet v0.9.4 BenchmarkDotNet v0.9.3 BenchmarkDotNet v0.9.2 BenchmarkDotNet v0.9.1 BenchmarkDotNet v0.9.0 BenchmarkDotNet v0.8.2 BenchmarkDotNet v0.8.1 BenchmarkDotNet v0.8.0 BenchmarkDotNet v0.7.8 BenchmarkDotNet v0.7.7 BenchmarkDotNet v0.7.6 BenchmarkDotNet v0.7.5 BenchmarkDotNet v0.7.4 BenchmarkDotNet v0.7.3 BenchmarkDotNet v0.7.2 BenchmarkDotNet v0.7.1 BenchmarkDotNet v0.7.0"
  },
  "changelog/index.html": {
    "href": "changelog/index.html",
    "title": "ChangeLog | BenchmarkDotNet",
    "summary": "ChangeLog BenchmarkDotNet v0.15.4 BenchmarkDotNet v0.15.3 BenchmarkDotNet v0.15.2 BenchmarkDotNet v0.15.1 BenchmarkDotNet v0.15.0 BenchmarkDotNet v0.14.0 BenchmarkDotNet v0.13.12 BenchmarkDotNet v0.13.11 BenchmarkDotNet v0.13.10 BenchmarkDotNet v0.13.9 BenchmarkDotNet v0.13.8 BenchmarkDotNet v0.13.7 BenchmarkDotNet v0.13.6 BenchmarkDotNet v0.13.5 BenchmarkDotNet v0.13.4 BenchmarkDotNet v0.13.3 BenchmarkDotNet v0.13.2 BenchmarkDotNet v0.13.1 BenchmarkDotNet v0.13.0 BenchmarkDotNet v0.12.1 BenchmarkDotNet v0.12.0 BenchmarkDotNet v0.11.5 BenchmarkDotNet v0.11.4 BenchmarkDotNet v0.11.3 BenchmarkDotNet v0.11.2 BenchmarkDotNet v0.11.1 BenchmarkDotNet v0.11.0 BenchmarkDotNet v0.10.14 BenchmarkDotNet v0.10.13 BenchmarkDotNet v0.10.12 BenchmarkDotNet v0.10.11 BenchmarkDotNet v0.10.10 BenchmarkDotNet v0.10.9 BenchmarkDotNet v0.10.8 BenchmarkDotNet v0.10.7 BenchmarkDotNet v0.10.6 BenchmarkDotNet v0.10.5 BenchmarkDotNet v0.10.4 BenchmarkDotNet v0.10.3 BenchmarkDotNet v0.10.2 BenchmarkDotNet v0.10.1 BenchmarkDotNet v0.10.0 BenchmarkDotNet v0.9.9 BenchmarkDotNet v0.9.8 BenchmarkDotNet v0.9.7 BenchmarkDotNet v0.9.6 BenchmarkDotNet v0.9.5 BenchmarkDotNet v0.9.4 BenchmarkDotNet v0.9.3 BenchmarkDotNet v0.9.2 BenchmarkDotNet v0.9.1 BenchmarkDotNet v0.9.0 BenchmarkDotNet v0.8.2 BenchmarkDotNet v0.8.1 BenchmarkDotNet v0.8.0 BenchmarkDotNet v0.7.8 BenchmarkDotNet v0.7.7 BenchmarkDotNet v0.7.6 BenchmarkDotNet v0.7.5 BenchmarkDotNet v0.7.4 BenchmarkDotNet v0.7.3 BenchmarkDotNet v0.7.2 BenchmarkDotNet v0.7.1 BenchmarkDotNet v0.7.0 Full ChangeLog"
  },
  "changelog/v0.10.0.html": {
    "href": "changelog/v0.10.0.html",
    "title": "BenchmarkDotNet v0.10.0 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.0"
  },
  "changelog/v0.10.1.html": {
    "href": "changelog/v0.10.1.html",
    "title": "BenchmarkDotNet v0.10.1 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.1"
  },
  "changelog/v0.10.10.html": {
    "href": "changelog/v0.10.10.html",
    "title": "BenchmarkDotNet v0.10.10 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.10"
  },
  "changelog/v0.10.11.html": {
    "href": "changelog/v0.10.11.html",
    "title": "BenchmarkDotNet v0.10.11 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.11"
  },
  "changelog/v0.10.12.html": {
    "href": "changelog/v0.10.12.html",
    "title": "BenchmarkDotNet v0.10.12 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.12"
  },
  "changelog/v0.10.13.html": {
    "href": "changelog/v0.10.13.html",
    "title": "BenchmarkDotNet v0.10.13 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.13"
  },
  "changelog/v0.10.14.html": {
    "href": "changelog/v0.10.14.html",
    "title": "BenchmarkDotNet v0.10.14 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.14"
  },
  "changelog/v0.10.2.html": {
    "href": "changelog/v0.10.2.html",
    "title": "BenchmarkDotNet v0.10.2 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.2"
  },
  "changelog/v0.10.3.html": {
    "href": "changelog/v0.10.3.html",
    "title": "BenchmarkDotNet v0.10.3 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.3"
  },
  "changelog/v0.10.4.html": {
    "href": "changelog/v0.10.4.html",
    "title": "BenchmarkDotNet v0.10.4 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.4"
  },
  "changelog/v0.10.5.html": {
    "href": "changelog/v0.10.5.html",
    "title": "BenchmarkDotNet v0.10.5 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.5"
  },
  "changelog/v0.10.6.html": {
    "href": "changelog/v0.10.6.html",
    "title": "BenchmarkDotNet v0.10.6 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.6"
  },
  "changelog/v0.10.7.html": {
    "href": "changelog/v0.10.7.html",
    "title": "BenchmarkDotNet v0.10.7 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.7"
  },
  "changelog/v0.10.8.html": {
    "href": "changelog/v0.10.8.html",
    "title": "BenchmarkDotNet v0.10.8 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.8"
  },
  "changelog/v0.10.9.html": {
    "href": "changelog/v0.10.9.html",
    "title": "BenchmarkDotNet v0.10.9 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.9"
  },
  "changelog/v0.11.0.html": {
    "href": "changelog/v0.11.0.html",
    "title": "BenchmarkDotNet v0.11.0 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.11.0"
  },
  "changelog/v0.11.1.html": {
    "href": "changelog/v0.11.1.html",
    "title": "BenchmarkDotNet v0.11.1 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.11.1"
  },
  "changelog/v0.11.2.html": {
    "href": "changelog/v0.11.2.html",
    "title": "BenchmarkDotNet v0.11.2 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.11.2"
  },
  "changelog/v0.11.3.html": {
    "href": "changelog/v0.11.3.html",
    "title": "BenchmarkDotNet v0.11.3 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.11.3"
  },
  "changelog/v0.11.4.html": {
    "href": "changelog/v0.11.4.html",
    "title": "BenchmarkDotNet v0.11.4 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.11.4"
  },
  "changelog/v0.11.5.html": {
    "href": "changelog/v0.11.5.html",
    "title": "BenchmarkDotNet v0.11.5 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.11.5"
  },
  "changelog/v0.12.0.html": {
    "href": "changelog/v0.12.0.html",
    "title": "BenchmarkDotNet v0.12.0 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.12.0"
  },
  "changelog/v0.12.1.html": {
    "href": "changelog/v0.12.1.html",
    "title": "BenchmarkDotNet v0.12.1 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.12.1"
  },
  "changelog/v0.13.0.html": {
    "href": "changelog/v0.13.0.html",
    "title": "BenchmarkDotNet v0.13.0 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.0"
  },
  "changelog/v0.13.1.html": {
    "href": "changelog/v0.13.1.html",
    "title": "BenchmarkDotNet v0.13.1 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.1"
  },
  "changelog/v0.13.10.html": {
    "href": "changelog/v0.13.10.html",
    "title": "BenchmarkDotNet v0.13.10 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.10"
  },
  "changelog/v0.13.11.html": {
    "href": "changelog/v0.13.11.html",
    "title": "BenchmarkDotNet v0.13.11 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.11"
  },
  "changelog/v0.13.12.html": {
    "href": "changelog/v0.13.12.html",
    "title": "BenchmarkDotNet v0.13.12 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.12"
  },
  "changelog/v0.13.2.html": {
    "href": "changelog/v0.13.2.html",
    "title": "BenchmarkDotNet v0.13.2 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.2"
  },
  "changelog/v0.13.3.html": {
    "href": "changelog/v0.13.3.html",
    "title": "BenchmarkDotNet v0.13.3 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.3"
  },
  "changelog/v0.13.4.html": {
    "href": "changelog/v0.13.4.html",
    "title": "BenchmarkDotNet v0.13.4 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.4"
  },
  "changelog/v0.13.5.html": {
    "href": "changelog/v0.13.5.html",
    "title": "BenchmarkDotNet v0.13.5 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.5"
  },
  "changelog/v0.13.6.html": {
    "href": "changelog/v0.13.6.html",
    "title": "BenchmarkDotNet v0.13.6 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.6"
  },
  "changelog/v0.13.7.html": {
    "href": "changelog/v0.13.7.html",
    "title": "BenchmarkDotNet v0.13.7 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.7"
  },
  "changelog/v0.13.8.html": {
    "href": "changelog/v0.13.8.html",
    "title": "BenchmarkDotNet v0.13.8 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.8"
  },
  "changelog/v0.13.9.html": {
    "href": "changelog/v0.13.9.html",
    "title": "BenchmarkDotNet v0.13.9 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.9"
  },
  "changelog/v0.14.0.html": {
    "href": "changelog/v0.14.0.html",
    "title": "BenchmarkDotNet v0.14.0 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.14.0"
  },
  "changelog/v0.15.0.html": {
    "href": "changelog/v0.15.0.html",
    "title": "BenchmarkDotNet v0.15.0 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.15.0"
  },
  "changelog/v0.15.1.html": {
    "href": "changelog/v0.15.1.html",
    "title": "BenchmarkDotNet v0.15.1 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.15.1"
  },
  "changelog/v0.15.2.html": {
    "href": "changelog/v0.15.2.html",
    "title": "BenchmarkDotNet v0.15.2 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.15.2"
  },
  "changelog/v0.15.3.html": {
    "href": "changelog/v0.15.3.html",
    "title": "BenchmarkDotNet v0.15.3 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.15.3"
  },
  "changelog/v0.15.4.html": {
    "href": "changelog/v0.15.4.html",
    "title": "BenchmarkDotNet v0.15.4 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.15.4 Milestone details In the v0.15.4 scope, 0 issues were resolved and 2 pull requests were merged. This release includes 3 commits by 3 contributors. Resolved issues (0) Merged pull requests (2) #2831 Fix condition for TestTfmsInParallel property (by @miniksa) #2832 Allow override method/property for ParamsSource (by @neuecc) Commits (3) f11522 Set next BenchmarkDotNet version: 0.15.4 (by @AndreyAkinshin) 4071ca Fix condition for TestTfmsInParallel property (#2831) (by @miniksa) 6a47e2 Allow override method/property for ParamsSource (#2832) (by @neuecc) Contributors (3) Andrey Akinshin (@AndreyAkinshin) Michael Niksa (@miniksa) Yoshifumi Kawai (@neuecc) Thank you very much!"
  },
  "changelog/v0.7.0.html": {
    "href": "changelog/v0.7.0.html",
    "title": "BenchmarkDotNet v0.7.0 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.7.0"
  },
  "changelog/v0.7.1.html": {
    "href": "changelog/v0.7.1.html",
    "title": "BenchmarkDotNet v0.7.1 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.7.1"
  },
  "changelog/v0.7.2.html": {
    "href": "changelog/v0.7.2.html",
    "title": "BenchmarkDotNet v0.7.2 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.7.2"
  },
  "changelog/v0.7.3.html": {
    "href": "changelog/v0.7.3.html",
    "title": "BenchmarkDotNet v0.7.3 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.7.3"
  },
  "changelog/v0.7.4.html": {
    "href": "changelog/v0.7.4.html",
    "title": "BenchmarkDotNet v0.7.4 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.7.4"
  },
  "changelog/v0.7.5.html": {
    "href": "changelog/v0.7.5.html",
    "title": "BenchmarkDotNet v0.7.5 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.7.5"
  },
  "changelog/v0.7.6.html": {
    "href": "changelog/v0.7.6.html",
    "title": "BenchmarkDotNet v0.7.6 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.7.6"
  },
  "changelog/v0.7.7.html": {
    "href": "changelog/v0.7.7.html",
    "title": "BenchmarkDotNet v0.7.7 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.7.7"
  },
  "changelog/v0.7.8.html": {
    "href": "changelog/v0.7.8.html",
    "title": "BenchmarkDotNet v0.7.8 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.7.8"
  },
  "changelog/v0.8.0.html": {
    "href": "changelog/v0.8.0.html",
    "title": "BenchmarkDotNet v0.8.0 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.8.0"
  },
  "changelog/v0.8.1.html": {
    "href": "changelog/v0.8.1.html",
    "title": "BenchmarkDotNet v0.8.1 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.8.1"
  },
  "changelog/v0.8.2.html": {
    "href": "changelog/v0.8.2.html",
    "title": "BenchmarkDotNet v0.8.2 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.8.2"
  },
  "changelog/v0.9.0.html": {
    "href": "changelog/v0.9.0.html",
    "title": "BenchmarkDotNet v0.9.0 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.9.0"
  },
  "changelog/v0.9.1.html": {
    "href": "changelog/v0.9.1.html",
    "title": "BenchmarkDotNet v0.9.1 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.9.1"
  },
  "changelog/v0.9.2.html": {
    "href": "changelog/v0.9.2.html",
    "title": "BenchmarkDotNet v0.9.2 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.9.2"
  },
  "changelog/v0.9.3.html": {
    "href": "changelog/v0.9.3.html",
    "title": "BenchmarkDotNet v0.9.3 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.9.3"
  },
  "changelog/v0.9.4.html": {
    "href": "changelog/v0.9.4.html",
    "title": "BenchmarkDotNet v0.9.4 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.9.4"
  },
  "changelog/v0.9.5.html": {
    "href": "changelog/v0.9.5.html",
    "title": "BenchmarkDotNet v0.9.5 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.9.5"
  },
  "changelog/v0.9.6.html": {
    "href": "changelog/v0.9.6.html",
    "title": "BenchmarkDotNet v0.9.6 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.9.6"
  },
  "changelog/v0.9.7.html": {
    "href": "changelog/v0.9.7.html",
    "title": "BenchmarkDotNet v0.9.7 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.9.7"
  },
  "changelog/v0.9.8.html": {
    "href": "changelog/v0.9.8.html",
    "title": "BenchmarkDotNet v0.9.8 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.9.8"
  },
  "changelog/v0.9.9.html": {
    "href": "changelog/v0.9.9.html",
    "title": "BenchmarkDotNet v0.9.9 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.9.9"
  },
  "index.html": {
    "href": "index.html",
    "title": "Home | BenchmarkDotNet",
    "summary": "Features  Getting started  Documentation  Learn more about benchmarking BenchmarkDotNet helps you to transform methods into benchmarks, track their performance, and share reproducible measurement experiments. It's no harder than writing unit tests! Under the hood, it performs a lot of magic that guarantees reliable and precise results thanks to the perfolizer statistical engine. BenchmarkDotNet protects you from popular benchmarking mistakes and warns you if something is wrong with your benchmark design or obtained measurements. The results are presented in a user-friendly form that highlights all the important facts about your experiment. BenchmarkDotNet is already adopted by 27000+ GitHub projects including .NET Runtime, .NET Compiler, .NET Performance, and many others. It's easy to start writing benchmarks, check out the following example (copy-pastable version is here): [SimpleJob(RuntimeMoniker.Net472, baseline: true)] [SimpleJob(RuntimeMoniker.NetCoreApp30)] [SimpleJob(RuntimeMoniker.NativeAot70)] [SimpleJob(RuntimeMoniker.Mono)] [RPlotExporter] public class Md5VsSha256 { private SHA256 sha256 = SHA256.Create(); private MD5 md5 = MD5.Create(); private byte[] data; [Params(1000, 10000)] public int N; [GlobalSetup] public void Setup() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark] public byte[] Sha256() => sha256.ComputeHash(data); [Benchmark] public byte[] Md5() => md5.ComputeHash(data); } BenchmarkDotNet automatically runs the benchmarks on all the runtimes, aggregates the measurements, and prints a summary table with the most important information: BenchmarkDotNet=v0.12.0, OS=Windows 10.0.17763.805 (1809/October2018Update/Redstone5) Intel Core i7-7700K CPU 4.20GHz (Kaby Lake), 1 CPU, 8 logical and 4 physical cores [Host] : .NET Framework 4.7.2 (4.7.3468.0), X64 RyuJIT Net472 : .NET Framework 4.7.2 (4.7.3468.0), X64 RyuJIT NetCoreApp30 : .NET Core 3.0.0 (CoreCLR 4.700.19.46205, CoreFX 4.700.19.46214), X64 RyuJIT NativeAot70 : .NET 7.0.0-preview.4.22172.7, X64 NativeAOT Mono : Mono 6.4.0 (Visual Studio), X64 | Method | Runtime | N | Mean | Error | StdDev | Ratio | |------- |-------------- |------ |-----------:|----------:|----------:|------:| | Sha256 | .NET 4.7.2 | 1000 | 7.735 us | 0.1913 us | 0.4034 us | 1.00 | | Sha256 | .NET Core 3.0 | 1000 | 3.989 us | 0.0796 us | 0.0745 us | 0.50 | | Sha256 | NativeAOT 7.0 | 1000 | 4.091 us | 0.0811 us | 0.1562 us | 0.53 | | Sha256 | Mono | 1000 | 13.117 us | 0.2485 us | 0.5019 us | 1.70 | | | | | | | | | | Md5 | .NET 4.7.2 | 1000 | 2.872 us | 0.0552 us | 0.0737 us | 1.00 | | Md5 | .NET Core 3.0 | 1000 | 1.848 us | 0.0348 us | 0.0326 us | 0.64 | | Md5 | NativeAOT 7.0 | 1000 | 1.817 us | 0.0359 us | 0.0427 us | 0.63 | | Md5 | Mono | 1000 | 3.574 us | 0.0678 us | 0.0753 us | 1.24 | | | | | | | | | | Sha256 | .NET 4.7.2 | 10000 | 74.509 us | 1.5787 us | 4.6052 us | 1.00 | | Sha256 | .NET Core 3.0 | 10000 | 36.049 us | 0.7151 us | 1.0025 us | 0.49 | | Sha256 | NativeAOT 7.0 | 10000 | 36.253 us | 0.7076 us | 0.7571 us | 0.49 | | Sha256 | Mono | 10000 | 116.350 us | 2.2555 us | 3.0110 us | 1.58 | | | | | | | | | | Md5 | .NET 4.7.2 | 10000 | 17.308 us | 0.3361 us | 0.4250 us | 1.00 | | Md5 | .NET Core 3.0 | 10000 | 15.726 us | 0.2064 us | 0.1930 us | 0.90 | | Md5 | NativeAOT 7.0 | 10000 | 15.627 us | 0.2631 us | 0.2461 us | 0.89 | | Md5 | Mono | 10000 | 30.205 us | 0.5868 us | 0.6522 us | 1.74 | The measured data can be exported to different formats (md, html, csv, xml, json, etc.) including plots: Supported runtimes: .NET 5+, .NET Framework 4.6.1+, .NET Core 2.0+, Mono, NativeAOT Supported languages: C#, F#, Visual Basic Supported OS: Windows, Linux, macOS Supported architectures: x86, x64, ARM, ARM64, Wasm and LoongArch64 Features BenchmarkDotNet has tons of features that are essential in comprehensive performance investigations. Four aspects define the design of these features: simplicity, automation, reliability, and friendliness. Simplicity You shouldn't have to be an experienced performance engineer if you want to write benchmarks. You can design very complicated performance experiments in the declarative style using simple APIs. For example, if you want to parameterize your benchmark, mark a field or a property with [Params(1, 2, 3)]: BenchmarkDotNet will enumerate all of the specified values and run benchmarks for each case. If you want to compare benchmarks with each other, mark one of the benchmarks as the baseline via [Benchmark(Baseline = true)]: BenchmarkDotNet will compare it with all of the other benchmarks. If you want to compare performance in different environments, use jobs. For example, you can run all the benchmarks on .NET 8.0 and Mono via [SimpleJob(RuntimeMoniker.Net80)] and [SimpleJob(RuntimeMoniker.Mono)]. If you don't like attributes, you can call most of the APIs via the fluent style and write code like this: ManualConfig.CreateEmpty() // A configuration for our benchmarks .AddJob(Job.Default // Adding first job .WithRuntime(ClrRuntime.Net472) // .NET Framework 4.7.2 .WithPlatform(Platform.X64) // Run as x64 application .WithJit(Jit.LegacyJit) // Use LegacyJIT instead of the default RyuJIT .WithGcServer(true) // Use Server GC ).AddJob(Job.Default // Adding second job .AsBaseline() // It will be marked as baseline .WithEnvironmentVariable(\"Key\", \"Value\") // Setting an environment variable .WithWarmupCount(0) // Disable warm-up stage ); If you prefer command-line experience, you can configure your benchmarks via the console arguments in any console application (other types of applications are not supported). Automation Reliable benchmarks always include a lot of boilerplate code. Let's think about what you should do in a typical case. First, you should perform a pilot experiment and determine the best number of method invocations. Next, you should execute several warm-up iterations and ensure that your benchmark achieved a steady state. After that, you should execute the main iterations and calculate some basic statistics. If you calculate some values in your benchmark, you should use it somehow to prevent dead code elimination. If you use loops, you should care about the effect of the loop unrolling on your results (which may depend on the processor architecture). Once you get results, you should check for some special properties of the obtained performance distribution like multimodality or extremely high outliers. You should also evaluate the overhead of your infrastructure and deduct it from your results. If you want to test several environments, you should perform the measurements in each of them and manually aggregate the results. If you write this code from scratch, it's easy to make a mistake and spoil your measurements. Note that it's a shortened version of the full checklist that you should follow during benchmarking: there are a lot of additional hidden pitfalls that should be handled appropriately. Fortunately, you shouldn't worry about it because BenchmarkDotNet will perform this boring and time-consuming stuff for you. Moreover, the library can help you with some advanced tasks that you may want to perform during the investigation. For example, BenchmarkDotNet can measure the managed and native memory traffic and print disassembly listings for your benchmarks. Reliability A lot of hand-written benchmarks produce wrong numbers that lead to incorrect business decisions. BenchmarkDotNet protects you from most of the benchmarking pitfalls and allows achieving high measurement precision. You shouldn't worry about the perfect number of method invocation, the number of warm-up and actual iterations: BenchmarkDotNet tries to choose the best benchmarking parameters and achieve a good trade-off between the measurement prevision and the total duration of all benchmark runs. So, you shouldn't use any magic numbers (like \"We should perform 100 iterations here\"), the library will do it for you based on the values of statistical metrics. BenchmarkDotNet also prevents benchmarking of non-optimized assemblies that were built using DEBUG mode because the corresponding results will be unreliable. The library will print a warning if you have an attached debugger, if you use a hypervisor (HyperV, VMware, VirtualBox), or if you have any other problems with the current environment. During 6+ years of development, we faced dozens of different problems that may spoil your measurements. Inside BenchmarkDotNet, there are a lot of heuristics, checks, hacks, and tricks that help you to increase the reliability of the results. Friendliness Analysis of performance data is a time-consuming activity that requires attentiveness, knowledge, and experience. BenchmarkDotNet performs the main part of this analysis for you and presents results in a user-friendly form. After the experiments, you get a summary table that contains a lot of useful data about the executed benchmarks. By default, it includes only the most important columns, but they can be easily customized. The column set is adaptive and depends on the benchmark definition and measured values. For example, if you mark one of the benchmarks as a baseline, you will get additional columns that will help you to compare all the benchmarks with the baseline. By default, it always shows the Mean column, but if we detected a vast difference between the Mean and the Median values, both columns will be presented. BenchmarkDotNet tries to find some unusual properties of your performance distributions and prints nice messages about it. For example, it will warn you in case of multimodal distribution or high outliers. In this case, you can scroll the results up and check out ASCII-style histograms for each distribution or generate beautiful png plots using [RPlotExporter]. BenchmarkDotNet doesn't overload you with data; it shows only the essential information depending on your results: it allows you to keep the summary small for primitive cases and extend it only for complicated cases. Of course, you can request any additional statistics and visualizations manually. If you don't customize the summary view, the default presentation will be as much user-friendly as possible. :) Learn more about benchmarking BenchmarkDotNet is not a silver bullet that magically makes all of your benchmarks correct and analyzes the measurements for you. Even if you use this library, you still should know how to design benchmark experiments and how to make correct conclusions based on the raw data. If you want to know more about benchmarking methodology and good practices, it's recommended to read a book by Andrey Akinshin (the BenchmarkDotNet project lead): \"Pro .NET Benchmarking\". Use this in-depth guide to correctly design benchmarks, measure key performance metrics of .NET applications, and analyze results. This book presents dozens of case studies to help you understand complicated benchmarking topics. You will avoid common pitfalls, control the accuracy of your measurements, and improve the performance of your software. Contributions are welcome! BenchmarkDotNet is already a stable full-featured library that allows performing performance investigation on a professional level. And it continues to evolve! We add new features all the time, but we have too many new cool ideas. Any help will be appreciated. You can develop new features, fix bugs, improve the documentation, or do some other cool stuff. If you want to contribute, check out the Contributing guide and up-for-grabs issues. If you have new ideas or want to complain about bugs, feel free to create a new issue. Let's build the best tool for benchmarking together! Code of Conduct This project has adopted the code of conduct defined by the Contributor Covenant to clarify expected behavior in our community. For more information, see the .NET Foundation Code of Conduct."
  }
}