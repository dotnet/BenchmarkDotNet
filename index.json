{
  "api/BenchmarkDotNet.Analysers.AnalyserBase.html": {
    "href": "api/BenchmarkDotNet.Analysers.AnalyserBase.html",
    "title": "Class AnalyserBase | BenchmarkDotNet",
    "summary": "Class AnalyserBase Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public abstract class AnalyserBase : IAnalyser Inheritance object AnalyserBase Implements IAnalyser Derived BaselineCustomAnalyzer EnvironmentAnalyser HideColumnsAnalyser MinIterationTimeAnalyser MultimodalDistributionAnalyzer OutliersAnalyser RuntimeErrorAnalyser ZeroMeasurementAnalyser Constructors AnalyserBase() protected AnalyserBase() Properties Id public abstract string Id { get; } Property Value string Methods Analyse(Summary) public IEnumerable<Conclusion> Analyse(Summary summary) Parameters summary Summary Returns IEnumerable<Conclusion> AnalyseReport(BenchmarkReport, Summary) protected virtual IEnumerable<Conclusion> AnalyseReport(BenchmarkReport report, Summary summary) Parameters report BenchmarkReport summary Summary Returns IEnumerable<Conclusion> AnalyseSummary(Summary) protected virtual IEnumerable<Conclusion> AnalyseSummary(Summary summary) Parameters summary Summary Returns IEnumerable<Conclusion> CreateError(string, BenchmarkReport?, bool) protected Conclusion CreateError(string message, BenchmarkReport? report = null, bool mergeable = true) Parameters message string report BenchmarkReport mergeable bool Returns Conclusion CreateHint(string, BenchmarkReport?, bool) protected Conclusion CreateHint(string message, BenchmarkReport? report = null, bool mergeable = true) Parameters message string report BenchmarkReport mergeable bool Returns Conclusion CreateWarning(string, BenchmarkReport?, bool) protected Conclusion CreateWarning(string message, BenchmarkReport? report = null, bool mergeable = true) Parameters message string report BenchmarkReport mergeable bool Returns Conclusion"
  },
  "api/BenchmarkDotNet.Analysers.BaselineCustomAnalyzer.html": {
    "href": "api/BenchmarkDotNet.Analysers.BaselineCustomAnalyzer.html",
    "title": "Class BaselineCustomAnalyzer | BenchmarkDotNet",
    "summary": "Class BaselineCustomAnalyzer Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public class BaselineCustomAnalyzer : AnalyserBase, IAnalyser Inheritance object AnalyserBase BaselineCustomAnalyzer Implements IAnalyser Inherited Members AnalyserBase.Analyse(Summary) AnalyserBase.AnalyseReport(BenchmarkReport, Summary) AnalyserBase.CreateHint(string, BenchmarkReport, bool) AnalyserBase.CreateWarning(string, BenchmarkReport, bool) AnalyserBase.CreateError(string, BenchmarkReport, bool) Constructors BaselineCustomAnalyzer() public BaselineCustomAnalyzer() Fields Default public static readonly IAnalyser Default Field Value IAnalyser Properties Id public override string Id { get; } Property Value string Methods AnalyseSummary(Summary) protected override IEnumerable<Conclusion> AnalyseSummary(Summary summary) Parameters summary Summary Returns IEnumerable<Conclusion>"
  },
  "api/BenchmarkDotNet.Analysers.CompositeAnalyser.html": {
    "href": "api/BenchmarkDotNet.Analysers.CompositeAnalyser.html",
    "title": "Class CompositeAnalyser | BenchmarkDotNet",
    "summary": "Class CompositeAnalyser Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public class CompositeAnalyser : IAnalyser Inheritance object CompositeAnalyser Implements IAnalyser Constructors CompositeAnalyser(ImmutableHashSet<IAnalyser>) public CompositeAnalyser(ImmutableHashSet<IAnalyser> analysers) Parameters analysers ImmutableHashSet<IAnalyser> Properties Id public string Id { get; } Property Value string Methods Analyse(Summary) public IEnumerable<Conclusion> Analyse(Summary summary) Parameters summary Summary Returns IEnumerable<Conclusion>"
  },
  "api/BenchmarkDotNet.Analysers.Conclusion.html": {
    "href": "api/BenchmarkDotNet.Analysers.Conclusion.html",
    "title": "Class Conclusion | BenchmarkDotNet",
    "summary": "Class Conclusion Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public sealed class Conclusion : IEquatable<Conclusion> Inheritance object Conclusion Implements IEquatable<Conclusion> Properties AnalyserId public string AnalyserId { get; } Property Value string Kind public ConclusionKind Kind { get; } Property Value ConclusionKind Mergeable public bool Mergeable { get; } Property Value bool Message public string Message { get; } Property Value string Report public BenchmarkReport? Report { get; } Property Value BenchmarkReport Methods CreateError(string, string, BenchmarkReport?, bool) public static Conclusion CreateError(string analyserId, string message, BenchmarkReport? report = null, bool mergeable = true) Parameters analyserId string message string report BenchmarkReport mergeable bool Returns Conclusion CreateHint(string, string, BenchmarkReport?, bool) public static Conclusion CreateHint(string analyserId, string message, BenchmarkReport? report = null, bool mergeable = true) Parameters analyserId string message string report BenchmarkReport mergeable bool Returns Conclusion CreateWarning(string, string, BenchmarkReport?, bool) public static Conclusion CreateWarning(string analyserId, string message, BenchmarkReport? report = null, bool mergeable = true) Parameters analyserId string message string report BenchmarkReport mergeable bool Returns Conclusion Equals(Conclusion?) public bool Equals(Conclusion? other) Parameters other Conclusion Returns bool Equals(object?) public override bool Equals(object? obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/BenchmarkDotNet.Analysers.ConclusionHelper.html": {
    "href": "api/BenchmarkDotNet.Analysers.ConclusionHelper.html",
    "title": "Class ConclusionHelper | BenchmarkDotNet",
    "summary": "Class ConclusionHelper Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public static class ConclusionHelper Inheritance object ConclusionHelper Methods Print(ILogger, IEnumerable<Conclusion>) public static void Print(ILogger logger, IEnumerable<Conclusion> conclusions) Parameters logger ILogger conclusions IEnumerable<Conclusion>"
  },
  "api/BenchmarkDotNet.Analysers.ConclusionKind.html": {
    "href": "api/BenchmarkDotNet.Analysers.ConclusionKind.html",
    "title": "Enum ConclusionKind | BenchmarkDotNet",
    "summary": "Enum ConclusionKind Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public enum ConclusionKind Fields Error = 0 Hint = 2 Warning = 1"
  },
  "api/BenchmarkDotNet.Analysers.EnvironmentAnalyser.html": {
    "href": "api/BenchmarkDotNet.Analysers.EnvironmentAnalyser.html",
    "title": "Class EnvironmentAnalyser | BenchmarkDotNet",
    "summary": "Class EnvironmentAnalyser Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public class EnvironmentAnalyser : AnalyserBase, IAnalyser Inheritance object AnalyserBase EnvironmentAnalyser Implements IAnalyser Inherited Members AnalyserBase.Analyse(Summary) AnalyserBase.CreateHint(string, BenchmarkReport, bool) AnalyserBase.CreateWarning(string, BenchmarkReport, bool) AnalyserBase.CreateError(string, BenchmarkReport, bool) Fields Default public static readonly IAnalyser Default Field Value IAnalyser Properties Id public override string Id { get; } Property Value string Methods AnalyseReport(BenchmarkReport, Summary) protected override IEnumerable<Conclusion> AnalyseReport(BenchmarkReport report, Summary summary) Parameters report BenchmarkReport summary Summary Returns IEnumerable<Conclusion> AnalyseSummary(Summary) protected override IEnumerable<Conclusion> AnalyseSummary(Summary summary) Parameters summary Summary Returns IEnumerable<Conclusion>"
  },
  "api/BenchmarkDotNet.Analysers.HideColumnsAnalyser.html": {
    "href": "api/BenchmarkDotNet.Analysers.HideColumnsAnalyser.html",
    "title": "Class HideColumnsAnalyser | BenchmarkDotNet",
    "summary": "Class HideColumnsAnalyser Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public class HideColumnsAnalyser : AnalyserBase, IAnalyser Inheritance object AnalyserBase HideColumnsAnalyser Implements IAnalyser Inherited Members AnalyserBase.Analyse(Summary) AnalyserBase.AnalyseReport(BenchmarkReport, Summary) AnalyserBase.CreateHint(string, BenchmarkReport, bool) AnalyserBase.CreateWarning(string, BenchmarkReport, bool) AnalyserBase.CreateError(string, BenchmarkReport, bool) Constructors HideColumnsAnalyser() public HideColumnsAnalyser() Fields Default public static readonly IAnalyser Default Field Value IAnalyser Properties Id public override string Id { get; } Property Value string Methods AnalyseSummary(Summary) protected override IEnumerable<Conclusion> AnalyseSummary(Summary summary) Parameters summary Summary Returns IEnumerable<Conclusion>"
  },
  "api/BenchmarkDotNet.Analysers.html": {
    "href": "api/BenchmarkDotNet.Analysers.html",
    "title": "Namespace BenchmarkDotNet.Analysers | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Analysers Classes AnalyserBase BaselineCustomAnalyzer CompositeAnalyser Conclusion ConclusionHelper EnvironmentAnalyser HideColumnsAnalyser MinIterationTimeAnalyser MultimodalDistributionAnalyzer OutliersAnalyser RuntimeErrorAnalyser ZeroMeasurementAnalyser Interfaces IAnalyser Enums ConclusionKind"
  },
  "api/BenchmarkDotNet.Analysers.IAnalyser.html": {
    "href": "api/BenchmarkDotNet.Analysers.IAnalyser.html",
    "title": "Interface IAnalyser | BenchmarkDotNet",
    "summary": "Interface IAnalyser Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public interface IAnalyser Properties Id string Id { get; } Property Value string Methods Analyse(Summary) IEnumerable<Conclusion> Analyse(Summary summary) Parameters summary Summary Returns IEnumerable<Conclusion>"
  },
  "api/BenchmarkDotNet.Analysers.MinIterationTimeAnalyser.html": {
    "href": "api/BenchmarkDotNet.Analysers.MinIterationTimeAnalyser.html",
    "title": "Class MinIterationTimeAnalyser | BenchmarkDotNet",
    "summary": "Class MinIterationTimeAnalyser Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public class MinIterationTimeAnalyser : AnalyserBase, IAnalyser Inheritance object AnalyserBase MinIterationTimeAnalyser Implements IAnalyser Inherited Members AnalyserBase.Analyse(Summary) AnalyserBase.AnalyseSummary(Summary) AnalyserBase.CreateHint(string, BenchmarkReport, bool) AnalyserBase.CreateWarning(string, BenchmarkReport, bool) AnalyserBase.CreateError(string, BenchmarkReport, bool) Fields Default public static readonly IAnalyser Default Field Value IAnalyser Properties Id public override string Id { get; } Property Value string Methods AnalyseReport(BenchmarkReport, Summary) protected override IEnumerable<Conclusion> AnalyseReport(BenchmarkReport report, Summary summary) Parameters report BenchmarkReport summary Summary Returns IEnumerable<Conclusion>"
  },
  "api/BenchmarkDotNet.Analysers.MultimodalDistributionAnalyzer.html": {
    "href": "api/BenchmarkDotNet.Analysers.MultimodalDistributionAnalyzer.html",
    "title": "Class MultimodalDistributionAnalyzer | BenchmarkDotNet",
    "summary": "Class MultimodalDistributionAnalyzer Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public class MultimodalDistributionAnalyzer : AnalyserBase, IAnalyser Inheritance object AnalyserBase MultimodalDistributionAnalyzer Implements IAnalyser Inherited Members AnalyserBase.Analyse(Summary) AnalyserBase.AnalyseSummary(Summary) AnalyserBase.CreateHint(string, BenchmarkReport, bool) AnalyserBase.CreateWarning(string, BenchmarkReport, bool) AnalyserBase.CreateError(string, BenchmarkReport, bool) Fields Default public static readonly IAnalyser Default Field Value IAnalyser Properties Id public override string Id { get; } Property Value string Methods AnalyseReport(BenchmarkReport, Summary) protected override IEnumerable<Conclusion> AnalyseReport(BenchmarkReport report, Summary summary) Parameters report BenchmarkReport summary Summary Returns IEnumerable<Conclusion>"
  },
  "api/BenchmarkDotNet.Analysers.OutliersAnalyser.html": {
    "href": "api/BenchmarkDotNet.Analysers.OutliersAnalyser.html",
    "title": "Class OutliersAnalyser | BenchmarkDotNet",
    "summary": "Class OutliersAnalyser Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public class OutliersAnalyser : AnalyserBase, IAnalyser Inheritance object AnalyserBase OutliersAnalyser Implements IAnalyser Inherited Members AnalyserBase.Analyse(Summary) AnalyserBase.AnalyseSummary(Summary) AnalyserBase.CreateHint(string, BenchmarkReport, bool) AnalyserBase.CreateWarning(string, BenchmarkReport, bool) AnalyserBase.CreateError(string, BenchmarkReport, bool) Fields Default public static readonly IAnalyser Default Field Value IAnalyser Properties Id public override string Id { get; } Property Value string Methods AnalyseReport(BenchmarkReport, Summary) protected override IEnumerable<Conclusion> AnalyseReport(BenchmarkReport report, Summary summary) Parameters report BenchmarkReport summary Summary Returns IEnumerable<Conclusion> GetMessage(double[], double[], double[], double[], CultureInfo) Returns a nice message which can be displayed in the summary. public static string GetMessage(double[] actualOutliers, double[] allOutliers, double[] lowerOutliers, double[] upperOutliers, CultureInfo cultureInfo) Parameters actualOutliers double[] Actual outliers which were removed from the statistics allOutliers double[] All outliers which present in the distribution (lower and upper) lowerOutliers double[] All lower outliers upperOutliers double[] All upper outliers cultureInfo CultureInfo CultureInfo Returns string The message"
  },
  "api/BenchmarkDotNet.Analysers.RuntimeErrorAnalyser.html": {
    "href": "api/BenchmarkDotNet.Analysers.RuntimeErrorAnalyser.html",
    "title": "Class RuntimeErrorAnalyser | BenchmarkDotNet",
    "summary": "Class RuntimeErrorAnalyser Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public class RuntimeErrorAnalyser : AnalyserBase, IAnalyser Inheritance object AnalyserBase RuntimeErrorAnalyser Implements IAnalyser Inherited Members AnalyserBase.Analyse(Summary) AnalyserBase.AnalyseSummary(Summary) AnalyserBase.CreateHint(string, BenchmarkReport, bool) AnalyserBase.CreateWarning(string, BenchmarkReport, bool) AnalyserBase.CreateError(string, BenchmarkReport, bool) Fields Default public static readonly IAnalyser Default Field Value IAnalyser Properties Id public override string Id { get; } Property Value string Methods AnalyseReport(BenchmarkReport, Summary) protected override IEnumerable<Conclusion> AnalyseReport(BenchmarkReport report, Summary summary) Parameters report BenchmarkReport summary Summary Returns IEnumerable<Conclusion>"
  },
  "api/BenchmarkDotNet.Analysers.ZeroMeasurementAnalyser.html": {
    "href": "api/BenchmarkDotNet.Analysers.ZeroMeasurementAnalyser.html",
    "title": "Class ZeroMeasurementAnalyser | BenchmarkDotNet",
    "summary": "Class ZeroMeasurementAnalyser Namespace BenchmarkDotNet.Analysers Assembly BenchmarkDotNet.dll public class ZeroMeasurementAnalyser : AnalyserBase, IAnalyser Inheritance object AnalyserBase ZeroMeasurementAnalyser Implements IAnalyser Inherited Members AnalyserBase.Analyse(Summary) AnalyserBase.AnalyseSummary(Summary) AnalyserBase.CreateHint(string, BenchmarkReport, bool) AnalyserBase.CreateWarning(string, BenchmarkReport, bool) AnalyserBase.CreateError(string, BenchmarkReport, bool) Fields Default public static readonly IAnalyser Default Field Value IAnalyser Properties Id public override string Id { get; } Property Value string Methods AnalyseReport(BenchmarkReport, Summary) protected override IEnumerable<Conclusion> AnalyseReport(BenchmarkReport report, Summary summary) Parameters report BenchmarkReport summary Summary Returns IEnumerable<Conclusion>"
  },
  "api/BenchmarkDotNet.Attributes.AllCategoriesFilterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.AllCategoriesFilterAttribute.html",
    "title": "Class AllCategoriesFilterAttribute | BenchmarkDotNet",
    "summary": "Class AllCategoriesFilterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class AllCategoriesFilterAttribute : FilterConfigBaseAttribute, IConfigSource Inheritance object Attribute FilterConfigBaseAttribute AllCategoriesFilterAttribute Implements IConfigSource Inherited Members FilterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors AllCategoriesFilterAttribute() public AllCategoriesFilterAttribute() AllCategoriesFilterAttribute(params string[]) public AllCategoriesFilterAttribute(params string[] targetCategories) Parameters targetCategories string[]"
  },
  "api/BenchmarkDotNet.Attributes.AllStatisticsColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.AllStatisticsColumnAttribute.html",
    "title": "Class AllStatisticsColumnAttribute | BenchmarkDotNet",
    "summary": "Class AllStatisticsColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class AllStatisticsColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute AllStatisticsColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors AllStatisticsColumnAttribute() public AllStatisticsColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.AnyCategoriesFilterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.AnyCategoriesFilterAttribute.html",
    "title": "Class AnyCategoriesFilterAttribute | BenchmarkDotNet",
    "summary": "Class AnyCategoriesFilterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class AnyCategoriesFilterAttribute : FilterConfigBaseAttribute, IConfigSource Inheritance object Attribute FilterConfigBaseAttribute AnyCategoriesFilterAttribute Implements IConfigSource Inherited Members FilterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors AnyCategoriesFilterAttribute() public AnyCategoriesFilterAttribute() AnyCategoriesFilterAttribute(params string[]) public AnyCategoriesFilterAttribute(params string[] targetCategories) Parameters targetCategories string[]"
  },
  "api/BenchmarkDotNet.Attributes.ArgumentsAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ArgumentsAttribute.html",
    "title": "Class ArgumentsAttribute | BenchmarkDotNet",
    "summary": "Class ArgumentsAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)] public class ArgumentsAttribute : PriorityAttribute Inheritance object Attribute PriorityAttribute ArgumentsAttribute Inherited Members PriorityAttribute.Priority Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ArgumentsAttribute() public ArgumentsAttribute() ArgumentsAttribute(params object?[]?) public ArgumentsAttribute(params object?[]? values) Parameters values object[] Properties Values public object?[] Values { get; } Property Value object[]"
  },
  "api/BenchmarkDotNet.Attributes.ArgumentsSourceAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ArgumentsSourceAttribute.html",
    "title": "Class ArgumentsSourceAttribute | BenchmarkDotNet",
    "summary": "Class ArgumentsSourceAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)] public class ArgumentsSourceAttribute : PriorityAttribute Inheritance object Attribute PriorityAttribute ArgumentsSourceAttribute Inherited Members PriorityAttribute.Priority Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ArgumentsSourceAttribute(string) public ArgumentsSourceAttribute(string name) Parameters name string Properties Name public string Name { get; } Property Value string"
  },
  "api/BenchmarkDotNet.Attributes.ArtifactsPathAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ArtifactsPathAttribute.html",
    "title": "Class ArtifactsPathAttribute | BenchmarkDotNet",
    "summary": "Class ArtifactsPathAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Class)] public class ArtifactsPathAttribute : Attribute, IConfigSource Inheritance object Attribute ArtifactsPathAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ArtifactsPathAttribute(string) public ArtifactsPathAttribute(string value) Parameters value string Properties Config public IConfig Config { get; } Property Value IConfig Value public string Value { get; } Property Value string"
  },
  "api/BenchmarkDotNet.Attributes.AsciiDocExporterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.AsciiDocExporterAttribute.html",
    "title": "Class AsciiDocExporterAttribute | BenchmarkDotNet",
    "summary": "Class AsciiDocExporterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class AsciiDocExporterAttribute : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute AsciiDocExporterAttribute Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors AsciiDocExporterAttribute() public AsciiDocExporterAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.BaselineColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.BaselineColumnAttribute.html",
    "title": "Class BaselineColumnAttribute | BenchmarkDotNet",
    "summary": "Class BaselineColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class BaselineColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute BaselineColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors BaselineColumnAttribute() public BaselineColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.BenchmarkAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.BenchmarkAttribute.html",
    "title": "Class BenchmarkAttribute | BenchmarkDotNet",
    "summary": "Class BenchmarkAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll [AttributeUsage(AttributeTargets.Method)] public class BenchmarkAttribute : Attribute Inheritance object Attribute BenchmarkAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors BenchmarkAttribute(int, string) public BenchmarkAttribute(int sourceCodeLineNumber = 0, string sourceCodeFile = \"\") Parameters sourceCodeLineNumber int sourceCodeFile string Properties Baseline public bool Baseline { get; set; } Property Value bool Description public string? Description { get; set; } Property Value string OperationsPerInvoke public int OperationsPerInvoke { get; set; } Property Value int SourceCodeFile public string SourceCodeFile { get; } Property Value string SourceCodeLineNumber public int SourceCodeLineNumber { get; } Property Value int"
  },
  "api/BenchmarkDotNet.Attributes.BenchmarkCategoryAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.BenchmarkCategoryAttribute.html",
    "title": "Class BenchmarkCategoryAttribute | BenchmarkDotNet",
    "summary": "Class BenchmarkCategoryAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = true)] public class BenchmarkCategoryAttribute : Attribute Inheritance object Attribute BenchmarkCategoryAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors BenchmarkCategoryAttribute() protected BenchmarkCategoryAttribute() BenchmarkCategoryAttribute(params string[]) public BenchmarkCategoryAttribute(params string[] categories) Parameters categories string[] Properties Categories public string[] Categories { get; } Property Value string[]"
  },
  "api/BenchmarkDotNet.Attributes.CategoriesColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.CategoriesColumnAttribute.html",
    "title": "Class CategoriesColumnAttribute | BenchmarkDotNet",
    "summary": "Class CategoriesColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class CategoriesColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute CategoriesColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors CategoriesColumnAttribute() public CategoriesColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.CategoryDiscovererAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.CategoryDiscovererAttribute.html",
    "title": "Class CategoryDiscovererAttribute | BenchmarkDotNet",
    "summary": "Class CategoryDiscovererAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Class)] public class CategoryDiscovererAttribute : Attribute, IConfigSource Inheritance object Attribute CategoryDiscovererAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors CategoryDiscovererAttribute(bool) public CategoryDiscovererAttribute(bool inherit = true) Parameters inherit bool Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.ClrJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ClrJobAttribute.html",
    "title": "Class ClrJobAttribute | BenchmarkDotNet",
    "summary": "Class ClrJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [Obsolete(\"Please use [SimpleJob(RuntimeMoniker.Net$)] instead.\", false)] public class ClrJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute ClrJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ClrJobAttribute() public ClrJobAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.ColumnConfigBaseAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ColumnConfigBaseAttribute.html",
    "title": "Class ColumnConfigBaseAttribute | BenchmarkDotNet",
    "summary": "Class ColumnConfigBaseAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public abstract class ColumnConfigBaseAttribute : Attribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute Implements IConfigSource Derived AllStatisticsColumnAttribute BaselineColumnAttribute CategoriesColumnAttribute ConfidenceIntervalErrorColumnAttribute IterationsColumnAttribute KurtosisColumnAttribute LogicalGroupColumnAttribute MaxColumnAttribute MeanColumnAttribute MedianColumnAttribute MinColumnAttribute MValueColumnAttribute NamespaceColumnAttribute OperationsPerSecondAttribute Q1ColumnAttribute Q3ColumnAttribute RankColumnAttribute SkewnessColumnAttribute StatisticalTestColumnAttribute StdDevColumnAttribute StdErrorColumnAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ColumnConfigBaseAttribute() protected ColumnConfigBaseAttribute() ColumnConfigBaseAttribute(params IColumn[]) protected ColumnConfigBaseAttribute(params IColumn[] columns) Parameters columns IColumn[] Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.ConfidenceIntervalErrorColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ConfidenceIntervalErrorColumnAttribute.html",
    "title": "Class ConfidenceIntervalErrorColumnAttribute | BenchmarkDotNet",
    "summary": "Class ConfidenceIntervalErrorColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class ConfidenceIntervalErrorColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute ConfidenceIntervalErrorColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ConfidenceIntervalErrorColumnAttribute() public ConfidenceIntervalErrorColumnAttribute() ConfidenceIntervalErrorColumnAttribute(ConfidenceLevel) public ConfidenceIntervalErrorColumnAttribute(ConfidenceLevel level) Parameters level ConfidenceLevel"
  },
  "api/BenchmarkDotNet.Attributes.ConfigAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ConfigAttribute.html",
    "title": "Class ConfigAttribute | BenchmarkDotNet",
    "summary": "Class ConfigAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class ConfigAttribute : Attribute, IConfigSource Inheritance object Attribute ConfigAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ConfigAttribute(Type) public ConfigAttribute(Type type) Parameters type Type Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.CoreJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.CoreJobAttribute.html",
    "title": "Class CoreJobAttribute | BenchmarkDotNet",
    "summary": "Class CoreJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [Obsolete(\"Please use [SimpleJob(RuntimeMoniker.NetCoreApp$)] instead.\", false)] public class CoreJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute CoreJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors CoreJobAttribute() public CoreJobAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.CsvExporterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.CsvExporterAttribute.html",
    "title": "Class CsvExporterAttribute | BenchmarkDotNet",
    "summary": "Class CsvExporterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class CsvExporterAttribute : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute CsvExporterAttribute Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors CsvExporterAttribute(CsvSeparator) public CsvExporterAttribute(CsvSeparator separator = CsvSeparator.CurrentCulture) Parameters separator CsvSeparator"
  },
  "api/BenchmarkDotNet.Attributes.CsvMeasurementsExporterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.CsvMeasurementsExporterAttribute.html",
    "title": "Class CsvMeasurementsExporterAttribute | BenchmarkDotNet",
    "summary": "Class CsvMeasurementsExporterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class CsvMeasurementsExporterAttribute : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute CsvMeasurementsExporterAttribute Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors CsvMeasurementsExporterAttribute(CsvSeparator) public CsvMeasurementsExporterAttribute(CsvSeparator separator = CsvSeparator.CurrentCulture) Parameters separator CsvSeparator"
  },
  "api/BenchmarkDotNet.Attributes.DisassemblyDiagnoserAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.DisassemblyDiagnoserAttribute.html",
    "title": "Class DisassemblyDiagnoserAttribute | BenchmarkDotNet",
    "summary": "Class DisassemblyDiagnoserAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Class)] public class DisassemblyDiagnoserAttribute : Attribute, IConfigSource Inheritance object Attribute DisassemblyDiagnoserAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors DisassemblyDiagnoserAttribute() protected DisassemblyDiagnoserAttribute() DisassemblyDiagnoserAttribute(int, DisassemblySyntax, bool, bool, bool, bool, bool, bool, params string[]) public DisassemblyDiagnoserAttribute(int maxDepth = 1, DisassemblySyntax syntax = DisassemblySyntax.Masm, bool printSource = false, bool printInstructionAddresses = false, bool exportGithubMarkdown = true, bool exportHtml = false, bool exportCombinedDisassemblyReport = false, bool exportDiff = false, params string[] filters) Parameters maxDepth int Includes called methods to given level. 1 by default, indexed from 1. To print just the benchmark set it to 0. syntax DisassemblySyntax The disassembly syntax. MASM is the default. printSource bool C#|F#|VB source code will be printed. False by default. printInstructionAddresses bool Print instruction addresses. False by default exportGithubMarkdown bool Exports to GitHub markdown. True by default. exportHtml bool Exports to HTML with clickable links. False by default. exportCombinedDisassemblyReport bool Exports all benchmarks to a single HTML report. Makes it easy to compare different runtimes or methods (each becomes a column in HTML table). exportDiff bool Exports a diff of the assembly code to the Github markdown format. False by default. filters string[] Glob patterns applied to full method signatures by the the disassembler. Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.DryClrJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.DryClrJobAttribute.html",
    "title": "Class DryClrJobAttribute | BenchmarkDotNet",
    "summary": "Class DryClrJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [Obsolete(\"Please use [DryJob(RuntimeMoniker.Net$)] instead.\", false)] public class DryClrJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute DryClrJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors DryClrJobAttribute() public DryClrJobAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.DryCoreJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.DryCoreJobAttribute.html",
    "title": "Class DryCoreJobAttribute | BenchmarkDotNet",
    "summary": "Class DryCoreJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [Obsolete(\"Please use [DryJob(RuntimeMoniker.NetCoreApp$)] instead.\", false)] public class DryCoreJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute DryCoreJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors DryCoreJobAttribute() public DryCoreJobAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.DryJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.DryJobAttribute.html",
    "title": "Class DryJobAttribute | BenchmarkDotNet",
    "summary": "Class DryJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class DryJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute DryJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors DryJobAttribute() public DryJobAttribute() DryJobAttribute(RuntimeMoniker) defines a new Dry Job that targets specified Framework public DryJobAttribute(RuntimeMoniker runtimeMoniker) Parameters runtimeMoniker RuntimeMoniker Target Framework to test. DryJobAttribute(RuntimeMoniker, Jit, Platform) defines a new Dry Job that targets specified Framework, JIT and Platform public DryJobAttribute(RuntimeMoniker runtimeMoniker, Jit jit, Platform platform) Parameters runtimeMoniker RuntimeMoniker Target Framework to test. jit Jit Jit to test. platform Platform Platform to test."
  },
  "api/BenchmarkDotNet.Attributes.DryMonoJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.DryMonoJobAttribute.html",
    "title": "Class DryMonoJobAttribute | BenchmarkDotNet",
    "summary": "Class DryMonoJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [Obsolete(\"Please use [DryJob(RuntimeMoniker.Mono)] instead.\", false)] public class DryMonoJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute DryMonoJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors DryMonoJobAttribute() public DryMonoJobAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.EncodingAttribute.ASCII.html": {
    "href": "api/BenchmarkDotNet.Attributes.EncodingAttribute.ASCII.html",
    "title": "Class EncodingAttribute.ASCII | BenchmarkDotNet",
    "summary": "Class EncodingAttribute.ASCII Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class EncodingAttribute.ASCII : EncodingAttribute, IConfigSource Inheritance object Attribute EncodingAttribute EncodingAttribute.ASCII Implements IConfigSource Inherited Members EncodingAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ASCII() public ASCII()"
  },
  "api/BenchmarkDotNet.Attributes.EncodingAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.EncodingAttribute.html",
    "title": "Class EncodingAttribute | BenchmarkDotNet",
    "summary": "Class EncodingAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] [Obsolete(\"Don't use it\")] public class EncodingAttribute : Attribute, IConfigSource Inheritance object Attribute EncodingAttribute Implements IConfigSource Derived EncodingAttribute.ASCII EncodingAttribute.Unicode Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.EncodingAttribute.Unicode.html": {
    "href": "api/BenchmarkDotNet.Attributes.EncodingAttribute.Unicode.html",
    "title": "Class EncodingAttribute.Unicode | BenchmarkDotNet",
    "summary": "Class EncodingAttribute.Unicode Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class EncodingAttribute.Unicode : EncodingAttribute, IConfigSource Inheritance object Attribute EncodingAttribute EncodingAttribute.Unicode Implements IConfigSource Inherited Members EncodingAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors Unicode() public Unicode()"
  },
  "api/BenchmarkDotNet.Attributes.EvaluateOverheadAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.EvaluateOverheadAttribute.html",
    "title": "Class EvaluateOverheadAttribute | BenchmarkDotNet",
    "summary": "Class EvaluateOverheadAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Specifies if the overhead should be evaluated (Idle runs) and it's average value subtracted from every result. True by default, very important for nano-benchmarks. public class EvaluateOverheadAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute EvaluateOverheadAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors EvaluateOverheadAttribute(bool) public EvaluateOverheadAttribute(bool value = true) Parameters value bool"
  },
  "api/BenchmarkDotNet.Attributes.EventPipeProfilerAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.EventPipeProfilerAttribute.html",
    "title": "Class EventPipeProfilerAttribute | BenchmarkDotNet",
    "summary": "Class EventPipeProfilerAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Class)] public class EventPipeProfilerAttribute : Attribute, IConfigSource Inheritance object Attribute EventPipeProfilerAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors EventPipeProfilerAttribute(EventPipeProfile) public EventPipeProfilerAttribute(EventPipeProfile profile) Parameters profile EventPipeProfile Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.ExceptionDiagnoserAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ExceptionDiagnoserAttribute.html",
    "title": "Class ExceptionDiagnoserAttribute | BenchmarkDotNet",
    "summary": "Class ExceptionDiagnoserAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Class)] public class ExceptionDiagnoserAttribute : Attribute, IConfigSource Inheritance object Attribute ExceptionDiagnoserAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ExceptionDiagnoserAttribute(bool) public ExceptionDiagnoserAttribute(bool displayExceptionsIfZeroValue = true) Parameters displayExceptionsIfZeroValue bool Display Exceptions column. True by default. Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.ExceptionDiagnoserConfig.html": {
    "href": "api/BenchmarkDotNet.Attributes.ExceptionDiagnoserConfig.html",
    "title": "Class ExceptionDiagnoserConfig | BenchmarkDotNet",
    "summary": "Class ExceptionDiagnoserConfig Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class ExceptionDiagnoserConfig Inheritance object ExceptionDiagnoserConfig Constructors ExceptionDiagnoserConfig(bool) public ExceptionDiagnoserConfig(bool displayExceptionsIfZeroValue = true) Parameters displayExceptionsIfZeroValue bool Determines whether the Exceptions column is displayed when its value is not calculated. True by default. Properties DisplayExceptionsIfZeroValue public bool DisplayExceptionsIfZeroValue { get; } Property Value bool"
  },
  "api/BenchmarkDotNet.Attributes.ExecutionValidatorAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ExecutionValidatorAttribute.html",
    "title": "Class ExecutionValidatorAttribute | BenchmarkDotNet",
    "summary": "Class ExecutionValidatorAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class ExecutionValidatorAttribute : ValidatorConfigBaseAttribute, IConfigSource Inheritance object Attribute ValidatorConfigBaseAttribute ExecutionValidatorAttribute Implements IConfigSource Inherited Members ValidatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ExecutionValidatorAttribute() public ExecutionValidatorAttribute() ExecutionValidatorAttribute(bool) public ExecutionValidatorAttribute(bool failOnError) Parameters failOnError bool"
  },
  "api/BenchmarkDotNet.Attributes.ExporterConfigBaseAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ExporterConfigBaseAttribute.html",
    "title": "Class ExporterConfigBaseAttribute | BenchmarkDotNet",
    "summary": "Class ExporterConfigBaseAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class ExporterConfigBaseAttribute : Attribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute Implements IConfigSource Derived AsciiDocExporterAttribute CsvExporterAttribute CsvMeasurementsExporterAttribute HtmlExporterAttribute JsonExporterAttribute MarkdownExporterAttribute MarkdownExporterAttribute.Atlassian MarkdownExporterAttribute.Default MarkdownExporterAttribute.GitHub MarkdownExporterAttribute.StackOverflow PlainExporterAttribute RPlotExporterAttribute XmlExporterAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ExporterConfigBaseAttribute() protected ExporterConfigBaseAttribute() ExporterConfigBaseAttribute(params IExporter[]) protected ExporterConfigBaseAttribute(params IExporter[] exporters) Parameters exporters IExporter[] Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.FilterConfigBaseAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.FilterConfigBaseAttribute.html",
    "title": "Class FilterConfigBaseAttribute | BenchmarkDotNet",
    "summary": "Class FilterConfigBaseAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class|AttributeTargets.Method)] public abstract class FilterConfigBaseAttribute : Attribute, IConfigSource Inheritance object Attribute FilterConfigBaseAttribute Implements IConfigSource Derived AllCategoriesFilterAttribute AnyCategoriesFilterAttribute AotFilterAttribute OperatingSystemsArchitectureFilterAttribute OperatingSystemsFilterAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors FilterConfigBaseAttribute() protected FilterConfigBaseAttribute() FilterConfigBaseAttribute(params IFilter[]) protected FilterConfigBaseAttribute(params IFilter[] filters) Parameters filters IFilter[] Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.Filters.AotFilterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.Filters.AotFilterAttribute.html",
    "title": "Class AotFilterAttribute | BenchmarkDotNet",
    "summary": "Class AotFilterAttribute Namespace BenchmarkDotNet.Attributes.Filters Assembly BenchmarkDotNet.dll public class AotFilterAttribute : FilterConfigBaseAttribute, IConfigSource Inheritance object Attribute FilterConfigBaseAttribute AotFilterAttribute Implements IConfigSource Inherited Members FilterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors AotFilterAttribute(string?) public AotFilterAttribute(string? reason = null) Parameters reason string"
  },
  "api/BenchmarkDotNet.Attributes.Filters.html": {
    "href": "api/BenchmarkDotNet.Attributes.Filters.html",
    "title": "Namespace BenchmarkDotNet.Attributes.Filters | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Attributes.Filters Classes AotFilterAttribute"
  },
  "api/BenchmarkDotNet.Attributes.GcConcurrentAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.GcConcurrentAttribute.html",
    "title": "Class GcConcurrentAttribute | BenchmarkDotNet",
    "summary": "Class GcConcurrentAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Specifies whether the common language runtime runs garbage collection on a separate thread. false: Does not run garbage collection concurrently. true: Runs garbage collection concurrently. This is the default. public class GcConcurrentAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute GcConcurrentAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors GcConcurrentAttribute(bool) public GcConcurrentAttribute(bool value = true) Parameters value bool"
  },
  "api/BenchmarkDotNet.Attributes.GcForceAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.GcForceAttribute.html",
    "title": "Class GcForceAttribute | BenchmarkDotNet",
    "summary": "Class GcForceAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Specifies whether the BenchmarkDotNet's benchmark runner forces full garbage collection after each benchmark invocation false: Does not force garbage collection. true: Forces full garbage collection after each benchmark invocation. This is the default. public class GcForceAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute GcForceAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors GcForceAttribute(bool) public GcForceAttribute(bool value = true) Parameters value bool"
  },
  "api/BenchmarkDotNet.Attributes.GcServerAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.GcServerAttribute.html",
    "title": "Class GcServerAttribute | BenchmarkDotNet",
    "summary": "Class GcServerAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Specifies whether the common language runtime runs server garbage collection. false: Does not run server garbage collection. This is the default. true: Runs server garbage collection. public class GcServerAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute GcServerAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors GcServerAttribute(bool) public GcServerAttribute(bool value = false) Parameters value bool"
  },
  "api/BenchmarkDotNet.Attributes.GenericTypeArgumentsAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.GenericTypeArgumentsAttribute.html",
    "title": "Class GenericTypeArgumentsAttribute | BenchmarkDotNet",
    "summary": "Class GenericTypeArgumentsAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)] public class GenericTypeArgumentsAttribute : Attribute Inheritance object Attribute GenericTypeArgumentsAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors GenericTypeArgumentsAttribute(Type) public GenericTypeArgumentsAttribute(Type type) Parameters type Type GenericTypeArgumentsAttribute(Type, Type) public GenericTypeArgumentsAttribute(Type type1, Type type2) Parameters type1 Type type2 Type GenericTypeArgumentsAttribute(Type, Type, Type) public GenericTypeArgumentsAttribute(Type type1, Type type2, Type type3) Parameters type1 Type type2 Type type3 Type Properties GenericTypeArguments public Type[] GenericTypeArguments { get; } Property Value Type[]"
  },
  "api/BenchmarkDotNet.Attributes.GlobalCleanupAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.GlobalCleanupAttribute.html",
    "title": "Class GlobalCleanupAttribute | BenchmarkDotNet",
    "summary": "Class GlobalCleanupAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll Marks method to be executed after all benchmark iterations. It's going to be executed only once, after all benchmark runs. [AttributeUsage(AttributeTargets.Method)] public class GlobalCleanupAttribute : TargetedAttribute Inheritance object Attribute TargetedAttribute GlobalCleanupAttribute Inherited Members TargetedAttribute.Match(MethodInfo) TargetedAttribute.Targets TargetedAttribute.Target Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors GlobalCleanupAttribute() public GlobalCleanupAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.GlobalSetupAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.GlobalSetupAttribute.html",
    "title": "Class GlobalSetupAttribute | BenchmarkDotNet",
    "summary": "Class GlobalSetupAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll Marks method to be executed before all benchmark iterations. It's going to be executed only once, just before warm up. [AttributeUsage(AttributeTargets.Method)] public class GlobalSetupAttribute : TargetedAttribute Inheritance object Attribute TargetedAttribute GlobalSetupAttribute Inherited Members TargetedAttribute.Match(MethodInfo) TargetedAttribute.Targets TargetedAttribute.Target Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors GlobalSetupAttribute() public GlobalSetupAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.GroupBenchmarksByAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.GroupBenchmarksByAttribute.html",
    "title": "Class GroupBenchmarksByAttribute | BenchmarkDotNet",
    "summary": "Class GroupBenchmarksByAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Class)] public class GroupBenchmarksByAttribute : Attribute, IConfigSource Inheritance object Attribute GroupBenchmarksByAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors GroupBenchmarksByAttribute() protected GroupBenchmarksByAttribute() GroupBenchmarksByAttribute(params BenchmarkLogicalGroupRule[]) public GroupBenchmarksByAttribute(params BenchmarkLogicalGroupRule[] rules) Parameters rules BenchmarkLogicalGroupRule[] Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.HardwareCountersAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.HardwareCountersAttribute.html",
    "title": "Class HardwareCountersAttribute | BenchmarkDotNet",
    "summary": "Class HardwareCountersAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class HardwareCountersAttribute : Attribute, IConfigSource Inheritance object Attribute HardwareCountersAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors HardwareCountersAttribute() protected HardwareCountersAttribute() HardwareCountersAttribute(params HardwareCounter[]) public HardwareCountersAttribute(params HardwareCounter[] counters) Parameters counters HardwareCounter[] Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.HideColumnsAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.HideColumnsAttribute.html",
    "title": "Class HideColumnsAttribute | BenchmarkDotNet",
    "summary": "Class HideColumnsAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class HideColumnsAttribute : Attribute, IConfigSource Inheritance object Attribute HideColumnsAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors HideColumnsAttribute() protected HideColumnsAttribute() HideColumnsAttribute(params string[]) public HideColumnsAttribute(params string[] names) Parameters names string[] Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.html": {
    "href": "api/BenchmarkDotNet.Attributes.html",
    "title": "Namespace BenchmarkDotNet.Attributes | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Attributes Classes AllCategoriesFilterAttribute AllStatisticsColumnAttribute AnyCategoriesFilterAttribute ArgumentsAttribute ArgumentsSourceAttribute ArtifactsPathAttribute AsciiDocExporterAttribute BaselineColumnAttribute BenchmarkAttribute BenchmarkCategoryAttribute CategoriesColumnAttribute CategoryDiscovererAttribute ClrJobAttribute ColumnConfigBaseAttribute ConfidenceIntervalErrorColumnAttribute ConfigAttribute CoreJobAttribute CsvExporterAttribute CsvMeasurementsExporterAttribute DisassemblyDiagnoserAttribute DryClrJobAttribute DryCoreJobAttribute DryJobAttribute DryMonoJobAttribute EncodingAttribute EncodingAttribute.ASCII EncodingAttribute.Unicode EvaluateOverheadAttribute Specifies if the overhead should be evaluated (Idle runs) and it's average value subtracted from every result. True by default, very important for nano-benchmarks. EventPipeProfilerAttribute ExceptionDiagnoserAttribute ExceptionDiagnoserConfig ExecutionValidatorAttribute ExporterConfigBaseAttribute FilterConfigBaseAttribute GcConcurrentAttribute Specifies whether the common language runtime runs garbage collection on a separate thread. false: Does not run garbage collection concurrently. true: Runs garbage collection concurrently. This is the default. GcForceAttribute Specifies whether the BenchmarkDotNet's benchmark runner forces full garbage collection after each benchmark invocation false: Does not force garbage collection. true: Forces full garbage collection after each benchmark invocation. This is the default. GcServerAttribute Specifies whether the common language runtime runs server garbage collection. false: Does not run server garbage collection. This is the default. true: Runs server garbage collection. GenericTypeArgumentsAttribute GlobalCleanupAttribute Marks method to be executed after all benchmark iterations. It's going to be executed only once, after all benchmark runs. GlobalSetupAttribute Marks method to be executed before all benchmark iterations. It's going to be executed only once, just before warm up. GroupBenchmarksByAttribute HardwareCountersAttribute HideColumnsAttribute HtmlExporterAttribute InProcessAttribute InnerIterationCountAttribute Invocation count in a single iteration. Does exactly the same as InvocationCountAttribute, added to make porting from xunit-performance to BenchmarkDotNet easier InvocationCountAttribute Invocation count in a single iteration. If specified, IterationTime will be ignored. If specified, it must be a multiple of UnrollFactor. IterationCleanupAttribute Marks method to be executed after each benchmark iteration. This should NOT be used for microbenchmarks - please see the docs. IterationCountAttribute How many target iterations should be performed If specified, MinIterationCount will be ignored. If specified, MaxIterationCount will be ignored. IterationSetupAttribute Marks method to be executed before each benchmark iteration. This should NOT be used for microbenchmarks - please see the docs. IterationTimeAttribute Desired time of execution of an iteration. Used by Pilot stage to estimate the number of invocations per iteration. The default value is 500 milliseconds. IterationsColumnAttribute JobConfigBaseAttribute JobMutatorConfigBaseAttribute JsonExporterAttribute JsonExporterAttribute.BriefAttribute JsonExporterAttribute.BriefCompressed JsonExporterAttribute.Full JsonExporterAttribute.FullCompressed KeepBenchmarkFilesAttribute determines if all auto-generated files should be kept or removed after running the benchmarks KurtosisColumnAttribute LegacyJitX64JobAttribute LegacyJitX86JobAttribute LogicalGroupColumnAttribute LongRunJobAttribute MValueColumnAttribute Prints mvalue. See http://www.brendangregg.com/FrequencyTrails/modes.html MarkdownExporterAttribute MarkdownExporterAttribute.Atlassian MarkdownExporterAttribute.Default MarkdownExporterAttribute.GitHub MarkdownExporterAttribute.StackOverflow MaxAbsoluteErrorAttribute Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error). Doesn't have a default value. If MaxRelativeError is also provided, the smallest value is used as stop criteria. MaxColumnAttribute MaxIterationCountAttribute Maximum count of target iterations that should be performed The default value is 100 If you set this value to below 15, then MultimodalDistributionAnalyzer is not going to work MaxRelativeErrorAttribute Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error). The default value is 0.02. If MaxAbsoluteError is also provided, the smallest value is used as stop criteria. MaxWarmupCountAttribute Maximum count of warmup iterations that should be performed The default value is 50 MeanColumnAttribute MedianColumnAttribute MediumRunJobAttribute MemoryDiagnoserAttribute MemoryRandomizationAttribute specifies whether Engine should allocate some random-sized memory between iterations it makes [GlobalCleanup] and [GlobalSetup] methods to be executed after every iteration MinColumnAttribute MinInvokeCountAttribute Minimum count of benchmark invocations per iteration. The default value is 4. MinIterationCountAttribute Minimum count of target iterations that should be performed. The default value is 15. If you set this value to below 15, then MultimodalDistributionAnalyzer is not going to work. MinIterationTimeAttribute Minimum time of a single iteration. Unlike Run.IterationTime, this characteristic specifies only the lower limit. In case of need, BenchmarkDotNet can increase this value. The default value is 500 milliseconds. MinWarmupCountAttribute Minimum count of warmup iterations that should be performed The default value is 6 MonoJobAttribute NamespaceColumnAttribute Add a column with the target method namespace. OperatingSystemsArchitectureFilterAttribute OperatingSystemsFilterAttribute OperationsPerSecondAttribute OrdererAttribute OutliersAttribute Specifies which outliers should be removed from the distribution ParamsAllValuesAttribute ParamsAttribute ParamsSourceAttribute PerfCollectProfilerAttribute PlainExporterAttribute PriorityAttribute ProcessCountAttribute How many times we should launch process with target benchmark. Q1ColumnAttribute Q3ColumnAttribute RPlotExporterAttribute RankColumnAttribute ReturnValueValidatorAttribute RunOncePerIterationAttribute Run the benchmark exactly once per iteration. RyuJitX64JobAttribute RyuJitX86JobAttribute ShortRunJobAttribute SimpleJobAttribute SkewnessColumnAttribute StatisticalTestColumnAttribute StdDevColumnAttribute StdErrorColumnAttribute StopOnFirstErrorAttribute determines if running should be stop after first error TargetedAttribute Base class for attributes that are targeted at one or more method(s) ThreadingDiagnoserAttribute UnicodeConsoleLoggerAttribute Enable unicode support in console logger ValidatorConfigBaseAttribute VeryLongRunJobAttribute WakeLockAttribute Placing a WakeLockAttribute on your assembly or class controls whether the Windows system enters sleep or turns off the display while benchmarks run. WarmupCountAttribute How many warmup iterations should be performed. XmlExporterAttribute XmlExporterAttribute.Brief XmlExporterAttribute.BriefCompressed XmlExporterAttribute.Full XmlExporterAttribute.FullCompressed Enums OS"
  },
  "api/BenchmarkDotNet.Attributes.HtmlExporterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.HtmlExporterAttribute.html",
    "title": "Class HtmlExporterAttribute | BenchmarkDotNet",
    "summary": "Class HtmlExporterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class HtmlExporterAttribute : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute HtmlExporterAttribute Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors HtmlExporterAttribute() public HtmlExporterAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.InnerIterationCountAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.InnerIterationCountAttribute.html",
    "title": "Class InnerIterationCountAttribute | BenchmarkDotNet",
    "summary": "Class InnerIterationCountAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Invocation count in a single iteration. Does exactly the same as InvocationCountAttribute, added to make porting from xunit-performance to BenchmarkDotNet easier public class InnerIterationCountAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute InnerIterationCountAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors InnerIterationCountAttribute(int) public InnerIterationCountAttribute(int invocationCount) Parameters invocationCount int"
  },
  "api/BenchmarkDotNet.Attributes.InProcessAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.InProcessAttribute.html",
    "title": "Class InProcessAttribute | BenchmarkDotNet",
    "summary": "Class InProcessAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class InProcessAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute InProcessAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors InProcessAttribute(bool) public InProcessAttribute(bool dontLogOutput = false) Parameters dontLogOutput bool"
  },
  "api/BenchmarkDotNet.Attributes.InvocationCountAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.InvocationCountAttribute.html",
    "title": "Class InvocationCountAttribute | BenchmarkDotNet",
    "summary": "Class InvocationCountAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Invocation count in a single iteration. If specified, IterationTime will be ignored. If specified, it must be a multiple of UnrollFactor. public class InvocationCountAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute InvocationCountAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors InvocationCountAttribute(int, int) public InvocationCountAttribute(int invocationCount, int unrollFactor = 1) Parameters invocationCount int unrollFactor int"
  },
  "api/BenchmarkDotNet.Attributes.IterationCleanupAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.IterationCleanupAttribute.html",
    "title": "Class IterationCleanupAttribute | BenchmarkDotNet",
    "summary": "Class IterationCleanupAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll Marks method to be executed after each benchmark iteration. This should NOT be used for microbenchmarks - please see the docs. [AttributeUsage(AttributeTargets.Method)] public class IterationCleanupAttribute : TargetedAttribute Inheritance object Attribute TargetedAttribute IterationCleanupAttribute Inherited Members TargetedAttribute.Match(MethodInfo) TargetedAttribute.Targets TargetedAttribute.Target Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors IterationCleanupAttribute() public IterationCleanupAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.IterationCountAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.IterationCountAttribute.html",
    "title": "Class IterationCountAttribute | BenchmarkDotNet",
    "summary": "Class IterationCountAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll How many target iterations should be performed If specified, MinIterationCount will be ignored. If specified, MaxIterationCount will be ignored. public class IterationCountAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute IterationCountAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors IterationCountAttribute(int) public IterationCountAttribute(int targetIterationCount) Parameters targetIterationCount int"
  },
  "api/BenchmarkDotNet.Attributes.IterationsColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.IterationsColumnAttribute.html",
    "title": "Class IterationsColumnAttribute | BenchmarkDotNet",
    "summary": "Class IterationsColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class IterationsColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute IterationsColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors IterationsColumnAttribute() public IterationsColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.IterationSetupAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.IterationSetupAttribute.html",
    "title": "Class IterationSetupAttribute | BenchmarkDotNet",
    "summary": "Class IterationSetupAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll Marks method to be executed before each benchmark iteration. This should NOT be used for microbenchmarks - please see the docs. [AttributeUsage(AttributeTargets.Method)] public class IterationSetupAttribute : TargetedAttribute Inheritance object Attribute TargetedAttribute IterationSetupAttribute Inherited Members TargetedAttribute.Match(MethodInfo) TargetedAttribute.Targets TargetedAttribute.Target Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors IterationSetupAttribute() public IterationSetupAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.IterationTimeAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.IterationTimeAttribute.html",
    "title": "Class IterationTimeAttribute | BenchmarkDotNet",
    "summary": "Class IterationTimeAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Desired time of execution of an iteration. Used by Pilot stage to estimate the number of invocations per iteration. The default value is 500 milliseconds. public class IterationTimeAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute IterationTimeAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors IterationTimeAttribute(double) public IterationTimeAttribute(double milliseconds) Parameters milliseconds double"
  },
  "api/BenchmarkDotNet.Attributes.JobConfigBaseAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.JobConfigBaseAttribute.html",
    "title": "Class JobConfigBaseAttribute | BenchmarkDotNet",
    "summary": "Class JobConfigBaseAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class JobConfigBaseAttribute : Attribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute Implements IConfigSource Derived ClrJobAttribute CoreJobAttribute DryClrJobAttribute DryCoreJobAttribute DryJobAttribute DryMonoJobAttribute InProcessAttribute LegacyJitX64JobAttribute LegacyJitX86JobAttribute LongRunJobAttribute MediumRunJobAttribute MonoJobAttribute RyuJitX64JobAttribute RyuJitX86JobAttribute ShortRunJobAttribute SimpleJobAttribute VeryLongRunJobAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors JobConfigBaseAttribute() public JobConfigBaseAttribute() JobConfigBaseAttribute(Job) protected JobConfigBaseAttribute(Job job) Parameters job Job Properties Config public IConfig Config { get; } Property Value IConfig Methods GetJob(Job, RuntimeMoniker, Jit?, Platform?) protected static Job GetJob(Job sourceJob, RuntimeMoniker runtimeMoniker, Jit? jit, Platform? platform) Parameters sourceJob Job runtimeMoniker RuntimeMoniker jit Jit? platform Platform? Returns Job"
  },
  "api/BenchmarkDotNet.Attributes.JobMutatorConfigBaseAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.JobMutatorConfigBaseAttribute.html",
    "title": "Class JobMutatorConfigBaseAttribute | BenchmarkDotNet",
    "summary": "Class JobMutatorConfigBaseAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = false)] public class JobMutatorConfigBaseAttribute : Attribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute Implements IConfigSource Derived EvaluateOverheadAttribute GcConcurrentAttribute GcForceAttribute GcServerAttribute InnerIterationCountAttribute InvocationCountAttribute IterationCountAttribute IterationTimeAttribute MaxAbsoluteErrorAttribute MaxIterationCountAttribute MaxRelativeErrorAttribute MaxWarmupCountAttribute MemoryRandomizationAttribute MinInvokeCountAttribute MinIterationCountAttribute MinIterationTimeAttribute MinWarmupCountAttribute OutliersAttribute ProcessCountAttribute RunOncePerIterationAttribute WarmupCountAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors JobMutatorConfigBaseAttribute() public JobMutatorConfigBaseAttribute() JobMutatorConfigBaseAttribute(Job) protected JobMutatorConfigBaseAttribute(Job job) Parameters job Job Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.JsonExporterAttribute.BriefAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.JsonExporterAttribute.BriefAttribute.html",
    "title": "Class JsonExporterAttribute.BriefAttribute | BenchmarkDotNet",
    "summary": "Class JsonExporterAttribute.BriefAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class JsonExporterAttribute.BriefAttribute : JsonExporterAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute JsonExporterAttribute JsonExporterAttribute.BriefAttribute Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors BriefAttribute() public BriefAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.JsonExporterAttribute.BriefCompressed.html": {
    "href": "api/BenchmarkDotNet.Attributes.JsonExporterAttribute.BriefCompressed.html",
    "title": "Class JsonExporterAttribute.BriefCompressed | BenchmarkDotNet",
    "summary": "Class JsonExporterAttribute.BriefCompressed Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class JsonExporterAttribute.BriefCompressed : JsonExporterAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute JsonExporterAttribute JsonExporterAttribute.BriefCompressed Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors BriefCompressed() public BriefCompressed()"
  },
  "api/BenchmarkDotNet.Attributes.JsonExporterAttribute.Full.html": {
    "href": "api/BenchmarkDotNet.Attributes.JsonExporterAttribute.Full.html",
    "title": "Class JsonExporterAttribute.Full | BenchmarkDotNet",
    "summary": "Class JsonExporterAttribute.Full Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class JsonExporterAttribute.Full : JsonExporterAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute JsonExporterAttribute JsonExporterAttribute.Full Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors Full() public Full()"
  },
  "api/BenchmarkDotNet.Attributes.JsonExporterAttribute.FullCompressed.html": {
    "href": "api/BenchmarkDotNet.Attributes.JsonExporterAttribute.FullCompressed.html",
    "title": "Class JsonExporterAttribute.FullCompressed | BenchmarkDotNet",
    "summary": "Class JsonExporterAttribute.FullCompressed Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class JsonExporterAttribute.FullCompressed : JsonExporterAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute JsonExporterAttribute JsonExporterAttribute.FullCompressed Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors FullCompressed() public FullCompressed()"
  },
  "api/BenchmarkDotNet.Attributes.JsonExporterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.JsonExporterAttribute.html",
    "title": "Class JsonExporterAttribute | BenchmarkDotNet",
    "summary": "Class JsonExporterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class JsonExporterAttribute : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute JsonExporterAttribute Implements IConfigSource Derived JsonExporterAttribute.BriefAttribute JsonExporterAttribute.BriefCompressed JsonExporterAttribute.Full JsonExporterAttribute.FullCompressed Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors JsonExporterAttribute(string, bool, bool) public JsonExporterAttribute(string fileNameSuffix = \"\", bool indentJson = false, bool excludeMeasurements = false) Parameters fileNameSuffix string indentJson bool excludeMeasurements bool"
  },
  "api/BenchmarkDotNet.Attributes.KeepBenchmarkFilesAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.KeepBenchmarkFilesAttribute.html",
    "title": "Class KeepBenchmarkFilesAttribute | BenchmarkDotNet",
    "summary": "Class KeepBenchmarkFilesAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll determines if all auto-generated files should be kept or removed after running the benchmarks [AttributeUsage(AttributeTargets.Class)] public class KeepBenchmarkFilesAttribute : Attribute, IConfigSource Inheritance object Attribute KeepBenchmarkFilesAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors KeepBenchmarkFilesAttribute(bool) public KeepBenchmarkFilesAttribute(bool value = true) Parameters value bool Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.KurtosisColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.KurtosisColumnAttribute.html",
    "title": "Class KurtosisColumnAttribute | BenchmarkDotNet",
    "summary": "Class KurtosisColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class KurtosisColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute KurtosisColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors KurtosisColumnAttribute() public KurtosisColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.LegacyJitX64JobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.LegacyJitX64JobAttribute.html",
    "title": "Class LegacyJitX64JobAttribute | BenchmarkDotNet",
    "summary": "Class LegacyJitX64JobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class LegacyJitX64JobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute LegacyJitX64JobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors LegacyJitX64JobAttribute() public LegacyJitX64JobAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.LegacyJitX86JobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.LegacyJitX86JobAttribute.html",
    "title": "Class LegacyJitX86JobAttribute | BenchmarkDotNet",
    "summary": "Class LegacyJitX86JobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class LegacyJitX86JobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute LegacyJitX86JobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors LegacyJitX86JobAttribute() public LegacyJitX86JobAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.LogicalGroupColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.LogicalGroupColumnAttribute.html",
    "title": "Class LogicalGroupColumnAttribute | BenchmarkDotNet",
    "summary": "Class LogicalGroupColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class LogicalGroupColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute LogicalGroupColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors LogicalGroupColumnAttribute() public LogicalGroupColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.LongRunJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.LongRunJobAttribute.html",
    "title": "Class LongRunJobAttribute | BenchmarkDotNet",
    "summary": "Class LongRunJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class LongRunJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute LongRunJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors LongRunJobAttribute() public LongRunJobAttribute() LongRunJobAttribute(RuntimeMoniker) defines a new LongRun Job that targets specified Framework public LongRunJobAttribute(RuntimeMoniker runtimeMoniker) Parameters runtimeMoniker RuntimeMoniker Target Framework to test. LongRunJobAttribute(RuntimeMoniker, Jit, Platform) defines a new LongRun Job that targets specified Framework, JIT and Platform public LongRunJobAttribute(RuntimeMoniker runtimeMoniker, Jit jit, Platform platform) Parameters runtimeMoniker RuntimeMoniker Target Framework to test. jit Jit Jit to test. platform Platform Platform to test."
  },
  "api/BenchmarkDotNet.Attributes.MarkdownExporterAttribute.Atlassian.html": {
    "href": "api/BenchmarkDotNet.Attributes.MarkdownExporterAttribute.Atlassian.html",
    "title": "Class MarkdownExporterAttribute.Atlassian | BenchmarkDotNet",
    "summary": "Class MarkdownExporterAttribute.Atlassian Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class MarkdownExporterAttribute.Atlassian : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute MarkdownExporterAttribute.Atlassian Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors Atlassian() public Atlassian()"
  },
  "api/BenchmarkDotNet.Attributes.MarkdownExporterAttribute.Default.html": {
    "href": "api/BenchmarkDotNet.Attributes.MarkdownExporterAttribute.Default.html",
    "title": "Class MarkdownExporterAttribute.Default | BenchmarkDotNet",
    "summary": "Class MarkdownExporterAttribute.Default Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class MarkdownExporterAttribute.Default : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute MarkdownExporterAttribute.Default Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors Default() public Default()"
  },
  "api/BenchmarkDotNet.Attributes.MarkdownExporterAttribute.GitHub.html": {
    "href": "api/BenchmarkDotNet.Attributes.MarkdownExporterAttribute.GitHub.html",
    "title": "Class MarkdownExporterAttribute.GitHub | BenchmarkDotNet",
    "summary": "Class MarkdownExporterAttribute.GitHub Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class MarkdownExporterAttribute.GitHub : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute MarkdownExporterAttribute.GitHub Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors GitHub() public GitHub()"
  },
  "api/BenchmarkDotNet.Attributes.MarkdownExporterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MarkdownExporterAttribute.html",
    "title": "Class MarkdownExporterAttribute | BenchmarkDotNet",
    "summary": "Class MarkdownExporterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class MarkdownExporterAttribute : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute MarkdownExporterAttribute Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MarkdownExporterAttribute() public MarkdownExporterAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.MarkdownExporterAttribute.StackOverflow.html": {
    "href": "api/BenchmarkDotNet.Attributes.MarkdownExporterAttribute.StackOverflow.html",
    "title": "Class MarkdownExporterAttribute.StackOverflow | BenchmarkDotNet",
    "summary": "Class MarkdownExporterAttribute.StackOverflow Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class MarkdownExporterAttribute.StackOverflow : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute MarkdownExporterAttribute.StackOverflow Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors StackOverflow() public StackOverflow()"
  },
  "api/BenchmarkDotNet.Attributes.MaxAbsoluteErrorAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MaxAbsoluteErrorAttribute.html",
    "title": "Class MaxAbsoluteErrorAttribute | BenchmarkDotNet",
    "summary": "Class MaxAbsoluteErrorAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error). Doesn't have a default value. If MaxRelativeError is also provided, the smallest value is used as stop criteria. public class MaxAbsoluteErrorAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute MaxAbsoluteErrorAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MaxAbsoluteErrorAttribute(double) public MaxAbsoluteErrorAttribute(double nanoseconds) Parameters nanoseconds double"
  },
  "api/BenchmarkDotNet.Attributes.MaxColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MaxColumnAttribute.html",
    "title": "Class MaxColumnAttribute | BenchmarkDotNet",
    "summary": "Class MaxColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class MaxColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute MaxColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MaxColumnAttribute() public MaxColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.MaxIterationCountAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MaxIterationCountAttribute.html",
    "title": "Class MaxIterationCountAttribute | BenchmarkDotNet",
    "summary": "Class MaxIterationCountAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Maximum count of target iterations that should be performed The default value is 100 If you set this value to below 15, then MultimodalDistributionAnalyzer is not going to work public class MaxIterationCountAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute MaxIterationCountAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MaxIterationCountAttribute(int) public MaxIterationCountAttribute(int maxTargetIterationCount) Parameters maxTargetIterationCount int"
  },
  "api/BenchmarkDotNet.Attributes.MaxRelativeErrorAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MaxRelativeErrorAttribute.html",
    "title": "Class MaxRelativeErrorAttribute | BenchmarkDotNet",
    "summary": "Class MaxRelativeErrorAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error). The default value is 0.02. If MaxAbsoluteError is also provided, the smallest value is used as stop criteria. public class MaxRelativeErrorAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute MaxRelativeErrorAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MaxRelativeErrorAttribute(double) public MaxRelativeErrorAttribute(double maxRelativeError) Parameters maxRelativeError double"
  },
  "api/BenchmarkDotNet.Attributes.MaxWarmupCountAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MaxWarmupCountAttribute.html",
    "title": "Class MaxWarmupCountAttribute | BenchmarkDotNet",
    "summary": "Class MaxWarmupCountAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Maximum count of warmup iterations that should be performed The default value is 50 public class MaxWarmupCountAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute MaxWarmupCountAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MaxWarmupCountAttribute(int, bool) public MaxWarmupCountAttribute(int maxWarmupCount, bool forceAutoWarmup = false) Parameters maxWarmupCount int Maximum count of warmup iterations that should be performed. The default value is 50 forceAutoWarmup bool if set to true, will overwrite WarmupCount of the global config"
  },
  "api/BenchmarkDotNet.Attributes.MeanColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MeanColumnAttribute.html",
    "title": "Class MeanColumnAttribute | BenchmarkDotNet",
    "summary": "Class MeanColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class MeanColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute MeanColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MeanColumnAttribute() public MeanColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.MedianColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MedianColumnAttribute.html",
    "title": "Class MedianColumnAttribute | BenchmarkDotNet",
    "summary": "Class MedianColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class MedianColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute MedianColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MedianColumnAttribute() public MedianColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.MediumRunJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MediumRunJobAttribute.html",
    "title": "Class MediumRunJobAttribute | BenchmarkDotNet",
    "summary": "Class MediumRunJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class MediumRunJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute MediumRunJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MediumRunJobAttribute() public MediumRunJobAttribute() MediumRunJobAttribute(RuntimeMoniker) defines a new MediumRun Job that targets specified Framework public MediumRunJobAttribute(RuntimeMoniker runtimeMoniker) Parameters runtimeMoniker RuntimeMoniker Target Framework to test. MediumRunJobAttribute(RuntimeMoniker, Jit, Platform) defines a new MediumRun Job that targets specified Framework, JIT and Platform public MediumRunJobAttribute(RuntimeMoniker runtimeMoniker, Jit jit, Platform platform) Parameters runtimeMoniker RuntimeMoniker Target Framework to test. jit Jit Jit to test. platform Platform Platform to test."
  },
  "api/BenchmarkDotNet.Attributes.MemoryDiagnoserAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MemoryDiagnoserAttribute.html",
    "title": "Class MemoryDiagnoserAttribute | BenchmarkDotNet",
    "summary": "Class MemoryDiagnoserAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Class)] public class MemoryDiagnoserAttribute : Attribute, IConfigSource Inheritance object Attribute MemoryDiagnoserAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MemoryDiagnoserAttribute(bool) public MemoryDiagnoserAttribute(bool displayGenColumns = true) Parameters displayGenColumns bool Display Garbage Collections per Generation columns (Gen 0, Gen 1, Gen 2). True by default. Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.MemoryRandomizationAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MemoryRandomizationAttribute.html",
    "title": "Class MemoryRandomizationAttribute | BenchmarkDotNet",
    "summary": "Class MemoryRandomizationAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll specifies whether Engine should allocate some random-sized memory between iterations it makes [GlobalCleanup] and [GlobalSetup] methods to be executed after every iteration public class MemoryRandomizationAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute MemoryRandomizationAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MemoryRandomizationAttribute(bool, OutlierMode) public MemoryRandomizationAttribute(bool enable = true, OutlierMode outlierMode = 0) Parameters enable bool outlierMode OutlierMode"
  },
  "api/BenchmarkDotNet.Attributes.MinColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MinColumnAttribute.html",
    "title": "Class MinColumnAttribute | BenchmarkDotNet",
    "summary": "Class MinColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class MinColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute MinColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MinColumnAttribute() public MinColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.MinInvokeCountAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MinInvokeCountAttribute.html",
    "title": "Class MinInvokeCountAttribute | BenchmarkDotNet",
    "summary": "Class MinInvokeCountAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Minimum count of benchmark invocations per iteration. The default value is 4. public class MinInvokeCountAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute MinInvokeCountAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MinInvokeCountAttribute(int) public MinInvokeCountAttribute(int minInvokeCount) Parameters minInvokeCount int"
  },
  "api/BenchmarkDotNet.Attributes.MinIterationCountAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MinIterationCountAttribute.html",
    "title": "Class MinIterationCountAttribute | BenchmarkDotNet",
    "summary": "Class MinIterationCountAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Minimum count of target iterations that should be performed. The default value is 15. If you set this value to below 15, then MultimodalDistributionAnalyzer is not going to work. public class MinIterationCountAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute MinIterationCountAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MinIterationCountAttribute(int) public MinIterationCountAttribute(int minTargetIterationCount) Parameters minTargetIterationCount int"
  },
  "api/BenchmarkDotNet.Attributes.MinIterationTimeAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MinIterationTimeAttribute.html",
    "title": "Class MinIterationTimeAttribute | BenchmarkDotNet",
    "summary": "Class MinIterationTimeAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Minimum time of a single iteration. Unlike Run.IterationTime, this characteristic specifies only the lower limit. In case of need, BenchmarkDotNet can increase this value. The default value is 500 milliseconds. public class MinIterationTimeAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute MinIterationTimeAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MinIterationTimeAttribute(double) public MinIterationTimeAttribute(double milliseconds) Parameters milliseconds double"
  },
  "api/BenchmarkDotNet.Attributes.MinWarmupCountAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MinWarmupCountAttribute.html",
    "title": "Class MinWarmupCountAttribute | BenchmarkDotNet",
    "summary": "Class MinWarmupCountAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Minimum count of warmup iterations that should be performed The default value is 6 public class MinWarmupCountAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute MinWarmupCountAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MinWarmupCountAttribute(int, bool) public MinWarmupCountAttribute(int minWarmupCount, bool forceAutoWarmup = false) Parameters minWarmupCount int Minimum count of warmup iterations that should be performed. The default value is 6 forceAutoWarmup bool if set to true, will overwrite WarmupCount in the global config"
  },
  "api/BenchmarkDotNet.Attributes.MonoJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MonoJobAttribute.html",
    "title": "Class MonoJobAttribute | BenchmarkDotNet",
    "summary": "Class MonoJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class MonoJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute MonoJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MonoJobAttribute(RuntimeMoniker, bool) public MonoJobAttribute(RuntimeMoniker runtimeMoniker, bool baseline = false) Parameters runtimeMoniker RuntimeMoniker baseline bool MonoJobAttribute(bool) public MonoJobAttribute(bool baseline = false) Parameters baseline bool MonoJobAttribute(string, string, bool) public MonoJobAttribute(string name, string path, bool baseline = false) Parameters name string path string baseline bool"
  },
  "api/BenchmarkDotNet.Attributes.MValueColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.MValueColumnAttribute.html",
    "title": "Class MValueColumnAttribute | BenchmarkDotNet",
    "summary": "Class MValueColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Prints mvalue. See http://www.brendangregg.com/FrequencyTrails/modes.html public class MValueColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute MValueColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors MValueColumnAttribute() public MValueColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.NamespaceColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.NamespaceColumnAttribute.html",
    "title": "Class NamespaceColumnAttribute | BenchmarkDotNet",
    "summary": "Class NamespaceColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Add a column with the target method namespace. public class NamespaceColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute NamespaceColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors NamespaceColumnAttribute() public NamespaceColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.OperatingSystemsArchitectureFilterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.OperatingSystemsArchitectureFilterAttribute.html",
    "title": "Class OperatingSystemsArchitectureFilterAttribute | BenchmarkDotNet",
    "summary": "Class OperatingSystemsArchitectureFilterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class OperatingSystemsArchitectureFilterAttribute : FilterConfigBaseAttribute, IConfigSource Inheritance object Attribute FilterConfigBaseAttribute OperatingSystemsArchitectureFilterAttribute Implements IConfigSource Inherited Members FilterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors OperatingSystemsArchitectureFilterAttribute() public OperatingSystemsArchitectureFilterAttribute() OperatingSystemsArchitectureFilterAttribute(bool, params Architecture[]) public OperatingSystemsArchitectureFilterAttribute(bool allowed, params Architecture[] architectures) Parameters allowed bool if set to true, the architectures are enabled, if set to false, disabled architectures Architecture[] the architecture(s) for which the filter should be applied"
  },
  "api/BenchmarkDotNet.Attributes.OperatingSystemsFilterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.OperatingSystemsFilterAttribute.html",
    "title": "Class OperatingSystemsFilterAttribute | BenchmarkDotNet",
    "summary": "Class OperatingSystemsFilterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class OperatingSystemsFilterAttribute : FilterConfigBaseAttribute, IConfigSource Inheritance object Attribute FilterConfigBaseAttribute OperatingSystemsFilterAttribute Implements IConfigSource Inherited Members FilterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors OperatingSystemsFilterAttribute() public OperatingSystemsFilterAttribute() OperatingSystemsFilterAttribute(bool, params OS[]) public OperatingSystemsFilterAttribute(bool allowed, params OS[] platforms) Parameters allowed bool if set to true, the OSes belonging to platforms are enabled, if set to false, disabled platforms OS[] the platform(s) for which the filter should be applied"
  },
  "api/BenchmarkDotNet.Attributes.OperationsPerSecondAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.OperationsPerSecondAttribute.html",
    "title": "Class OperationsPerSecondAttribute | BenchmarkDotNet",
    "summary": "Class OperationsPerSecondAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class OperationsPerSecondAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute OperationsPerSecondAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors OperationsPerSecondAttribute() public OperationsPerSecondAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.OrdererAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.OrdererAttribute.html",
    "title": "Class OrdererAttribute | BenchmarkDotNet",
    "summary": "Class OrdererAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class OrdererAttribute : Attribute, IConfigSource Inheritance object Attribute OrdererAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors OrdererAttribute(SummaryOrderPolicy, MethodOrderPolicy) public OrdererAttribute(SummaryOrderPolicy summaryOrderPolicy = SummaryOrderPolicy.Default, MethodOrderPolicy methodOrderPolicy = MethodOrderPolicy.Declared) Parameters summaryOrderPolicy SummaryOrderPolicy methodOrderPolicy MethodOrderPolicy Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.OS.html": {
    "href": "api/BenchmarkDotNet.Attributes.OS.html",
    "title": "Enum OS | BenchmarkDotNet",
    "summary": "Enum OS Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public enum OS : byte Fields Browser = 3 WebAssembly Linux = 1 Windows = 0 macOS = 2"
  },
  "api/BenchmarkDotNet.Attributes.OutliersAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.OutliersAttribute.html",
    "title": "Class OutliersAttribute | BenchmarkDotNet",
    "summary": "Class OutliersAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Specifies which outliers should be removed from the distribution public class OutliersAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute OutliersAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors OutliersAttribute(OutlierMode) public OutliersAttribute(OutlierMode outlierMode) Parameters outlierMode OutlierMode"
  },
  "api/BenchmarkDotNet.Attributes.ParamsAllValuesAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ParamsAllValuesAttribute.html",
    "title": "Class ParamsAllValuesAttribute | BenchmarkDotNet",
    "summary": "Class ParamsAllValuesAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll [AttributeUsage(AttributeTargets.Property|AttributeTargets.Field)] public class ParamsAllValuesAttribute : PriorityAttribute Inheritance object Attribute PriorityAttribute ParamsAllValuesAttribute Inherited Members PriorityAttribute.Priority Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ParamsAllValuesAttribute() public ParamsAllValuesAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.ParamsAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ParamsAttribute.html",
    "title": "Class ParamsAttribute | BenchmarkDotNet",
    "summary": "Class ParamsAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll [AttributeUsage(AttributeTargets.Property|AttributeTargets.Field)] public class ParamsAttribute : PriorityAttribute Inheritance object Attribute PriorityAttribute ParamsAttribute Inherited Members PriorityAttribute.Priority Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ParamsAttribute() public ParamsAttribute() ParamsAttribute(params object?[]?) public ParamsAttribute(params object?[]? values) Parameters values object[] Properties Values public object?[] Values { get; protected set; } Property Value object[]"
  },
  "api/BenchmarkDotNet.Attributes.ParamsSourceAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ParamsSourceAttribute.html",
    "title": "Class ParamsSourceAttribute | BenchmarkDotNet",
    "summary": "Class ParamsSourceAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll [AttributeUsage(AttributeTargets.Property|AttributeTargets.Field)] public class ParamsSourceAttribute : PriorityAttribute Inheritance object Attribute PriorityAttribute ParamsSourceAttribute Inherited Members PriorityAttribute.Priority Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ParamsSourceAttribute(string) public ParamsSourceAttribute(string name) Parameters name string Properties Name public string Name { get; } Property Value string"
  },
  "api/BenchmarkDotNet.Attributes.PerfCollectProfilerAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.PerfCollectProfilerAttribute.html",
    "title": "Class PerfCollectProfilerAttribute | BenchmarkDotNet",
    "summary": "Class PerfCollectProfilerAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class PerfCollectProfilerAttribute : Attribute, IConfigSource Inheritance object Attribute PerfCollectProfilerAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors PerfCollectProfilerAttribute(bool, int) public PerfCollectProfilerAttribute(bool performExtraBenchmarksRun = false, int timeoutInSeconds = 300) Parameters performExtraBenchmarksRun bool When set to true, benchmarks will be executed one more time with the profiler attached. If set to false, there will be no extra run but the results will contain overhead. False by default. timeoutInSeconds int How long should we wait for the perfcollect script to finish processing the trace. 300s by default. Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.PlainExporterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.PlainExporterAttribute.html",
    "title": "Class PlainExporterAttribute | BenchmarkDotNet",
    "summary": "Class PlainExporterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class PlainExporterAttribute : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute PlainExporterAttribute Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors PlainExporterAttribute() public PlainExporterAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.PriorityAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.PriorityAttribute.html",
    "title": "Class PriorityAttribute | BenchmarkDotNet",
    "summary": "Class PriorityAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll public abstract class PriorityAttribute : Attribute Inheritance object Attribute PriorityAttribute Derived ArgumentsAttribute ArgumentsSourceAttribute ParamsAllValuesAttribute ParamsAttribute ParamsSourceAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors PriorityAttribute() protected PriorityAttribute() Properties Priority Defines display order of column in the same category. public int Priority { get; set; } Property Value int"
  },
  "api/BenchmarkDotNet.Attributes.ProcessCountAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ProcessCountAttribute.html",
    "title": "Class ProcessCountAttribute | BenchmarkDotNet",
    "summary": "Class ProcessCountAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll How many times we should launch process with target benchmark. public class ProcessCountAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute ProcessCountAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ProcessCountAttribute(int) public ProcessCountAttribute(int processLaunchCount) Parameters processLaunchCount int"
  },
  "api/BenchmarkDotNet.Attributes.Q1ColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.Q1ColumnAttribute.html",
    "title": "Class Q1ColumnAttribute | BenchmarkDotNet",
    "summary": "Class Q1ColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class Q1ColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute Q1ColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors Q1ColumnAttribute() public Q1ColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.Q3ColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.Q3ColumnAttribute.html",
    "title": "Class Q3ColumnAttribute | BenchmarkDotNet",
    "summary": "Class Q3ColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class Q3ColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute Q3ColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors Q3ColumnAttribute() public Q3ColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.RankColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.RankColumnAttribute.html",
    "title": "Class RankColumnAttribute | BenchmarkDotNet",
    "summary": "Class RankColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class RankColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute RankColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors RankColumnAttribute(NumeralSystem) public RankColumnAttribute(NumeralSystem system = NumeralSystem.Arabic) Parameters system NumeralSystem"
  },
  "api/BenchmarkDotNet.Attributes.ReturnValueValidatorAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ReturnValueValidatorAttribute.html",
    "title": "Class ReturnValueValidatorAttribute | BenchmarkDotNet",
    "summary": "Class ReturnValueValidatorAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class ReturnValueValidatorAttribute : ValidatorConfigBaseAttribute, IConfigSource Inheritance object Attribute ValidatorConfigBaseAttribute ReturnValueValidatorAttribute Implements IConfigSource Inherited Members ValidatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ReturnValueValidatorAttribute() public ReturnValueValidatorAttribute() ReturnValueValidatorAttribute(bool) public ReturnValueValidatorAttribute(bool failOnError) Parameters failOnError bool"
  },
  "api/BenchmarkDotNet.Attributes.RPlotExporterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.RPlotExporterAttribute.html",
    "title": "Class RPlotExporterAttribute | BenchmarkDotNet",
    "summary": "Class RPlotExporterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class RPlotExporterAttribute : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute RPlotExporterAttribute Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors RPlotExporterAttribute() public RPlotExporterAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.RunOncePerIterationAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.RunOncePerIterationAttribute.html",
    "title": "Class RunOncePerIterationAttribute | BenchmarkDotNet",
    "summary": "Class RunOncePerIterationAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Run the benchmark exactly once per iteration. public class RunOncePerIterationAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute RunOncePerIterationAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors RunOncePerIterationAttribute() public RunOncePerIterationAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.RyuJitX64JobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.RyuJitX64JobAttribute.html",
    "title": "Class RyuJitX64JobAttribute | BenchmarkDotNet",
    "summary": "Class RyuJitX64JobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class RyuJitX64JobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute RyuJitX64JobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors RyuJitX64JobAttribute() public RyuJitX64JobAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.RyuJitX86JobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.RyuJitX86JobAttribute.html",
    "title": "Class RyuJitX86JobAttribute | BenchmarkDotNet",
    "summary": "Class RyuJitX86JobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class RyuJitX86JobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute RyuJitX86JobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors RyuJitX86JobAttribute() public RyuJitX86JobAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.ShortRunJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ShortRunJobAttribute.html",
    "title": "Class ShortRunJobAttribute | BenchmarkDotNet",
    "summary": "Class ShortRunJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class ShortRunJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute ShortRunJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ShortRunJobAttribute() public ShortRunJobAttribute() ShortRunJobAttribute(RuntimeMoniker) defines a new ShortRun Job that targets specified Framework public ShortRunJobAttribute(RuntimeMoniker runtimeMoniker) Parameters runtimeMoniker RuntimeMoniker Target Framework to test. ShortRunJobAttribute(RuntimeMoniker, Jit, Platform) defines a new ShortRun Job that targets specified Framework, JIT and Platform public ShortRunJobAttribute(RuntimeMoniker runtimeMoniker, Jit jit, Platform platform) Parameters runtimeMoniker RuntimeMoniker Target Framework to test. jit Jit Jit to test. platform Platform Platform to test."
  },
  "api/BenchmarkDotNet.Attributes.SimpleJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.SimpleJobAttribute.html",
    "title": "Class SimpleJobAttribute | BenchmarkDotNet",
    "summary": "Class SimpleJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class SimpleJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute SimpleJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors SimpleJobAttribute(RunStrategy, RuntimeMoniker, int, int, int, int, string?, bool) public SimpleJobAttribute(RunStrategy runStrategy, RuntimeMoniker runtimeMoniker, int launchCount = -1, int warmupCount = -1, int iterationCount = -1, int invocationCount = -1, string? id = null, bool baseline = false) Parameters runStrategy RunStrategy runtimeMoniker RuntimeMoniker launchCount int warmupCount int iterationCount int invocationCount int id string baseline bool SimpleJobAttribute(RunStrategy, int, int, int, int, string?, bool) public SimpleJobAttribute(RunStrategy runStrategy, int launchCount = -1, int warmupCount = -1, int iterationCount = -1, int invocationCount = -1, string? id = null, bool baseline = false) Parameters runStrategy RunStrategy launchCount int warmupCount int iterationCount int invocationCount int id string baseline bool SimpleJobAttribute(RuntimeMoniker, int, int, int, int, string?, bool) public SimpleJobAttribute(RuntimeMoniker runtimeMoniker, int launchCount = -1, int warmupCount = -1, int iterationCount = -1, int invocationCount = -1, string? id = null, bool baseline = false) Parameters runtimeMoniker RuntimeMoniker launchCount int warmupCount int iterationCount int invocationCount int id string baseline bool SimpleJobAttribute(int, int, int, int, string?, bool) public SimpleJobAttribute(int launchCount = -1, int warmupCount = -1, int iterationCount = -1, int invocationCount = -1, string? id = null, bool baseline = false) Parameters launchCount int warmupCount int iterationCount int invocationCount int id string baseline bool"
  },
  "api/BenchmarkDotNet.Attributes.SkewnessColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.SkewnessColumnAttribute.html",
    "title": "Class SkewnessColumnAttribute | BenchmarkDotNet",
    "summary": "Class SkewnessColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class SkewnessColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute SkewnessColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors SkewnessColumnAttribute() public SkewnessColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.StatisticalTestColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.StatisticalTestColumnAttribute.html",
    "title": "Class StatisticalTestColumnAttribute | BenchmarkDotNet",
    "summary": "Class StatisticalTestColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class StatisticalTestColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute StatisticalTestColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors StatisticalTestColumnAttribute() public StatisticalTestColumnAttribute() StatisticalTestColumnAttribute(string) public StatisticalTestColumnAttribute(string threshold) Parameters threshold string StatisticalTestColumnAttribute(string, SignificanceLevel) public StatisticalTestColumnAttribute(string threshold, SignificanceLevel significanceLevel) Parameters threshold string significanceLevel SignificanceLevel"
  },
  "api/BenchmarkDotNet.Attributes.StdDevColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.StdDevColumnAttribute.html",
    "title": "Class StdDevColumnAttribute | BenchmarkDotNet",
    "summary": "Class StdDevColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class StdDevColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute StdDevColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors StdDevColumnAttribute() public StdDevColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.StdErrorColumnAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.StdErrorColumnAttribute.html",
    "title": "Class StdErrorColumnAttribute | BenchmarkDotNet",
    "summary": "Class StdErrorColumnAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class StdErrorColumnAttribute : ColumnConfigBaseAttribute, IConfigSource Inheritance object Attribute ColumnConfigBaseAttribute StdErrorColumnAttribute Implements IConfigSource Inherited Members ColumnConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors StdErrorColumnAttribute() public StdErrorColumnAttribute()"
  },
  "api/BenchmarkDotNet.Attributes.StopOnFirstErrorAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.StopOnFirstErrorAttribute.html",
    "title": "Class StopOnFirstErrorAttribute | BenchmarkDotNet",
    "summary": "Class StopOnFirstErrorAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll determines if running should be stop after first error [AttributeUsage(AttributeTargets.Class)] public class StopOnFirstErrorAttribute : Attribute, IConfigSource Inheritance object Attribute StopOnFirstErrorAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors StopOnFirstErrorAttribute(bool) public StopOnFirstErrorAttribute(bool value = true) Parameters value bool Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.TargetedAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.TargetedAttribute.html",
    "title": "Class TargetedAttribute | BenchmarkDotNet",
    "summary": "Class TargetedAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.Annotations.dll Base class for attributes that are targeted at one or more method(s) public abstract class TargetedAttribute : Attribute Inheritance object Attribute TargetedAttribute Derived GlobalCleanupAttribute GlobalSetupAttribute IterationCleanupAttribute IterationSetupAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors TargetedAttribute() protected TargetedAttribute() Properties Target Target method for attribute public string Target { get; set; } Property Value string Targets public string[] Targets { get; set; } Property Value string[] Methods Match(MethodInfo) public bool Match(MethodInfo method) Parameters method MethodInfo Returns bool"
  },
  "api/BenchmarkDotNet.Attributes.ThreadingDiagnoserAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ThreadingDiagnoserAttribute.html",
    "title": "Class ThreadingDiagnoserAttribute | BenchmarkDotNet",
    "summary": "Class ThreadingDiagnoserAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Class)] public class ThreadingDiagnoserAttribute : Attribute, IConfigSource Inheritance object Attribute ThreadingDiagnoserAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ThreadingDiagnoserAttribute(bool, bool) public ThreadingDiagnoserAttribute(bool displayLockContentionWhenZero = true, bool displayCompletedWorkItemCountWhenZero = true) Parameters displayLockContentionWhenZero bool Display configuration for 'LockContentionCount' when it is empty. True (displayed) by default. displayCompletedWorkItemCountWhenZero bool Display configuration for 'CompletedWorkItemCount' when it is empty. True (displayed) by default. Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.UnicodeConsoleLoggerAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.UnicodeConsoleLoggerAttribute.html",
    "title": "Class UnicodeConsoleLoggerAttribute | BenchmarkDotNet",
    "summary": "Class UnicodeConsoleLoggerAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Enable unicode support in console logger [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public class UnicodeConsoleLoggerAttribute : Attribute, IConfigSource Inheritance object Attribute UnicodeConsoleLoggerAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors UnicodeConsoleLoggerAttribute() public UnicodeConsoleLoggerAttribute() Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.ValidatorConfigBaseAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.ValidatorConfigBaseAttribute.html",
    "title": "Class ValidatorConfigBaseAttribute | BenchmarkDotNet",
    "summary": "Class ValidatorConfigBaseAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public abstract class ValidatorConfigBaseAttribute : Attribute, IConfigSource Inheritance object Attribute ValidatorConfigBaseAttribute Implements IConfigSource Derived ExecutionValidatorAttribute ReturnValueValidatorAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors ValidatorConfigBaseAttribute() protected ValidatorConfigBaseAttribute() ValidatorConfigBaseAttribute(params IValidator[]) protected ValidatorConfigBaseAttribute(params IValidator[] validators) Parameters validators IValidator[] Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.VeryLongRunJobAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.VeryLongRunJobAttribute.html",
    "title": "Class VeryLongRunJobAttribute | BenchmarkDotNet",
    "summary": "Class VeryLongRunJobAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class VeryLongRunJobAttribute : JobConfigBaseAttribute, IConfigSource Inheritance object Attribute JobConfigBaseAttribute VeryLongRunJobAttribute Implements IConfigSource Inherited Members JobConfigBaseAttribute.GetJob(Job, RuntimeMoniker, Jit?, Platform?) JobConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors VeryLongRunJobAttribute() public VeryLongRunJobAttribute() VeryLongRunJobAttribute(RuntimeMoniker) defines a new VeryLongRun Job that targets specified Framework public VeryLongRunJobAttribute(RuntimeMoniker runtimeMoniker) Parameters runtimeMoniker RuntimeMoniker Target Framework to test. VeryLongRunJobAttribute(RuntimeMoniker, Jit, Platform) defines a new VeryLongRun Job that targets specified Framework, JIT and Platform public VeryLongRunJobAttribute(RuntimeMoniker runtimeMoniker, Jit jit, Platform platform) Parameters runtimeMoniker RuntimeMoniker Target Framework to test. jit Jit Jit to test. platform Platform Platform to test."
  },
  "api/BenchmarkDotNet.Attributes.WakeLockAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.WakeLockAttribute.html",
    "title": "Class WakeLockAttribute | BenchmarkDotNet",
    "summary": "Class WakeLockAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll Placing a WakeLockAttribute on your assembly or class controls whether the Windows system enters sleep or turns off the display while benchmarks run. [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class)] public sealed class WakeLockAttribute : Attribute, IConfigSource Inheritance object Attribute WakeLockAttribute Implements IConfigSource Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors WakeLockAttribute(WakeLockType) public WakeLockAttribute(WakeLockType wakeLockType) Parameters wakeLockType WakeLockType Properties Config public IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Attributes.WarmupCountAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.WarmupCountAttribute.html",
    "title": "Class WarmupCountAttribute | BenchmarkDotNet",
    "summary": "Class WarmupCountAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll How many warmup iterations should be performed. public class WarmupCountAttribute : JobMutatorConfigBaseAttribute, IConfigSource Inheritance object Attribute JobMutatorConfigBaseAttribute WarmupCountAttribute Implements IConfigSource Inherited Members JobMutatorConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors WarmupCountAttribute(int) public WarmupCountAttribute(int warmupCount) Parameters warmupCount int"
  },
  "api/BenchmarkDotNet.Attributes.XmlExporterAttribute.Brief.html": {
    "href": "api/BenchmarkDotNet.Attributes.XmlExporterAttribute.Brief.html",
    "title": "Class XmlExporterAttribute.Brief | BenchmarkDotNet",
    "summary": "Class XmlExporterAttribute.Brief Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class XmlExporterAttribute.Brief : XmlExporterAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute XmlExporterAttribute XmlExporterAttribute.Brief Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors Brief() public Brief()"
  },
  "api/BenchmarkDotNet.Attributes.XmlExporterAttribute.BriefCompressed.html": {
    "href": "api/BenchmarkDotNet.Attributes.XmlExporterAttribute.BriefCompressed.html",
    "title": "Class XmlExporterAttribute.BriefCompressed | BenchmarkDotNet",
    "summary": "Class XmlExporterAttribute.BriefCompressed Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class XmlExporterAttribute.BriefCompressed : XmlExporterAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute XmlExporterAttribute XmlExporterAttribute.BriefCompressed Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors BriefCompressed() public BriefCompressed()"
  },
  "api/BenchmarkDotNet.Attributes.XmlExporterAttribute.Full.html": {
    "href": "api/BenchmarkDotNet.Attributes.XmlExporterAttribute.Full.html",
    "title": "Class XmlExporterAttribute.Full | BenchmarkDotNet",
    "summary": "Class XmlExporterAttribute.Full Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class XmlExporterAttribute.Full : XmlExporterAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute XmlExporterAttribute XmlExporterAttribute.Full Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors Full() public Full()"
  },
  "api/BenchmarkDotNet.Attributes.XmlExporterAttribute.FullCompressed.html": {
    "href": "api/BenchmarkDotNet.Attributes.XmlExporterAttribute.FullCompressed.html",
    "title": "Class XmlExporterAttribute.FullCompressed | BenchmarkDotNet",
    "summary": "Class XmlExporterAttribute.FullCompressed Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll public class XmlExporterAttribute.FullCompressed : XmlExporterAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute XmlExporterAttribute XmlExporterAttribute.FullCompressed Implements IConfigSource Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors FullCompressed() public FullCompressed()"
  },
  "api/BenchmarkDotNet.Attributes.XmlExporterAttribute.html": {
    "href": "api/BenchmarkDotNet.Attributes.XmlExporterAttribute.html",
    "title": "Class XmlExporterAttribute | BenchmarkDotNet",
    "summary": "Class XmlExporterAttribute Namespace BenchmarkDotNet.Attributes Assembly BenchmarkDotNet.dll [AttributeUsage(AttributeTargets.Assembly|AttributeTargets.Class, AllowMultiple = true)] public class XmlExporterAttribute : ExporterConfigBaseAttribute, IConfigSource Inheritance object Attribute ExporterConfigBaseAttribute XmlExporterAttribute Implements IConfigSource Derived XmlExporterAttribute.Brief XmlExporterAttribute.BriefCompressed XmlExporterAttribute.Full XmlExporterAttribute.FullCompressed Inherited Members ExporterConfigBaseAttribute.Config Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId Constructors XmlExporterAttribute(string, bool, bool) public XmlExporterAttribute(string fileNameSuffix = \"\", bool indentXml = false, bool excludeMeasurements = false) Parameters fileNameSuffix string indentXml bool excludeMeasurements bool"
  },
  "api/BenchmarkDotNet.Characteristics.Characteristic-1.html": {
    "href": "api/BenchmarkDotNet.Characteristics.Characteristic-1.html",
    "title": "Class Characteristic<T> | BenchmarkDotNet",
    "summary": "Class Characteristic<T> Namespace BenchmarkDotNet.Characteristics Assembly BenchmarkDotNet.dll public class Characteristic<T> : Characteristic Type Parameters T Inheritance object Characteristic Characteristic<T> Inherited Members Characteristic.EmptyValue Characteristic.Create<TOwner, T>(string) Characteristic.Create<TOwner, T>(string, T) Characteristic.Create<TOwner, T>(string, Func<CharacteristicObject, T, T>, T, bool) Characteristic.CreateHidden<TOwner, T>(string) Characteristic.CreateIgnoreOnApply<TOwner, T>(string) Characteristic.ToString() Characteristic.Id Characteristic.FullId Characteristic.IgnoreOnApply Characteristic.DontShowInSummary Characteristic.CharacteristicType Characteristic.DeclaringType Characteristic.HasChildCharacteristics Extension Methods CharacteristicHelper.IsPresentableCharacteristic(Characteristic, bool) Properties FallbackValue public T FallbackValue { get; } Property Value T this[CharacteristicObject] public T this[CharacteristicObject obj] { get; set; } Parameters obj CharacteristicObject Property Value T"
  },
  "api/BenchmarkDotNet.Characteristics.Characteristic.html": {
    "href": "api/BenchmarkDotNet.Characteristics.Characteristic.html",
    "title": "Class Characteristic | BenchmarkDotNet",
    "summary": "Class Characteristic Namespace BenchmarkDotNet.Characteristics Assembly BenchmarkDotNet.dll public abstract class Characteristic Inheritance object Characteristic Derived Characteristic<T> Extension Methods CharacteristicHelper.IsPresentableCharacteristic(Characteristic, bool) Constructors Characteristic(string, Type, Type, object, bool, bool) protected Characteristic(string id, Type characteristicType, Type declaringType, object fallbackValue, bool ignoreOnApply, bool dontShowInSummary = false) Parameters id string characteristicType Type declaringType Type fallbackValue object ignoreOnApply bool dontShowInSummary bool Fields EmptyValue public static readonly object EmptyValue Field Value object Properties CharacteristicType public Type CharacteristicType { get; } Property Value Type DeclaringType public Type DeclaringType { get; } Property Value Type DontShowInSummary public bool DontShowInSummary { get; } Property Value bool FullId public string FullId { get; } Property Value string HasChildCharacteristics public bool HasChildCharacteristics { get; } Property Value bool Id public string Id { get; } Property Value string IgnoreOnApply public bool IgnoreOnApply { get; } Property Value bool this[CharacteristicObject] public object? this[CharacteristicObject obj] { get; set; } Parameters obj CharacteristicObject Property Value object Methods CreateHidden<TOwner, T>(string) public static Characteristic<T> CreateHidden<TOwner, T>(string memberName) where TOwner : CharacteristicObject Parameters memberName string Returns Characteristic<T> Type Parameters TOwner T CreateIgnoreOnApply<TOwner, T>(string) public static Characteristic<T> CreateIgnoreOnApply<TOwner, T>(string memberName) where TOwner : CharacteristicObject Parameters memberName string Returns Characteristic<T> Type Parameters TOwner T Create<TOwner, T>(string) public static Characteristic<T> Create<TOwner, T>(string memberName) where TOwner : CharacteristicObject Parameters memberName string Returns Characteristic<T> Type Parameters TOwner T Create<TOwner, T>(string, Func<CharacteristicObject, T, T>, T, bool) public static Characteristic<T> Create<TOwner, T>(string memberName, Func<CharacteristicObject, T, T> resolver, T fallbackValue, bool ignoreOnApply) where TOwner : CharacteristicObject Parameters memberName string resolver Func<CharacteristicObject, T, T> fallbackValue T ignoreOnApply bool Returns Characteristic<T> Type Parameters TOwner T Create<TOwner, T>(string, T) public static Characteristic<T> Create<TOwner, T>(string memberName, T fallbackValue) where TOwner : CharacteristicObject Parameters memberName string fallbackValue T Returns Characteristic<T> Type Parameters TOwner T ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Characteristics.CharacteristicHelper.html": {
    "href": "api/BenchmarkDotNet.Characteristics.CharacteristicHelper.html",
    "title": "Class CharacteristicHelper | BenchmarkDotNet",
    "summary": "Class CharacteristicHelper Namespace BenchmarkDotNet.Characteristics Assembly BenchmarkDotNet.dll public static class CharacteristicHelper Inheritance object CharacteristicHelper Methods GetAllCharacteristics(CharacteristicObject) public static IReadOnlyList<Characteristic> GetAllCharacteristics(this CharacteristicObject obj) Parameters obj CharacteristicObject Returns IReadOnlyList<Characteristic> GetAllCharacteristics(Type) public static IReadOnlyList<Characteristic> GetAllCharacteristics(Type characteristicObjectType) Parameters characteristicObjectType Type Returns IReadOnlyList<Characteristic> GetAllPresentableCharacteristics(Type, bool) public static IReadOnlyList<Characteristic> GetAllPresentableCharacteristics(Type characteristicObjectType, bool includeIgnoreOnApply = false) Parameters characteristicObjectType Type includeIgnoreOnApply bool Returns IReadOnlyList<Characteristic> GetThisTypeCharacteristics(CharacteristicObject) public static IReadOnlyList<Characteristic> GetThisTypeCharacteristics(this CharacteristicObject obj) Parameters obj CharacteristicObject Returns IReadOnlyList<Characteristic> GetThisTypeCharacteristics(Type) public static IReadOnlyList<Characteristic> GetThisTypeCharacteristics(Type characteristicObjectType) Parameters characteristicObjectType Type Returns IReadOnlyList<Characteristic> IsPresentableCharacteristic(Characteristic, bool) public static bool IsPresentableCharacteristic(this Characteristic c, bool includeIgnoreOnApply = false) Parameters c Characteristic includeIgnoreOnApply bool Returns bool"
  },
  "api/BenchmarkDotNet.Characteristics.CharacteristicObject-1.html": {
    "href": "api/BenchmarkDotNet.Characteristics.CharacteristicObject-1.html",
    "title": "Class CharacteristicObject<T> | BenchmarkDotNet",
    "summary": "Class CharacteristicObject<T> Namespace BenchmarkDotNet.Characteristics Assembly BenchmarkDotNet.dll public abstract class CharacteristicObject<T> : CharacteristicObject where T : CharacteristicObject<T>, new() Type Parameters T Inheritance object CharacteristicObject CharacteristicObject<T> Derived CharacteristicSet JobMode<T> Inherited Members CharacteristicObject.IdCharacteristic CharacteristicObject.ResolveId(CharacteristicObject, string) CharacteristicObject.GetCharacteristicsWithValues() CharacteristicObject.HasValue(Characteristic) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver, T) CharacteristicObject.ResolveValue(Characteristic, IResolver) CharacteristicObject.ResolveValue(Characteristic, IResolver, object) CharacteristicObject.ResolveValue<T>(Characteristic<T>, T) CharacteristicObject.ResolveValue(Characteristic, object) CharacteristicObject.ResolveValueAsNullable<T>(Characteristic<T>) CharacteristicObject.ApplyCore(CharacteristicObject) CharacteristicObject.FreezeCore() CharacteristicObject.UnfreezeCopyCore() CharacteristicObject.ToString() CharacteristicObject.OwnerOrSelf CharacteristicObject.Frozen CharacteristicObject.IsPropertyBag CharacteristicObject.HasChanges CharacteristicObject.Id Extension Methods CharacteristicHelper.GetAllCharacteristics(CharacteristicObject) CharacteristicHelper.GetThisTypeCharacteristics(CharacteristicObject) Constructors CharacteristicObject() protected CharacteristicObject() CharacteristicObject(string?) protected CharacteristicObject(string? id) Parameters id string Methods Apply(CharacteristicObject) public T Apply(CharacteristicObject other) Parameters other CharacteristicObject Returns T Apply(params CharacteristicObject[]) public T Apply(params CharacteristicObject[] others) Parameters others CharacteristicObject[] Returns T ApplyAndFreeze(CharacteristicObject) public T ApplyAndFreeze(CharacteristicObject other) Parameters other CharacteristicObject Returns T ApplyAndFreeze(params CharacteristicObject[]) public T ApplyAndFreeze(params CharacteristicObject[] others) Parameters others CharacteristicObject[] Returns T CreateCharacteristic<TC>(string) protected static Characteristic<TC> CreateCharacteristic<TC>(string memberName) Parameters memberName string Returns Characteristic<TC> Type Parameters TC CreateHiddenCharacteristic<TC>(string) protected static Characteristic<TC> CreateHiddenCharacteristic<TC>(string memberName) Parameters memberName string Returns Characteristic<TC> Type Parameters TC CreateIgnoreOnApplyCharacteristic<TC>(string) protected static Characteristic<TC> CreateIgnoreOnApplyCharacteristic<TC>(string memberName) Parameters memberName string Returns Characteristic<TC> Type Parameters TC Freeze() public T Freeze() Returns T UnfreezeCopy() public T UnfreezeCopy() Returns T"
  },
  "api/BenchmarkDotNet.Characteristics.CharacteristicObject.html": {
    "href": "api/BenchmarkDotNet.Characteristics.CharacteristicObject.html",
    "title": "Class CharacteristicObject | BenchmarkDotNet",
    "summary": "Class CharacteristicObject Namespace BenchmarkDotNet.Characteristics Assembly BenchmarkDotNet.dll public abstract class CharacteristicObject Inheritance object CharacteristicObject Derived CharacteristicObject<T> Extension Methods CharacteristicHelper.GetAllCharacteristics(CharacteristicObject) CharacteristicHelper.GetThisTypeCharacteristics(CharacteristicObject) Constructors CharacteristicObject() protected CharacteristicObject() CharacteristicObject(string?) protected CharacteristicObject(string? id) Parameters id string Fields IdCharacteristic public static readonly Characteristic<string> IdCharacteristic Field Value Characteristic<string> Properties Frozen public bool Frozen { get; } Property Value bool HasChanges public bool HasChanges { get; } Property Value bool Id public string Id { get; } Property Value string IsPropertyBag protected virtual bool IsPropertyBag { get; } Property Value bool OwnerOrSelf protected CharacteristicObject OwnerOrSelf { get; } Property Value CharacteristicObject Methods Apply(CharacteristicObject) public void Apply(CharacteristicObject other) Parameters other CharacteristicObject ApplyCore(CharacteristicObject) protected CharacteristicObject ApplyCore(CharacteristicObject other) Parameters other CharacteristicObject Returns CharacteristicObject Freeze() public void Freeze() FreezeCore() protected CharacteristicObject FreezeCore() Returns CharacteristicObject GetCharacteristicsWithValues() public IEnumerable<Characteristic> GetCharacteristicsWithValues() Returns IEnumerable<Characteristic> HasValue(Characteristic) public bool HasValue(Characteristic characteristic) Parameters characteristic Characteristic Returns bool ResolveId(CharacteristicObject, string) protected static string ResolveId(CharacteristicObject obj, string actual) Parameters obj CharacteristicObject actual string Returns string ResolveValue(Characteristic, IResolver) public object ResolveValue(Characteristic characteristic, IResolver resolver) Parameters characteristic Characteristic resolver IResolver Returns object ResolveValue(Characteristic, IResolver, object) public object ResolveValue(Characteristic characteristic, IResolver resolver, object defaultValue) Parameters characteristic Characteristic resolver IResolver defaultValue object Returns object ResolveValue(Characteristic, object) public object ResolveValue(Characteristic characteristic, object defaultValue) Parameters characteristic Characteristic defaultValue object Returns object ResolveValueAsNullable<T>(Characteristic<T>) public T? ResolveValueAsNullable<T>(Characteristic<T> characteristic) where T : struct Parameters characteristic Characteristic<T> Returns T? Type Parameters T ResolveValue<T>(Characteristic<T>, IResolver) public T ResolveValue<T>(Characteristic<T> characteristic, IResolver resolver) Parameters characteristic Characteristic<T> resolver IResolver Returns T Type Parameters T ResolveValue<T>(Characteristic<T>, IResolver, T) public T ResolveValue<T>(Characteristic<T> characteristic, IResolver resolver, T defaultValue) Parameters characteristic Characteristic<T> resolver IResolver defaultValue T Returns T Type Parameters T ResolveValue<T>(Characteristic<T>, T) public T ResolveValue<T>(Characteristic<T> characteristic, T defaultValue) Parameters characteristic Characteristic<T> defaultValue T Returns T Type Parameters T ToString() public override string ToString() Returns string UnfreezeCopy() public CharacteristicObject UnfreezeCopy() Returns CharacteristicObject UnfreezeCopyCore() protected CharacteristicObject UnfreezeCopyCore() Returns CharacteristicObject"
  },
  "api/BenchmarkDotNet.Characteristics.CharacteristicPresenter.html": {
    "href": "api/BenchmarkDotNet.Characteristics.CharacteristicPresenter.html",
    "title": "Class CharacteristicPresenter | BenchmarkDotNet",
    "summary": "Class CharacteristicPresenter Namespace BenchmarkDotNet.Characteristics Assembly BenchmarkDotNet.dll public abstract class CharacteristicPresenter Inheritance object CharacteristicPresenter Constructors CharacteristicPresenter() protected CharacteristicPresenter() Fields DefaultPresenter public static readonly CharacteristicPresenter DefaultPresenter Field Value CharacteristicPresenter FolderPresenter public static readonly CharacteristicPresenter FolderPresenter Field Value CharacteristicPresenter SourceCodePresenter public static readonly CharacteristicPresenter SourceCodePresenter Field Value CharacteristicPresenter SummaryPresenter public static readonly CharacteristicPresenter SummaryPresenter Field Value CharacteristicPresenter Methods ToPresentation(CharacteristicObject, Characteristic) public abstract string ToPresentation(CharacteristicObject obj, Characteristic characteristic) Parameters obj CharacteristicObject characteristic Characteristic Returns string ToPresentation(object, Characteristic) public abstract string ToPresentation(object characteristicValue, Characteristic characteristic) Parameters characteristicValue object characteristic Characteristic Returns string"
  },
  "api/BenchmarkDotNet.Characteristics.CharacteristicSet.html": {
    "href": "api/BenchmarkDotNet.Characteristics.CharacteristicSet.html",
    "title": "Class CharacteristicSet | BenchmarkDotNet",
    "summary": "Class CharacteristicSet Namespace BenchmarkDotNet.Characteristics Assembly BenchmarkDotNet.dll public sealed class CharacteristicSet : CharacteristicObject<CharacteristicSet> Inheritance object CharacteristicObject CharacteristicObject<CharacteristicSet> CharacteristicSet Inherited Members CharacteristicObject<CharacteristicSet>.Apply(CharacteristicObject) CharacteristicObject<CharacteristicSet>.Apply(params CharacteristicObject[]) CharacteristicObject<CharacteristicSet>.ApplyAndFreeze(CharacteristicObject) CharacteristicObject<CharacteristicSet>.ApplyAndFreeze(params CharacteristicObject[]) CharacteristicObject<CharacteristicSet>.Freeze() CharacteristicObject<CharacteristicSet>.UnfreezeCopy() CharacteristicObject.IdCharacteristic CharacteristicObject.GetCharacteristicsWithValues() CharacteristicObject.HasValue(Characteristic) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver, T) CharacteristicObject.ResolveValue(Characteristic, IResolver) CharacteristicObject.ResolveValue(Characteristic, IResolver, object) CharacteristicObject.ResolveValue<T>(Characteristic<T>, T) CharacteristicObject.ResolveValue(Characteristic, object) CharacteristicObject.ResolveValueAsNullable<T>(Characteristic<T>) CharacteristicObject.ToString() CharacteristicObject.Frozen CharacteristicObject.HasChanges CharacteristicObject.Id Extension Methods CharacteristicHelper.GetAllCharacteristics(CharacteristicObject) CharacteristicHelper.GetThisTypeCharacteristics(CharacteristicObject) Constructors CharacteristicSet() public CharacteristicSet() CharacteristicSet(CharacteristicObject) public CharacteristicSet(CharacteristicObject other) Parameters other CharacteristicObject CharacteristicSet(params CharacteristicObject[]) public CharacteristicSet(params CharacteristicObject[] others) Parameters others CharacteristicObject[] Properties IsPropertyBag protected override bool IsPropertyBag { get; } Property Value bool"
  },
  "api/BenchmarkDotNet.Characteristics.CharacteristicSetPresenter.html": {
    "href": "api/BenchmarkDotNet.Characteristics.CharacteristicSetPresenter.html",
    "title": "Class CharacteristicSetPresenter | BenchmarkDotNet",
    "summary": "Class CharacteristicSetPresenter Namespace BenchmarkDotNet.Characteristics Assembly BenchmarkDotNet.dll public abstract class CharacteristicSetPresenter Inheritance object CharacteristicSetPresenter Constructors CharacteristicSetPresenter() protected CharacteristicSetPresenter() Fields Default public static readonly CharacteristicSetPresenter Default Field Value CharacteristicSetPresenter Display public static readonly CharacteristicSetPresenter Display Field Value CharacteristicSetPresenter Folder public static readonly CharacteristicSetPresenter Folder Field Value CharacteristicSetPresenter SourceCode public static readonly CharacteristicSetPresenter SourceCode Field Value CharacteristicSetPresenter Methods GetPresentableCharacteristics(CharacteristicObject, bool) protected virtual IEnumerable<Characteristic> GetPresentableCharacteristics(CharacteristicObject obj, bool includeIgnoreOnApply = false) Parameters obj CharacteristicObject includeIgnoreOnApply bool Returns IEnumerable<Characteristic> ToPresentation(CharacteristicObject) public abstract string ToPresentation(CharacteristicObject obj) Parameters obj CharacteristicObject Returns string"
  },
  "api/BenchmarkDotNet.Characteristics.CompositeResolver.html": {
    "href": "api/BenchmarkDotNet.Characteristics.CompositeResolver.html",
    "title": "Class CompositeResolver | BenchmarkDotNet",
    "summary": "Class CompositeResolver Namespace BenchmarkDotNet.Characteristics Assembly BenchmarkDotNet.dll public class CompositeResolver : IResolver Inheritance object CompositeResolver Implements IResolver Constructors CompositeResolver(params IResolver[]) public CompositeResolver(params IResolver[] resolvers) Parameters resolvers IResolver[] Methods CanResolve(Characteristic) public bool CanResolve(Characteristic characteristic) Parameters characteristic Characteristic Returns bool Resolve(CharacteristicObject, Characteristic) public object Resolve(CharacteristicObject obj, Characteristic characteristic) Parameters obj CharacteristicObject characteristic Characteristic Returns object Resolve(CharacteristicObject, Characteristic, object) public object Resolve(CharacteristicObject obj, Characteristic characteristic, object defaultValue) Parameters obj CharacteristicObject characteristic Characteristic defaultValue object Returns object Resolve<T>(CharacteristicObject, Characteristic<T>) public T Resolve<T>(CharacteristicObject obj, Characteristic<T> characteristic) Parameters obj CharacteristicObject characteristic Characteristic<T> Returns T Type Parameters T Resolve<T>(CharacteristicObject, Characteristic<T>, T) public T Resolve<T>(CharacteristicObject obj, Characteristic<T> characteristic, T defaultValue) Parameters obj CharacteristicObject characteristic Characteristic<T> defaultValue T Returns T Type Parameters T"
  },
  "api/BenchmarkDotNet.Characteristics.html": {
    "href": "api/BenchmarkDotNet.Characteristics.html",
    "title": "Namespace BenchmarkDotNet.Characteristics | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Characteristics Classes Characteristic CharacteristicHelper CharacteristicObject CharacteristicObject<T> CharacteristicPresenter CharacteristicSet CharacteristicSetPresenter Characteristic<T> CompositeResolver Resolver Interfaces IResolver An entity which can resolve default values of Characteristic<T>."
  },
  "api/BenchmarkDotNet.Characteristics.IResolver.html": {
    "href": "api/BenchmarkDotNet.Characteristics.IResolver.html",
    "title": "Interface IResolver | BenchmarkDotNet",
    "summary": "Interface IResolver Namespace BenchmarkDotNet.Characteristics Assembly BenchmarkDotNet.dll An entity which can resolve default values of Characteristic<T>. public interface IResolver Methods CanResolve(Characteristic) bool CanResolve(Characteristic characteristic) Parameters characteristic Characteristic Returns bool Resolve(CharacteristicObject, Characteristic) object Resolve(CharacteristicObject obj, Characteristic characteristic) Parameters obj CharacteristicObject characteristic Characteristic Returns object Resolve(CharacteristicObject, Characteristic, object) object Resolve(CharacteristicObject obj, Characteristic characteristic, object defaultValue) Parameters obj CharacteristicObject characteristic Characteristic defaultValue object Returns object Resolve<T>(CharacteristicObject, Characteristic<T>) T Resolve<T>(CharacteristicObject obj, Characteristic<T> characteristic) Parameters obj CharacteristicObject characteristic Characteristic<T> Returns T Type Parameters T Resolve<T>(CharacteristicObject, Characteristic<T>, T) T Resolve<T>(CharacteristicObject obj, Characteristic<T> characteristic, T defaultValue) Parameters obj CharacteristicObject characteristic Characteristic<T> defaultValue T Returns T Type Parameters T"
  },
  "api/BenchmarkDotNet.Characteristics.Resolver.html": {
    "href": "api/BenchmarkDotNet.Characteristics.Resolver.html",
    "title": "Class Resolver | BenchmarkDotNet",
    "summary": "Class Resolver Namespace BenchmarkDotNet.Characteristics Assembly BenchmarkDotNet.dll public class Resolver : IResolver Inheritance object Resolver Implements IResolver Derived EngineResolver EnvironmentResolver GcResolver InfrastructureResolver Constructors Resolver() public Resolver() Methods CanResolve(Characteristic) public bool CanResolve(Characteristic characteristic) Parameters characteristic Characteristic Returns bool Register<T>(Characteristic<T>, Func<CharacteristicObject, T>) protected void Register<T>(Characteristic<T> characteristic, Func<CharacteristicObject, T> resolver) Parameters characteristic Characteristic<T> resolver Func<CharacteristicObject, T> Type Parameters T Register<T>(Characteristic<T>, Func<T>) protected void Register<T>(Characteristic<T> characteristic, Func<T> resolver) Parameters characteristic Characteristic<T> resolver Func<T> Type Parameters T Resolve(CharacteristicObject, Characteristic) public object Resolve(CharacteristicObject obj, Characteristic characteristic) Parameters obj CharacteristicObject characteristic Characteristic Returns object Resolve(CharacteristicObject, Characteristic, object) public object Resolve(CharacteristicObject obj, Characteristic characteristic, object defaultValue) Parameters obj CharacteristicObject characteristic Characteristic defaultValue object Returns object Resolve<T>(CharacteristicObject, Characteristic<T>) public T Resolve<T>(CharacteristicObject obj, Characteristic<T> characteristic) Parameters obj CharacteristicObject characteristic Characteristic<T> Returns T Type Parameters T Resolve<T>(CharacteristicObject, Characteristic<T>, T) public T Resolve<T>(CharacteristicObject obj, Characteristic<T> characteristic, T defaultValue) Parameters obj CharacteristicObject characteristic Characteristic<T> defaultValue T Returns T Type Parameters T"
  },
  "api/BenchmarkDotNet.Code.ArrayParam-1.html": {
    "href": "api/BenchmarkDotNet.Code.ArrayParam-1.html",
    "title": "Class ArrayParam<T> | BenchmarkDotNet",
    "summary": "Class ArrayParam<T> Namespace BenchmarkDotNet.Code Assembly BenchmarkDotNet.dll public class ArrayParam<T> : IParam Type Parameters T Inheritance object ArrayParam<T> Implements IParam Properties DisplayText used to display the value (e.g. in summary in Params column) public string DisplayText { get; } Property Value string Value value of the parameter object for benchmark used internally (e.g. by the InProcessToolchain) public object Value { get; } Property Value object Methods ForComplexTypes(T[], Func<T, string>) for types where calling .ToString() will be NOT enough to re-create them in auto-generated source code file public static ArrayParam<T> ForComplexTypes(T[] array, Func<T, string> toSourceCode) Parameters array T[] the array toSourceCode Func<T, string> method which transforms an item of type T to it's C# representation example: point => $\"new Point2d({point.X}, {point.Y})\" Returns ArrayParam<T> ForPrimitives(T[]) for types where calling .ToString() will be enough to re-create them in auto-generated source code file (integers, strings and other primitives) public static ArrayParam<T> ForPrimitives(T[] array) Parameters array T[] Returns ArrayParam<T> ToSourceCode() this source code is used to create parameter for benchmark in C# source code file example: $\"new Point2D({Value.X}, {Value.Y})\" public string ToSourceCode() Returns string"
  },
  "api/BenchmarkDotNet.Code.EnumParam.html": {
    "href": "api/BenchmarkDotNet.Code.EnumParam.html",
    "title": "Class EnumParam | BenchmarkDotNet",
    "summary": "Class EnumParam Namespace BenchmarkDotNet.Code Assembly BenchmarkDotNet.dll public class EnumParam : IParam Inheritance object EnumParam Implements IParam Properties DisplayText used to display the value (e.g. in summary in Params column) public string DisplayText { get; } Property Value string Value value of the parameter object for benchmark used internally (e.g. by the InProcessToolchain) public object Value { get; } Property Value object Methods ToSourceCode() this source code is used to create parameter for benchmark in C# source code file example: $\"new Point2D({Value.X}, {Value.Y})\" public string ToSourceCode() Returns string"
  },
  "api/BenchmarkDotNet.Code.html": {
    "href": "api/BenchmarkDotNet.Code.html",
    "title": "Namespace BenchmarkDotNet.Code | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Code Classes ArrayParam<T> EnumParam Interfaces IParam"
  },
  "api/BenchmarkDotNet.Code.IParam.html": {
    "href": "api/BenchmarkDotNet.Code.IParam.html",
    "title": "Interface IParam | BenchmarkDotNet",
    "summary": "Interface IParam Namespace BenchmarkDotNet.Code Assembly BenchmarkDotNet.dll public interface IParam Properties DisplayText used to display the value (e.g. in summary in Params column) string DisplayText { get; } Property Value string Value value of the parameter object for benchmark used internally (e.g. by the InProcessToolchain) object Value { get; } Property Value object Methods ToSourceCode() this source code is used to create parameter for benchmark in C# source code file example: $\"new Point2D({Value.X}, {Value.Y})\" string ToSourceCode() Returns string"
  },
  "api/BenchmarkDotNet.Columns.BaselineAllocationRatioColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.BaselineAllocationRatioColumn.html",
    "title": "Class BaselineAllocationRatioColumn | BenchmarkDotNet",
    "summary": "Class BaselineAllocationRatioColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class BaselineAllocationRatioColumn : BaselineCustomColumn, IColumn Inheritance object BaselineCustomColumn BaselineAllocationRatioColumn Implements IColumn Inherited Members BaselineCustomColumn.GetValue(Summary, BenchmarkCase) BaselineCustomColumn.IsAvailable(Summary) BaselineCustomColumn.GetValue(Summary, BenchmarkCase, SummaryStyle) BaselineCustomColumn.ToString() BaselineCustomColumn.IsDefault(Summary, BenchmarkCase) BaselineCustomColumn.AlwaysShow Extension Methods ColumnExtensions.ToProvider(IColumn) Fields RatioMean public static readonly IColumn RatioMean Field Value IColumn Properties Category public override ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public override string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public override string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public override bool IsNumeric { get; } Property Value bool Legend Column description. public override string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public override int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public override UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase, Statistics, IReadOnlyDictionary<string, Metric>, Statistics, IReadOnlyDictionary<string, Metric>, bool) public override string GetValue(Summary summary, BenchmarkCase benchmarkCase, Statistics baseline, IReadOnlyDictionary<string, Metric> baselineMetrics, Statistics current, IReadOnlyDictionary<string, Metric> currentMetrics, bool isBaseline) Parameters summary Summary benchmarkCase BenchmarkCase baseline Statistics baselineMetrics IReadOnlyDictionary<string, Metric> current Statistics currentMetrics IReadOnlyDictionary<string, Metric> isBaseline bool Returns string"
  },
  "api/BenchmarkDotNet.Columns.BaselineColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.BaselineColumn.html",
    "title": "Class BaselineColumn | BenchmarkDotNet",
    "summary": "Class BaselineColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class BaselineColumn : IColumn Inheritance object BaselineColumn Implements IColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Constructors BaselineColumn() public BaselineColumn() Fields Default public static readonly IColumn Default Field Value IColumn Properties AlwaysShow public bool AlwaysShow { get; } Property Value bool Category public ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public bool IsNumeric { get; } Property Value bool Legend Column description. public string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) public bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Columns.BaselineCustomColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.BaselineCustomColumn.html",
    "title": "Class BaselineCustomColumn | BenchmarkDotNet",
    "summary": "Class BaselineCustomColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public abstract class BaselineCustomColumn : IColumn Inheritance object BaselineCustomColumn Implements IColumn Derived BaselineAllocationRatioColumn BaselineRatioColumn BaselineScaledColumn StatisticalTestColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Constructors BaselineCustomColumn() protected BaselineCustomColumn() Properties AlwaysShow public bool AlwaysShow { get; } Property Value bool Category public virtual ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public abstract string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public abstract string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public abstract bool IsNumeric { get; } Property Value bool Legend Column description. public abstract string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public abstract int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public abstract UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, Statistics, IReadOnlyDictionary<string, Metric>, Statistics, IReadOnlyDictionary<string, Metric>, bool) public abstract string GetValue(Summary summary, BenchmarkCase benchmarkCase, Statistics baseline, IReadOnlyDictionary<string, Metric> baselineMetrics, Statistics current, IReadOnlyDictionary<string, Metric> currentMetrics, bool isBaseline) Parameters summary Summary benchmarkCase BenchmarkCase baseline Statistics baselineMetrics IReadOnlyDictionary<string, Metric> current Statistics currentMetrics IReadOnlyDictionary<string, Metric> isBaseline bool Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) public bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Columns.BaselineRatioColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.BaselineRatioColumn.html",
    "title": "Class BaselineRatioColumn | BenchmarkDotNet",
    "summary": "Class BaselineRatioColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class BaselineRatioColumn : BaselineCustomColumn, IColumn Inheritance object BaselineCustomColumn BaselineRatioColumn Implements IColumn Inherited Members BaselineCustomColumn.GetValue(Summary, BenchmarkCase) BaselineCustomColumn.IsAvailable(Summary) BaselineCustomColumn.GetValue(Summary, BenchmarkCase, SummaryStyle) BaselineCustomColumn.ToString() BaselineCustomColumn.IsDefault(Summary, BenchmarkCase) BaselineCustomColumn.AlwaysShow BaselineCustomColumn.Category Extension Methods ColumnExtensions.ToProvider(IColumn) Fields RatioMean public static readonly IColumn RatioMean Field Value IColumn RatioStdDev public static readonly IColumn RatioStdDev Field Value IColumn Properties ColumnName Display column title in the summary. public override string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public override string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public override bool IsNumeric { get; } Property Value bool Legend Column description. public override string Legend { get; } Property Value string Metric public BaselineRatioColumn.RatioMetric Metric { get; } Property Value BaselineRatioColumn.RatioMetric PriorityInCategory Defines order of column in the same category. public override int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public override UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase, Statistics, IReadOnlyDictionary<string, Metric>, Statistics, IReadOnlyDictionary<string, Metric>, bool) public override string GetValue(Summary summary, BenchmarkCase benchmarkCase, Statistics baseline, IReadOnlyDictionary<string, Metric> baselineMetrics, Statistics current, IReadOnlyDictionary<string, Metric> currentMetrics, bool isBaseline) Parameters summary Summary benchmarkCase BenchmarkCase baseline Statistics baselineMetrics IReadOnlyDictionary<string, Metric> current Statistics currentMetrics IReadOnlyDictionary<string, Metric> isBaseline bool Returns string"
  },
  "api/BenchmarkDotNet.Columns.BaselineRatioColumn.RatioMetric.html": {
    "href": "api/BenchmarkDotNet.Columns.BaselineRatioColumn.RatioMetric.html",
    "title": "Enum BaselineRatioColumn.RatioMetric | BenchmarkDotNet",
    "summary": "Enum BaselineRatioColumn.RatioMetric Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public enum BaselineRatioColumn.RatioMetric Fields Mean = 0 StdDev = 1"
  },
  "api/BenchmarkDotNet.Columns.BaselineScaledColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.BaselineScaledColumn.html",
    "title": "Class BaselineScaledColumn | BenchmarkDotNet",
    "summary": "Class BaselineScaledColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll [Obsolete(\"Use BaselineRatioColumn\")] public class BaselineScaledColumn : BaselineCustomColumn, IColumn Inheritance object BaselineCustomColumn BaselineScaledColumn Implements IColumn Inherited Members BaselineCustomColumn.GetValue(Summary, BenchmarkCase) BaselineCustomColumn.IsAvailable(Summary) BaselineCustomColumn.GetValue(Summary, BenchmarkCase, SummaryStyle) BaselineCustomColumn.ToString() BaselineCustomColumn.IsDefault(Summary, BenchmarkCase) BaselineCustomColumn.AlwaysShow BaselineCustomColumn.Category Extension Methods ColumnExtensions.ToProvider(IColumn) Fields Scaled public static readonly IColumn Scaled Field Value IColumn Properties ColumnName Display column title in the summary. public override string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public override string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public override bool IsNumeric { get; } Property Value bool Kind public BaselineScaledColumn.ScaledKind Kind { get; } Property Value BaselineScaledColumn.ScaledKind Legend Column description. public override string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public override int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public override UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase, Statistics, IReadOnlyDictionary<string, Metric>, Statistics, IReadOnlyDictionary<string, Metric>, bool) public override string GetValue(Summary summary, BenchmarkCase benchmarkCase, Statistics baseline, IReadOnlyDictionary<string, Metric> baselineMetrics, Statistics current, IReadOnlyDictionary<string, Metric> currentMetrics, bool isBaseline) Parameters summary Summary benchmarkCase BenchmarkCase baseline Statistics baselineMetrics IReadOnlyDictionary<string, Metric> current Statistics currentMetrics IReadOnlyDictionary<string, Metric> isBaseline bool Returns string"
  },
  "api/BenchmarkDotNet.Columns.BaselineScaledColumn.ScaledKind.html": {
    "href": "api/BenchmarkDotNet.Columns.BaselineScaledColumn.ScaledKind.html",
    "title": "Enum BaselineScaledColumn.ScaledKind | BenchmarkDotNet",
    "summary": "Enum BaselineScaledColumn.ScaledKind Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public enum BaselineScaledColumn.ScaledKind Fields Mean = 0"
  },
  "api/BenchmarkDotNet.Columns.CategoriesColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.CategoriesColumn.html",
    "title": "Class CategoriesColumn | BenchmarkDotNet",
    "summary": "Class CategoriesColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class CategoriesColumn : IColumn Inheritance object CategoriesColumn Implements IColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Constructors CategoriesColumn() public CategoriesColumn() Fields Default public static readonly IColumn Default Field Value IColumn Properties AlwaysShow public bool AlwaysShow { get; } Property Value bool Category public ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public bool IsNumeric { get; } Property Value bool Legend Column description. public string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) public bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Columns.Column.html": {
    "href": "api/BenchmarkDotNet.Columns.Column.html",
    "title": "Class Column | BenchmarkDotNet",
    "summary": "Class Column Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public static class Column Inheritance object Column Fields Accuracy public const string Accuracy = \"Accuracy\" Field Value string Affinity public const string Affinity = \"Affinity\" Field Value string AllocRatio public const string AllocRatio = \"Alloc Ratio\" Field Value string Allocated public const string Allocated = \"Allocated\" Field Value string AllocatedNativeMemory public const string AllocatedNativeMemory = \"Allocated native memory\" Field Value string AllowVeryLargeObjects public const string AllowVeryLargeObjects = \"AllowVeryLargeObjects\" Field Value string AnalyzeLaunchVariance public const string AnalyzeLaunchVariance = \"AnalyzeLaunchVariance\" Field Value string Arguments public const string Arguments = \"Arguments\" Field Value string Baseline public const string Baseline = \"Baseline\" Field Value string BuildConfiguration public const string BuildConfiguration = \"BuildConfiguration\" Field Value string Categories public const string Categories = \"Categories\" Field Value string Clock public const string Clock = \"Clock\" Field Value string CodeSize public const string CodeSize = \"Code Size\" Field Value string CompletedWorkItems public const string CompletedWorkItems = \"Completed Work Items\" Field Value string Concurrent public const string Concurrent = \"Concurrent\" Field Value string CpuGroups public const string CpuGroups = \"CpuGroups\" Field Value string EngineFactory public const string EngineFactory = \"EngineFactory\" Field Value string Environment public const string Environment = \"Environment\" Field Value string EnvironmentVariables public const string EnvironmentVariables = \"EnvironmentVariables\" Field Value string Error public const string Error = \"Error\" Field Value string EvaluateOverhead public const string EvaluateOverhead = \"EvaluateOverhead\" Field Value string Exceptions public const string Exceptions = \"Exceptions\" Field Value string Force public const string Force = \"Force\" Field Value string Gc public const string Gc = \"Gc\" Field Value string Gen0 public const string Gen0 = \"Gen0\" Field Value string Gen1 public const string Gen1 = \"Gen1\" Field Value string Gen2 public const string Gen2 = \"Gen2\" Field Value string HeapAffinitizeMask public const string HeapAffinitizeMask = \"HeapAffinitizeMask\" Field Value string HeapCount public const string HeapCount = \"HeapCount\" Field Value string Id public const string Id = \"Id\" Field Value string Infrastructure public const string Infrastructure = \"Infrastructure\" Field Value string InvocationCount public const string InvocationCount = \"InvocationCount\" Field Value string IsDefault public const string IsDefault = \"IsDefault\" Field Value string IsMutator public const string IsMutator = \"IsMutator\" Field Value string IterationCount public const string IterationCount = \"IterationCount\" Field Value string IterationTime public const string IterationTime = \"IterationTime\" Field Value string Iterations public const string Iterations = \"Iterations\" Field Value string Jit public const string Jit = \"Jit\" Field Value string Job public const string Job = \"Job\" Field Value string Kurtosis public const string Kurtosis = \"Kurtosis\" Field Value string LaunchCount public const string LaunchCount = \"LaunchCount\" Field Value string LockContentions public const string LockContentions = \"Lock Contentions\" Field Value string LogicalGroup public const string LogicalGroup = \"LogicalGroup\" Field Value string MValue public const string MValue = \"MValue\" Field Value string Max public const string Max = \"Max\" Field Value string MaxAbsoluteError public const string MaxAbsoluteError = \"MaxAbsoluteError\" Field Value string MaxIterationCount public const string MaxIterationCount = \"MaxIterationCount\" Field Value string MaxRelativeError public const string MaxRelativeError = \"MaxRelativeError\" Field Value string MaxWarmupIterationCount public const string MaxWarmupIterationCount = \"MaxWarmupIterationCount\" Field Value string Mean public const string Mean = \"Mean\" Field Value string Median public const string Median = \"Median\" Field Value string MemoryRandomization public const string MemoryRandomization = \"MemoryRandomization\" Field Value string Meta public const string Meta = \"Meta\" Field Value string Method public const string Method = \"Method\" Field Value string Min public const string Min = \"Min\" Field Value string MinInvokeCount public const string MinInvokeCount = \"MinInvokeCount\" Field Value string MinIterationCount public const string MinIterationCount = \"MinIterationCount\" Field Value string MinIterationTime public const string MinIterationTime = \"MinIterationTime\" Field Value string MinWarmupIterationCount public const string MinWarmupIterationCount = \"MinWarmupIterationCount\" Field Value string Namespace public const string Namespace = \"Namespace\" Field Value string NativeMemoryLeak public const string NativeMemoryLeak = \"Native memory leak\" Field Value string NoAffinitize public const string NoAffinitize = \"NoAffinitize\" Field Value string NuGetReferences public const string NuGetReferences = \"NuGetReferences\" Field Value string OperationPerSecond public const string OperationPerSecond = \"Op/s\" Field Value string OutlierMode public const string OutlierMode = \"OutlierMode\" Field Value string P0 public const string P0 = \"P0\" Field Value string P100 public const string P100 = \"P100\" Field Value string P25 public const string P25 = \"P25\" Field Value string P50 public const string P50 = \"P50\" Field Value string P67 public const string P67 = \"P67\" Field Value string P80 public const string P80 = \"P80\" Field Value string P85 public const string P85 = \"P85\" Field Value string P90 public const string P90 = \"P90\" Field Value string P95 public const string P95 = \"P95\" Field Value string Platform public const string Platform = \"Platform\" Field Value string PowerPlanMode public const string PowerPlanMode = \"PowerPlanMode\" Field Value string Q1 public const string Q1 = \"Q1\" Field Value string Q3 public const string Q3 = \"Q3\" Field Value string Rank public const string Rank = \"Rank\" Field Value string Ratio public const string Ratio = \"Ratio\" Field Value string RatioSD public const string RatioSD = \"RatioSD\" Field Value string RetainVm public const string RetainVm = \"RetainVm\" Field Value string Run public const string Run = \"Run\" Field Value string RunStrategy public const string RunStrategy = \"RunStrategy\" Field Value string Runtime public const string Runtime = \"Runtime\" Field Value string Server public const string Server = \"Server\" Field Value string Skewness public const string Skewness = \"Skewness\" Field Value string StdDev public const string StdDev = \"StdDev\" Field Value string StdErr public const string StdErr = \"StdErr\" Field Value string Toolchain public const string Toolchain = \"Toolchain\" Field Value string Type public const string Type = \"Type\" Field Value string UnrollFactor public const string UnrollFactor = \"UnrollFactor\" Field Value string WarmupCount public const string WarmupCount = \"WarmupCount\" Field Value string"
  },
  "api/BenchmarkDotNet.Columns.ColumnCategory.html": {
    "href": "api/BenchmarkDotNet.Columns.ColumnCategory.html",
    "title": "Enum ColumnCategory | BenchmarkDotNet",
    "summary": "Enum ColumnCategory Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public enum ColumnCategory Fields Baseline = 3 Custom = 4 Job = 0 Meta = 5 Metric = 6 Params = 1 Statistics = 2"
  },
  "api/BenchmarkDotNet.Columns.ColumnExtensions.html": {
    "href": "api/BenchmarkDotNet.Columns.ColumnExtensions.html",
    "title": "Class ColumnExtensions | BenchmarkDotNet",
    "summary": "Class ColumnExtensions Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public static class ColumnExtensions Inheritance object ColumnExtensions Methods ToProvider(IColumn) public static IColumnProvider ToProvider(this IColumn column) Parameters column IColumn Returns IColumnProvider"
  },
  "api/BenchmarkDotNet.Columns.ColumnHidingByIdRule.html": {
    "href": "api/BenchmarkDotNet.Columns.ColumnHidingByIdRule.html",
    "title": "Class ColumnHidingByIdRule | BenchmarkDotNet",
    "summary": "Class ColumnHidingByIdRule Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class ColumnHidingByIdRule : IColumnHidingRule Inheritance object ColumnHidingByIdRule Implements IColumnHidingRule Constructors ColumnHidingByIdRule(IColumn) public ColumnHidingByIdRule(IColumn column) Parameters column IColumn Properties Id public string Id { get; } Property Value string Methods NeedToHide(IColumn) public bool NeedToHide(IColumn column) Parameters column IColumn Returns bool"
  },
  "api/BenchmarkDotNet.Columns.ColumnHidingByNameRule.html": {
    "href": "api/BenchmarkDotNet.Columns.ColumnHidingByNameRule.html",
    "title": "Class ColumnHidingByNameRule | BenchmarkDotNet",
    "summary": "Class ColumnHidingByNameRule Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class ColumnHidingByNameRule : IColumnHidingRule Inheritance object ColumnHidingByNameRule Implements IColumnHidingRule Constructors ColumnHidingByNameRule(string) public ColumnHidingByNameRule(string name) Parameters name string Properties Name public string Name { get; } Property Value string Methods NeedToHide(IColumn) public bool NeedToHide(IColumn column) Parameters column IColumn Returns bool"
  },
  "api/BenchmarkDotNet.Columns.CompositeColumnProvider.html": {
    "href": "api/BenchmarkDotNet.Columns.CompositeColumnProvider.html",
    "title": "Class CompositeColumnProvider | BenchmarkDotNet",
    "summary": "Class CompositeColumnProvider Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class CompositeColumnProvider : IColumnProvider Inheritance object CompositeColumnProvider Implements IColumnProvider Constructors CompositeColumnProvider(params IColumnProvider[]) public CompositeColumnProvider(params IColumnProvider[] providers) Parameters providers IColumnProvider[] Methods GetColumns(Summary) public IEnumerable<IColumn> GetColumns(Summary summary) Parameters summary Summary Returns IEnumerable<IColumn>"
  },
  "api/BenchmarkDotNet.Columns.DefaultColumnProviders.html": {
    "href": "api/BenchmarkDotNet.Columns.DefaultColumnProviders.html",
    "title": "Class DefaultColumnProviders | BenchmarkDotNet",
    "summary": "Class DefaultColumnProviders Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public static class DefaultColumnProviders Inheritance object DefaultColumnProviders Fields Descriptor public static readonly IColumnProvider Descriptor Field Value IColumnProvider Instance public static readonly IColumnProvider[] Instance Field Value IColumnProvider[] Job public static readonly IColumnProvider Job Field Value IColumnProvider Metrics public static readonly IColumnProvider Metrics Field Value IColumnProvider Params public static readonly IColumnProvider Params Field Value IColumnProvider Statistics public static readonly IColumnProvider Statistics Field Value IColumnProvider"
  },
  "api/BenchmarkDotNet.Columns.EmptyColumnProvider.html": {
    "href": "api/BenchmarkDotNet.Columns.EmptyColumnProvider.html",
    "title": "Class EmptyColumnProvider | BenchmarkDotNet",
    "summary": "Class EmptyColumnProvider Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class EmptyColumnProvider : IColumnProvider Inheritance object EmptyColumnProvider Implements IColumnProvider Fields Instance public static readonly IColumnProvider Instance Field Value IColumnProvider Methods GetColumns(Summary) public IEnumerable<IColumn> GetColumns(Summary summary) Parameters summary Summary Returns IEnumerable<IColumn>"
  },
  "api/BenchmarkDotNet.Columns.html": {
    "href": "api/BenchmarkDotNet.Columns.html",
    "title": "Namespace BenchmarkDotNet.Columns | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Columns Classes BaselineAllocationRatioColumn BaselineColumn BaselineCustomColumn BaselineRatioColumn BaselineScaledColumn CategoriesColumn Column ColumnExtensions ColumnHidingByIdRule ColumnHidingByNameRule CompositeColumnProvider DefaultColumnProviders EmptyColumnProvider JobCharacteristicColumn LogicalGroupColumn MetricColumn ParamColumn RankColumn SimpleColumnProvider StatisticColumn StatisticalTestColumn TagColumn TargetMethodColumn Interfaces IColumn IColumnHidingRule IColumnProvider IStatisticColumn Enums BaselineRatioColumn.RatioMetric BaselineScaledColumn.ScaledKind ColumnCategory RatioStyle UnitType"
  },
  "api/BenchmarkDotNet.Columns.IColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.IColumn.html",
    "title": "Interface IColumn | BenchmarkDotNet",
    "summary": "Interface IColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public interface IColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Properties AlwaysShow bool AlwaysShow { get; } Property Value bool Category ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number bool IsNumeric { get; } Property Value bool Legend Column description. string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Columns.IColumnHidingRule.html": {
    "href": "api/BenchmarkDotNet.Columns.IColumnHidingRule.html",
    "title": "Interface IColumnHidingRule | BenchmarkDotNet",
    "summary": "Interface IColumnHidingRule Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public interface IColumnHidingRule Methods NeedToHide(IColumn) bool NeedToHide(IColumn column) Parameters column IColumn Returns bool"
  },
  "api/BenchmarkDotNet.Columns.IColumnProvider.html": {
    "href": "api/BenchmarkDotNet.Columns.IColumnProvider.html",
    "title": "Interface IColumnProvider | BenchmarkDotNet",
    "summary": "Interface IColumnProvider Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public interface IColumnProvider Methods GetColumns(Summary) IEnumerable<IColumn> GetColumns(Summary summary) Parameters summary Summary Returns IEnumerable<IColumn>"
  },
  "api/BenchmarkDotNet.Columns.IStatisticColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.IStatisticColumn.html",
    "title": "Interface IStatisticColumn | BenchmarkDotNet",
    "summary": "Interface IStatisticColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public interface IStatisticColumn : IColumn Inherited Members IColumn.GetValue(Summary, BenchmarkCase) IColumn.GetValue(Summary, BenchmarkCase, SummaryStyle) IColumn.IsDefault(Summary, BenchmarkCase) IColumn.IsAvailable(Summary) IColumn.Id IColumn.ColumnName IColumn.AlwaysShow IColumn.Category IColumn.PriorityInCategory IColumn.IsNumeric IColumn.UnitType IColumn.Legend Extension Methods ColumnExtensions.ToProvider(IColumn) Methods GetAllValues(Summary, SummaryStyle) List<double> GetAllValues(Summary summary, SummaryStyle style) Parameters summary Summary style SummaryStyle Returns List<double>"
  },
  "api/BenchmarkDotNet.Columns.JobCharacteristicColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.JobCharacteristicColumn.html",
    "title": "Class JobCharacteristicColumn | BenchmarkDotNet",
    "summary": "Class JobCharacteristicColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class JobCharacteristicColumn : IColumn Inheritance object JobCharacteristicColumn Implements IColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Properties AllColumns public static IColumn[] AllColumns { get; } Property Value IColumn[] AlwaysShow public bool AlwaysShow { get; } Property Value bool Category public ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public bool IsNumeric { get; } Property Value bool Legend Column description. public string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) public bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Columns.LogicalGroupColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.LogicalGroupColumn.html",
    "title": "Class LogicalGroupColumn | BenchmarkDotNet",
    "summary": "Class LogicalGroupColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class LogicalGroupColumn : IColumn Inheritance object LogicalGroupColumn Implements IColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Constructors LogicalGroupColumn() public LogicalGroupColumn() Fields Default public static readonly IColumn Default Field Value IColumn Properties AlwaysShow public bool AlwaysShow { get; } Property Value bool Category public ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public bool IsNumeric { get; } Property Value bool Legend Column description. public string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) public bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Columns.MetricColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.MetricColumn.html",
    "title": "Class MetricColumn | BenchmarkDotNet",
    "summary": "Class MetricColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class MetricColumn : IColumn Inheritance object MetricColumn Implements IColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Constructors MetricColumn(IMetricDescriptor) public MetricColumn(IMetricDescriptor metricDescriptor) Parameters metricDescriptor IMetricDescriptor Properties AlwaysShow public bool AlwaysShow { get; } Property Value bool Category public ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public bool IsNumeric { get; } Property Value bool Legend Column description. public string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) public bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Columns.ParamColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.ParamColumn.html",
    "title": "Class ParamColumn | BenchmarkDotNet",
    "summary": "Class ParamColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class ParamColumn : IColumn Inheritance object ParamColumn Implements IColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Constructors ParamColumn(string, int) public ParamColumn(string columnName, int priorityInCategory = 0) Parameters columnName string priorityInCategory int Properties AlwaysShow public bool AlwaysShow { get; } Property Value bool Category public ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public bool IsNumeric { get; } Property Value bool Legend Column description. public string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) public bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Columns.RankColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.RankColumn.html",
    "title": "Class RankColumn | BenchmarkDotNet",
    "summary": "Class RankColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class RankColumn : IColumn Inheritance object RankColumn Implements IColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Constructors RankColumn(NumeralSystem) public RankColumn(NumeralSystem system) Parameters system NumeralSystem Fields Arabic public static readonly IColumn Arabic Field Value IColumn Roman public static readonly IColumn Roman Field Value IColumn Stars public static readonly IColumn Stars Field Value IColumn Properties AlwaysShow public bool AlwaysShow { get; } Property Value bool Category public ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public bool IsNumeric { get; } Property Value bool Legend Column description. public string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) public bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Columns.RatioStyle.html": {
    "href": "api/BenchmarkDotNet.Columns.RatioStyle.html",
    "title": "Enum RatioStyle | BenchmarkDotNet",
    "summary": "Enum RatioStyle Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public enum RatioStyle Fields Percentage = 1 Trend = 2 Value = 0"
  },
  "api/BenchmarkDotNet.Columns.SimpleColumnProvider.html": {
    "href": "api/BenchmarkDotNet.Columns.SimpleColumnProvider.html",
    "title": "Class SimpleColumnProvider | BenchmarkDotNet",
    "summary": "Class SimpleColumnProvider Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class SimpleColumnProvider : IColumnProvider Inheritance object SimpleColumnProvider Implements IColumnProvider Constructors SimpleColumnProvider(params IColumn[]) public SimpleColumnProvider(params IColumn[] columns) Parameters columns IColumn[] Methods GetColumns(Summary) public IEnumerable<IColumn> GetColumns(Summary summary) Parameters summary Summary Returns IEnumerable<IColumn>"
  },
  "api/BenchmarkDotNet.Columns.StatisticalTestColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.StatisticalTestColumn.html",
    "title": "Class StatisticalTestColumn | BenchmarkDotNet",
    "summary": "Class StatisticalTestColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class StatisticalTestColumn : BaselineCustomColumn, IColumn Inheritance object BaselineCustomColumn StatisticalTestColumn Implements IColumn Inherited Members BaselineCustomColumn.GetValue(Summary, BenchmarkCase) BaselineCustomColumn.IsAvailable(Summary) BaselineCustomColumn.GetValue(Summary, BenchmarkCase, SummaryStyle) BaselineCustomColumn.ToString() BaselineCustomColumn.IsDefault(Summary, BenchmarkCase) BaselineCustomColumn.AlwaysShow BaselineCustomColumn.Category Extension Methods ColumnExtensions.ToProvider(IColumn) Constructors StatisticalTestColumn(Threshold, SignificanceLevel?) public StatisticalTestColumn(Threshold threshold, SignificanceLevel? significanceLevel = null) Parameters threshold Threshold significanceLevel SignificanceLevel? Properties ColumnName Display column title in the summary. public override string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public override string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public override bool IsNumeric { get; } Property Value bool Legend Column description. public override string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public override int PriorityInCategory { get; } Property Value int SignificanceLevel public SignificanceLevel SignificanceLevel { get; } Property Value SignificanceLevel Threshold public Threshold Threshold { get; } Property Value Threshold UnitType Defines how to format column's value public override UnitType UnitType { get; } Property Value UnitType Methods Create(Threshold, SignificanceLevel?) public static StatisticalTestColumn Create(Threshold threshold, SignificanceLevel? significanceLevel = null) Parameters threshold Threshold significanceLevel SignificanceLevel? Returns StatisticalTestColumn Create(string, SignificanceLevel?) public static StatisticalTestColumn Create(string threshold, SignificanceLevel? significanceLevel = null) Parameters threshold string significanceLevel SignificanceLevel? Returns StatisticalTestColumn CreateDefault() public static StatisticalTestColumn CreateDefault() Returns StatisticalTestColumn GetValue(Summary, BenchmarkCase, Statistics, IReadOnlyDictionary<string, Metric>, Statistics, IReadOnlyDictionary<string, Metric>, bool) public override string GetValue(Summary summary, BenchmarkCase benchmarkCase, Statistics baseline, IReadOnlyDictionary<string, Metric> baselineMetrics, Statistics current, IReadOnlyDictionary<string, Metric> currentMetrics, bool isBaseline) Parameters summary Summary benchmarkCase BenchmarkCase baseline Statistics baselineMetrics IReadOnlyDictionary<string, Metric> current Statistics currentMetrics IReadOnlyDictionary<string, Metric> isBaseline bool Returns string"
  },
  "api/BenchmarkDotNet.Columns.StatisticColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.StatisticColumn.html",
    "title": "Class StatisticColumn | BenchmarkDotNet",
    "summary": "Class StatisticColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class StatisticColumn : IStatisticColumn, IColumn Inheritance object StatisticColumn Implements IStatisticColumn IColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Fields AllStatistics public static readonly IColumn[] AllStatistics Field Value IColumn[] Error public static readonly IColumn Error Field Value IColumn Iterations public static readonly IColumn Iterations Field Value IColumn Kurtosis public static readonly IColumn Kurtosis Field Value IColumn MValue See http://www.brendangregg.com/FrequencyTrails/modes.html public static readonly IColumn MValue Field Value IColumn Max public static readonly IColumn Max Field Value IColumn Mean public static readonly IStatisticColumn Mean Field Value IStatisticColumn Median public static readonly IColumn Median Field Value IColumn Min public static readonly IColumn Min Field Value IColumn OperationsPerSecond public static readonly IColumn OperationsPerSecond Field Value IColumn P0 public static readonly IColumn P0 Field Value IColumn P100 public static readonly IColumn P100 Field Value IColumn P25 public static readonly IColumn P25 Field Value IColumn P50 public static readonly IColumn P50 Field Value IColumn P67 public static readonly IColumn P67 Field Value IColumn P80 public static readonly IColumn P80 Field Value IColumn P85 public static readonly IColumn P85 Field Value IColumn P90 public static readonly IColumn P90 Field Value IColumn P95 public static readonly IColumn P95 Field Value IColumn Q1 public static readonly IColumn Q1 Field Value IColumn Q3 public static readonly IColumn Q3 Field Value IColumn Skewness public static readonly IColumn Skewness Field Value IColumn StdDev public static readonly IColumn StdDev Field Value IColumn StdErr public static readonly IColumn StdErr Field Value IColumn Properties AlwaysShow public bool AlwaysShow { get; } Property Value bool Category public ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public bool IsNumeric { get; } Property Value bool Legend Column description. public string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public UnitType UnitType { get; } Property Value UnitType Methods CiError(ConfidenceLevel) public static IColumn CiError(ConfidenceLevel level) Parameters level ConfidenceLevel Returns IColumn CiLower(ConfidenceLevel) public static IColumn CiLower(ConfidenceLevel level) Parameters level ConfidenceLevel Returns IColumn CiUpper(ConfidenceLevel) public static IColumn CiUpper(ConfidenceLevel level) Parameters level ConfidenceLevel Returns IColumn GetAllValues(Summary, SummaryStyle) public List<double> GetAllValues(Summary summary, SummaryStyle style) Parameters summary Summary style SummaryStyle Returns List<double> GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) public bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Columns.TagColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.TagColumn.html",
    "title": "Class TagColumn | BenchmarkDotNet",
    "summary": "Class TagColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class TagColumn : IColumn Inheritance object TagColumn Implements IColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Constructors TagColumn(string, Func<string, string>) public TagColumn(string columnName, Func<string, string> getTag) Parameters columnName string getTag Func<string, string> Properties AlwaysShow public bool AlwaysShow { get; } Property Value bool Category public ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public bool IsNumeric { get; } Property Value bool Legend Column description. public string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) public bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Columns.TargetMethodColumn.html": {
    "href": "api/BenchmarkDotNet.Columns.TargetMethodColumn.html",
    "title": "Class TargetMethodColumn | BenchmarkDotNet",
    "summary": "Class TargetMethodColumn Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public class TargetMethodColumn : IColumn Inheritance object TargetMethodColumn Implements IColumn Extension Methods ColumnExtensions.ToProvider(IColumn) Fields Method public static readonly IColumn Method Field Value IColumn Namespace public static readonly IColumn Namespace Field Value IColumn Type public static readonly IColumn Type Field Value IColumn Properties AlwaysShow public bool AlwaysShow { get; } Property Value bool Category public ColumnCategory Category { get; } Property Value ColumnCategory ColumnName Display column title in the summary. public string ColumnName { get; } Property Value string Id An unique identifier of the column. If there are several columns with the same Id, only one of them will be shown in the summary. public string Id { get; } Property Value string IsNumeric Defines if the column's value represents a number public bool IsNumeric { get; } Property Value bool Legend Column description. public string Legend { get; } Property Value string PriorityInCategory Defines order of column in the same category. public int PriorityInCategory { get; } Property Value int UnitType Defines how to format column's value public UnitType UnitType { get; } Property Value UnitType Methods GetValue(Summary, BenchmarkCase) Value in this column formatted using the default style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns string GetValue(Summary, BenchmarkCase, SummaryStyle) Value in this column formatted using the specified style. public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) Parameters summary Summary benchmarkCase BenchmarkCase style SummaryStyle Returns string IsAvailable(Summary) public bool IsAvailable(Summary summary) Parameters summary Summary Returns bool IsDefault(Summary, BenchmarkCase) public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns bool ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Columns.UnitType.html": {
    "href": "api/BenchmarkDotNet.Columns.UnitType.html",
    "title": "Enum UnitType | BenchmarkDotNet",
    "summary": "Enum UnitType Namespace BenchmarkDotNet.Columns Assembly BenchmarkDotNet.dll public enum UnitType Fields CodeSize = 3 Dimensionless = 0 Size = 2 Time = 1"
  },
  "api/BenchmarkDotNet.Configs.BenchmarkLogicalGroupRule.html": {
    "href": "api/BenchmarkDotNet.Configs.BenchmarkLogicalGroupRule.html",
    "title": "Enum BenchmarkLogicalGroupRule | BenchmarkDotNet",
    "summary": "Enum BenchmarkLogicalGroupRule Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll public enum BenchmarkLogicalGroupRule Fields ByCategory = 3 ByJob = 1 ByMethod = 0 ByParams = 2"
  },
  "api/BenchmarkDotNet.Configs.ConfigExtensions.html": {
    "href": "api/BenchmarkDotNet.Configs.ConfigExtensions.html",
    "title": "Class ConfigExtensions | BenchmarkDotNet",
    "summary": "Class ConfigExtensions Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll public static class ConfigExtensions Inheritance object ConfigExtensions Methods AddAnalyser(IConfig, params IAnalyser[]) public static ManualConfig AddAnalyser(this IConfig config, params IAnalyser[] analysers) Parameters config IConfig analysers IAnalyser[] Returns ManualConfig AddColumn(IConfig, params IColumn[]) public static ManualConfig AddColumn(this IConfig config, params IColumn[] columns) Parameters config IConfig columns IColumn[] Returns ManualConfig AddColumnProvider(IConfig, params IColumnProvider[]) public static ManualConfig AddColumnProvider(this IConfig config, params IColumnProvider[] columnProviders) Parameters config IConfig columnProviders IColumnProvider[] Returns ManualConfig AddDiagnoser(IConfig, params IDiagnoser[]) public static ManualConfig AddDiagnoser(this IConfig config, params IDiagnoser[] diagnosers) Parameters config IConfig diagnosers IDiagnoser[] Returns ManualConfig AddEventProcessor(IConfig, params EventProcessor[]) public static ManualConfig AddEventProcessor(this IConfig config, params EventProcessor[] eventProcessors) Parameters config IConfig eventProcessors EventProcessor[] Returns ManualConfig AddExporter(IConfig, params IExporter[]) public static ManualConfig AddExporter(this IConfig config, params IExporter[] exporters) Parameters config IConfig exporters IExporter[] Returns ManualConfig AddFilter(IConfig, params IFilter[]) public static ManualConfig AddFilter(this IConfig config, params IFilter[] filters) Parameters config IConfig filters IFilter[] Returns ManualConfig AddHardwareCounters(IConfig, params HardwareCounter[]) public static ManualConfig AddHardwareCounters(this IConfig config, params HardwareCounter[] counters) Parameters config IConfig counters HardwareCounter[] Returns ManualConfig AddJob(IConfig, Job) public static ManualConfig AddJob(this IConfig config, Job job) Parameters config IConfig job Job Returns ManualConfig AddLogger(IConfig, params ILogger[]) public static ManualConfig AddLogger(this IConfig config, params ILogger[] loggers) Parameters config IConfig loggers ILogger[] Returns ManualConfig AddLogicalGroupRules(IConfig, params BenchmarkLogicalGroupRule[]) public static ManualConfig AddLogicalGroupRules(this IConfig config, params BenchmarkLogicalGroupRule[] rules) Parameters config IConfig rules BenchmarkLogicalGroupRule[] Returns ManualConfig AddValidator(IConfig, params IValidator[]) public static ManualConfig AddValidator(this IConfig config, params IValidator[] validators) Parameters config IConfig validators IValidator[] Returns ManualConfig CreateImmutableConfig(IConfig) public static ImmutableConfig CreateImmutableConfig(this IConfig config) Parameters config IConfig Returns ImmutableConfig DontOverwriteResults(IConfig, bool) determines if the exported result files should not be overwritten (be default they are overwritten) public static IConfig DontOverwriteResults(this IConfig config, bool value = true) Parameters config IConfig value bool Returns IConfig HideColumns(IConfig, params IColumnHidingRule[]) public static ManualConfig HideColumns(this IConfig config, params IColumnHidingRule[] rules) Parameters config IConfig rules IColumnHidingRule[] Returns ManualConfig HideColumns(IConfig, params IColumn[]) public static ManualConfig HideColumns(this IConfig config, params IColumn[] columns) Parameters config IConfig columns IColumn[] Returns ManualConfig HideColumns(IConfig, params string[]) public static ManualConfig HideColumns(this IConfig config, params string[] columnNames) Parameters config IConfig columnNames string[] Returns ManualConfig KeepBenchmarkFiles(IConfig, bool) determines if all auto-generated files should be kept or removed after running the benchmarks public static IConfig KeepBenchmarkFiles(this IConfig config, bool value = true) Parameters config IConfig value bool Returns IConfig StopOnFirstError(IConfig, bool) determines if benchmarking should be stopped after the first error (by default it's not) public static IConfig StopOnFirstError(this IConfig config, bool value = true) Parameters config IConfig value bool Returns IConfig WithArtifactsPath(IConfig, string) public static ManualConfig WithArtifactsPath(this IConfig config, string artifactsPath) Parameters config IConfig artifactsPath string Returns ManualConfig WithCultureInfo(IConfig, CultureInfo) public static ManualConfig WithCultureInfo(this IConfig config, CultureInfo cultureInfo) Parameters config IConfig cultureInfo CultureInfo Returns ManualConfig WithOption(IConfig, ConfigOptions, bool) sets given option to provided value public static ManualConfig WithOption(this IConfig config, ConfigOptions option, bool value) Parameters config IConfig option ConfigOptions value bool Returns ManualConfig WithOptions(IConfig, ConfigOptions) sets given options for the config public static ManualConfig WithOptions(this IConfig config, ConfigOptions options) Parameters config IConfig options ConfigOptions Returns ManualConfig WithOrderer(IConfig, IOrderer) public static ManualConfig WithOrderer(this IConfig config, IOrderer orderer) Parameters config IConfig orderer IOrderer Returns ManualConfig WithSummaryStyle(IConfig, SummaryStyle) public static ManualConfig WithSummaryStyle(this IConfig config, SummaryStyle summaryStyle) Parameters config IConfig summaryStyle SummaryStyle Returns ManualConfig WithUnionRule(IConfig, ConfigUnionRule) public static ManualConfig WithUnionRule(this IConfig config, ConfigUnionRule unionRule) Parameters config IConfig unionRule ConfigUnionRule Returns ManualConfig"
  },
  "api/BenchmarkDotNet.Configs.ConfigOptions.html": {
    "href": "api/BenchmarkDotNet.Configs.ConfigOptions.html",
    "title": "Enum ConfigOptions | BenchmarkDotNet",
    "summary": "Enum ConfigOptions Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll [Flags] public enum ConfigOptions Fields ApplesToApples = 256 Performs apples-to-apples comparison for provided benchmarks and jobs. Experimental, will change in the near future! Default = 0 no custom settings DisableLogFile = 32 Determines if the log file should be disabled. DisableOptimizationsValidator = 8 determines if \"mandatory\" optimizations validator should be entirely turned off DisableParallelBuild = 1024 Determines whether parallel build of benchmark projects should be disabled. DontOverwriteResults = 16 determines if the exported result files should not be overwritten (be default they are overwritten) GenerateMSBuildBinLog = 128 Determines whether to generate msbuild binlogs JoinSummary = 2 determines if all benchmarks results should be joined into a single summary (by default we have a summary per type) KeepBenchmarkFiles = 1 determines if all auto-generated files should be kept after running the benchmarks (be default they are removed) LogBuildOutput = 64 Determines whether build output should be logged. Resume = 512 Continue the execution if the last run was stopped. StopOnFirstError = 4 determines if benchmarking should be stopped after the first error (by default it's not)"
  },
  "api/BenchmarkDotNet.Configs.ConfigUnionRule.html": {
    "href": "api/BenchmarkDotNet.Configs.ConfigUnionRule.html",
    "title": "Enum ConfigUnionRule | BenchmarkDotNet",
    "summary": "Enum ConfigUnionRule Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll public enum ConfigUnionRule Fields AlwaysUseGlobal = 2 AlwaysUseLocal = 1 Union = 0"
  },
  "api/BenchmarkDotNet.Configs.DebugBuildConfig.html": {
    "href": "api/BenchmarkDotNet.Configs.DebugBuildConfig.html",
    "title": "Class DebugBuildConfig | BenchmarkDotNet",
    "summary": "Class DebugBuildConfig Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll config which allows to build benchmarks in Debug public class DebugBuildConfig : DebugConfig, IConfig Inheritance object DebugConfig DebugBuildConfig Implements IConfig Inherited Members DebugConfig.GetValidators() DebugConfig.GetColumnProviders() DebugConfig.GetExporters() DebugConfig.GetLoggers() DebugConfig.GetDiagnosers() DebugConfig.GetAnalysers() DebugConfig.GetHardwareCounters() DebugConfig.GetEventProcessors() DebugConfig.GetFilters() DebugConfig.GetColumnHidingRules() DebugConfig.GetLogicalGroupRules() DebugConfig.Orderer DebugConfig.CategoryDiscoverer DebugConfig.SummaryStyle DebugConfig.UnionRule DebugConfig.BuildTimeout DebugConfig.WakeLock DebugConfig.ArtifactsPath DebugConfig.CultureInfo DebugConfig.Options DebugConfig.ConfigAnalysisConclusion Extension Methods ConfigExtensions.AddAnalyser(IConfig, params IAnalyser[]) ConfigExtensions.AddColumn(IConfig, params IColumn[]) ConfigExtensions.AddColumnProvider(IConfig, params IColumnProvider[]) ConfigExtensions.AddDiagnoser(IConfig, params IDiagnoser[]) ConfigExtensions.AddEventProcessor(IConfig, params EventProcessor[]) ConfigExtensions.AddExporter(IConfig, params IExporter[]) ConfigExtensions.AddFilter(IConfig, params IFilter[]) ConfigExtensions.AddHardwareCounters(IConfig, params HardwareCounter[]) ConfigExtensions.AddJob(IConfig, Job) ConfigExtensions.AddLogger(IConfig, params ILogger[]) ConfigExtensions.AddLogicalGroupRules(IConfig, params BenchmarkLogicalGroupRule[]) ConfigExtensions.AddValidator(IConfig, params IValidator[]) ConfigExtensions.CreateImmutableConfig(IConfig) ConfigExtensions.DontOverwriteResults(IConfig, bool) ConfigExtensions.HideColumns(IConfig, params IColumn[]) ConfigExtensions.HideColumns(IConfig, params IColumnHidingRule[]) ConfigExtensions.HideColumns(IConfig, params string[]) ConfigExtensions.KeepBenchmarkFiles(IConfig, bool) ConfigExtensions.StopOnFirstError(IConfig, bool) ConfigExtensions.WithArtifactsPath(IConfig, string) ConfigExtensions.WithCultureInfo(IConfig, CultureInfo) ConfigExtensions.WithOption(IConfig, ConfigOptions, bool) ConfigExtensions.WithOptions(IConfig, ConfigOptions) ConfigExtensions.WithOrderer(IConfig, IOrderer) ConfigExtensions.WithSummaryStyle(IConfig, SummaryStyle) ConfigExtensions.WithUnionRule(IConfig, ConfigUnionRule) Constructors DebugBuildConfig() public DebugBuildConfig() Methods GetJobs() public override IEnumerable<Job> GetJobs() Returns IEnumerable<Job>"
  },
  "api/BenchmarkDotNet.Configs.DebugConfig.html": {
    "href": "api/BenchmarkDotNet.Configs.DebugConfig.html",
    "title": "Class DebugConfig | BenchmarkDotNet",
    "summary": "Class DebugConfig Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll public abstract class DebugConfig : IConfig Inheritance object DebugConfig Implements IConfig Derived DebugBuildConfig DebugInProcessConfig Extension Methods ConfigExtensions.AddAnalyser(IConfig, params IAnalyser[]) ConfigExtensions.AddColumn(IConfig, params IColumn[]) ConfigExtensions.AddColumnProvider(IConfig, params IColumnProvider[]) ConfigExtensions.AddDiagnoser(IConfig, params IDiagnoser[]) ConfigExtensions.AddEventProcessor(IConfig, params EventProcessor[]) ConfigExtensions.AddExporter(IConfig, params IExporter[]) ConfigExtensions.AddFilter(IConfig, params IFilter[]) ConfigExtensions.AddHardwareCounters(IConfig, params HardwareCounter[]) ConfigExtensions.AddJob(IConfig, Job) ConfigExtensions.AddLogger(IConfig, params ILogger[]) ConfigExtensions.AddLogicalGroupRules(IConfig, params BenchmarkLogicalGroupRule[]) ConfigExtensions.AddValidator(IConfig, params IValidator[]) ConfigExtensions.CreateImmutableConfig(IConfig) ConfigExtensions.DontOverwriteResults(IConfig, bool) ConfigExtensions.HideColumns(IConfig, params IColumn[]) ConfigExtensions.HideColumns(IConfig, params IColumnHidingRule[]) ConfigExtensions.HideColumns(IConfig, params string[]) ConfigExtensions.KeepBenchmarkFiles(IConfig, bool) ConfigExtensions.StopOnFirstError(IConfig, bool) ConfigExtensions.WithArtifactsPath(IConfig, string) ConfigExtensions.WithCultureInfo(IConfig, CultureInfo) ConfigExtensions.WithOption(IConfig, ConfigOptions, bool) ConfigExtensions.WithOptions(IConfig, ConfigOptions) ConfigExtensions.WithOrderer(IConfig, IOrderer) ConfigExtensions.WithSummaryStyle(IConfig, SummaryStyle) ConfigExtensions.WithUnionRule(IConfig, ConfigUnionRule) Constructors DebugConfig() protected DebugConfig() Properties ArtifactsPath the default value is \"./BenchmarkDotNet.Artifacts\" public string ArtifactsPath { get; } Property Value string BuildTimeout the auto-generated project build timeout public TimeSpan BuildTimeout { get; } Property Value TimeSpan CategoryDiscoverer public ICategoryDiscoverer? CategoryDiscoverer { get; } Property Value ICategoryDiscoverer ConfigAnalysisConclusion Collect any errors or warnings when composing the configuration public IReadOnlyList<Conclusion> ConfigAnalysisConclusion { get; } Property Value IReadOnlyList<Conclusion> CultureInfo public CultureInfo CultureInfo { get; } Property Value CultureInfo Options a set of custom flags that can enable/disable various settings public ConfigOptions Options { get; } Property Value ConfigOptions Orderer public IOrderer Orderer { get; } Property Value IOrderer SummaryStyle public SummaryStyle SummaryStyle { get; } Property Value SummaryStyle UnionRule public ConfigUnionRule UnionRule { get; } Property Value ConfigUnionRule WakeLock public WakeLockType WakeLock { get; } Property Value WakeLockType Methods GetAnalysers() public IEnumerable<IAnalyser> GetAnalysers() Returns IEnumerable<IAnalyser> GetColumnHidingRules() public IEnumerable<IColumnHidingRule> GetColumnHidingRules() Returns IEnumerable<IColumnHidingRule> GetColumnProviders() public IEnumerable<IColumnProvider> GetColumnProviders() Returns IEnumerable<IColumnProvider> GetDiagnosers() public IEnumerable<IDiagnoser> GetDiagnosers() Returns IEnumerable<IDiagnoser> GetEventProcessors() public IEnumerable<EventProcessor> GetEventProcessors() Returns IEnumerable<EventProcessor> GetExporters() public IEnumerable<IExporter> GetExporters() Returns IEnumerable<IExporter> GetFilters() public IEnumerable<IFilter> GetFilters() Returns IEnumerable<IFilter> GetHardwareCounters() public IEnumerable<HardwareCounter> GetHardwareCounters() Returns IEnumerable<HardwareCounter> GetJobs() public abstract IEnumerable<Job> GetJobs() Returns IEnumerable<Job> GetLoggers() public IEnumerable<ILogger> GetLoggers() Returns IEnumerable<ILogger> GetLogicalGroupRules() public IEnumerable<BenchmarkLogicalGroupRule> GetLogicalGroupRules() Returns IEnumerable<BenchmarkLogicalGroupRule> GetValidators() public IEnumerable<IValidator> GetValidators() Returns IEnumerable<IValidator>"
  },
  "api/BenchmarkDotNet.Configs.DebugInProcessConfig.html": {
    "href": "api/BenchmarkDotNet.Configs.DebugInProcessConfig.html",
    "title": "Class DebugInProcessConfig | BenchmarkDotNet",
    "summary": "Class DebugInProcessConfig Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll config which allows to debug benchmarks running it in the same process public class DebugInProcessConfig : DebugConfig, IConfig Inheritance object DebugConfig DebugInProcessConfig Implements IConfig Inherited Members DebugConfig.GetValidators() DebugConfig.GetColumnProviders() DebugConfig.GetExporters() DebugConfig.GetLoggers() DebugConfig.GetDiagnosers() DebugConfig.GetAnalysers() DebugConfig.GetHardwareCounters() DebugConfig.GetEventProcessors() DebugConfig.GetFilters() DebugConfig.GetColumnHidingRules() DebugConfig.GetLogicalGroupRules() DebugConfig.Orderer DebugConfig.CategoryDiscoverer DebugConfig.SummaryStyle DebugConfig.UnionRule DebugConfig.BuildTimeout DebugConfig.WakeLock DebugConfig.ArtifactsPath DebugConfig.CultureInfo DebugConfig.Options DebugConfig.ConfigAnalysisConclusion Extension Methods ConfigExtensions.AddAnalyser(IConfig, params IAnalyser[]) ConfigExtensions.AddColumn(IConfig, params IColumn[]) ConfigExtensions.AddColumnProvider(IConfig, params IColumnProvider[]) ConfigExtensions.AddDiagnoser(IConfig, params IDiagnoser[]) ConfigExtensions.AddEventProcessor(IConfig, params EventProcessor[]) ConfigExtensions.AddExporter(IConfig, params IExporter[]) ConfigExtensions.AddFilter(IConfig, params IFilter[]) ConfigExtensions.AddHardwareCounters(IConfig, params HardwareCounter[]) ConfigExtensions.AddJob(IConfig, Job) ConfigExtensions.AddLogger(IConfig, params ILogger[]) ConfigExtensions.AddLogicalGroupRules(IConfig, params BenchmarkLogicalGroupRule[]) ConfigExtensions.AddValidator(IConfig, params IValidator[]) ConfigExtensions.CreateImmutableConfig(IConfig) ConfigExtensions.DontOverwriteResults(IConfig, bool) ConfigExtensions.HideColumns(IConfig, params IColumn[]) ConfigExtensions.HideColumns(IConfig, params IColumnHidingRule[]) ConfigExtensions.HideColumns(IConfig, params string[]) ConfigExtensions.KeepBenchmarkFiles(IConfig, bool) ConfigExtensions.StopOnFirstError(IConfig, bool) ConfigExtensions.WithArtifactsPath(IConfig, string) ConfigExtensions.WithCultureInfo(IConfig, CultureInfo) ConfigExtensions.WithOption(IConfig, ConfigOptions, bool) ConfigExtensions.WithOptions(IConfig, ConfigOptions) ConfigExtensions.WithOrderer(IConfig, IOrderer) ConfigExtensions.WithSummaryStyle(IConfig, SummaryStyle) ConfigExtensions.WithUnionRule(IConfig, ConfigUnionRule) Constructors DebugInProcessConfig() public DebugInProcessConfig() Methods GetJobs() public override IEnumerable<Job> GetJobs() Returns IEnumerable<Job>"
  },
  "api/BenchmarkDotNet.Configs.DefaultConfig.html": {
    "href": "api/BenchmarkDotNet.Configs.DefaultConfig.html",
    "title": "Class DefaultConfig | BenchmarkDotNet",
    "summary": "Class DefaultConfig Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll public class DefaultConfig : IConfig Inheritance object DefaultConfig Implements IConfig Extension Methods ConfigExtensions.AddAnalyser(IConfig, params IAnalyser[]) ConfigExtensions.AddColumn(IConfig, params IColumn[]) ConfigExtensions.AddColumnProvider(IConfig, params IColumnProvider[]) ConfigExtensions.AddDiagnoser(IConfig, params IDiagnoser[]) ConfigExtensions.AddEventProcessor(IConfig, params EventProcessor[]) ConfigExtensions.AddExporter(IConfig, params IExporter[]) ConfigExtensions.AddFilter(IConfig, params IFilter[]) ConfigExtensions.AddHardwareCounters(IConfig, params HardwareCounter[]) ConfigExtensions.AddJob(IConfig, Job) ConfigExtensions.AddLogger(IConfig, params ILogger[]) ConfigExtensions.AddLogicalGroupRules(IConfig, params BenchmarkLogicalGroupRule[]) ConfigExtensions.AddValidator(IConfig, params IValidator[]) ConfigExtensions.CreateImmutableConfig(IConfig) ConfigExtensions.DontOverwriteResults(IConfig, bool) ConfigExtensions.HideColumns(IConfig, params IColumn[]) ConfigExtensions.HideColumns(IConfig, params IColumnHidingRule[]) ConfigExtensions.HideColumns(IConfig, params string[]) ConfigExtensions.KeepBenchmarkFiles(IConfig, bool) ConfigExtensions.StopOnFirstError(IConfig, bool) ConfigExtensions.WithArtifactsPath(IConfig, string) ConfigExtensions.WithCultureInfo(IConfig, CultureInfo) ConfigExtensions.WithOption(IConfig, ConfigOptions, bool) ConfigExtensions.WithOptions(IConfig, ConfigOptions) ConfigExtensions.WithOrderer(IConfig, IOrderer) ConfigExtensions.WithSummaryStyle(IConfig, SummaryStyle) ConfigExtensions.WithUnionRule(IConfig, ConfigUnionRule) Fields Instance public static readonly IConfig Instance Field Value IConfig Properties ArtifactsPath the default value is \"./BenchmarkDotNet.Artifacts\" public string ArtifactsPath { get; } Property Value string BuildTimeout the auto-generated project build timeout public TimeSpan BuildTimeout { get; } Property Value TimeSpan CategoryDiscoverer public ICategoryDiscoverer? CategoryDiscoverer { get; } Property Value ICategoryDiscoverer ConfigAnalysisConclusion Collect any errors or warnings when composing the configuration public IReadOnlyList<Conclusion> ConfigAnalysisConclusion { get; } Property Value IReadOnlyList<Conclusion> CultureInfo public CultureInfo CultureInfo { get; } Property Value CultureInfo Options a set of custom flags that can enable/disable various settings public ConfigOptions Options { get; } Property Value ConfigOptions Orderer public IOrderer Orderer { get; } Property Value IOrderer SummaryStyle public SummaryStyle SummaryStyle { get; } Property Value SummaryStyle UnionRule public ConfigUnionRule UnionRule { get; } Property Value ConfigUnionRule WakeLock public WakeLockType WakeLock { get; } Property Value WakeLockType Methods GetAnalysers() public IEnumerable<IAnalyser> GetAnalysers() Returns IEnumerable<IAnalyser> GetColumnHidingRules() public IEnumerable<IColumnHidingRule> GetColumnHidingRules() Returns IEnumerable<IColumnHidingRule> GetColumnProviders() public IEnumerable<IColumnProvider> GetColumnProviders() Returns IEnumerable<IColumnProvider> GetDiagnosers() public IEnumerable<IDiagnoser> GetDiagnosers() Returns IEnumerable<IDiagnoser> GetEventProcessors() public IEnumerable<EventProcessor> GetEventProcessors() Returns IEnumerable<EventProcessor> GetExporters() public IEnumerable<IExporter> GetExporters() Returns IEnumerable<IExporter> GetFilters() public IEnumerable<IFilter> GetFilters() Returns IEnumerable<IFilter> GetHardwareCounters() public IEnumerable<HardwareCounter> GetHardwareCounters() Returns IEnumerable<HardwareCounter> GetJobs() public IEnumerable<Job> GetJobs() Returns IEnumerable<Job> GetLoggers() public IEnumerable<ILogger> GetLoggers() Returns IEnumerable<ILogger> GetLogicalGroupRules() public IEnumerable<BenchmarkLogicalGroupRule> GetLogicalGroupRules() Returns IEnumerable<BenchmarkLogicalGroupRule> GetValidators() public IEnumerable<IValidator> GetValidators() Returns IEnumerable<IValidator>"
  },
  "api/BenchmarkDotNet.Configs.html": {
    "href": "api/BenchmarkDotNet.Configs.html",
    "title": "Namespace BenchmarkDotNet.Configs | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Configs Classes ConfigExtensions DebugBuildConfig config which allows to build benchmarks in Debug DebugConfig DebugInProcessConfig config which allows to debug benchmarks running it in the same process DefaultConfig ImmutableConfig ImmutableConfigBuilder this class is responsible for config that has no duplicates, does all of the internal hacks and is ready to run ManualConfig Interfaces IConfig IConfigSource Enums BenchmarkLogicalGroupRule ConfigOptions ConfigUnionRule WakeLockType"
  },
  "api/BenchmarkDotNet.Configs.IConfig.html": {
    "href": "api/BenchmarkDotNet.Configs.IConfig.html",
    "title": "Interface IConfig | BenchmarkDotNet",
    "summary": "Interface IConfig Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll public interface IConfig Extension Methods ConfigExtensions.AddAnalyser(IConfig, params IAnalyser[]) ConfigExtensions.AddColumn(IConfig, params IColumn[]) ConfigExtensions.AddColumnProvider(IConfig, params IColumnProvider[]) ConfigExtensions.AddDiagnoser(IConfig, params IDiagnoser[]) ConfigExtensions.AddEventProcessor(IConfig, params EventProcessor[]) ConfigExtensions.AddExporter(IConfig, params IExporter[]) ConfigExtensions.AddFilter(IConfig, params IFilter[]) ConfigExtensions.AddHardwareCounters(IConfig, params HardwareCounter[]) ConfigExtensions.AddJob(IConfig, Job) ConfigExtensions.AddLogger(IConfig, params ILogger[]) ConfigExtensions.AddLogicalGroupRules(IConfig, params BenchmarkLogicalGroupRule[]) ConfigExtensions.AddValidator(IConfig, params IValidator[]) ConfigExtensions.CreateImmutableConfig(IConfig) ConfigExtensions.DontOverwriteResults(IConfig, bool) ConfigExtensions.HideColumns(IConfig, params IColumn[]) ConfigExtensions.HideColumns(IConfig, params IColumnHidingRule[]) ConfigExtensions.HideColumns(IConfig, params string[]) ConfigExtensions.KeepBenchmarkFiles(IConfig, bool) ConfigExtensions.StopOnFirstError(IConfig, bool) ConfigExtensions.WithArtifactsPath(IConfig, string) ConfigExtensions.WithCultureInfo(IConfig, CultureInfo) ConfigExtensions.WithOption(IConfig, ConfigOptions, bool) ConfigExtensions.WithOptions(IConfig, ConfigOptions) ConfigExtensions.WithOrderer(IConfig, IOrderer) ConfigExtensions.WithSummaryStyle(IConfig, SummaryStyle) ConfigExtensions.WithUnionRule(IConfig, ConfigUnionRule) Properties ArtifactsPath the default value is \"./BenchmarkDotNet.Artifacts\" string ArtifactsPath { get; } Property Value string BuildTimeout the auto-generated project build timeout TimeSpan BuildTimeout { get; } Property Value TimeSpan CategoryDiscoverer ICategoryDiscoverer? CategoryDiscoverer { get; } Property Value ICategoryDiscoverer ConfigAnalysisConclusion Collect any errors or warnings when composing the configuration IReadOnlyList<Conclusion> ConfigAnalysisConclusion { get; } Property Value IReadOnlyList<Conclusion> CultureInfo CultureInfo? CultureInfo { get; } Property Value CultureInfo Options a set of custom flags that can enable/disable various settings ConfigOptions Options { get; } Property Value ConfigOptions Orderer IOrderer? Orderer { get; } Property Value IOrderer SummaryStyle SummaryStyle SummaryStyle { get; } Property Value SummaryStyle UnionRule ConfigUnionRule UnionRule { get; } Property Value ConfigUnionRule WakeLock WakeLockType WakeLock { get; } Property Value WakeLockType Methods GetAnalysers() IEnumerable<IAnalyser> GetAnalysers() Returns IEnumerable<IAnalyser> GetColumnHidingRules() IEnumerable<IColumnHidingRule> GetColumnHidingRules() Returns IEnumerable<IColumnHidingRule> GetColumnProviders() IEnumerable<IColumnProvider> GetColumnProviders() Returns IEnumerable<IColumnProvider> GetDiagnosers() IEnumerable<IDiagnoser> GetDiagnosers() Returns IEnumerable<IDiagnoser> GetEventProcessors() IEnumerable<EventProcessor> GetEventProcessors() Returns IEnumerable<EventProcessor> GetExporters() IEnumerable<IExporter> GetExporters() Returns IEnumerable<IExporter> GetFilters() IEnumerable<IFilter> GetFilters() Returns IEnumerable<IFilter> GetHardwareCounters() IEnumerable<HardwareCounter> GetHardwareCounters() Returns IEnumerable<HardwareCounter> GetJobs() IEnumerable<Job> GetJobs() Returns IEnumerable<Job> GetLoggers() IEnumerable<ILogger> GetLoggers() Returns IEnumerable<ILogger> GetLogicalGroupRules() IEnumerable<BenchmarkLogicalGroupRule> GetLogicalGroupRules() Returns IEnumerable<BenchmarkLogicalGroupRule> GetValidators() IEnumerable<IValidator> GetValidators() Returns IEnumerable<IValidator>"
  },
  "api/BenchmarkDotNet.Configs.IConfigSource.html": {
    "href": "api/BenchmarkDotNet.Configs.IConfigSource.html",
    "title": "Interface IConfigSource | BenchmarkDotNet",
    "summary": "Interface IConfigSource Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll public interface IConfigSource Properties Config IConfig Config { get; } Property Value IConfig"
  },
  "api/BenchmarkDotNet.Configs.ImmutableConfig.html": {
    "href": "api/BenchmarkDotNet.Configs.ImmutableConfig.html",
    "title": "Class ImmutableConfig | BenchmarkDotNet",
    "summary": "Class ImmutableConfig Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll public sealed class ImmutableConfig : IConfig Inheritance object ImmutableConfig Implements IConfig Extension Methods ConfigExtensions.AddAnalyser(IConfig, params IAnalyser[]) ConfigExtensions.AddColumn(IConfig, params IColumn[]) ConfigExtensions.AddColumnProvider(IConfig, params IColumnProvider[]) ConfigExtensions.AddDiagnoser(IConfig, params IDiagnoser[]) ConfigExtensions.AddEventProcessor(IConfig, params EventProcessor[]) ConfigExtensions.AddExporter(IConfig, params IExporter[]) ConfigExtensions.AddFilter(IConfig, params IFilter[]) ConfigExtensions.AddHardwareCounters(IConfig, params HardwareCounter[]) ConfigExtensions.AddJob(IConfig, Job) ConfigExtensions.AddLogger(IConfig, params ILogger[]) ConfigExtensions.AddLogicalGroupRules(IConfig, params BenchmarkLogicalGroupRule[]) ConfigExtensions.AddValidator(IConfig, params IValidator[]) ConfigExtensions.CreateImmutableConfig(IConfig) ConfigExtensions.DontOverwriteResults(IConfig, bool) ConfigExtensions.HideColumns(IConfig, params IColumn[]) ConfigExtensions.HideColumns(IConfig, params IColumnHidingRule[]) ConfigExtensions.HideColumns(IConfig, params string[]) ConfigExtensions.KeepBenchmarkFiles(IConfig, bool) ConfigExtensions.StopOnFirstError(IConfig, bool) ConfigExtensions.WithArtifactsPath(IConfig, string) ConfigExtensions.WithCultureInfo(IConfig, CultureInfo) ConfigExtensions.WithOption(IConfig, ConfigOptions, bool) ConfigExtensions.WithOptions(IConfig, ConfigOptions) ConfigExtensions.WithOrderer(IConfig, IOrderer) ConfigExtensions.WithSummaryStyle(IConfig, SummaryStyle) ConfigExtensions.WithUnionRule(IConfig, ConfigUnionRule) Properties ArtifactsPath the default value is \"./BenchmarkDotNet.Artifacts\" public string ArtifactsPath { get; } Property Value string BuildTimeout the auto-generated project build timeout public TimeSpan BuildTimeout { get; } Property Value TimeSpan CategoryDiscoverer public ICategoryDiscoverer CategoryDiscoverer { get; } Property Value ICategoryDiscoverer ConfigAnalysisConclusion Collect any errors or warnings when composing the configuration public IReadOnlyList<Conclusion> ConfigAnalysisConclusion { get; } Property Value IReadOnlyList<Conclusion> CultureInfo public CultureInfo CultureInfo { get; } Property Value CultureInfo Options a set of custom flags that can enable/disable various settings public ConfigOptions Options { get; } Property Value ConfigOptions Orderer public IOrderer Orderer { get; } Property Value IOrderer SummaryStyle public SummaryStyle SummaryStyle { get; } Property Value SummaryStyle UnionRule public ConfigUnionRule UnionRule { get; } Property Value ConfigUnionRule WakeLock public WakeLockType WakeLock { get; } Property Value WakeLockType Methods GetAnalysers() public IEnumerable<IAnalyser> GetAnalysers() Returns IEnumerable<IAnalyser> GetColumnHidingRules() public IEnumerable<IColumnHidingRule> GetColumnHidingRules() Returns IEnumerable<IColumnHidingRule> GetColumnProviders() public IEnumerable<IColumnProvider> GetColumnProviders() Returns IEnumerable<IColumnProvider> GetCompositeAnalyser() public IAnalyser GetCompositeAnalyser() Returns IAnalyser GetCompositeDiagnoser() public IDiagnoser GetCompositeDiagnoser() Returns IDiagnoser GetCompositeDiagnoser(BenchmarkCase, RunMode) public IDiagnoser? GetCompositeDiagnoser(BenchmarkCase benchmarkCase, RunMode runMode) Parameters benchmarkCase BenchmarkCase runMode RunMode Returns IDiagnoser GetCompositeExporter() public IExporter GetCompositeExporter() Returns IExporter GetCompositeLogger() public ILogger GetCompositeLogger() Returns ILogger GetCompositeValidator() public IValidator GetCompositeValidator() Returns IValidator GetDiagnosers() public IEnumerable<IDiagnoser> GetDiagnosers() Returns IEnumerable<IDiagnoser> GetEventProcessors() public IEnumerable<EventProcessor> GetEventProcessors() Returns IEnumerable<EventProcessor> GetExporters() public IEnumerable<IExporter> GetExporters() Returns IEnumerable<IExporter> GetFilters() public IEnumerable<IFilter> GetFilters() Returns IEnumerable<IFilter> GetHardwareCounters() public IEnumerable<HardwareCounter> GetHardwareCounters() Returns IEnumerable<HardwareCounter> GetJobs() public IEnumerable<Job> GetJobs() Returns IEnumerable<Job> GetLoggers() public IEnumerable<ILogger> GetLoggers() Returns IEnumerable<ILogger> GetLogicalGroupRules() public IEnumerable<BenchmarkLogicalGroupRule> GetLogicalGroupRules() Returns IEnumerable<BenchmarkLogicalGroupRule> GetValidators() public IEnumerable<IValidator> GetValidators() Returns IEnumerable<IValidator> HasExceptionDiagnoser() public bool HasExceptionDiagnoser() Returns bool HasExtraStatsDiagnoser() public bool HasExtraStatsDiagnoser() Returns bool HasMemoryDiagnoser() public bool HasMemoryDiagnoser() Returns bool HasThreadingDiagnoser() public bool HasThreadingDiagnoser() Returns bool"
  },
  "api/BenchmarkDotNet.Configs.ImmutableConfigBuilder.html": {
    "href": "api/BenchmarkDotNet.Configs.ImmutableConfigBuilder.html",
    "title": "Class ImmutableConfigBuilder | BenchmarkDotNet",
    "summary": "Class ImmutableConfigBuilder Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll this class is responsible for config that has no duplicates, does all of the internal hacks and is ready to run public static class ImmutableConfigBuilder Inheritance object ImmutableConfigBuilder Methods Create(IConfig) removes duplicates and applies all extra logic required to make the config a final one public static ImmutableConfig Create(IConfig source) Parameters source IConfig Returns ImmutableConfig"
  },
  "api/BenchmarkDotNet.Configs.ManualConfig.html": {
    "href": "api/BenchmarkDotNet.Configs.ManualConfig.html",
    "title": "Class ManualConfig | BenchmarkDotNet",
    "summary": "Class ManualConfig Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll public class ManualConfig : IConfig Inheritance object ManualConfig Implements IConfig Extension Methods ConfigExtensions.AddAnalyser(IConfig, params IAnalyser[]) ConfigExtensions.AddColumn(IConfig, params IColumn[]) ConfigExtensions.AddColumnProvider(IConfig, params IColumnProvider[]) ConfigExtensions.AddDiagnoser(IConfig, params IDiagnoser[]) ConfigExtensions.AddEventProcessor(IConfig, params EventProcessor[]) ConfigExtensions.AddExporter(IConfig, params IExporter[]) ConfigExtensions.AddFilter(IConfig, params IFilter[]) ConfigExtensions.AddHardwareCounters(IConfig, params HardwareCounter[]) ConfigExtensions.AddJob(IConfig, Job) ConfigExtensions.AddLogger(IConfig, params ILogger[]) ConfigExtensions.AddLogicalGroupRules(IConfig, params BenchmarkLogicalGroupRule[]) ConfigExtensions.AddValidator(IConfig, params IValidator[]) ConfigExtensions.CreateImmutableConfig(IConfig) ConfigExtensions.DontOverwriteResults(IConfig, bool) ConfigExtensions.HideColumns(IConfig, params IColumn[]) ConfigExtensions.HideColumns(IConfig, params IColumnHidingRule[]) ConfigExtensions.HideColumns(IConfig, params string[]) ConfigExtensions.KeepBenchmarkFiles(IConfig, bool) ConfigExtensions.StopOnFirstError(IConfig, bool) ConfigExtensions.WithArtifactsPath(IConfig, string) ConfigExtensions.WithCultureInfo(IConfig, CultureInfo) ConfigExtensions.WithOption(IConfig, ConfigOptions, bool) ConfigExtensions.WithOptions(IConfig, ConfigOptions) ConfigExtensions.WithOrderer(IConfig, IOrderer) ConfigExtensions.WithSummaryStyle(IConfig, SummaryStyle) ConfigExtensions.WithUnionRule(IConfig, ConfigUnionRule) Constructors ManualConfig() public ManualConfig() Properties ArtifactsPath the default value is \"./BenchmarkDotNet.Artifacts\" public string ArtifactsPath { get; set; } Property Value string BuildTimeout the auto-generated project build timeout public TimeSpan BuildTimeout { get; set; } Property Value TimeSpan CategoryDiscoverer public ICategoryDiscoverer CategoryDiscoverer { get; set; } Property Value ICategoryDiscoverer ConfigAnalysisConclusion Collect any errors or warnings when composing the configuration public IReadOnlyList<Conclusion> ConfigAnalysisConclusion { get; } Property Value IReadOnlyList<Conclusion> CultureInfo public CultureInfo CultureInfo { get; set; } Property Value CultureInfo Options a set of custom flags that can enable/disable various settings public ConfigOptions Options { get; set; } Property Value ConfigOptions Orderer public IOrderer Orderer { get; set; } Property Value IOrderer SummaryStyle public SummaryStyle SummaryStyle { get; set; } Property Value SummaryStyle UnionRule public ConfigUnionRule UnionRule { get; set; } Property Value ConfigUnionRule WakeLock public WakeLockType WakeLock { get; set; } Property Value WakeLockType Methods Add(IConfig) public void Add(IConfig config) Parameters config IConfig AddAnalyser(params IAnalyser[]) public ManualConfig AddAnalyser(params IAnalyser[] newAnalysers) Parameters newAnalysers IAnalyser[] Returns ManualConfig AddColumn(params IColumn[]) public ManualConfig AddColumn(params IColumn[] newColumns) Parameters newColumns IColumn[] Returns ManualConfig AddColumnProvider(params IColumnProvider[]) public ManualConfig AddColumnProvider(params IColumnProvider[] newColumnProviders) Parameters newColumnProviders IColumnProvider[] Returns ManualConfig AddDiagnoser(params IDiagnoser[]) public ManualConfig AddDiagnoser(params IDiagnoser[] newDiagnosers) Parameters newDiagnosers IDiagnoser[] Returns ManualConfig AddEventProcessor(params EventProcessor[]) public ManualConfig AddEventProcessor(params EventProcessor[] newEventProcessors) Parameters newEventProcessors EventProcessor[] Returns ManualConfig AddExporter(params IExporter[]) public ManualConfig AddExporter(params IExporter[] newExporters) Parameters newExporters IExporter[] Returns ManualConfig AddFilter(params IFilter[]) public ManualConfig AddFilter(params IFilter[] newFilters) Parameters newFilters IFilter[] Returns ManualConfig AddHardwareCounters(params HardwareCounter[]) public ManualConfig AddHardwareCounters(params HardwareCounter[] newHardwareCounters) Parameters newHardwareCounters HardwareCounter[] Returns ManualConfig AddJob(params Job[]) public ManualConfig AddJob(params Job[] newJobs) Parameters newJobs Job[] Returns ManualConfig AddLogger(params ILogger[]) public ManualConfig AddLogger(params ILogger[] newLoggers) Parameters newLoggers ILogger[] Returns ManualConfig AddLogicalGroupRules(params BenchmarkLogicalGroupRule[]) public ManualConfig AddLogicalGroupRules(params BenchmarkLogicalGroupRule[] rules) Parameters rules BenchmarkLogicalGroupRule[] Returns ManualConfig AddValidator(params IValidator[]) public ManualConfig AddValidator(params IValidator[] newValidators) Parameters newValidators IValidator[] Returns ManualConfig Create(IConfig) public static ManualConfig Create(IConfig config) Parameters config IConfig Returns ManualConfig CreateEmpty() Creates a completely EMPTY config with no predefined settings. public static ManualConfig CreateEmpty() Returns ManualConfig Remarks You should most probably use the CreateMinimumViable() method instead. CreateMinimumViable() Creates a minimum viable config with predefined columns provider and console logger. public static ManualConfig CreateMinimumViable() Returns ManualConfig GetAnalysers() public IEnumerable<IAnalyser> GetAnalysers() Returns IEnumerable<IAnalyser> GetColumnHidingRules() public IEnumerable<IColumnHidingRule> GetColumnHidingRules() Returns IEnumerable<IColumnHidingRule> GetColumnProviders() public IEnumerable<IColumnProvider> GetColumnProviders() Returns IEnumerable<IColumnProvider> GetDiagnosers() public IEnumerable<IDiagnoser> GetDiagnosers() Returns IEnumerable<IDiagnoser> GetEventProcessors() public IEnumerable<EventProcessor> GetEventProcessors() Returns IEnumerable<EventProcessor> GetExporters() public IEnumerable<IExporter> GetExporters() Returns IEnumerable<IExporter> GetFilters() public IEnumerable<IFilter> GetFilters() Returns IEnumerable<IFilter> GetHardwareCounters() public IEnumerable<HardwareCounter> GetHardwareCounters() Returns IEnumerable<HardwareCounter> GetJobs() public IEnumerable<Job> GetJobs() Returns IEnumerable<Job> GetLoggers() public IEnumerable<ILogger> GetLoggers() Returns IEnumerable<ILogger> GetLogicalGroupRules() public IEnumerable<BenchmarkLogicalGroupRule> GetLogicalGroupRules() Returns IEnumerable<BenchmarkLogicalGroupRule> GetValidators() public IEnumerable<IValidator> GetValidators() Returns IEnumerable<IValidator> HideColumns(params IColumnHidingRule[]) public ManualConfig HideColumns(params IColumnHidingRule[] rules) Parameters rules IColumnHidingRule[] Returns ManualConfig HideColumns(params IColumn[]) public ManualConfig HideColumns(params IColumn[] columns) Parameters columns IColumn[] Returns ManualConfig HideColumns(params string[]) public ManualConfig HideColumns(params string[] columnNames) Parameters columnNames string[] Returns ManualConfig Union(IConfig, IConfig) public static ManualConfig Union(IConfig globalConfig, IConfig localConfig) Parameters globalConfig IConfig localConfig IConfig Returns ManualConfig WithArtifactsPath(string) public ManualConfig WithArtifactsPath(string artifactsPath) Parameters artifactsPath string Returns ManualConfig WithBuildTimeout(TimeSpan) public ManualConfig WithBuildTimeout(TimeSpan buildTimeout) Parameters buildTimeout TimeSpan Returns ManualConfig WithCategoryDiscoverer(ICategoryDiscoverer) public ManualConfig WithCategoryDiscoverer(ICategoryDiscoverer categoryDiscoverer) Parameters categoryDiscoverer ICategoryDiscoverer Returns ManualConfig WithOption(ConfigOptions, bool) public ManualConfig WithOption(ConfigOptions option, bool value) Parameters option ConfigOptions value bool Returns ManualConfig WithOptions(ConfigOptions) public ManualConfig WithOptions(ConfigOptions options) Parameters options ConfigOptions Returns ManualConfig WithOrderer(IOrderer) public ManualConfig WithOrderer(IOrderer orderer) Parameters orderer IOrderer Returns ManualConfig WithSummaryStyle(SummaryStyle) public ManualConfig WithSummaryStyle(SummaryStyle summaryStyle) Parameters summaryStyle SummaryStyle Returns ManualConfig WithUnionRule(ConfigUnionRule) public ManualConfig WithUnionRule(ConfigUnionRule unionRule) Parameters unionRule ConfigUnionRule Returns ManualConfig WithWakeLock(WakeLockType) public ManualConfig WithWakeLock(WakeLockType wakeLockType) Parameters wakeLockType WakeLockType Returns ManualConfig"
  },
  "api/BenchmarkDotNet.Configs.WakeLockType.html": {
    "href": "api/BenchmarkDotNet.Configs.WakeLockType.html",
    "title": "Enum WakeLockType | BenchmarkDotNet",
    "summary": "Enum WakeLockType Namespace BenchmarkDotNet.Configs Assembly BenchmarkDotNet.dll public enum WakeLockType Fields Display = 2 Forces the display to be on while benchmarks are running. None = 0 Allows the system to enter sleep and/or turn off the display while benchmarks are running. System = 1 Forces the system to be in the working state while benchmarks are running."
  },
  "api/BenchmarkDotNet.ConsoleArguments.CommandLineOptions.html": {
    "href": "api/BenchmarkDotNet.ConsoleArguments.CommandLineOptions.html",
    "title": "Class CommandLineOptions | BenchmarkDotNet",
    "summary": "Class CommandLineOptions Namespace BenchmarkDotNet.ConsoleArguments Assembly BenchmarkDotNet.dll public class CommandLineOptions Inheritance object CommandLineOptions Constructors CommandLineOptions() public CommandLineOptions() Properties AOTCompilerMode public MonoAotCompilerMode AOTCompilerMode { get; set; } Property Value MonoAotCompilerMode AOTCompilerPath public FileInfo AOTCompilerPath { get; set; } Property Value FileInfo Affinity public int? Affinity { get; set; } Property Value int? AllCategories public IEnumerable<string> AllCategories { get; set; } Property Value IEnumerable<string> AnyCategories public IEnumerable<string> AnyCategories { get; set; } Property Value IEnumerable<string> ApplesToApples public bool ApplesToApples { get; set; } Property Value bool ArtifactsDirectory public DirectoryInfo ArtifactsDirectory { get; set; } Property Value DirectoryInfo AttributeNames public IEnumerable<string> AttributeNames { get; set; } Property Value IEnumerable<string> BaseJob public string BaseJob { get; set; } Property Value string CliPath public FileInfo CliPath { get; set; } Property Value FileInfo ClrVersion public string ClrVersion { get; set; } Property Value string CoreRunPaths public IReadOnlyList<FileInfo> CoreRunPaths { get; set; } Property Value IReadOnlyList<FileInfo> CustomRuntimePack public string CustomRuntimePack { get; set; } Property Value string DisableLogFile public bool DisableLogFile { get; set; } Property Value bool DisassemblerDiff public bool DisassemblerDiff { get; set; } Property Value bool DisassemblerFilters public IEnumerable<string> DisassemblerFilters { get; set; } Property Value IEnumerable<string> DisassemblerRecursiveDepth public int DisassemblerRecursiveDepth { get; set; } Property Value int DisplayAllStatistics public bool DisplayAllStatistics { get; set; } Property Value bool DontOverwriteResults public bool DontOverwriteResults { get; set; } Property Value bool EnvironmentVariables public IEnumerable<string> EnvironmentVariables { get; set; } Property Value IEnumerable<string> Examples public static IEnumerable<Example> Examples { get; } Property Value IEnumerable<Example> Exporters public IEnumerable<string> Exporters { get; set; } Property Value IEnumerable<string> Filters public IEnumerable<string> Filters { get; set; } Property Value IEnumerable<string> GenerateMSBuildBinLog public bool GenerateMSBuildBinLog { get; set; } Property Value bool HardwareCounters public IEnumerable<string> HardwareCounters { get; set; } Property Value IEnumerable<string> HiddenColumns public IEnumerable<string> HiddenColumns { get; set; } Property Value IEnumerable<string> ILCompilerVersion public string ILCompilerVersion { get; set; } Property Value string IlcPackages public DirectoryInfo IlcPackages { get; set; } Property Value DirectoryInfo InvocationCount public long? InvocationCount { get; set; } Property Value long? IterationCount public int? IterationCount { get; set; } Property Value int? IterationTimeInMilliseconds public int? IterationTimeInMilliseconds { get; set; } Property Value int? Join public bool Join { get; set; } Property Value bool KeepBenchmarkFiles public bool KeepBenchmarkFiles { get; set; } Property Value bool LaunchCount public int? LaunchCount { get; set; } Property Value int? ListBenchmarkCaseMode public ListBenchmarkCaseMode ListBenchmarkCaseMode { get; set; } Property Value ListBenchmarkCaseMode LogBuildOutput public bool LogBuildOutput { get; set; } Property Value bool MaxIterationCount public int? MaxIterationCount { get; set; } Property Value int? MaxParameterColumnWidth public int? MaxParameterColumnWidth { get; set; } Property Value int? MaxWarmupIterationCount public int? MaxWarmupIterationCount { get; set; } Property Value int? MemoryRandomization public bool MemoryRandomization { get; set; } Property Value bool MinIterationCount public int? MinIterationCount { get; set; } Property Value int? MinWarmupIterationCount public int? MinWarmupIterationCount { get; set; } Property Value int? MonoPath public FileInfo MonoPath { get; set; } Property Value FileInfo NoEvaluationOverhead public bool NoEvaluationOverhead { get; set; } Property Value bool NoForcedGCs public bool NoForcedGCs { get; set; } Property Value bool Outliers public OutlierMode Outliers { get; set; } Property Value OutlierMode Platform public Platform? Platform { get; set; } Property Value Platform? PrintInformation public bool PrintInformation { get; set; } Property Value bool Profiler public string Profiler { get; set; } Property Value string RestorePath public DirectoryInfo RestorePath { get; set; } Property Value DirectoryInfo Resume public bool Resume { get; set; } Property Value bool RunInProcess public bool RunInProcess { get; set; } Property Value bool RunOncePerIteration public bool RunOncePerIteration { get; set; } Property Value bool RunStrategy public RunStrategy? RunStrategy { get; set; } Property Value RunStrategy? Runtimes public IEnumerable<string> Runtimes { get; set; } Property Value IEnumerable<string> StatisticalTestThreshold public string StatisticalTestThreshold { get; set; } Property Value string StopOnFirstError public bool StopOnFirstError { get; set; } Property Value bool TimeOutInSeconds public int? TimeOutInSeconds { get; set; } Property Value int? UnrollFactor public int? UnrollFactor { get; set; } Property Value int? UseDisassemblyDiagnoser public bool UseDisassemblyDiagnoser { get; set; } Property Value bool UseExceptionDiagnoser public bool UseExceptionDiagnoser { get; set; } Property Value bool UseMemoryDiagnoser public bool UseMemoryDiagnoser { get; set; } Property Value bool UseThreadingDiagnoser public bool UseThreadingDiagnoser { get; set; } Property Value bool WakeLock public WakeLockType? WakeLock { get; set; } Property Value WakeLockType? WarmupIterationCount public int? WarmupIterationCount { get; set; } Property Value int? WasmDataDirectory public DirectoryInfo WasmDataDirectory { get; set; } Property Value DirectoryInfo WasmJavaScriptEngineArguments public string WasmJavaScriptEngineArguments { get; set; } Property Value string WasmJavascriptEngine public FileInfo WasmJavascriptEngine { get; set; } Property Value FileInfo"
  },
  "api/BenchmarkDotNet.ConsoleArguments.ConfigParser.html": {
    "href": "api/BenchmarkDotNet.ConsoleArguments.ConfigParser.html",
    "title": "Class ConfigParser | BenchmarkDotNet",
    "summary": "Class ConfigParser Namespace BenchmarkDotNet.ConsoleArguments Assembly BenchmarkDotNet.dll public static class ConfigParser Inheritance object ConfigParser Methods Parse(string[], ILogger, IConfig?) public static (bool isSuccess, IConfig config, CommandLineOptions options) Parse(string[] args, ILogger logger, IConfig? globalConfig = null) Parameters args string[] logger ILogger globalConfig IConfig Returns (bool isSuccess, IConfig config, CommandLineOptions options)"
  },
  "api/BenchmarkDotNet.ConsoleArguments.CorrectionsSuggester.html": {
    "href": "api/BenchmarkDotNet.ConsoleArguments.CorrectionsSuggester.html",
    "title": "Class CorrectionsSuggester | BenchmarkDotNet",
    "summary": "Class CorrectionsSuggester Namespace BenchmarkDotNet.ConsoleArguments Assembly BenchmarkDotNet.dll public class CorrectionsSuggester Inheritance object CorrectionsSuggester Constructors CorrectionsSuggester(IReadOnlyList<Type>) public CorrectionsSuggester(IReadOnlyList<Type> types) Parameters types IReadOnlyList<Type> Methods GetAllBenchmarkNames() public string[] GetAllBenchmarkNames() Returns string[] SuggestFor(string) public string[] SuggestFor(string userInput) Parameters userInput string Returns string[]"
  },
  "api/BenchmarkDotNet.ConsoleArguments.html": {
    "href": "api/BenchmarkDotNet.ConsoleArguments.html",
    "title": "Namespace BenchmarkDotNet.ConsoleArguments | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.ConsoleArguments Classes CommandLineOptions ConfigParser CorrectionsSuggester"
  },
  "api/BenchmarkDotNet.ConsoleArguments.ListBenchmarks.html": {
    "href": "api/BenchmarkDotNet.ConsoleArguments.ListBenchmarks.html",
    "title": "Namespace BenchmarkDotNet.ConsoleArguments.ListBenchmarks | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.ConsoleArguments.ListBenchmarks Enums ListBenchmarkCaseMode"
  },
  "api/BenchmarkDotNet.ConsoleArguments.ListBenchmarks.ListBenchmarkCaseMode.html": {
    "href": "api/BenchmarkDotNet.ConsoleArguments.ListBenchmarks.ListBenchmarkCaseMode.html",
    "title": "Enum ListBenchmarkCaseMode | BenchmarkDotNet",
    "summary": "Enum ListBenchmarkCaseMode Namespace BenchmarkDotNet.ConsoleArguments.ListBenchmarks Assembly BenchmarkDotNet.dll public enum ListBenchmarkCaseMode Fields Disabled = 0 Do not print any of the available full benchmark names. Flat = 1 Prints flat list of the available benchmark names. Tree = 2 Prints tree of the available full benchmark names."
  },
  "api/BenchmarkDotNet.Detectors.Cpu.html": {
    "href": "api/BenchmarkDotNet.Detectors.Cpu.html",
    "title": "Namespace BenchmarkDotNet.Detectors.Cpu | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Detectors.Cpu Interfaces ICpuDetector Loads the Perfolizer.Models.CpuInfo for the current hardware"
  },
  "api/BenchmarkDotNet.Detectors.Cpu.ICpuDetector.html": {
    "href": "api/BenchmarkDotNet.Detectors.Cpu.ICpuDetector.html",
    "title": "Interface ICpuDetector | BenchmarkDotNet",
    "summary": "Interface ICpuDetector Namespace BenchmarkDotNet.Detectors.Cpu Assembly BenchmarkDotNet.dll Loads the Perfolizer.Models.CpuInfo for the current hardware public interface ICpuDetector Methods Detect() CpuInfo? Detect() Returns CpuInfo IsApplicable() bool IsApplicable() Returns bool"
  },
  "api/BenchmarkDotNet.Detectors.CpuDetector.html": {
    "href": "api/BenchmarkDotNet.Detectors.CpuDetector.html",
    "title": "Class CpuDetector | BenchmarkDotNet",
    "summary": "Class CpuDetector Namespace BenchmarkDotNet.Detectors Assembly BenchmarkDotNet.dll public class CpuDetector : ICpuDetector Inheritance object CpuDetector Implements ICpuDetector Constructors CpuDetector(params ICpuDetector[]) public CpuDetector(params ICpuDetector[] detectors) Parameters detectors ICpuDetector[] Properties Cpu public static CpuInfo? Cpu { get; } Property Value CpuInfo CrossPlatform public static CpuDetector CrossPlatform { get; } Property Value CpuDetector Methods Detect() public CpuInfo? Detect() Returns CpuInfo IsApplicable() public bool IsApplicable() Returns bool"
  },
  "api/BenchmarkDotNet.Detectors.html": {
    "href": "api/BenchmarkDotNet.Detectors.html",
    "title": "Namespace BenchmarkDotNet.Detectors | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Detectors Classes CpuDetector OsDetector"
  },
  "api/BenchmarkDotNet.Detectors.OsDetector.html": {
    "href": "api/BenchmarkDotNet.Detectors.OsDetector.html",
    "title": "Class OsDetector | BenchmarkDotNet",
    "summary": "Class OsDetector Namespace BenchmarkDotNet.Detectors Assembly BenchmarkDotNet.dll public class OsDetector Inheritance object OsDetector Fields Instance public static readonly OsDetector Instance Field Value OsDetector Methods GetOs() public static OsInfo GetOs() Returns OsInfo"
  },
  "api/BenchmarkDotNet.Diagnosers.CompositeDiagnoser.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.CompositeDiagnoser.html",
    "title": "Class CompositeDiagnoser | BenchmarkDotNet",
    "summary": "Class CompositeDiagnoser Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class CompositeDiagnoser : IDiagnoser Inheritance object CompositeDiagnoser Implements IDiagnoser Constructors CompositeDiagnoser(ImmutableHashSet<IDiagnoser>) public CompositeDiagnoser(ImmutableHashSet<IDiagnoser> diagnosers) Parameters diagnosers ImmutableHashSet<IDiagnoser> Properties Analysers public IEnumerable<IAnalyser> Analysers { get; } Property Value IEnumerable<IAnalyser> Exporters public IEnumerable<IExporter> Exporters { get; } Property Value IEnumerable<IExporter> Ids public IEnumerable<string> Ids { get; } Property Value IEnumerable<string> Methods DisplayResults(ILogger) public void DisplayResults(ILogger logger) Parameters logger ILogger GetRunMode(BenchmarkCase) public RunMode GetRunMode(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns RunMode Handle(HostSignal, DiagnoserActionParameters) public void Handle(HostSignal signal, DiagnoserActionParameters parameters) Parameters signal HostSignal parameters DiagnoserActionParameters ProcessResults(DiagnoserResults) public IEnumerable<Metric> ProcessResults(DiagnoserResults results) Parameters results DiagnoserResults Returns IEnumerable<Metric> Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Diagnosers.DiagnoserActionParameters.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.DiagnoserActionParameters.html",
    "title": "Class DiagnoserActionParameters | BenchmarkDotNet",
    "summary": "Class DiagnoserActionParameters Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class DiagnoserActionParameters Inheritance object DiagnoserActionParameters Constructors DiagnoserActionParameters(Process?, BenchmarkCase, BenchmarkId) public DiagnoserActionParameters(Process? process, BenchmarkCase benchmarkCase, BenchmarkId benchmarkId) Parameters process Process benchmarkCase BenchmarkCase benchmarkId BenchmarkId Properties BenchmarkCase public BenchmarkCase BenchmarkCase { get; } Property Value BenchmarkCase BenchmarkId public BenchmarkId BenchmarkId { get; } Property Value BenchmarkId Config public ImmutableConfig Config { get; } Property Value ImmutableConfig Process public Process Process { get; } Property Value Process"
  },
  "api/BenchmarkDotNet.Diagnosers.DiagnoserResults.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.DiagnoserResults.html",
    "title": "Class DiagnoserResults | BenchmarkDotNet",
    "summary": "Class DiagnoserResults Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class DiagnoserResults Inheritance object DiagnoserResults Constructors DiagnoserResults(BenchmarkCase, ExecuteResult, BuildResult) public DiagnoserResults(BenchmarkCase benchmarkCase, ExecuteResult executeResult, BuildResult buildResult) Parameters benchmarkCase BenchmarkCase executeResult ExecuteResult buildResult BuildResult Properties BenchmarkCase public BenchmarkCase BenchmarkCase { get; } Property Value BenchmarkCase BuildResult public BuildResult BuildResult { get; } Property Value BuildResult ExceptionFrequency public double ExceptionFrequency { get; } Property Value double GcStats public GcStats GcStats { get; } Property Value GcStats Measurements public IReadOnlyList<Measurement> Measurements { get; } Property Value IReadOnlyList<Measurement> ThreadingStats public ThreadingStats ThreadingStats { get; } Property Value ThreadingStats TotalOperations public long TotalOperations { get; } Property Value long"
  },
  "api/BenchmarkDotNet.Diagnosers.DisassemblyDiagnoser.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.DisassemblyDiagnoser.html",
    "title": "Class DisassemblyDiagnoser | BenchmarkDotNet",
    "summary": "Class DisassemblyDiagnoser Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class DisassemblyDiagnoser : IDiagnoser Inheritance object DisassemblyDiagnoser Implements IDiagnoser Constructors DisassemblyDiagnoser(DisassemblyDiagnoserConfig) public DisassemblyDiagnoser(DisassemblyDiagnoserConfig config) Parameters config DisassemblyDiagnoserConfig Properties Analysers public IEnumerable<IAnalyser> Analysers { get; } Property Value IEnumerable<IAnalyser> Config public DisassemblyDiagnoserConfig Config { get; } Property Value DisassemblyDiagnoserConfig Exporters public IEnumerable<IExporter> Exporters { get; } Property Value IEnumerable<IExporter> Ids public IEnumerable<string> Ids { get; } Property Value IEnumerable<string> Results public IReadOnlyDictionary<BenchmarkCase, DisassemblyResult> Results { get; } Property Value IReadOnlyDictionary<BenchmarkCase, DisassemblyResult> Methods DisplayResults(ILogger) public void DisplayResults(ILogger logger) Parameters logger ILogger GetRunMode(BenchmarkCase) public RunMode GetRunMode(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns RunMode Handle(HostSignal, DiagnoserActionParameters) public void Handle(HostSignal signal, DiagnoserActionParameters parameters) Parameters signal HostSignal parameters DiagnoserActionParameters ProcessResults(DiagnoserResults) public IEnumerable<Metric> ProcessResults(DiagnoserResults diagnoserResults) Parameters diagnoserResults DiagnoserResults Returns IEnumerable<Metric> Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Diagnosers.DisassemblyDiagnoserConfig.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.DisassemblyDiagnoserConfig.html",
    "title": "Class DisassemblyDiagnoserConfig | BenchmarkDotNet",
    "summary": "Class DisassemblyDiagnoserConfig Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class DisassemblyDiagnoserConfig Inheritance object DisassemblyDiagnoserConfig Constructors DisassemblyDiagnoserConfig(int, DisassemblySyntax, string[]?, FormatterOptions?, bool, bool, bool, bool, bool, bool) public DisassemblyDiagnoserConfig(int maxDepth = 1, DisassemblySyntax syntax = DisassemblySyntax.Masm, string[]? filters = null, FormatterOptions? formatterOptions = null, bool printSource = false, bool printInstructionAddresses = false, bool exportGithubMarkdown = true, bool exportHtml = false, bool exportCombinedDisassemblyReport = false, bool exportDiff = false) Parameters maxDepth int Includes called methods to given level. 1 by default, indexed from 1. To print just the benchmark set it to 0. syntax DisassemblySyntax The disassembly syntax. MASM is the default. filters string[] Glob patterns applied to full method signatures by the the disassembler. formatterOptions FormatterOptions Code formatter options. If not provided, the recommended settings will be used. printSource bool C#|F#|VB source code will be printed. False by default. printInstructionAddresses bool Print instruction addresses. False by default exportGithubMarkdown bool Exports to GitHub markdown. True by default. exportHtml bool Exports to HTML with clickable links. False by default. exportCombinedDisassemblyReport bool Exports all benchmarks to a single HTML report. Makes it easy to compare different runtimes or methods (each becomes a column in HTML table). exportDiff bool Exports a diff of the assembly code to the Github markdown format. False by default. Properties ExportCombinedDisassemblyReport public bool ExportCombinedDisassemblyReport { get; } Property Value bool ExportDiff public bool ExportDiff { get; } Property Value bool ExportGithubMarkdown public bool ExportGithubMarkdown { get; } Property Value bool ExportHtml public bool ExportHtml { get; } Property Value bool Filters public string[] Filters { get; } Property Value string[] Formatting public FormatterOptions Formatting { get; } Property Value FormatterOptions MaxDepth public int MaxDepth { get; } Property Value int PrintInstructionAddresses public bool PrintInstructionAddresses { get; } Property Value bool PrintSource public bool PrintSource { get; } Property Value bool Syntax public DisassemblySyntax Syntax { get; } Property Value DisassemblySyntax"
  },
  "api/BenchmarkDotNet.Diagnosers.DisassemblySyntax.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.DisassemblySyntax.html",
    "title": "Enum DisassemblySyntax | BenchmarkDotNet",
    "summary": "Enum DisassemblySyntax Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public enum DisassemblySyntax Fields Att = 2 Indicates a disassembler should use AT&T syntax for generated assembly code. Intel = 1 Indicates a disassembler should use Intel syntax for generated assembly code. Masm = 0 Indicates a disassembler should use MASM syntax for generated assembly code"
  },
  "api/BenchmarkDotNet.Diagnosers.EventPipeProfile.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.EventPipeProfile.html",
    "title": "Enum EventPipeProfile | BenchmarkDotNet",
    "summary": "Enum EventPipeProfile Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public enum EventPipeProfile Fields CpuSampling = 0 Useful for tracking CPU usage and general .NET runtime information. This is the default option if no profile or providers are specified. GcCollect = 2 Tracks GC collections only at very low overhead. GcVerbose = 1 Tracks GC collections and samples object allocations. Jit = 3 Logging when Just in time (JIT) compilation occurs. Logging of the internal workings of the Just In Time compiler. This is fairly verbose. It details decisions about interesting optimization (like inlining and tail call)"
  },
  "api/BenchmarkDotNet.Diagnosers.EventPipeProfiler.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.EventPipeProfiler.html",
    "title": "Class EventPipeProfiler | BenchmarkDotNet",
    "summary": "Class EventPipeProfiler Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class EventPipeProfiler : IDiagnoser Inheritance object EventPipeProfiler Implements IDiagnoser Constructors EventPipeProfiler() public EventPipeProfiler() EventPipeProfiler(EventPipeProfile, IReadOnlyCollection<EventPipeProvider>?, bool) Creates a new instance of EventPipeProfiler public EventPipeProfiler(EventPipeProfile profile = EventPipeProfile.CpuSampling, IReadOnlyCollection<EventPipeProvider>? providers = null, bool performExtraBenchmarksRun = true) Parameters profile EventPipeProfile A named pre-defined set of provider configurations that allows common tracing scenarios to be specified succinctly. providers IReadOnlyCollection<EventPipeProvider> A list of EventPipe providers to be enabled. performExtraBenchmarksRun bool if set to true, benchmarks will be executed one more time with the profiler attached. If set to false, there will be no extra run but the results will contain overhead. True by default. Fields Default public static readonly EventPipeProfiler Default Field Value EventPipeProfiler Properties Analysers public IEnumerable<IAnalyser> Analysers { get; } Property Value IEnumerable<IAnalyser> Exporters public IEnumerable<IExporter> Exporters { get; } Property Value IEnumerable<IExporter> Ids public IEnumerable<string> Ids { get; } Property Value IEnumerable<string> ShortName public string ShortName { get; } Property Value string Methods DisplayResults(ILogger) public void DisplayResults(ILogger resultLogger) Parameters resultLogger ILogger GetRunMode(BenchmarkCase) public RunMode GetRunMode(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns RunMode Handle(HostSignal, DiagnoserActionParameters) public void Handle(HostSignal signal, DiagnoserActionParameters parameters) Parameters signal HostSignal parameters DiagnoserActionParameters ProcessResults(DiagnoserResults) public IEnumerable<Metric> ProcessResults(DiagnoserResults results) Parameters results DiagnoserResults Returns IEnumerable<Metric> Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Diagnosers.ExceptionDiagnoser.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.ExceptionDiagnoser.html",
    "title": "Class ExceptionDiagnoser | BenchmarkDotNet",
    "summary": "Class ExceptionDiagnoser Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class ExceptionDiagnoser : IDiagnoser Inheritance object ExceptionDiagnoser Implements IDiagnoser Constructors ExceptionDiagnoser(ExceptionDiagnoserConfig) public ExceptionDiagnoser(ExceptionDiagnoserConfig config) Parameters config ExceptionDiagnoserConfig Fields Default public static readonly ExceptionDiagnoser Default Field Value ExceptionDiagnoser Properties Analysers public IEnumerable<IAnalyser> Analysers { get; } Property Value IEnumerable<IAnalyser> Config public ExceptionDiagnoserConfig Config { get; } Property Value ExceptionDiagnoserConfig Exporters public IEnumerable<IExporter> Exporters { get; } Property Value IEnumerable<IExporter> Ids public IEnumerable<string> Ids { get; } Property Value IEnumerable<string> Methods DisplayResults(ILogger) public void DisplayResults(ILogger logger) Parameters logger ILogger GetRunMode(BenchmarkCase) public RunMode GetRunMode(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns RunMode Handle(HostSignal, DiagnoserActionParameters) public void Handle(HostSignal signal, DiagnoserActionParameters parameters) Parameters signal HostSignal parameters DiagnoserActionParameters ProcessResults(DiagnoserResults) public IEnumerable<Metric> ProcessResults(DiagnoserResults results) Parameters results DiagnoserResults Returns IEnumerable<Metric> Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Diagnosers.HardwareCounter.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.HardwareCounter.html",
    "title": "Enum HardwareCounter | BenchmarkDotNet",
    "summary": "Enum HardwareCounter Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public enum HardwareCounter Extension Methods HardwareCounterExtensions.TheGreaterTheBetter(HardwareCounter) HardwareCounterExtensions.ToShortName(HardwareCounter) Fields BranchInstructionRetired = 12 BranchInstructions = 3 BranchMispredictions = 5 BranchMispredictsRetired = 13 CacheMisses = 4 InstructionRetired = 8 LlcMisses = 11 LlcReference = 10 NotSet = 0 Timer = 1 TotalCycles = 6 TotalIssues = 2 UnhaltedCoreCycles = 7 UnhaltedReferenceCycles = 9"
  },
  "api/BenchmarkDotNet.Diagnosers.HardwareCounterExtensions.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.HardwareCounterExtensions.html",
    "title": "Class HardwareCounterExtensions | BenchmarkDotNet",
    "summary": "Class HardwareCounterExtensions Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public static class HardwareCounterExtensions Inheritance object HardwareCounterExtensions Methods TheGreaterTheBetter(HardwareCounter) public static bool TheGreaterTheBetter(this HardwareCounter hardwareCounter) Parameters hardwareCounter HardwareCounter Returns bool ToShortName(HardwareCounter) public static string ToShortName(this HardwareCounter hardwareCounter) Parameters hardwareCounter HardwareCounter Returns string"
  },
  "api/BenchmarkDotNet.Diagnosers.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.html",
    "title": "Namespace BenchmarkDotNet.Diagnosers | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Diagnosers Classes CompositeDiagnoser DiagnoserActionParameters DiagnoserResults DisassemblyDiagnoser DisassemblyDiagnoserConfig EventPipeProfiler ExceptionDiagnoser HardwareCounterExtensions MemoryDiagnoser MemoryDiagnoserConfig PerfCollectProfiler PerfCollectProfilerConfig PmcStats PreciseMachineCounter SnapshotProfilerBase SnapshotProfilerBase.Progress ThreadingDiagnoser ThreadingDiagnoserConfig UnresolvedDiagnoser Interfaces IConfigurableDiagnoser<TConfig> IDiagnoser Enums DisassemblySyntax EventPipeProfile HardwareCounter RunMode"
  },
  "api/BenchmarkDotNet.Diagnosers.IConfigurableDiagnoser-1.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.IConfigurableDiagnoser-1.html",
    "title": "Interface IConfigurableDiagnoser<TConfig> | BenchmarkDotNet",
    "summary": "Interface IConfigurableDiagnoser<TConfig> Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public interface IConfigurableDiagnoser<in TConfig> : IDiagnoser Type Parameters TConfig Inherited Members IDiagnoser.GetRunMode(BenchmarkCase) IDiagnoser.Handle(HostSignal, DiagnoserActionParameters) IDiagnoser.ProcessResults(DiagnoserResults) IDiagnoser.DisplayResults(ILogger) IDiagnoser.Validate(ValidationParameters) IDiagnoser.Ids IDiagnoser.Exporters IDiagnoser.Analysers Methods Configure(TConfig) IConfigurableDiagnoser<in TConfig> Configure(TConfig config) Parameters config TConfig Returns IConfigurableDiagnoser<TConfig>"
  },
  "api/BenchmarkDotNet.Diagnosers.IDiagnoser.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.IDiagnoser.html",
    "title": "Interface IDiagnoser | BenchmarkDotNet",
    "summary": "Interface IDiagnoser Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public interface IDiagnoser Properties Analysers IEnumerable<IAnalyser> Analysers { get; } Property Value IEnumerable<IAnalyser> Exporters IEnumerable<IExporter> Exporters { get; } Property Value IEnumerable<IExporter> Ids IEnumerable<string> Ids { get; } Property Value IEnumerable<string> Methods DisplayResults(ILogger) void DisplayResults(ILogger logger) Parameters logger ILogger GetRunMode(BenchmarkCase) RunMode GetRunMode(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns RunMode Handle(HostSignal, DiagnoserActionParameters) void Handle(HostSignal signal, DiagnoserActionParameters parameters) Parameters signal HostSignal parameters DiagnoserActionParameters ProcessResults(DiagnoserResults) IEnumerable<Metric> ProcessResults(DiagnoserResults results) Parameters results DiagnoserResults Returns IEnumerable<Metric> Validate(ValidationParameters) IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Diagnosers.MemoryDiagnoser.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.MemoryDiagnoser.html",
    "title": "Class MemoryDiagnoser | BenchmarkDotNet",
    "summary": "Class MemoryDiagnoser Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class MemoryDiagnoser : IDiagnoser Inheritance object MemoryDiagnoser Implements IDiagnoser Constructors MemoryDiagnoser(MemoryDiagnoserConfig) public MemoryDiagnoser(MemoryDiagnoserConfig config) Parameters config MemoryDiagnoserConfig Fields Default public static readonly MemoryDiagnoser Default Field Value MemoryDiagnoser Properties Analysers public IEnumerable<IAnalyser> Analysers { get; } Property Value IEnumerable<IAnalyser> Config public MemoryDiagnoserConfig Config { get; } Property Value MemoryDiagnoserConfig Exporters public IEnumerable<IExporter> Exporters { get; } Property Value IEnumerable<IExporter> Ids public IEnumerable<string> Ids { get; } Property Value IEnumerable<string> Methods DisplayResults(ILogger) public void DisplayResults(ILogger logger) Parameters logger ILogger GetRunMode(BenchmarkCase) public RunMode GetRunMode(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns RunMode Handle(HostSignal, DiagnoserActionParameters) public void Handle(HostSignal signal, DiagnoserActionParameters parameters) Parameters signal HostSignal parameters DiagnoserActionParameters ProcessResults(DiagnoserResults) public IEnumerable<Metric> ProcessResults(DiagnoserResults diagnoserResults) Parameters diagnoserResults DiagnoserResults Returns IEnumerable<Metric> Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Diagnosers.MemoryDiagnoserConfig.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.MemoryDiagnoserConfig.html",
    "title": "Class MemoryDiagnoserConfig | BenchmarkDotNet",
    "summary": "Class MemoryDiagnoserConfig Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class MemoryDiagnoserConfig Inheritance object MemoryDiagnoserConfig Constructors MemoryDiagnoserConfig(bool) public MemoryDiagnoserConfig(bool displayGenColumns = true) Parameters displayGenColumns bool Display Garbage Collections per Generation columns (Gen 0, Gen 1, Gen 2). True by default. Properties DisplayGenColumns public bool DisplayGenColumns { get; } Property Value bool"
  },
  "api/BenchmarkDotNet.Diagnosers.PerfCollectProfiler.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.PerfCollectProfiler.html",
    "title": "Class PerfCollectProfiler | BenchmarkDotNet",
    "summary": "Class PerfCollectProfiler Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class PerfCollectProfiler : IDiagnoser Inheritance object PerfCollectProfiler Implements IDiagnoser Constructors PerfCollectProfiler(PerfCollectProfilerConfig) public PerfCollectProfiler(PerfCollectProfilerConfig config) Parameters config PerfCollectProfilerConfig Fields Default public static readonly IDiagnoser Default Field Value IDiagnoser Properties Analysers public IEnumerable<IAnalyser> Analysers { get; } Property Value IEnumerable<IAnalyser> Exporters public IEnumerable<IExporter> Exporters { get; } Property Value IEnumerable<IExporter> Ids public IEnumerable<string> Ids { get; } Property Value IEnumerable<string> ShortName public string ShortName { get; } Property Value string Methods DisplayResults(ILogger) public void DisplayResults(ILogger logger) Parameters logger ILogger GetRunMode(BenchmarkCase) public RunMode GetRunMode(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns RunMode Handle(HostSignal, DiagnoserActionParameters) public void Handle(HostSignal signal, DiagnoserActionParameters parameters) Parameters signal HostSignal parameters DiagnoserActionParameters ProcessResults(DiagnoserResults) public IEnumerable<Metric> ProcessResults(DiagnoserResults results) Parameters results DiagnoserResults Returns IEnumerable<Metric> Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Diagnosers.PerfCollectProfilerConfig.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.PerfCollectProfilerConfig.html",
    "title": "Class PerfCollectProfilerConfig | BenchmarkDotNet",
    "summary": "Class PerfCollectProfilerConfig Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class PerfCollectProfilerConfig Inheritance object PerfCollectProfilerConfig Constructors PerfCollectProfilerConfig(bool, int) public PerfCollectProfilerConfig(bool performExtraBenchmarksRun = false, int timeoutInSeconds = 300) Parameters performExtraBenchmarksRun bool When set to true, benchmarks will be executed one more time with the profiler attached. If set to false, there will be no extra run but the results will contain overhead. False by default. timeoutInSeconds int How long should we wait for the perfcollect script to finish processing the trace. 300s by default. Properties RunMode public RunMode RunMode { get; } Property Value RunMode Timeout public TimeSpan Timeout { get; } Property Value TimeSpan"
  },
  "api/BenchmarkDotNet.Diagnosers.PmcStats.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.PmcStats.html",
    "title": "Class PmcStats | BenchmarkDotNet",
    "summary": "Class PmcStats Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class PmcStats Inheritance object PmcStats Constructors PmcStats() public PmcStats() PmcStats(IReadOnlyCollection<HardwareCounter>, Func<HardwareCounter, PreciseMachineCounter>) public PmcStats(IReadOnlyCollection<HardwareCounter> hardwareCounters, Func<HardwareCounter, PreciseMachineCounter> factory) Parameters hardwareCounters IReadOnlyCollection<HardwareCounter> factory Func<HardwareCounter, PreciseMachineCounter> Properties Counters public IReadOnlyDictionary<HardwareCounter, PreciseMachineCounter> Counters { get; } Property Value IReadOnlyDictionary<HardwareCounter, PreciseMachineCounter> TotalOperations public long TotalOperations { get; set; } Property Value long"
  },
  "api/BenchmarkDotNet.Diagnosers.PreciseMachineCounter.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.PreciseMachineCounter.html",
    "title": "Class PreciseMachineCounter | BenchmarkDotNet",
    "summary": "Class PreciseMachineCounter Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class PreciseMachineCounter Inheritance object PreciseMachineCounter Properties Count public ulong Count { get; } Property Value ulong Counter public HardwareCounter Counter { get; } Property Value HardwareCounter Interval public int Interval { get; } Property Value int Name public string Name { get; } Property Value string PerInstructionPointer public Dictionary<ulong, ulong> PerInstructionPointer { get; } Property Value Dictionary<ulong, ulong> ProfileSourceId public int ProfileSourceId { get; } Property Value int Methods OnSample(ulong) public void OnSample(ulong instructionPointer) Parameters instructionPointer ulong"
  },
  "api/BenchmarkDotNet.Diagnosers.RunMode.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.RunMode.html",
    "title": "Enum RunMode | BenchmarkDotNet",
    "summary": "Enum RunMode Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public enum RunMode : byte Fields ExtraRun = 1 needs extra run of the benchmark NoOverhead = 2 no overhead, can be executed without extra run None = 0 given diagnoser should not be executed for given benchmark SeparateLogic = 3 implements some separate logic, that can be executed at any time"
  },
  "api/BenchmarkDotNet.Diagnosers.SnapshotProfilerBase.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.SnapshotProfilerBase.html",
    "title": "Class SnapshotProfilerBase | BenchmarkDotNet",
    "summary": "Class SnapshotProfilerBase Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public abstract class SnapshotProfilerBase : IDiagnoser Inheritance object SnapshotProfilerBase Implements IDiagnoser Constructors SnapshotProfilerBase() protected SnapshotProfilerBase() Properties Analysers public IEnumerable<IAnalyser> Analysers { get; } Property Value IEnumerable<IAnalyser> Exporters public IEnumerable<IExporter> Exporters { get; } Property Value IEnumerable<IExporter> Ids public IEnumerable<string> Ids { get; } Property Value IEnumerable<string> ShortName public abstract string ShortName { get; } Property Value string Methods AttachToCurrentProcess(string) protected abstract void AttachToCurrentProcess(string snapshotFile) Parameters snapshotFile string AttachToProcessByPid(int, string) protected abstract void AttachToProcessByPid(int pid, string snapshotFile) Parameters pid int snapshotFile string CreateSnapshotFilePath(DiagnoserActionParameters) protected abstract string CreateSnapshotFilePath(DiagnoserActionParameters parameters) Parameters parameters DiagnoserActionParameters Returns string Detach() protected abstract void Detach() DisplayResults(ILogger) public void DisplayResults(ILogger logger) Parameters logger ILogger GetRunMode(BenchmarkCase) public RunMode GetRunMode(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns RunMode GetRunnerPath() protected abstract string GetRunnerPath() Returns string Handle(HostSignal, DiagnoserActionParameters) public void Handle(HostSignal signal, DiagnoserActionParameters parameters) Parameters signal HostSignal parameters DiagnoserActionParameters InitTool(Progress) protected abstract void InitTool(SnapshotProfilerBase.Progress progress) Parameters progress SnapshotProfilerBase.Progress ProcessResults(DiagnoserResults) public IEnumerable<Metric> ProcessResults(DiagnoserResults results) Parameters results DiagnoserResults Returns IEnumerable<Metric> TakeSnapshot() protected abstract void TakeSnapshot() Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Diagnosers.SnapshotProfilerBase.Progress.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.SnapshotProfilerBase.Progress.html",
    "title": "Class SnapshotProfilerBase.Progress | BenchmarkDotNet",
    "summary": "Class SnapshotProfilerBase.Progress Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll protected class SnapshotProfilerBase.Progress : IProgress<double> Inheritance object SnapshotProfilerBase.Progress Implements IProgress<double> Constructors Progress(ILogger, string) public Progress(ILogger logger, string title) Parameters logger ILogger title string Methods Report(double) public void Report(double value) Parameters value double"
  },
  "api/BenchmarkDotNet.Diagnosers.ThreadingDiagnoser.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.ThreadingDiagnoser.html",
    "title": "Class ThreadingDiagnoser | BenchmarkDotNet",
    "summary": "Class ThreadingDiagnoser Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class ThreadingDiagnoser : IDiagnoser Inheritance object ThreadingDiagnoser Implements IDiagnoser Constructors ThreadingDiagnoser(ThreadingDiagnoserConfig) public ThreadingDiagnoser(ThreadingDiagnoserConfig config) Parameters config ThreadingDiagnoserConfig Fields Default public static readonly ThreadingDiagnoser Default Field Value ThreadingDiagnoser Properties Analysers public IEnumerable<IAnalyser> Analysers { get; } Property Value IEnumerable<IAnalyser> Config public ThreadingDiagnoserConfig Config { get; } Property Value ThreadingDiagnoserConfig Exporters public IEnumerable<IExporter> Exporters { get; } Property Value IEnumerable<IExporter> Ids public IEnumerable<string> Ids { get; } Property Value IEnumerable<string> Methods DisplayResults(ILogger) public void DisplayResults(ILogger logger) Parameters logger ILogger GetRunMode(BenchmarkCase) public RunMode GetRunMode(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns RunMode Handle(HostSignal, DiagnoserActionParameters) public void Handle(HostSignal signal, DiagnoserActionParameters parameters) Parameters signal HostSignal parameters DiagnoserActionParameters ProcessResults(DiagnoserResults) public IEnumerable<Metric> ProcessResults(DiagnoserResults results) Parameters results DiagnoserResults Returns IEnumerable<Metric> Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Diagnosers.ThreadingDiagnoserConfig.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.ThreadingDiagnoserConfig.html",
    "title": "Class ThreadingDiagnoserConfig | BenchmarkDotNet",
    "summary": "Class ThreadingDiagnoserConfig Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class ThreadingDiagnoserConfig Inheritance object ThreadingDiagnoserConfig Constructors ThreadingDiagnoserConfig(bool, bool) public ThreadingDiagnoserConfig(bool displayLockContentionWhenZero = true, bool displayCompletedWorkItemCountWhenZero = true) Parameters displayLockContentionWhenZero bool Display configuration for 'LockContentionCount' when it is empty. True (displayed) by default. displayCompletedWorkItemCountWhenZero bool Display configuration for 'CompletedWorkItemCount' when it is empty. True (displayed) by default. Properties DisplayCompletedWorkItemCountWhenZero public bool DisplayCompletedWorkItemCountWhenZero { get; } Property Value bool DisplayLockContentionWhenZero public bool DisplayLockContentionWhenZero { get; } Property Value bool"
  },
  "api/BenchmarkDotNet.Diagnosers.UnresolvedDiagnoser.html": {
    "href": "api/BenchmarkDotNet.Diagnosers.UnresolvedDiagnoser.html",
    "title": "Class UnresolvedDiagnoser | BenchmarkDotNet",
    "summary": "Class UnresolvedDiagnoser Namespace BenchmarkDotNet.Diagnosers Assembly BenchmarkDotNet.dll public class UnresolvedDiagnoser : IDiagnoser Inheritance object UnresolvedDiagnoser Implements IDiagnoser Constructors UnresolvedDiagnoser(Type) public UnresolvedDiagnoser(Type unresolved) Parameters unresolved Type Properties Analysers public IEnumerable<IAnalyser> Analysers { get; } Property Value IEnumerable<IAnalyser> Exporters public IEnumerable<IExporter> Exporters { get; } Property Value IEnumerable<IExporter> Ids public IEnumerable<string> Ids { get; } Property Value IEnumerable<string> Methods DisplayResults(ILogger) public void DisplayResults(ILogger logger) Parameters logger ILogger GetRunMode(BenchmarkCase) public RunMode GetRunMode(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns RunMode Handle(HostSignal, DiagnoserActionParameters) public void Handle(HostSignal signal, DiagnoserActionParameters parameters) Parameters signal HostSignal parameters DiagnoserActionParameters ProcessResults(DiagnoserResults) public IEnumerable<Metric> ProcessResults(DiagnoserResults _) Parameters _ DiagnoserResults Returns IEnumerable<Metric> Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Disassemblers.Arm64Asm.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.Arm64Asm.html",
    "title": "Class Arm64Asm | BenchmarkDotNet",
    "summary": "Class Arm64Asm Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public class Arm64Asm : Asm Inheritance object SourceCode Asm Arm64Asm Inherited Members Asm.InstructionLength Asm.ReferencedAddress Asm.IsReferencedAddressIndirect SourceCode.InstructionPointer Constructors Arm64Asm() public Arm64Asm() Properties Instruction public Arm64Instruction Instruction { get; set; } Property Value Arm64Instruction Methods ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Disassemblers.Asm.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.Asm.html",
    "title": "Class Asm | BenchmarkDotNet",
    "summary": "Class Asm Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public abstract class Asm : SourceCode Inheritance object SourceCode Asm Derived Arm64Asm IntelAsm Inherited Members SourceCode.InstructionPointer Constructors Asm() protected Asm() Properties InstructionLength public int InstructionLength { get; set; } Property Value int IsReferencedAddressIndirect public bool IsReferencedAddressIndirect { get; set; } Property Value bool ReferencedAddress public ulong? ReferencedAddress { get; set; } Property Value ulong?"
  },
  "api/BenchmarkDotNet.Disassemblers.DisassembledMethod.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.DisassembledMethod.html",
    "title": "Class DisassembledMethod | BenchmarkDotNet",
    "summary": "Class DisassembledMethod Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public class DisassembledMethod Inheritance object DisassembledMethod Constructors DisassembledMethod() public DisassembledMethod() Properties CommandLine public string CommandLine { get; set; } Property Value string Maps public Map[] Maps { get; set; } Property Value Map[] Name public string Name { get; set; } Property Value string NativeCode public ulong NativeCode { get; set; } Property Value ulong Problem public string Problem { get; set; } Property Value string Methods Empty(string, ulong, string) public static DisassembledMethod Empty(string fullSignature, ulong nativeCode, string problem) Parameters fullSignature string nativeCode ulong problem string Returns DisassembledMethod"
  },
  "api/BenchmarkDotNet.Disassemblers.DisassemblerConstants.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.DisassemblerConstants.html",
    "title": "Class DisassemblerConstants | BenchmarkDotNet",
    "summary": "Class DisassemblerConstants Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public static class DisassemblerConstants Inheritance object DisassemblerConstants Fields DisassemblerEntryMethodName public const string DisassemblerEntryMethodName = \"__ForDisassemblyDiagnoser__\" Field Value string"
  },
  "api/BenchmarkDotNet.Disassemblers.DisassemblyResult.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.DisassemblyResult.html",
    "title": "Class DisassemblyResult | BenchmarkDotNet",
    "summary": "Class DisassemblyResult Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public class DisassemblyResult Inheritance object DisassemblyResult Constructors DisassemblyResult() public DisassemblyResult() Properties AddressToNameMapping public Dictionary<ulong, string> AddressToNameMapping { get; } Property Value Dictionary<ulong, string> Errors public string[] Errors { get; set; } Property Value string[] Methods public DisassembledMethod[] Methods { get; set; } Property Value DisassembledMethod[] PointerSize public uint PointerSize { get; set; } Property Value uint SerializedAddressToNameMapping public DisassemblyResult.MutablePair[] SerializedAddressToNameMapping { get; set; } Property Value MutablePair[]"
  },
  "api/BenchmarkDotNet.Disassemblers.DisassemblyResult.MutablePair.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.DisassemblyResult.MutablePair.html",
    "title": "Struct DisassemblyResult.MutablePair | BenchmarkDotNet",
    "summary": "Struct DisassemblyResult.MutablePair Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public struct DisassemblyResult.MutablePair Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() Properties Key public ulong Key { readonly get; set; } Property Value ulong Value public string Value { readonly get; set; } Property Value string"
  },
  "api/BenchmarkDotNet.Disassemblers.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.html",
    "title": "Namespace BenchmarkDotNet.Disassemblers | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Disassemblers Classes Arm64Asm Asm DisassembledMethod DisassemblerConstants DisassemblyResult IntelAsm Map MonoCode Sharp SourceCode WindowsDisassembler Structs DisassemblyResult.MutablePair"
  },
  "api/BenchmarkDotNet.Disassemblers.IntelAsm.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.IntelAsm.html",
    "title": "Class IntelAsm | BenchmarkDotNet",
    "summary": "Class IntelAsm Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public class IntelAsm : Asm Inheritance object SourceCode Asm IntelAsm Inherited Members Asm.InstructionLength Asm.ReferencedAddress Asm.IsReferencedAddressIndirect SourceCode.InstructionPointer Constructors IntelAsm() public IntelAsm() Properties Instruction public Instruction Instruction { get; set; } Property Value Instruction Methods ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Disassemblers.Map.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.Map.html",
    "title": "Class Map | BenchmarkDotNet",
    "summary": "Class Map Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public class Map Inheritance object Map Constructors Map() public Map() Properties SourceCodes public SourceCode[] SourceCodes { get; set; } Property Value SourceCode[]"
  },
  "api/BenchmarkDotNet.Disassemblers.MonoCode.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.MonoCode.html",
    "title": "Class MonoCode | BenchmarkDotNet",
    "summary": "Class MonoCode Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public class MonoCode : SourceCode Inheritance object SourceCode MonoCode Inherited Members SourceCode.InstructionPointer Constructors MonoCode() public MonoCode() Properties Text public string Text { get; set; } Property Value string"
  },
  "api/BenchmarkDotNet.Disassemblers.Sharp.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.Sharp.html",
    "title": "Class Sharp | BenchmarkDotNet",
    "summary": "Class Sharp Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public class Sharp : SourceCode Inheritance object SourceCode Sharp Inherited Members SourceCode.InstructionPointer Constructors Sharp() public Sharp() Properties FilePath public string FilePath { get; set; } Property Value string LineNumber public int LineNumber { get; set; } Property Value int Text public string Text { get; set; } Property Value string"
  },
  "api/BenchmarkDotNet.Disassemblers.SourceCode.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.SourceCode.html",
    "title": "Class SourceCode | BenchmarkDotNet",
    "summary": "Class SourceCode Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public abstract class SourceCode Inheritance object SourceCode Derived Asm MonoCode Sharp Constructors SourceCode() protected SourceCode() Properties InstructionPointer public ulong InstructionPointer { get; set; } Property Value ulong"
  },
  "api/BenchmarkDotNet.Disassemblers.WindowsDisassembler.html": {
    "href": "api/BenchmarkDotNet.Disassemblers.WindowsDisassembler.html",
    "title": "Class WindowsDisassembler | BenchmarkDotNet",
    "summary": "Class WindowsDisassembler Namespace BenchmarkDotNet.Disassemblers Assembly BenchmarkDotNet.dll public class WindowsDisassembler Inheritance object WindowsDisassembler Constructors WindowsDisassembler(DisassemblyDiagnoserConfig) public WindowsDisassembler(DisassemblyDiagnoserConfig config) Parameters config DisassemblyDiagnoserConfig Methods Disassemble(DiagnoserActionParameters) public DisassemblyResult Disassemble(DiagnoserActionParameters parameters) Parameters parameters DiagnoserActionParameters Returns DisassemblyResult"
  },
  "api/BenchmarkDotNet.Engines.AnonymousPipesHost.html": {
    "href": "api/BenchmarkDotNet.Engines.AnonymousPipesHost.html",
    "title": "Class AnonymousPipesHost | BenchmarkDotNet",
    "summary": "Class AnonymousPipesHost Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public class AnonymousPipesHost : IHost, IDisposable Inheritance object AnonymousPipesHost Implements IHost IDisposable Extension Methods HostExtensions.AfterAll(IHost) HostExtensions.AfterMainRun(IHost) HostExtensions.BeforeAnythingElse(IHost) HostExtensions.BeforeMainRun(IHost) HostExtensions.WriteLine(IHost, string, params object[]) Constructors AnonymousPipesHost(string, string) public AnonymousPipesHost(string writHandle, string readHandle) Parameters writHandle string readHandle string Methods Dispose() public void Dispose() ReportResults(RunResults) public void ReportResults(RunResults runResults) Parameters runResults RunResults SendError(string) public void SendError(string message) Parameters message string SendSignal(HostSignal) public void SendSignal(HostSignal hostSignal) Parameters hostSignal HostSignal TryGetFileHandles(string[], out string?, out string?) public static bool TryGetFileHandles(string[] args, out string? writeHandle, out string? readHandle) Parameters args string[] writeHandle string readHandle string Returns bool Write(string) public void Write(string message) Parameters message string WriteLine() public void WriteLine() WriteLine(string) public void WriteLine(string message) Parameters message string"
  },
  "api/BenchmarkDotNet.Engines.Consumer.html": {
    "href": "api/BenchmarkDotNet.Engines.Consumer.html",
    "title": "Class Consumer | BenchmarkDotNet",
    "summary": "Class Consumer Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public class Consumer Inheritance object Consumer Constructors Consumer() public Consumer() Methods Consume(bool) public void Consume(bool boolValue) Parameters boolValue bool Consume(byte) public void Consume(byte byteValue) Parameters byteValue byte Consume(char) public void Consume(char charValue) Parameters charValue char Consume(double) public void Consume(double doubleValue) Parameters doubleValue double Consume(short) public void Consume(short shortValue) Parameters shortValue short Consume(int) public void Consume(int intValue) Parameters intValue int Consume(long) public void Consume(long longValue) Parameters longValue long Consume(nint) public void Consume(nint intPtrValue) Parameters intPtrValue nint Consume(object) public void Consume(object objectValue) Parameters objectValue object Consume(sbyte) [CLSCompliant(false)] public void Consume(sbyte sbyteValue) Parameters sbyteValue sbyte Consume(float) public void Consume(float floatValue) Parameters floatValue float Consume(string) public void Consume(string stringValue) Parameters stringValue string Consume(ushort) [CLSCompliant(false)] public void Consume(ushort ushortValue) Parameters ushortValue ushort Consume(uint) [CLSCompliant(false)] public void Consume(uint uintValue) Parameters uintValue uint Consume(ulong) [CLSCompliant(false)] public void Consume(ulong ulongValue) Parameters ulongValue ulong Consume(nuint) public void Consume(nuint uintPtrValue) Parameters uintPtrValue nuint Consume(void*) public void Consume(void* ptrValue) Parameters ptrValue void* Consume<T>(T) public void Consume<T>(T objectValue) where T : class Parameters objectValue T Type Parameters T Consume<T>(T*) public void Consume<T>(T* ptrValue) where T : unmanaged Parameters ptrValue T* Type Parameters T Consume<T>(in T) public void Consume<T>(in T value) Parameters value T Type Parameters T"
  },
  "api/BenchmarkDotNet.Engines.ConsumerExtensions.html": {
    "href": "api/BenchmarkDotNet.Engines.ConsumerExtensions.html",
    "title": "Class ConsumerExtensions | BenchmarkDotNet",
    "summary": "Class ConsumerExtensions Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public static class ConsumerExtensions Inheritance object ConsumerExtensions Methods Consume(IEnumerable, Consumer) executes and consumes given IEnumerable By using non-generic IEnumerable you pay for boxing. Use generic IEnumerable<T> if you can. public static void Consume(this IEnumerable enumerable, Consumer consumer) Parameters enumerable IEnumerable non-generic IEnumerable consumer Consumer instance of Consumer. Create it on your own once, store it in the field and just pass here Consume(IQueryable, Consumer) executes and consumes given IQueryable By using non-generic IQueryable you pay for boxing. Use generic IQueryable<T> if you can. public static void Consume(this IQueryable queryable, Consumer consumer) Parameters queryable IQueryable non-generic IQueryable consumer Consumer instance of Consumer. Create it on your own once, store it in the field and just pass here Consume<T>(IEnumerable<T>, Consumer) executes and consumes given IEnumerable<T> public static void Consume<T>(this IEnumerable<T> enumerable, Consumer consumer) Parameters enumerable IEnumerable<T> generic IEnumerable<T> consumer Consumer instance of Consumer. Create it on your own once, store it in the field and just pass here Type Parameters T Consume<T>(IQueryable<T>, Consumer) executes and consumes given IQueryable<T> public static void Consume<T>(this IQueryable<T> queryable, Consumer consumer) Parameters queryable IQueryable<T> generic IQueryable<T> consumer Consumer instance of Consumer. Create it on your own once, store it in the field and just pass here Type Parameters T"
  },
  "api/BenchmarkDotNet.Engines.DeadCodeEliminationHelper.html": {
    "href": "api/BenchmarkDotNet.Engines.DeadCodeEliminationHelper.html",
    "title": "Class DeadCodeEliminationHelper | BenchmarkDotNet",
    "summary": "Class DeadCodeEliminationHelper Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public static class DeadCodeEliminationHelper Inheritance object DeadCodeEliminationHelper Methods KeepAliveWithoutBoxingReadonly<T>(in T) This method can't get inlined, so any value send to it will not get eliminated by the dead code elimination it's not called KeepAliveWithoutBoxing because compiler would not be able to diff ref and in public static void KeepAliveWithoutBoxingReadonly<T>(in T value) Parameters value T Type Parameters T KeepAliveWithoutBoxing<T>(T) This method can't get inlined, so any value send to it will not get eliminated by the dead code elimination public static void KeepAliveWithoutBoxing<T>(T value) Parameters value T Type Parameters T KeepAliveWithoutBoxing<T>(ref T) This method can't get inlined, so any value send to it will not get eliminated by the dead code elimination public static void KeepAliveWithoutBoxing<T>(ref T value) Parameters value T Type Parameters T"
  },
  "api/BenchmarkDotNet.Engines.Engine.html": {
    "href": "api/BenchmarkDotNet.Engines.Engine.html",
    "title": "Class Engine | BenchmarkDotNet",
    "summary": "Class Engine Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public class Engine : IEngine, IDisposable Inheritance object Engine Implements IEngine IDisposable Properties BenchmarkName public string BenchmarkName { get; } Property Value string CultureInfo public CultureInfo CultureInfo { get; } Property Value CultureInfo Dummy1Action public Action Dummy1Action { get; } Property Value Action Dummy2Action public Action Dummy2Action { get; } Property Value Action Dummy3Action public Action Dummy3Action { get; } Property Value Action GlobalCleanupAction public Action GlobalCleanupAction { get; } Property Value Action GlobalSetupAction public Action GlobalSetupAction { get; } Property Value Action Host public IHost Host { get; } Property Value IHost IterationCleanupAction public Action IterationCleanupAction { get; } Property Value Action IterationSetupAction public Action IterationSetupAction { get; } Property Value Action OperationsPerInvoke public long OperationsPerInvoke { get; } Property Value long OverheadAction public Action<long> OverheadAction { get; } Property Value Action<long> Resolver public IResolver Resolver { get; } Property Value IResolver TargetJob public Job TargetJob { get; } Property Value Job WorkloadAction public Action<long> WorkloadAction { get; } Property Value Action<long> Methods Dispose() public void Dispose() Run() public RunResults Run() Returns RunResults RunIteration(IterationData) public Measurement RunIteration(IterationData data) Parameters data IterationData Returns Measurement WriteLine() public void WriteLine() WriteLine(string) public void WriteLine(string text) Parameters text string"
  },
  "api/BenchmarkDotNet.Engines.Engine.Signals.html": {
    "href": "api/BenchmarkDotNet.Engines.Engine.Signals.html",
    "title": "Class Engine.Signals | BenchmarkDotNet",
    "summary": "Class Engine.Signals Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public static class Engine.Signals Inheritance object Engine.Signals Fields Acknowledgment public const string Acknowledgment = \"Acknowledgment\" Field Value string Methods ToMessage(HostSignal) public static string ToMessage(HostSignal signal) Parameters signal HostSignal Returns string TryGetSignal(string, out HostSignal) public static bool TryGetSignal(string message, out HostSignal signal) Parameters message string signal HostSignal Returns bool"
  },
  "api/BenchmarkDotNet.Engines.EngineEventSource.html": {
    "href": "api/BenchmarkDotNet.Engines.EngineEventSource.html",
    "title": "Class EngineEventSource | BenchmarkDotNet",
    "summary": "Class EngineEventSource Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll [EventSource(Name = \"BenchmarkDotNet.EngineEventSource\")] public class EngineEventSource : EventSource, IDisposable Inheritance object EventSource EngineEventSource Implements IDisposable Inherited Members EventSource.IsEnabled() EventSource.IsEnabled(EventLevel, EventKeywords) EventSource.IsEnabled(EventLevel, EventKeywords, EventChannel) EventSource.GetGuid(Type) EventSource.GetName(Type) EventSource.GenerateManifest(Type, string) EventSource.GenerateManifest(Type, string, EventManifestOptions) EventSource.GetSources() EventSource.SendCommand(EventSource, EventCommand, IDictionary<string, string>) EventSource.GetTrait(string) EventSource.ToString() EventSource.SetCurrentThreadActivityId(Guid) EventSource.SetCurrentThreadActivityId(Guid, out Guid) EventSource.OnEventCommand(EventCommandEventArgs) EventSource.WriteEvent(int) EventSource.WriteEvent(int, int) EventSource.WriteEvent(int, int, int) EventSource.WriteEvent(int, int, int, int) EventSource.WriteEvent(int, long) EventSource.WriteEvent(int, long, long) EventSource.WriteEvent(int, long, long, long) EventSource.WriteEvent(int, string) EventSource.WriteEvent(int, string, string) EventSource.WriteEvent(int, string, string, string) EventSource.WriteEvent(int, string, int) EventSource.WriteEvent(int, string, int, int) EventSource.WriteEvent(int, string, long) EventSource.WriteEvent(int, long, string) EventSource.WriteEvent(int, int, string) EventSource.WriteEvent(int, byte[]) EventSource.WriteEvent(int, long, byte[]) EventSource.WriteEventCore(int, int, EventSource.EventData*) EventSource.WriteEventWithRelatedActivityIdCore(int, Guid*, int, EventSource.EventData*) EventSource.WriteEvent(int, params EventSource.EventSourcePrimitive[]) EventSource.WriteEvent(int, params object[]) EventSource.WriteEventWithRelatedActivityId(int, Guid, params object[]) EventSource.Dispose() EventSource.Dispose(bool) EventSource.Write(string) EventSource.Write(string, EventSourceOptions) EventSource.Write<T>(string, T) EventSource.Write<T>(string, EventSourceOptions, T) EventSource.Write<T>(string, ref EventSourceOptions, ref T) EventSource.Write<T>(string, ref EventSourceOptions, ref Guid, ref Guid, ref T) EventSource.Name EventSource.Guid EventSource.Settings EventSource.ConstructionException EventSource.CurrentThreadActivityId EventSource.EventCommandExecuted Fields BenchmarkStartEventId public const int BenchmarkStartEventId = 1 Field Value int BenchmarkStopEventId public const int BenchmarkStopEventId = 2 Field Value int OverheadActualStartEventId public const int OverheadActualStartEventId = 11 Field Value int OverheadActualStopEventId public const int OverheadActualStopEventId = 12 Field Value int OverheadJittingStartEventId public const int OverheadJittingStartEventId = 3 Field Value int OverheadJittingStopEventId public const int OverheadJittingStopEventId = 4 Field Value int OverheadWarmupStartEventId public const int OverheadWarmupStartEventId = 9 Field Value int OverheadWarmupStopEventId public const int OverheadWarmupStopEventId = 10 Field Value int SourceName public const string SourceName = \"BenchmarkDotNet.EngineEventSource\" Field Value string WorkloadActualStartEventId public const int WorkloadActualStartEventId = 15 Field Value int WorkloadActualStopEventId public const int WorkloadActualStopEventId = 16 Field Value int WorkloadJittingStartEventId public const int WorkloadJittingStartEventId = 5 Field Value int WorkloadJittingStopEventId public const int WorkloadJittingStopEventId = 6 Field Value int WorkloadPilotStartEventId public const int WorkloadPilotStartEventId = 7 Field Value int WorkloadPilotStopEventId public const int WorkloadPilotStopEventId = 8 Field Value int WorkloadWarmupStartEventId public const int WorkloadWarmupStartEventId = 13 Field Value int WorkloadWarmupStopEventId public const int WorkloadWarmupStopEventId = 14 Field Value int"
  },
  "api/BenchmarkDotNet.Engines.EngineEventSource.Tasks.html": {
    "href": "api/BenchmarkDotNet.Engines.EngineEventSource.Tasks.html",
    "title": "Class EngineEventSource.Tasks | BenchmarkDotNet",
    "summary": "Class EngineEventSource.Tasks Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public class EngineEventSource.Tasks Inheritance object EngineEventSource.Tasks Constructors Tasks() public Tasks() Fields Benchmark public const EventTask Benchmark = (EventTask)1 Field Value EventTask OverheadActual public const EventTask OverheadActual = (EventTask)6 Field Value EventTask OverheadJitting public const EventTask OverheadJitting = (EventTask)2 Field Value EventTask OverheadWarmup public const EventTask OverheadWarmup = (EventTask)5 Field Value EventTask WorkloadActual public const EventTask WorkloadActual = (EventTask)8 Field Value EventTask WorkloadJitting public const EventTask WorkloadJitting = (EventTask)3 Field Value EventTask WorkloadPilot public const EventTask WorkloadPilot = (EventTask)4 Field Value EventTask WorkloadWarmup public const EventTask WorkloadWarmup = (EventTask)7 Field Value EventTask"
  },
  "api/BenchmarkDotNet.Engines.EngineFactory.html": {
    "href": "api/BenchmarkDotNet.Engines.EngineFactory.html",
    "title": "Class EngineFactory | BenchmarkDotNet",
    "summary": "Class EngineFactory Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public class EngineFactory : IEngineFactory Inheritance object EngineFactory Implements IEngineFactory Constructors EngineFactory() public EngineFactory() Methods CreateReadyToRun(EngineParameters) public IEngine CreateReadyToRun(EngineParameters engineParameters) Parameters engineParameters EngineParameters Returns IEngine"
  },
  "api/BenchmarkDotNet.Engines.EngineParameters.html": {
    "href": "api/BenchmarkDotNet.Engines.EngineParameters.html",
    "title": "Class EngineParameters | BenchmarkDotNet",
    "summary": "Class EngineParameters Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public class EngineParameters Inheritance object EngineParameters Constructors EngineParameters() public EngineParameters() Fields DefaultResolver public static readonly IResolver DefaultResolver Field Value IResolver Properties BenchmarkName public string BenchmarkName { get; set; } Property Value string Dummy1Action public Action Dummy1Action { get; set; } Property Value Action Dummy2Action public Action Dummy2Action { get; set; } Property Value Action Dummy3Action public Action Dummy3Action { get; set; } Property Value Action GlobalCleanupAction public Action GlobalCleanupAction { get; set; } Property Value Action GlobalSetupAction public Action GlobalSetupAction { get; set; } Property Value Action HasInvocationCount public bool HasInvocationCount { get; } Property Value bool HasUnrollFactor public bool HasUnrollFactor { get; } Property Value bool Host public IHost Host { get; set; } Property Value IHost IterationCleanupAction public Action IterationCleanupAction { get; set; } Property Value Action IterationSetupAction public Action IterationSetupAction { get; set; } Property Value Action IterationTime public TimeInterval IterationTime { get; } Property Value TimeInterval MeasureExtraStats public bool MeasureExtraStats { get; set; } Property Value bool NeedsJitting public bool NeedsJitting { get; } Property Value bool OperationsPerInvoke public long OperationsPerInvoke { get; set; } Property Value long OverheadActionNoUnroll public Action<long> OverheadActionNoUnroll { get; set; } Property Value Action<long> OverheadActionUnroll public Action<long> OverheadActionUnroll { get; set; } Property Value Action<long> TargetJob public Job TargetJob { get; set; } Property Value Job UnrollFactor public int UnrollFactor { get; } Property Value int WorkloadActionNoUnroll public Action<long> WorkloadActionNoUnroll { get; set; } Property Value Action<long> WorkloadActionUnroll public Action<long> WorkloadActionUnroll { get; set; } Property Value Action<long>"
  },
  "api/BenchmarkDotNet.Engines.EngineResolver.html": {
    "href": "api/BenchmarkDotNet.Engines.EngineResolver.html",
    "title": "Class EngineResolver | BenchmarkDotNet",
    "summary": "Class EngineResolver Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public class EngineResolver : Resolver, IResolver Inheritance object Resolver EngineResolver Implements IResolver Inherited Members Resolver.Register<T>(Characteristic<T>, Func<T>) Resolver.Register<T>(Characteristic<T>, Func<CharacteristicObject, T>) Resolver.CanResolve(Characteristic) Resolver.Resolve(CharacteristicObject, Characteristic) Resolver.Resolve<T>(CharacteristicObject, Characteristic<T>) Resolver.Resolve(CharacteristicObject, Characteristic, object) Resolver.Resolve<T>(CharacteristicObject, Characteristic<T>, T) Fields Instance public static readonly IResolver Instance Field Value IResolver"
  },
  "api/BenchmarkDotNet.Engines.GcStats.html": {
    "href": "api/BenchmarkDotNet.Engines.GcStats.html",
    "title": "Struct GcStats | BenchmarkDotNet",
    "summary": "Struct GcStats Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public struct GcStats : IEquatable<GcStats> Implements IEquatable<GcStats> Fields AllocationQuantum public static readonly long AllocationQuantum Field Value long Empty public static readonly GcStats Empty Field Value GcStats Properties Gen0Collections public readonly int Gen0Collections { get; } Property Value int Gen1Collections public readonly int Gen1Collections { get; } Property Value int Gen2Collections public readonly int Gen2Collections { get; } Property Value int TotalOperations public readonly long TotalOperations { get; } Property Value long Methods Equals(GcStats) public bool Equals(GcStats other) Parameters other GcStats Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool FromForced(int) public static GcStats FromForced(int forcedFullGarbageCollections) Parameters forcedFullGarbageCollections int Returns GcStats GetBytesAllocatedPerOperation(BenchmarkCase) public long? GetBytesAllocatedPerOperation(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns long? GetCollectionsCount(int) public int GetCollectionsCount(int generation) Parameters generation int Returns int GetHashCode() public override int GetHashCode() Returns int GetTotalAllocatedBytes(bool) returns total allocated bytes (not per operation) public long? GetTotalAllocatedBytes(bool excludeAllocationQuantumSideEffects) Parameters excludeAllocationQuantumSideEffects bool Allocation quantum can affecting some of our nano-benchmarks in non-deterministic way. when this parameter is set to true and the number of all allocated bytes is less or equal AQ, we ignore AQ and put 0 to the results Returns long? Parse(string) public static GcStats Parse(string line) Parameters line string Returns GcStats ReadFinal() public static GcStats ReadFinal() Returns GcStats ReadInitial() public static GcStats ReadInitial() Returns GcStats ToOutputLine() public string ToOutputLine() Returns string ToString() public override string ToString() Returns string WithTotalOperations(long) public GcStats WithTotalOperations(long totalOperationsCount) Parameters totalOperationsCount long Returns GcStats Operators operator +(GcStats, GcStats) public static GcStats operator +(GcStats left, GcStats right) Parameters left GcStats right GcStats Returns GcStats operator -(GcStats, GcStats) public static GcStats operator -(GcStats left, GcStats right) Parameters left GcStats right GcStats Returns GcStats"
  },
  "api/BenchmarkDotNet.Engines.HostExtensions.html": {
    "href": "api/BenchmarkDotNet.Engines.HostExtensions.html",
    "title": "Class HostExtensions | BenchmarkDotNet",
    "summary": "Class HostExtensions Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public static class HostExtensions Inheritance object HostExtensions Methods AfterAll(IHost) public static void AfterAll(this IHost host) Parameters host IHost AfterMainRun(IHost) public static void AfterMainRun(this IHost host) Parameters host IHost BeforeAnythingElse(IHost) public static void BeforeAnythingElse(this IHost host) Parameters host IHost BeforeMainRun(IHost) public static void BeforeMainRun(this IHost host) Parameters host IHost WriteLine(IHost, string, params object[]) public static void WriteLine(this IHost host, string messageFormat, params object[] args) Parameters host IHost messageFormat string args object[]"
  },
  "api/BenchmarkDotNet.Engines.HostSignal.html": {
    "href": "api/BenchmarkDotNet.Engines.HostSignal.html",
    "title": "Enum HostSignal | BenchmarkDotNet",
    "summary": "Enum HostSignal Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public enum HostSignal Fields AfterActualRun = 4 after main run, but before global Cleanup AfterAll = 5 after all (the last thing the benchmarking engine does is to fire this signal) AfterProcessExit = 7 after the benchmarking process exits AfterProcessStart = 1 right after we start the benchmarking process BeforeActualRun = 3 after globalSetup, warmup and pilot but before the main run BeforeAnythingElse = 2 before jitting, warmup BeforeProcessStart = 0 before we start the benchmarking process SeparateLogic = 6 used to run some code independent to the benchmarked process"
  },
  "api/BenchmarkDotNet.Engines.html": {
    "href": "api/BenchmarkDotNet.Engines.html",
    "title": "Namespace BenchmarkDotNet.Engines | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Engines Classes AnonymousPipesHost Consumer ConsumerExtensions DeadCodeEliminationHelper Engine Engine.Signals EngineEventSource EngineEventSource.Tasks EngineFactory EngineParameters EngineResolver HostExtensions NoAcknowledgementConsoleHost RunStrategyExtensions Structs GcStats IterationData RunResults ThreadingStats Interfaces IEngine IEngineFactory IHost Enums HostSignal IterationMode IterationStage RunStrategy"
  },
  "api/BenchmarkDotNet.Engines.IEngine.html": {
    "href": "api/BenchmarkDotNet.Engines.IEngine.html",
    "title": "Interface IEngine | BenchmarkDotNet",
    "summary": "Interface IEngine Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public interface IEngine : IDisposable Inherited Members IDisposable.Dispose() Properties GlobalCleanupAction Action? GlobalCleanupAction { get; } Property Value Action GlobalSetupAction Action? GlobalSetupAction { get; } Property Value Action Host IHost Host { get; } Property Value IHost OperationsPerInvoke long OperationsPerInvoke { get; } Property Value long OverheadAction Action<long> OverheadAction { get; } Property Value Action<long> Resolver IResolver Resolver { get; } Property Value IResolver TargetJob Job TargetJob { get; } Property Value Job WorkloadAction Action<long> WorkloadAction { get; } Property Value Action<long> Methods Run() RunResults Run() Returns RunResults RunIteration(IterationData) Measurement RunIteration(IterationData data) Parameters data IterationData Returns Measurement WriteLine() void WriteLine() WriteLine(string) void WriteLine(string line) Parameters line string"
  },
  "api/BenchmarkDotNet.Engines.IEngineFactory.html": {
    "href": "api/BenchmarkDotNet.Engines.IEngineFactory.html",
    "title": "Interface IEngineFactory | BenchmarkDotNet",
    "summary": "Interface IEngineFactory Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public interface IEngineFactory Methods CreateReadyToRun(EngineParameters) IEngine CreateReadyToRun(EngineParameters engineParameters) Parameters engineParameters EngineParameters Returns IEngine"
  },
  "api/BenchmarkDotNet.Engines.IHost.html": {
    "href": "api/BenchmarkDotNet.Engines.IHost.html",
    "title": "Interface IHost | BenchmarkDotNet",
    "summary": "Interface IHost Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public interface IHost : IDisposable Inherited Members IDisposable.Dispose() Extension Methods HostExtensions.AfterAll(IHost) HostExtensions.AfterMainRun(IHost) HostExtensions.BeforeAnythingElse(IHost) HostExtensions.BeforeMainRun(IHost) HostExtensions.WriteLine(IHost, string, params object[]) Methods ReportResults(RunResults) void ReportResults(RunResults runResults) Parameters runResults RunResults SendError(string) void SendError(string message) Parameters message string SendSignal(HostSignal) void SendSignal(HostSignal hostSignal) Parameters hostSignal HostSignal Write(string) void Write(string message) Parameters message string WriteLine() void WriteLine() WriteLine(string) void WriteLine(string message) Parameters message string"
  },
  "api/BenchmarkDotNet.Engines.IterationData.html": {
    "href": "api/BenchmarkDotNet.Engines.IterationData.html",
    "title": "Struct IterationData | BenchmarkDotNet",
    "summary": "Struct IterationData Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public struct IterationData Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() Constructors IterationData(IterationMode, IterationStage, int, long, int) public IterationData(IterationMode iterationMode, IterationStage iterationStage, int index, long invokeCount, int unrollFactor) Parameters iterationMode IterationMode iterationStage IterationStage index int invokeCount long unrollFactor int Properties Index public readonly int Index { get; } Property Value int InvokeCount public readonly long InvokeCount { get; } Property Value long IterationMode public readonly IterationMode IterationMode { get; } Property Value IterationMode IterationStage public readonly IterationStage IterationStage { get; } Property Value IterationStage UnrollFactor public readonly int UnrollFactor { get; } Property Value int"
  },
  "api/BenchmarkDotNet.Engines.IterationMode.html": {
    "href": "api/BenchmarkDotNet.Engines.IterationMode.html",
    "title": "Enum IterationMode | BenchmarkDotNet",
    "summary": "Enum IterationMode Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public enum IterationMode Fields Overhead = 0 Unknown = 2 Workload = 1"
  },
  "api/BenchmarkDotNet.Engines.IterationStage.html": {
    "href": "api/BenchmarkDotNet.Engines.IterationStage.html",
    "title": "Enum IterationStage | BenchmarkDotNet",
    "summary": "Enum IterationStage Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public enum IterationStage Fields Actual = 3 Jitting = 0 Pilot = 1 https://en.wikipedia.org/wiki/Pilot_experiment Result = 4 Unknown = 5 Warmup = 2"
  },
  "api/BenchmarkDotNet.Engines.NoAcknowledgementConsoleHost.html": {
    "href": "api/BenchmarkDotNet.Engines.NoAcknowledgementConsoleHost.html",
    "title": "Class NoAcknowledgementConsoleHost | BenchmarkDotNet",
    "summary": "Class NoAcknowledgementConsoleHost Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public sealed class NoAcknowledgementConsoleHost : IHost, IDisposable Inheritance object NoAcknowledgementConsoleHost Implements IHost IDisposable Extension Methods HostExtensions.AfterAll(IHost) HostExtensions.AfterMainRun(IHost) HostExtensions.BeforeAnythingElse(IHost) HostExtensions.BeforeMainRun(IHost) HostExtensions.WriteLine(IHost, string, params object[]) Constructors NoAcknowledgementConsoleHost() public NoAcknowledgementConsoleHost() Methods Dispose() public void Dispose() ReportResults(RunResults) public void ReportResults(RunResults runResults) Parameters runResults RunResults SendError(string) public void SendError(string message) Parameters message string SendSignal(HostSignal) public void SendSignal(HostSignal hostSignal) Parameters hostSignal HostSignal Write(string) public void Write(string message) Parameters message string WriteLine() public void WriteLine() WriteLine(string) public void WriteLine(string message) Parameters message string"
  },
  "api/BenchmarkDotNet.Engines.RunResults.html": {
    "href": "api/BenchmarkDotNet.Engines.RunResults.html",
    "title": "Struct RunResults | BenchmarkDotNet",
    "summary": "Struct RunResults Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public struct RunResults Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() Constructors RunResults(IReadOnlyList<Measurement>, OutlierMode, GcStats, ThreadingStats, double) public RunResults(IReadOnlyList<Measurement> engineMeasurements, OutlierMode outlierMode, GcStats gcStats, ThreadingStats threadingStats, double exceptionFrequency) Parameters engineMeasurements IReadOnlyList<Measurement> outlierMode OutlierMode gcStats GcStats threadingStats ThreadingStats exceptionFrequency double Properties EngineMeasurements public readonly IReadOnlyList<Measurement> EngineMeasurements { get; } Property Value IReadOnlyList<Measurement> ExceptionFrequency public readonly double ExceptionFrequency { get; } Property Value double GCStats public readonly GcStats GCStats { get; } Property Value GcStats Overhead public IReadOnlyList<Measurement>? Overhead { get; } Property Value IReadOnlyList<Measurement> ThreadingStats public readonly ThreadingStats ThreadingStats { get; } Property Value ThreadingStats Workload public IReadOnlyList<Measurement> Workload { get; } Property Value IReadOnlyList<Measurement> Methods GetAllMeasurements() public IEnumerable<Measurement> GetAllMeasurements() Returns IEnumerable<Measurement> GetWorkloadResultMeasurements() public IEnumerable<Measurement> GetWorkloadResultMeasurements() Returns IEnumerable<Measurement> Print(TextWriter) public void Print(TextWriter outWriter) Parameters outWriter TextWriter"
  },
  "api/BenchmarkDotNet.Engines.RunStrategy.html": {
    "href": "api/BenchmarkDotNet.Engines.RunStrategy.html",
    "title": "Enum RunStrategy | BenchmarkDotNet",
    "summary": "Enum RunStrategy Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public enum RunStrategy Extension Methods RunStrategyExtensions.NeedsJitting(RunStrategy) Fields ColdStart = 1 A mode without overhead evaluating and warmup, with single invocation. Perfect for startup time evaluation. Monitoring = 2 A mode without overhead evaluating, with several target iterations. Perfect for macrobenchmarks without a steady state with high variance. Throughput = 0 Throughput mode. Perfect for microbenchmarking."
  },
  "api/BenchmarkDotNet.Engines.RunStrategyExtensions.html": {
    "href": "api/BenchmarkDotNet.Engines.RunStrategyExtensions.html",
    "title": "Class RunStrategyExtensions | BenchmarkDotNet",
    "summary": "Class RunStrategyExtensions Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public static class RunStrategyExtensions Inheritance object RunStrategyExtensions Methods NeedsJitting(RunStrategy) public static bool NeedsJitting(this RunStrategy runStrategy) Parameters runStrategy RunStrategy Returns bool"
  },
  "api/BenchmarkDotNet.Engines.ThreadingStats.html": {
    "href": "api/BenchmarkDotNet.Engines.ThreadingStats.html",
    "title": "Struct ThreadingStats | BenchmarkDotNet",
    "summary": "Struct ThreadingStats Namespace BenchmarkDotNet.Engines Assembly BenchmarkDotNet.dll public struct ThreadingStats : IEquatable<ThreadingStats> Implements IEquatable<ThreadingStats> Constructors ThreadingStats(long, long, long) public ThreadingStats(long completedWorkItemCount, long lockContentionCount, long totalOperations) Parameters completedWorkItemCount long lockContentionCount long totalOperations long Properties CompletedWorkItemCount public readonly long CompletedWorkItemCount { get; } Property Value long Empty public static ThreadingStats Empty { get; } Property Value ThreadingStats LockContentionCount public readonly long LockContentionCount { get; } Property Value long TotalOperations public readonly long TotalOperations { get; } Property Value long Methods Equals(ThreadingStats) public bool Equals(ThreadingStats other) Parameters other ThreadingStats Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int Parse(string) public static ThreadingStats Parse(string line) Parameters line string Returns ThreadingStats ReadFinal() public static ThreadingStats ReadFinal() Returns ThreadingStats ReadInitial() public static ThreadingStats ReadInitial() Returns ThreadingStats ToOutputLine() public string ToOutputLine() Returns string ToString() public override string ToString() Returns string WithTotalOperations(long) public ThreadingStats WithTotalOperations(long totalOperationsCount) Parameters totalOperationsCount long Returns ThreadingStats Operators operator +(ThreadingStats, ThreadingStats) public static ThreadingStats operator +(ThreadingStats left, ThreadingStats right) Parameters left ThreadingStats right ThreadingStats Returns ThreadingStats operator -(ThreadingStats, ThreadingStats) public static ThreadingStats operator -(ThreadingStats left, ThreadingStats right) Parameters left ThreadingStats right ThreadingStats Returns ThreadingStats"
  },
  "api/BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.html": {
    "href": "api/BenchmarkDotNet.Environments.BenchmarkEnvironmentInfo.html",
    "title": "Class BenchmarkEnvironmentInfo | BenchmarkDotNet",
    "summary": "Class BenchmarkEnvironmentInfo Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public class BenchmarkEnvironmentInfo Inheritance object BenchmarkEnvironmentInfo Derived HostEnvironmentInfo Constructors BenchmarkEnvironmentInfo() protected BenchmarkEnvironmentInfo() Properties Architecture public string Architecture { get; protected set; } Property Value string Configuration public string Configuration { get; protected set; } Property Value string GCAllocationQuantum public long GCAllocationQuantum { get; protected set; } Property Value long HardwareIntrinsicsShort public string HardwareIntrinsicsShort { get; protected set; } Property Value string HasAttachedDebugger public bool HasAttachedDebugger { get; protected set; } Property Value bool HasRyuJit public bool HasRyuJit { get; protected set; } Property Value bool InDocker public bool InDocker { get; protected set; } Property Value bool IsConcurrentGC public bool IsConcurrentGC { get; protected set; } Property Value bool IsServerGC public bool IsServerGC { get; protected set; } Property Value bool JitInfo public string JitInfo { get; protected set; } Property Value string RuntimeVersion public string RuntimeVersion { get; protected set; } Property Value string Methods GetConfigurationFlag() protected string GetConfigurationFlag() Returns string GetCurrent() public static BenchmarkEnvironmentInfo GetCurrent() Returns BenchmarkEnvironmentInfo GetDebuggerFlag() protected string GetDebuggerFlag() Returns string GetGcConcurrentFlag() protected string GetGcConcurrentFlag() Returns string GetGcServerFlag() protected string GetGcServerFlag() Returns string ToFormattedString() public virtual IEnumerable<string> ToFormattedString() Returns IEnumerable<string> Validate(Job) public static IEnumerable<ValidationError> Validate(Job job) Parameters job Job Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Environments.ClrRuntime.html": {
    "href": "api/BenchmarkDotNet.Environments.ClrRuntime.html",
    "title": "Class ClrRuntime | BenchmarkDotNet",
    "summary": "Class ClrRuntime Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public class ClrRuntime : Runtime, IEquatable<Runtime>, IEquatable<ClrRuntime> Inheritance object Runtime ClrRuntime Implements IEquatable<Runtime> IEquatable<ClrRuntime> Inherited Members Runtime.ToString() Runtime.Equals(Runtime) Runtime.Name Runtime.RuntimeMoniker Runtime.MsBuildMoniker Runtime.IsAOT Fields Net461 public static readonly ClrRuntime Net461 Field Value ClrRuntime Net462 public static readonly ClrRuntime Net462 Field Value ClrRuntime Net47 public static readonly ClrRuntime Net47 Field Value ClrRuntime Net471 public static readonly ClrRuntime Net471 Field Value ClrRuntime Net472 public static readonly ClrRuntime Net472 Field Value ClrRuntime Net48 public static readonly ClrRuntime Net48 Field Value ClrRuntime Net481 public static readonly ClrRuntime Net481 Field Value ClrRuntime Properties Version public string Version { get; } Property Value string Methods CreateForLocalFullNetFrameworkBuild(string) public static ClrRuntime CreateForLocalFullNetFrameworkBuild(string version) Parameters version string YOU PROBABLY DON'T NEED IT, but if you are a .NET Runtime developer.. please set it to particular .NET Runtime version if you want to benchmark it. BenchmarkDotNet in going to pass COMPLUS_Version env var to the process for you. Returns ClrRuntime Equals(ClrRuntime) public bool Equals(ClrRuntime other) Parameters other ClrRuntime Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/BenchmarkDotNet.Environments.CoreRtRuntime.html": {
    "href": "api/BenchmarkDotNet.Environments.CoreRtRuntime.html",
    "title": "Class CoreRtRuntime | BenchmarkDotNet",
    "summary": "Class CoreRtRuntime Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll [Obsolete(\"Please use NativeAotRuntime instead.\", true)] public class CoreRtRuntime Inheritance object CoreRtRuntime Constructors CoreRtRuntime() public CoreRtRuntime()"
  },
  "api/BenchmarkDotNet.Environments.CoreRuntime.html": {
    "href": "api/BenchmarkDotNet.Environments.CoreRuntime.html",
    "title": "Class CoreRuntime | BenchmarkDotNet",
    "summary": "Class CoreRuntime Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public class CoreRuntime : Runtime, IEquatable<Runtime> Inheritance object Runtime CoreRuntime Implements IEquatable<Runtime> Inherited Members Runtime.ToString() Runtime.Equals(Runtime) Runtime.Equals(object) Runtime.GetHashCode() Runtime.Name Runtime.RuntimeMoniker Runtime.MsBuildMoniker Runtime.IsAOT Fields Core10_0 public static readonly CoreRuntime Core10_0 Field Value CoreRuntime Core20 public static readonly CoreRuntime Core20 Field Value CoreRuntime Core21 public static readonly CoreRuntime Core21 Field Value CoreRuntime Core22 public static readonly CoreRuntime Core22 Field Value CoreRuntime Core30 public static readonly CoreRuntime Core30 Field Value CoreRuntime Core31 public static readonly CoreRuntime Core31 Field Value CoreRuntime Core50 public static readonly CoreRuntime Core50 Field Value CoreRuntime Core60 public static readonly CoreRuntime Core60 Field Value CoreRuntime Core70 public static readonly CoreRuntime Core70 Field Value CoreRuntime Core80 public static readonly CoreRuntime Core80 Field Value CoreRuntime Core90 public static readonly CoreRuntime Core90 Field Value CoreRuntime Properties IsPlatformSpecific public bool IsPlatformSpecific { get; } Property Value bool Latest public static CoreRuntime Latest { get; } Property Value CoreRuntime Methods CreateForNewVersion(string, string) use this method if you want to target .NET version not supported by current version of BenchmarkDotNet. Example: .NET 10 public static CoreRuntime CreateForNewVersion(string msBuildMoniker, string displayName) Parameters msBuildMoniker string msbuild moniker, example: net10.0 displayName string display name used by BDN to print the results Returns CoreRuntime new runtime information"
  },
  "api/BenchmarkDotNet.Environments.CustomRuntime.html": {
    "href": "api/BenchmarkDotNet.Environments.CustomRuntime.html",
    "title": "Class CustomRuntime | BenchmarkDotNet",
    "summary": "Class CustomRuntime Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public abstract class CustomRuntime : Runtime, IEquatable<Runtime> Inheritance object Runtime CustomRuntime Implements IEquatable<Runtime> Inherited Members Runtime.ToString() Runtime.Equals(Runtime) Runtime.Equals(object) Runtime.GetHashCode() Runtime.Name Runtime.RuntimeMoniker Runtime.MsBuildMoniker Runtime.IsAOT Constructors CustomRuntime(RuntimeMoniker, string, string) protected CustomRuntime(RuntimeMoniker runtimeMoniker, string msBuildMoniker, string displayName) Parameters runtimeMoniker RuntimeMoniker msBuildMoniker string displayName string"
  },
  "api/BenchmarkDotNet.Environments.EnvironmentResolver.html": {
    "href": "api/BenchmarkDotNet.Environments.EnvironmentResolver.html",
    "title": "Class EnvironmentResolver | BenchmarkDotNet",
    "summary": "Class EnvironmentResolver Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public class EnvironmentResolver : Resolver, IResolver Inheritance object Resolver EnvironmentResolver Implements IResolver Inherited Members Resolver.Register<T>(Characteristic<T>, Func<T>) Resolver.Register<T>(Characteristic<T>, Func<CharacteristicObject, T>) Resolver.CanResolve(Characteristic) Resolver.Resolve(CharacteristicObject, Characteristic) Resolver.Resolve<T>(CharacteristicObject, Characteristic<T>) Resolver.Resolve(CharacteristicObject, Characteristic, object) Resolver.Resolve<T>(CharacteristicObject, Characteristic<T>, T) Fields DefaultUnrollFactorForThroughput public const int DefaultUnrollFactorForThroughput = 16 Field Value int Instance public static readonly IResolver Instance Field Value IResolver"
  },
  "api/BenchmarkDotNet.Environments.GcResolver.html": {
    "href": "api/BenchmarkDotNet.Environments.GcResolver.html",
    "title": "Class GcResolver | BenchmarkDotNet",
    "summary": "Class GcResolver Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public class GcResolver : Resolver, IResolver Inheritance object Resolver GcResolver Implements IResolver Inherited Members Resolver.Register<T>(Characteristic<T>, Func<T>) Resolver.Register<T>(Characteristic<T>, Func<CharacteristicObject, T>) Resolver.CanResolve(Characteristic) Resolver.Resolve(CharacteristicObject, Characteristic) Resolver.Resolve<T>(CharacteristicObject, Characteristic<T>) Resolver.Resolve(CharacteristicObject, Characteristic, object) Resolver.Resolve<T>(CharacteristicObject, Characteristic<T>, T) Fields Instance public static readonly IResolver Instance Field Value IResolver"
  },
  "api/BenchmarkDotNet.Environments.HostEnvironmentInfo.html": {
    "href": "api/BenchmarkDotNet.Environments.HostEnvironmentInfo.html",
    "title": "Class HostEnvironmentInfo | BenchmarkDotNet",
    "summary": "Class HostEnvironmentInfo Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public class HostEnvironmentInfo : BenchmarkEnvironmentInfo Inheritance object BenchmarkEnvironmentInfo HostEnvironmentInfo Inherited Members BenchmarkEnvironmentInfo.GetConfigurationFlag() BenchmarkEnvironmentInfo.GetDebuggerFlag() BenchmarkEnvironmentInfo.GetGcServerFlag() BenchmarkEnvironmentInfo.GetGcConcurrentFlag() BenchmarkEnvironmentInfo.Validate(Job) BenchmarkEnvironmentInfo.Architecture BenchmarkEnvironmentInfo.Configuration BenchmarkEnvironmentInfo.RuntimeVersion BenchmarkEnvironmentInfo.HasAttachedDebugger BenchmarkEnvironmentInfo.HasRyuJit BenchmarkEnvironmentInfo.JitInfo BenchmarkEnvironmentInfo.HardwareIntrinsicsShort BenchmarkEnvironmentInfo.IsServerGC BenchmarkEnvironmentInfo.IsConcurrentGC BenchmarkEnvironmentInfo.GCAllocationQuantum BenchmarkEnvironmentInfo.InDocker Constructors HostEnvironmentInfo() protected HostEnvironmentInfo() Fields BenchmarkDotNetCaption public const string BenchmarkDotNetCaption = \"BenchmarkDotNet\" Field Value string Properties AntivirusProducts public Lazy<ICollection<Antivirus>> AntivirusProducts { get; } Property Value Lazy<ICollection<Antivirus>> BenchmarkDotNetVersion public string BenchmarkDotNetVersion { get; protected set; } Property Value string ChronometerFrequency The frequency of the timer as the number of ticks per second. public Frequency ChronometerFrequency { get; protected set; } Property Value Frequency ChronometerResolution public TimeInterval ChronometerResolution { get; } Property Value TimeInterval Cpu is expensive to call (1s) public Lazy<CpuInfo> Cpu { get; protected set; } Property Value Lazy<CpuInfo> DotNetSdkVersion .NET Core SDK version It's expensive to call (creates new process by calling dotnet --version) public Lazy<string> DotNetSdkVersion { get; protected set; } Property Value Lazy<string> FallbackLogger Logger to use when there's no config available. public static ILogger FallbackLogger { get; } Property Value ILogger HardwareTimerKind public HardwareTimerKind HardwareTimerKind { get; protected set; } Property Value HardwareTimerKind IsMonoInstalled checks if Mono is installed It's expensive to call (creates new process by calling mono --version) public Lazy<bool> IsMonoInstalled { get; } Property Value Lazy<bool> Os public Lazy<OsInfo> Os { get; protected set; } Property Value Lazy<OsInfo> VirtualMachineHypervisor public Lazy<VirtualMachineHypervisor?> VirtualMachineHypervisor { get; protected set; } Property Value Lazy<VirtualMachineHypervisor> Methods GetCurrent() public static HostEnvironmentInfo GetCurrent() Returns HostEnvironmentInfo GetInformation() Return string representation of CPU and environment configuration including BenchmarkDotNet, OS and .NET version public static string GetInformation() Returns string IsDotNetCliInstalled() public bool IsDotNetCliInstalled() Returns bool ToFormattedString() public override IEnumerable<string> ToFormattedString() Returns IEnumerable<string>"
  },
  "api/BenchmarkDotNet.Environments.html": {
    "href": "api/BenchmarkDotNet.Environments.html",
    "title": "Namespace BenchmarkDotNet.Environments | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Environments Classes BenchmarkEnvironmentInfo ClrRuntime CoreRtRuntime CoreRuntime CustomRuntime EnvironmentResolver GcResolver HostEnvironmentInfo InfrastructureResolver MonoAotLLVMRuntime MonoRuntime NativeAotRuntime Runtime WasmRuntime Enums Jit Platform PowerPlan"
  },
  "api/BenchmarkDotNet.Environments.InfrastructureResolver.html": {
    "href": "api/BenchmarkDotNet.Environments.InfrastructureResolver.html",
    "title": "Class InfrastructureResolver | BenchmarkDotNet",
    "summary": "Class InfrastructureResolver Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public class InfrastructureResolver : Resolver, IResolver Inheritance object Resolver InfrastructureResolver Implements IResolver Inherited Members Resolver.Register<T>(Characteristic<T>, Func<T>) Resolver.Register<T>(Characteristic<T>, Func<CharacteristicObject, T>) Resolver.CanResolve(Characteristic) Resolver.Resolve(CharacteristicObject, Characteristic) Resolver.Resolve<T>(CharacteristicObject, Characteristic<T>) Resolver.Resolve(CharacteristicObject, Characteristic, object) Resolver.Resolve<T>(CharacteristicObject, Characteristic<T>, T) Fields Instance public static readonly IResolver Instance Field Value IResolver"
  },
  "api/BenchmarkDotNet.Environments.Jit.html": {
    "href": "api/BenchmarkDotNet.Environments.Jit.html",
    "title": "Enum Jit | BenchmarkDotNet",
    "summary": "Enum Jit Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public enum Jit Extension Methods ConfigurationExtensions.ToConfig(Jit) Fields Default = 0 Default By default LegacyJit = 1 LegacyJIT Supported only for Full Framework Llvm = 3 LLVM Supported only for Mono RyuJit = 2 RyuJIT Full Framework or CoreCLR"
  },
  "api/BenchmarkDotNet.Environments.MonoAotLLVMRuntime.html": {
    "href": "api/BenchmarkDotNet.Environments.MonoAotLLVMRuntime.html",
    "title": "Class MonoAotLLVMRuntime | BenchmarkDotNet",
    "summary": "Class MonoAotLLVMRuntime Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public class MonoAotLLVMRuntime : Runtime, IEquatable<Runtime>, IEquatable<MonoAotLLVMRuntime> Inheritance object Runtime MonoAotLLVMRuntime Implements IEquatable<Runtime> IEquatable<MonoAotLLVMRuntime> Inherited Members Runtime.ToString() Runtime.Equals(Runtime) Runtime.Name Runtime.RuntimeMoniker Runtime.MsBuildMoniker Constructors MonoAotLLVMRuntime(FileInfo, MonoAotCompilerMode, string, string, RuntimeMoniker) creates new instance of MonoAotLLVMRuntime public MonoAotLLVMRuntime(FileInfo aotCompilerPath, MonoAotCompilerMode aotCompilerMode, string msBuildMoniker = \"net6.0\", string displayName = \"MonoAOTLLVM\", RuntimeMoniker moniker = RuntimeMoniker.MonoAOTLLVM) Parameters aotCompilerPath FileInfo aotCompilerMode MonoAotCompilerMode msBuildMoniker string displayName string moniker RuntimeMoniker Properties AOTCompilerMode public MonoAotCompilerMode AOTCompilerMode { get; } Property Value MonoAotCompilerMode AOTCompilerPath public FileInfo AOTCompilerPath { get; } Property Value FileInfo IsAOT public override bool IsAOT { get; } Property Value bool Methods Equals(MonoAotLLVMRuntime) public bool Equals(MonoAotLLVMRuntime other) Parameters other MonoAotLLVMRuntime Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/BenchmarkDotNet.Environments.MonoRuntime.html": {
    "href": "api/BenchmarkDotNet.Environments.MonoRuntime.html",
    "title": "Class MonoRuntime | BenchmarkDotNet",
    "summary": "Class MonoRuntime Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public class MonoRuntime : Runtime, IEquatable<Runtime>, IEquatable<MonoRuntime> Inheritance object Runtime MonoRuntime Implements IEquatable<Runtime> IEquatable<MonoRuntime> Inherited Members Runtime.ToString() Runtime.Equals(Runtime) Runtime.Name Runtime.RuntimeMoniker Runtime.MsBuildMoniker Constructors MonoRuntime(string, string) public MonoRuntime(string name, string customPath) Parameters name string customPath string MonoRuntime(string, string, string, string) public MonoRuntime(string name, string customPath, string aotArgs, string monoBclPath) Parameters name string customPath string aotArgs string monoBclPath string Fields Default public static readonly MonoRuntime Default Field Value MonoRuntime Mono10_0 public static readonly MonoRuntime Mono10_0 Field Value MonoRuntime Mono60 public static readonly MonoRuntime Mono60 Field Value MonoRuntime Mono70 public static readonly MonoRuntime Mono70 Field Value MonoRuntime Mono80 public static readonly MonoRuntime Mono80 Field Value MonoRuntime Mono90 public static readonly MonoRuntime Mono90 Field Value MonoRuntime Properties AotArgs public string AotArgs { get; } Property Value string CustomPath public string CustomPath { get; } Property Value string IsAOT public override bool IsAOT { get; } Property Value bool MonoBclPath public string MonoBclPath { get; } Property Value string Methods Equals(MonoRuntime) public bool Equals(MonoRuntime other) Parameters other MonoRuntime Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/BenchmarkDotNet.Environments.NativeAotRuntime.html": {
    "href": "api/BenchmarkDotNet.Environments.NativeAotRuntime.html",
    "title": "Class NativeAotRuntime | BenchmarkDotNet",
    "summary": "Class NativeAotRuntime Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public class NativeAotRuntime : Runtime, IEquatable<Runtime> Inheritance object Runtime NativeAotRuntime Implements IEquatable<Runtime> Inherited Members Runtime.ToString() Runtime.Equals(Runtime) Runtime.Equals(object) Runtime.GetHashCode() Runtime.Name Runtime.RuntimeMoniker Runtime.MsBuildMoniker Fields Net10_0 NativeAOT compiled as net10.0 public static readonly NativeAotRuntime Net10_0 Field Value NativeAotRuntime Net60 NativeAOT compiled as net6.0 public static readonly NativeAotRuntime Net60 Field Value NativeAotRuntime Net70 NativeAOT compiled as net7.0 public static readonly NativeAotRuntime Net70 Field Value NativeAotRuntime Net80 NativeAOT compiled as net8.0 public static readonly NativeAotRuntime Net80 Field Value NativeAotRuntime Net90 NativeAOT compiled as net9.0 public static readonly NativeAotRuntime Net90 Field Value NativeAotRuntime Properties IsAOT public override bool IsAOT { get; } Property Value bool Methods GetCurrentVersion() public static NativeAotRuntime GetCurrentVersion() Returns NativeAotRuntime"
  },
  "api/BenchmarkDotNet.Environments.Platform.html": {
    "href": "api/BenchmarkDotNet.Environments.Platform.html",
    "title": "Enum Platform | BenchmarkDotNet",
    "summary": "Enum Platform Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public enum Platform Extension Methods ConfigurationExtensions.ToConfig(Platform) Fields AnyCpu = 0 AnyCPU Arm = 3 ARM Arm64 = 4 ARM64 Armv6 = 8 A 32-bit ARMv6 processor architecture. LoongArch64 = 7 LOONGARCH64 Ppc64le = 9 A PowerPC 64-bit (little-endian) processor architecture. RiscV64 = 10 A RiscV 64-bit processor architecture. S390x = 6 S390x Wasm = 5 Wasm X64 = 2 x64 X86 = 1 x86"
  },
  "api/BenchmarkDotNet.Environments.PowerPlan.html": {
    "href": "api/BenchmarkDotNet.Environments.PowerPlan.html",
    "title": "Enum PowerPlan | BenchmarkDotNet",
    "summary": "Enum PowerPlan Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public enum PowerPlan Fields Balanced = 3 HighPerformance = 0 PowerSaver = 2 UltimatePerformance = 4 UserPowerPlan = 1"
  },
  "api/BenchmarkDotNet.Environments.Runtime.html": {
    "href": "api/BenchmarkDotNet.Environments.Runtime.html",
    "title": "Class Runtime | BenchmarkDotNet",
    "summary": "Class Runtime Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public abstract class Runtime : IEquatable<Runtime> Inheritance object Runtime Implements IEquatable<Runtime> Derived ClrRuntime CoreRuntime CustomRuntime MonoAotLLVMRuntime MonoRuntime NativeAotRuntime WasmRuntime Constructors Runtime(RuntimeMoniker, string, string) protected Runtime(RuntimeMoniker runtimeMoniker, string msBuildMoniker, string displayName) Parameters runtimeMoniker RuntimeMoniker msBuildMoniker string displayName string Properties IsAOT public virtual bool IsAOT { get; } Property Value bool MsBuildMoniker MsBuild Target Framework Moniker, example: net462, net8.0 public string MsBuildMoniker { get; } Property Value string Name Display name public string Name { get; } Property Value string RuntimeMoniker Target Framework Moniker public RuntimeMoniker RuntimeMoniker { get; } Property Value RuntimeMoniker Methods Equals(Runtime) public bool Equals(Runtime other) Parameters other Runtime Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Environments.WasmRuntime.html": {
    "href": "api/BenchmarkDotNet.Environments.WasmRuntime.html",
    "title": "Class WasmRuntime | BenchmarkDotNet",
    "summary": "Class WasmRuntime Namespace BenchmarkDotNet.Environments Assembly BenchmarkDotNet.dll public class WasmRuntime : Runtime, IEquatable<Runtime>, IEquatable<WasmRuntime> Inheritance object Runtime WasmRuntime Implements IEquatable<Runtime> IEquatable<WasmRuntime> Inherited Members Runtime.ToString() Runtime.Equals(Runtime) Runtime.Name Runtime.RuntimeMoniker Runtime.MsBuildMoniker Runtime.IsAOT Constructors WasmRuntime(string, string, string, string, bool, string?, RuntimeMoniker) creates new instance of WasmRuntime public WasmRuntime(string msBuildMoniker = \"net5.0\", string displayName = \"Wasm\", string javaScriptEngine = \"v8\", string javaScriptEngineArguments = \"--expose_wasm\", bool aot = false, string? wasmDataDir = null, RuntimeMoniker moniker = RuntimeMoniker.Wasm) Parameters msBuildMoniker string moniker, default: \"net5.0\" displayName string default: \"Wasm\" javaScriptEngine string Full path to a java script engine used to run the benchmarks. \"v8\" by default javaScriptEngineArguments string Arguments for the javascript engine. \"--expose_wasm\" by default aot bool Specifies whether AOT or Interpreter (default) project should be generated. wasmDataDir string Specifies a wasm data directory surfaced as $(WasmDataDir) for the project moniker RuntimeMoniker Runtime moniker Properties Aot public bool Aot { get; } Property Value bool JavaScriptEngine public string JavaScriptEngine { get; } Property Value string JavaScriptEngineArguments public string JavaScriptEngineArguments { get; } Property Value string WasmDataDir public string WasmDataDir { get; } Property Value string Methods Equals(WasmRuntime) public bool Equals(WasmRuntime other) Parameters other WasmRuntime Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/BenchmarkDotNet.EventProcessors.EventProcessor.html": {
    "href": "api/BenchmarkDotNet.EventProcessors.EventProcessor.html",
    "title": "Class EventProcessor | BenchmarkDotNet",
    "summary": "Class EventProcessor Namespace BenchmarkDotNet.EventProcessors Assembly BenchmarkDotNet.dll public abstract class EventProcessor Inheritance object EventProcessor Constructors EventProcessor() protected EventProcessor() Methods OnBuildComplete(BuildPartition, BuildResult) public virtual void OnBuildComplete(BuildPartition partition, BuildResult buildResult) Parameters partition BuildPartition buildResult BuildResult OnEndBuildStage() public virtual void OnEndBuildStage() OnEndRunBenchmark(BenchmarkCase, BenchmarkReport) public virtual void OnEndRunBenchmark(BenchmarkCase benchmarkCase, BenchmarkReport report) Parameters benchmarkCase BenchmarkCase report BenchmarkReport OnEndRunBenchmarksInType(Type, Summary) public virtual void OnEndRunBenchmarksInType(Type type, Summary summary) Parameters type Type summary Summary OnEndRunStage() public virtual void OnEndRunStage() OnEndValidationStage() public virtual void OnEndValidationStage() OnStartBuildStage(IReadOnlyList<BuildPartition>) public virtual void OnStartBuildStage(IReadOnlyList<BuildPartition> partitions) Parameters partitions IReadOnlyList<BuildPartition> OnStartRunBenchmark(BenchmarkCase) public virtual void OnStartRunBenchmark(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase OnStartRunBenchmarksInType(Type, IReadOnlyList<BenchmarkCase>) public virtual void OnStartRunBenchmarksInType(Type type, IReadOnlyList<BenchmarkCase> benchmarks) Parameters type Type benchmarks IReadOnlyList<BenchmarkCase> OnStartRunStage() public virtual void OnStartRunStage() OnStartValidationStage() public virtual void OnStartValidationStage() OnValidationError(ValidationError) public virtual void OnValidationError(ValidationError validationError) Parameters validationError ValidationError"
  },
  "api/BenchmarkDotNet.EventProcessors.html": {
    "href": "api/BenchmarkDotNet.EventProcessors.html",
    "title": "Namespace BenchmarkDotNet.EventProcessors | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.EventProcessors Classes EventProcessor"
  },
  "api/BenchmarkDotNet.Exporters.AsciiDocExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.AsciiDocExporter.html",
    "title": "Class AsciiDocExporter | BenchmarkDotNet",
    "summary": "Class AsciiDocExporter Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public class AsciiDocExporter : ExporterBase, IExporter Inheritance object ExporterBase AsciiDocExporter Implements IExporter Inherited Members ExporterBase.ExportToFiles(Summary, ILogger) ExporterBase.Name ExporterBase.FileNameSuffix ExporterBase.FileCaption Fields Default public static readonly IExporter Default Field Value IExporter Properties FileExtension protected override string FileExtension { get; } Property Value string Methods ExportToLog(Summary, ILogger) public override void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger"
  },
  "api/BenchmarkDotNet.Exporters.BenchmarkReportExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.BenchmarkReportExporter.html",
    "title": "Class BenchmarkReportExporter | BenchmarkDotNet",
    "summary": "Class BenchmarkReportExporter Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public class BenchmarkReportExporter : ExporterBase, IExporter Inheritance object ExporterBase BenchmarkReportExporter Implements IExporter Inherited Members ExporterBase.ExportToFiles(Summary, ILogger) ExporterBase.Name ExporterBase.FileExtension ExporterBase.FileNameSuffix ExporterBase.FileCaption Fields Default public static readonly IExporter Default Field Value IExporter Methods ExportToLog(Summary, ILogger) public override void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger"
  },
  "api/BenchmarkDotNet.Exporters.CompositeExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.CompositeExporter.html",
    "title": "Class CompositeExporter | BenchmarkDotNet",
    "summary": "Class CompositeExporter Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public class CompositeExporter : IExporter Inheritance object CompositeExporter Implements IExporter Constructors CompositeExporter(ImmutableArray<IExporter>) public CompositeExporter(ImmutableArray<IExporter> exporters) Parameters exporters ImmutableArray<IExporter> Properties Name public string Name { get; } Property Value string Methods ExportToFiles(Summary, ILogger) public IEnumerable<string> ExportToFiles(Summary summary, ILogger consoleLogger) Parameters summary Summary consoleLogger ILogger Returns IEnumerable<string> ExportToLog(Summary, ILogger) public void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger"
  },
  "api/BenchmarkDotNet.Exporters.Csv.CsvExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.Csv.CsvExporter.html",
    "title": "Class CsvExporter | BenchmarkDotNet",
    "summary": "Class CsvExporter Namespace BenchmarkDotNet.Exporters.Csv Assembly BenchmarkDotNet.dll public class CsvExporter : ExporterBase, IExporter Inheritance object ExporterBase CsvExporter Implements IExporter Inherited Members ExporterBase.ExportToFiles(Summary, ILogger) ExporterBase.Name ExporterBase.FileNameSuffix ExporterBase.FileCaption Constructors CsvExporter(CsvSeparator, SummaryStyle?) public CsvExporter(CsvSeparator separator, SummaryStyle? style = null) Parameters separator CsvSeparator style SummaryStyle Fields Default public static readonly IExporter Default Field Value IExporter Properties FileExtension protected override string FileExtension { get; } Property Value string Methods ExportToLog(Summary, ILogger) public override void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger"
  },
  "api/BenchmarkDotNet.Exporters.Csv.CsvHelper.html": {
    "href": "api/BenchmarkDotNet.Exporters.Csv.CsvHelper.html",
    "title": "Class CsvHelper | BenchmarkDotNet",
    "summary": "Class CsvHelper Namespace BenchmarkDotNet.Exporters.Csv Assembly BenchmarkDotNet.dll public static class CsvHelper Inheritance object CsvHelper Methods Escape(string?, string) public static string Escape(string? value, string currentListSeparator) Parameters value string currentListSeparator string Returns string"
  },
  "api/BenchmarkDotNet.Exporters.Csv.CsvMeasurementsExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.Csv.CsvMeasurementsExporter.html",
    "title": "Class CsvMeasurementsExporter | BenchmarkDotNet",
    "summary": "Class CsvMeasurementsExporter Namespace BenchmarkDotNet.Exporters.Csv Assembly BenchmarkDotNet.dll public class CsvMeasurementsExporter : ExporterBase, IExporter Inheritance object ExporterBase CsvMeasurementsExporter Implements IExporter Inherited Members ExporterBase.ExportToFiles(Summary, ILogger) ExporterBase.Name ExporterBase.FileNameSuffix Constructors CsvMeasurementsExporter(CsvSeparator, SummaryStyle?) public CsvMeasurementsExporter(CsvSeparator separator, SummaryStyle? style = null) Parameters separator CsvSeparator style SummaryStyle Fields Default public static readonly CsvMeasurementsExporter Default Field Value CsvMeasurementsExporter Properties FileCaption protected override string FileCaption { get; } Property Value string FileExtension protected override string FileExtension { get; } Property Value string Separator public string Separator { get; } Property Value string Style public SummaryStyle Style { get; } Property Value SummaryStyle Methods ExportToLog(Summary, ILogger) public override void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger GetJobs(Summary) public static Job[] GetJobs(Summary summary) Parameters summary Summary Returns Job[] WithStyle(SummaryStyle) public static CsvMeasurementsExporter WithStyle(SummaryStyle style) Parameters style SummaryStyle Returns CsvMeasurementsExporter"
  },
  "api/BenchmarkDotNet.Exporters.Csv.CsvSeparator.html": {
    "href": "api/BenchmarkDotNet.Exporters.Csv.CsvSeparator.html",
    "title": "Enum CsvSeparator | BenchmarkDotNet",
    "summary": "Enum CsvSeparator Namespace BenchmarkDotNet.Exporters.Csv Assembly BenchmarkDotNet.dll public enum CsvSeparator Extension Methods CsvSeparatorExtensions.ToRealSeparator(CsvSeparator) Fields Comma = 0 ',' will be used as the CSV separator. CurrentCulture = 2 Semicolon = 1 ';' will be used as the CSV separator."
  },
  "api/BenchmarkDotNet.Exporters.Csv.CsvSeparatorExtensions.html": {
    "href": "api/BenchmarkDotNet.Exporters.Csv.CsvSeparatorExtensions.html",
    "title": "Class CsvSeparatorExtensions | BenchmarkDotNet",
    "summary": "Class CsvSeparatorExtensions Namespace BenchmarkDotNet.Exporters.Csv Assembly BenchmarkDotNet.dll public static class CsvSeparatorExtensions Inheritance object CsvSeparatorExtensions Methods ToRealSeparator(CsvSeparator) Return a string which represent real CSV separator which can be used as plain text. public static string ToRealSeparator(this CsvSeparator separator) Parameters separator CsvSeparator Returns string"
  },
  "api/BenchmarkDotNet.Exporters.Csv.html": {
    "href": "api/BenchmarkDotNet.Exporters.Csv.html",
    "title": "Namespace BenchmarkDotNet.Exporters.Csv | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Exporters.Csv Classes CsvExporter CsvHelper CsvMeasurementsExporter CsvSeparatorExtensions Enums CsvSeparator"
  },
  "api/BenchmarkDotNet.Exporters.DefaultExporters.html": {
    "href": "api/BenchmarkDotNet.Exporters.DefaultExporters.html",
    "title": "Class DefaultExporters | BenchmarkDotNet",
    "summary": "Class DefaultExporters Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public static class DefaultExporters Inheritance object DefaultExporters Fields AsciiDoc public static readonly IExporter AsciiDoc Field Value IExporter Csv public static readonly IExporter Csv Field Value IExporter CsvMeasurements public static readonly IExporter CsvMeasurements Field Value IExporter Html public static readonly IExporter Html Field Value IExporter Json public static readonly IExporter Json Field Value IExporter JsonBrief public static readonly IExporter JsonBrief Field Value IExporter JsonBriefCompressed public static readonly IExporter JsonBriefCompressed Field Value IExporter JsonFull public static readonly IExporter JsonFull Field Value IExporter JsonFullCompressed public static readonly IExporter JsonFullCompressed Field Value IExporter Markdown public static readonly IExporter Markdown Field Value IExporter Plain public static readonly IExporter Plain Field Value IExporter RPlot public static readonly IExporter RPlot Field Value IExporter Xml public static readonly IExporter Xml Field Value IExporter XmlBrief public static readonly IExporter XmlBrief Field Value IExporter XmlBriefCompressed public static readonly IExporter XmlBriefCompressed Field Value IExporter XmlFull public static readonly IExporter XmlFull Field Value IExporter XmlFullCompressed public static readonly IExporter XmlFullCompressed Field Value IExporter"
  },
  "api/BenchmarkDotNet.Exporters.ExporterBase.html": {
    "href": "api/BenchmarkDotNet.Exporters.ExporterBase.html",
    "title": "Class ExporterBase | BenchmarkDotNet",
    "summary": "Class ExporterBase Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public abstract class ExporterBase : IExporter Inheritance object ExporterBase Implements IExporter Derived AsciiDocExporter BenchmarkReportExporter CsvExporter CsvMeasurementsExporter HtmlExporter JsonExporterBase MarkdownExporter PlainExporter XmlExporterBase Constructors ExporterBase() protected ExporterBase() Properties FileCaption protected virtual string FileCaption { get; } Property Value string FileExtension protected virtual string FileExtension { get; } Property Value string FileNameSuffix protected virtual string FileNameSuffix { get; } Property Value string Name public string Name { get; } Property Value string Methods ExportToFiles(Summary, ILogger) public IEnumerable<string> ExportToFiles(Summary summary, ILogger consoleLogger) Parameters summary Summary consoleLogger ILogger Returns IEnumerable<string> ExportToLog(Summary, ILogger) public abstract void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger"
  },
  "api/BenchmarkDotNet.Exporters.FullNameProvider.html": {
    "href": "api/BenchmarkDotNet.Exporters.FullNameProvider.html",
    "title": "Class FullNameProvider | BenchmarkDotNet",
    "summary": "Class FullNameProvider Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public static class FullNameProvider Inheritance object FullNameProvider Methods GetBenchmarkName(BenchmarkCase) public static string GetBenchmarkName(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns string"
  },
  "api/BenchmarkDotNet.Exporters.html": {
    "href": "api/BenchmarkDotNet.Exporters.html",
    "title": "Namespace BenchmarkDotNet.Exporters | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Exporters Classes AsciiDocExporter BenchmarkReportExporter CompositeExporter DefaultExporters ExporterBase FullNameProvider HtmlExporter MarkdownExporter PlainExporter RPlotExporter Interfaces IExporter Enums MarkdownExporter.MarkdownHighlightStrategy"
  },
  "api/BenchmarkDotNet.Exporters.HtmlExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.HtmlExporter.html",
    "title": "Class HtmlExporter | BenchmarkDotNet",
    "summary": "Class HtmlExporter Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public class HtmlExporter : ExporterBase, IExporter Inheritance object ExporterBase HtmlExporter Implements IExporter Inherited Members ExporterBase.ExportToFiles(Summary, ILogger) ExporterBase.Name ExporterBase.FileNameSuffix ExporterBase.FileCaption Constructors HtmlExporter() public HtmlExporter() Fields Default public static readonly IExporter Default Field Value IExporter Properties FileExtension protected override string FileExtension { get; } Property Value string Methods ExportToLog(Summary, ILogger) public override void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger"
  },
  "api/BenchmarkDotNet.Exporters.IExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.IExporter.html",
    "title": "Interface IExporter | BenchmarkDotNet",
    "summary": "Interface IExporter Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public interface IExporter Properties Name string Name { get; } Property Value string Methods ExportToFiles(Summary, ILogger) IEnumerable<string> ExportToFiles(Summary summary, ILogger consoleLogger) Parameters summary Summary consoleLogger ILogger Returns IEnumerable<string> ExportToLog(Summary, ILogger) void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger"
  },
  "api/BenchmarkDotNet.Exporters.Json.html": {
    "href": "api/BenchmarkDotNet.Exporters.Json.html",
    "title": "Namespace BenchmarkDotNet.Exporters.Json | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Exporters.Json Classes JsonExporter JsonExporterBase"
  },
  "api/BenchmarkDotNet.Exporters.Json.JsonExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.Json.JsonExporter.html",
    "title": "Class JsonExporter | BenchmarkDotNet",
    "summary": "Class JsonExporter Namespace BenchmarkDotNet.Exporters.Json Assembly BenchmarkDotNet.dll public class JsonExporter : JsonExporterBase, IExporter Inheritance object ExporterBase JsonExporterBase JsonExporter Implements IExporter Inherited Members JsonExporterBase.ExportToLog(Summary, ILogger) JsonExporterBase.GetDataToSerialize(Summary) JsonExporterBase.GetDataToSerialize(HostEnvironmentInfo) JsonExporterBase.GetDataToSerialize(BenchmarkReport) JsonExporterBase.FileExtension ExporterBase.ExportToFiles(Summary, ILogger) ExporterBase.Name ExporterBase.FileCaption Constructors JsonExporter(string, bool, bool) public JsonExporter(string fileNameSuffix = \"\", bool indentJson = false, bool excludeMeasurements = false) Parameters fileNameSuffix string indentJson bool excludeMeasurements bool Fields Brief public static readonly IExporter Brief Field Value IExporter BriefCompressed public static readonly IExporter BriefCompressed Field Value IExporter Default public static readonly IExporter Default Field Value IExporter Full public static readonly IExporter Full Field Value IExporter FullCompressed public static readonly IExporter FullCompressed Field Value IExporter Properties FileNameSuffix protected override string FileNameSuffix { get; } Property Value string Methods Custom(string, bool, bool) public static IExporter Custom(string fileNameSuffix = \"\", bool indentJson = false, bool excludeMeasurements = false) Parameters fileNameSuffix string indentJson bool excludeMeasurements bool Returns IExporter"
  },
  "api/BenchmarkDotNet.Exporters.Json.JsonExporterBase.html": {
    "href": "api/BenchmarkDotNet.Exporters.Json.JsonExporterBase.html",
    "title": "Class JsonExporterBase | BenchmarkDotNet",
    "summary": "Class JsonExporterBase Namespace BenchmarkDotNet.Exporters.Json Assembly BenchmarkDotNet.dll public abstract class JsonExporterBase : ExporterBase, IExporter Inheritance object ExporterBase JsonExporterBase Implements IExporter Derived JsonExporter Inherited Members ExporterBase.ExportToFiles(Summary, ILogger) ExporterBase.Name ExporterBase.FileNameSuffix ExporterBase.FileCaption Constructors JsonExporterBase(bool, bool) protected JsonExporterBase(bool indentJson = false, bool excludeMeasurements = false) Parameters indentJson bool excludeMeasurements bool Properties FileExtension protected override string FileExtension { get; } Property Value string Methods ExportToLog(Summary, ILogger) public override void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger GetDataToSerialize(HostEnvironmentInfo) protected virtual IReadOnlyDictionary<string, object> GetDataToSerialize(HostEnvironmentInfo environmentInfo) Parameters environmentInfo HostEnvironmentInfo Returns IReadOnlyDictionary<string, object> GetDataToSerialize(BenchmarkReport) protected virtual IReadOnlyDictionary<string, object> GetDataToSerialize(BenchmarkReport report) Parameters report BenchmarkReport Returns IReadOnlyDictionary<string, object> GetDataToSerialize(Summary) protected virtual IReadOnlyDictionary<string, object> GetDataToSerialize(Summary summary) Parameters summary Summary Returns IReadOnlyDictionary<string, object>"
  },
  "api/BenchmarkDotNet.Exporters.MarkdownExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.MarkdownExporter.html",
    "title": "Class MarkdownExporter | BenchmarkDotNet",
    "summary": "Class MarkdownExporter Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public class MarkdownExporter : ExporterBase, IExporter Inheritance object ExporterBase MarkdownExporter Implements IExporter Inherited Members ExporterBase.ExportToFiles(Summary, ILogger) ExporterBase.Name ExporterBase.FileCaption Constructors MarkdownExporter() protected MarkdownExporter() Fields Atlassian public static readonly IExporter Atlassian Field Value IExporter BoldMarkupFormat protected string BoldMarkupFormat Field Value string CodeBlockEnd protected string CodeBlockEnd Field Value string CodeBlockStart protected string CodeBlockStart Field Value string ColumnsStartWithSeparator protected bool ColumnsStartWithSeparator Field Value bool Console public static readonly IExporter Console Field Value IExporter Default public static readonly IExporter Default Field Value IExporter EscapeHtml protected bool EscapeHtml Field Value bool GitHub public static readonly IExporter GitHub Field Value IExporter Prefix protected string Prefix Field Value string StackOverflow public static readonly IExporter StackOverflow Field Value IExporter StartOfGroupHighlightStrategy protected MarkdownExporter.MarkdownHighlightStrategy StartOfGroupHighlightStrategy Field Value MarkdownExporter.MarkdownHighlightStrategy TableColumnSeparator protected string TableColumnSeparator Field Value string TableHeaderSeparator protected string TableHeaderSeparator Field Value string UseCodeBlocks protected bool UseCodeBlocks Field Value bool UseHeaderSeparatingRow protected bool UseHeaderSeparatingRow Field Value bool Properties Dialect protected string Dialect { get; set; } Property Value string FileExtension protected override string FileExtension { get; } Property Value string FileNameSuffix protected override string FileNameSuffix { get; } Property Value string Methods ExportToLog(Summary, ILogger) public override void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger"
  },
  "api/BenchmarkDotNet.Exporters.MarkdownExporter.MarkdownHighlightStrategy.html": {
    "href": "api/BenchmarkDotNet.Exporters.MarkdownExporter.MarkdownHighlightStrategy.html",
    "title": "Enum MarkdownExporter.MarkdownHighlightStrategy | BenchmarkDotNet",
    "summary": "Enum MarkdownExporter.MarkdownHighlightStrategy Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public enum MarkdownExporter.MarkdownHighlightStrategy Fields Bold = 1 Marker = 2 None = 0"
  },
  "api/BenchmarkDotNet.Exporters.PlainExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.PlainExporter.html",
    "title": "Class PlainExporter | BenchmarkDotNet",
    "summary": "Class PlainExporter Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public class PlainExporter : ExporterBase, IExporter Inheritance object ExporterBase PlainExporter Implements IExporter Inherited Members ExporterBase.ExportToFiles(Summary, ILogger) ExporterBase.Name ExporterBase.FileExtension ExporterBase.FileNameSuffix ExporterBase.FileCaption Fields Default public static readonly IExporter Default Field Value IExporter Methods ExportToLog(Summary, ILogger) public override void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger"
  },
  "api/BenchmarkDotNet.Exporters.RPlotExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.RPlotExporter.html",
    "title": "Class RPlotExporter | BenchmarkDotNet",
    "summary": "Class RPlotExporter Namespace BenchmarkDotNet.Exporters Assembly BenchmarkDotNet.dll public class RPlotExporter : IExporter Inheritance object RPlotExporter Implements IExporter Constructors RPlotExporter() public RPlotExporter() Fields Default public static readonly IExporter Default Field Value IExporter Properties Dependencies public IEnumerable<IExporter> Dependencies { get; } Property Value IEnumerable<IExporter> Name public string Name { get; } Property Value string Methods ExportToFiles(Summary, ILogger) public IEnumerable<string> ExportToFiles(Summary summary, ILogger consoleLogger) Parameters summary Summary consoleLogger ILogger Returns IEnumerable<string> ExportToLog(Summary, ILogger) public void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger"
  },
  "api/BenchmarkDotNet.Exporters.Xml.html": {
    "href": "api/BenchmarkDotNet.Exporters.Xml.html",
    "title": "Namespace BenchmarkDotNet.Exporters.Xml | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Exporters.Xml Classes XmlExporter XmlExporterBase"
  },
  "api/BenchmarkDotNet.Exporters.Xml.XmlExporter.html": {
    "href": "api/BenchmarkDotNet.Exporters.Xml.XmlExporter.html",
    "title": "Class XmlExporter | BenchmarkDotNet",
    "summary": "Class XmlExporter Namespace BenchmarkDotNet.Exporters.Xml Assembly BenchmarkDotNet.dll public class XmlExporter : XmlExporterBase, IExporter Inheritance object ExporterBase XmlExporterBase XmlExporter Implements IExporter Inherited Members XmlExporterBase.ExportToLog(Summary, ILogger) XmlExporterBase.FileExtension ExporterBase.ExportToFiles(Summary, ILogger) ExporterBase.Name ExporterBase.FileCaption Constructors XmlExporter(string, bool, bool) public XmlExporter(string fileNameSuffix = \"\", bool indentXml = false, bool excludeMeasurements = false) Parameters fileNameSuffix string indentXml bool excludeMeasurements bool Fields Brief public static readonly IExporter Brief Field Value IExporter BriefCompressed public static readonly IExporter BriefCompressed Field Value IExporter Default public static readonly IExporter Default Field Value IExporter Full public static readonly IExporter Full Field Value IExporter FullCompressed public static readonly IExporter FullCompressed Field Value IExporter Properties FileNameSuffix protected override string FileNameSuffix { get; } Property Value string Methods Custom(string, bool, bool) public static IExporter Custom(string fileNameSuffix = \"\", bool indentXml = false, bool excludeMeasurements = false) Parameters fileNameSuffix string indentXml bool excludeMeasurements bool Returns IExporter"
  },
  "api/BenchmarkDotNet.Exporters.Xml.XmlExporterBase.html": {
    "href": "api/BenchmarkDotNet.Exporters.Xml.XmlExporterBase.html",
    "title": "Class XmlExporterBase | BenchmarkDotNet",
    "summary": "Class XmlExporterBase Namespace BenchmarkDotNet.Exporters.Xml Assembly BenchmarkDotNet.dll public abstract class XmlExporterBase : ExporterBase, IExporter Inheritance object ExporterBase XmlExporterBase Implements IExporter Derived XmlExporter Inherited Members ExporterBase.ExportToFiles(Summary, ILogger) ExporterBase.Name ExporterBase.FileNameSuffix ExporterBase.FileCaption Constructors XmlExporterBase(bool, bool) protected XmlExporterBase(bool indentXml = false, bool excludeMeasurements = false) Parameters indentXml bool excludeMeasurements bool Properties FileExtension protected override string FileExtension { get; } Property Value string Methods ExportToLog(Summary, ILogger) public override void ExportToLog(Summary summary, ILogger logger) Parameters summary Summary logger ILogger"
  },
  "api/BenchmarkDotNet.Extensions.ConfigurationExtensions.html": {
    "href": "api/BenchmarkDotNet.Extensions.ConfigurationExtensions.html",
    "title": "Class ConfigurationExtensions | BenchmarkDotNet",
    "summary": "Class ConfigurationExtensions Namespace BenchmarkDotNet.Extensions Assembly BenchmarkDotNet.dll public static class ConfigurationExtensions Inheritance object ConfigurationExtensions Methods ToConfig(Jit) public static string ToConfig(this Jit jit) Parameters jit Jit Returns string ToConfig(Platform) public static string ToConfig(this Platform platform) Parameters platform Platform Returns string"
  },
  "api/BenchmarkDotNet.Extensions.html": {
    "href": "api/BenchmarkDotNet.Extensions.html",
    "title": "Namespace BenchmarkDotNet.Extensions | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Extensions Classes ConfigurationExtensions ReportExtensions StatisticsExtensions"
  },
  "api/BenchmarkDotNet.Extensions.ReportExtensions.html": {
    "href": "api/BenchmarkDotNet.Extensions.ReportExtensions.html",
    "title": "Class ReportExtensions | BenchmarkDotNet",
    "summary": "Class ReportExtensions Namespace BenchmarkDotNet.Extensions Assembly BenchmarkDotNet.dll public static class ReportExtensions Inheritance object ReportExtensions Methods GetReportFor<T>(Summary, Expression<Action<T>>) public static BenchmarkReport GetReportFor<T>(this Summary summary, Expression<Action<T>> actionExp) Parameters summary Summary actionExp Expression<Action<T>> Returns BenchmarkReport Type Parameters T GetRunsFor<T>(Summary, Expression<Action<T>>) public static IList<Measurement> GetRunsFor<T>(this Summary summary, Expression<Action<T>> actionExp) Parameters summary Summary actionExp Expression<Action<T>> Returns IList<Measurement> Type Parameters T GetStatistics(IEnumerable<Measurement>) public static Statistics GetStatistics(this IEnumerable<Measurement> runs) Parameters runs IEnumerable<Measurement> Returns Statistics GetStatistics(IReadOnlyCollection<Measurement>) public static Statistics GetStatistics(this IReadOnlyCollection<Measurement> runs) Parameters runs IReadOnlyCollection<Measurement> Returns Statistics"
  },
  "api/BenchmarkDotNet.Extensions.StatisticsExtensions.html": {
    "href": "api/BenchmarkDotNet.Extensions.StatisticsExtensions.html",
    "title": "Class StatisticsExtensions | BenchmarkDotNet",
    "summary": "Class StatisticsExtensions Namespace BenchmarkDotNet.Extensions Assembly BenchmarkDotNet.dll public static class StatisticsExtensions Inheritance object StatisticsExtensions Methods CreateNanosecondFormatter(Statistics, CultureInfo, string) public static Func<double, string> CreateNanosecondFormatter(this Statistics s, CultureInfo cultureInfo, string format = \"N3\") Parameters s Statistics cultureInfo CultureInfo format string Returns Func<double, string> ToString(Statistics?, CultureInfo, Func<double, string>, bool) public static string ToString(this Statistics? s, CultureInfo cultureInfo, Func<double, string> formatter, bool calcHistogram = false) Parameters s Statistics cultureInfo CultureInfo formatter Func<double, string> calcHistogram bool Returns string"
  },
  "api/BenchmarkDotNet.Filters.AllCategoriesFilter.html": {
    "href": "api/BenchmarkDotNet.Filters.AllCategoriesFilter.html",
    "title": "Class AllCategoriesFilter | BenchmarkDotNet",
    "summary": "Class AllCategoriesFilter Namespace BenchmarkDotNet.Filters Assembly BenchmarkDotNet.dll Filter benchmarks which have all the target categories public class AllCategoriesFilter : IFilter Inheritance object AllCategoriesFilter Implements IFilter Constructors AllCategoriesFilter(string[]) public AllCategoriesFilter(string[] targetCategories) Parameters targetCategories string[] Methods Predicate(BenchmarkCase) public bool Predicate(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Filters.AnyCategoriesFilter.html": {
    "href": "api/BenchmarkDotNet.Filters.AnyCategoriesFilter.html",
    "title": "Class AnyCategoriesFilter | BenchmarkDotNet",
    "summary": "Class AnyCategoriesFilter Namespace BenchmarkDotNet.Filters Assembly BenchmarkDotNet.dll Filter benchmarks which have any of the target categories public class AnyCategoriesFilter : IFilter Inheritance object AnyCategoriesFilter Implements IFilter Constructors AnyCategoriesFilter(string[]) public AnyCategoriesFilter(string[] targetCategories) Parameters targetCategories string[] Methods Predicate(BenchmarkCase) public bool Predicate(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Filters.AttributesFilter.html": {
    "href": "api/BenchmarkDotNet.Filters.AttributesFilter.html",
    "title": "Class AttributesFilter | BenchmarkDotNet",
    "summary": "Class AttributesFilter Namespace BenchmarkDotNet.Filters Assembly BenchmarkDotNet.dll filters benchmarks by provided attribute names public class AttributesFilter : IFilter Inheritance object AttributesFilter Implements IFilter Constructors AttributesFilter(string[]) public AttributesFilter(string[] attributes) Parameters attributes string[] Methods Predicate(BenchmarkCase) public bool Predicate(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Filters.DisjunctionFilter.html": {
    "href": "api/BenchmarkDotNet.Filters.DisjunctionFilter.html",
    "title": "Class DisjunctionFilter | BenchmarkDotNet",
    "summary": "Class DisjunctionFilter Namespace BenchmarkDotNet.Filters Assembly BenchmarkDotNet.dll public class DisjunctionFilter : IFilter Inheritance object DisjunctionFilter Implements IFilter Constructors DisjunctionFilter(params IFilter[]) public DisjunctionFilter(params IFilter[] filters) Parameters filters IFilter[] Methods Predicate(BenchmarkCase) public bool Predicate(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Filters.GlobFilter.html": {
    "href": "api/BenchmarkDotNet.Filters.GlobFilter.html",
    "title": "Class GlobFilter | BenchmarkDotNet",
    "summary": "Class GlobFilter Namespace BenchmarkDotNet.Filters Assembly BenchmarkDotNet.dll filters benchmarks by provided glob patterns public class GlobFilter : IFilter Inheritance object GlobFilter Implements IFilter Constructors GlobFilter(string[]) public GlobFilter(string[] patterns) Parameters patterns string[] Methods Predicate(BenchmarkCase) public bool Predicate(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Filters.html": {
    "href": "api/BenchmarkDotNet.Filters.html",
    "title": "Namespace BenchmarkDotNet.Filters | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Filters Classes AllCategoriesFilter Filter benchmarks which have all the target categories AnyCategoriesFilter Filter benchmarks which have any of the target categories AttributesFilter filters benchmarks by provided attribute names DisjunctionFilter GlobFilter filters benchmarks by provided glob patterns NameFilter SimpleFilter UnionFilter Interfaces IFilter"
  },
  "api/BenchmarkDotNet.Filters.IFilter.html": {
    "href": "api/BenchmarkDotNet.Filters.IFilter.html",
    "title": "Interface IFilter | BenchmarkDotNet",
    "summary": "Interface IFilter Namespace BenchmarkDotNet.Filters Assembly BenchmarkDotNet.dll public interface IFilter Methods Predicate(BenchmarkCase) bool Predicate(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Filters.NameFilter.html": {
    "href": "api/BenchmarkDotNet.Filters.NameFilter.html",
    "title": "Class NameFilter | BenchmarkDotNet",
    "summary": "Class NameFilter Namespace BenchmarkDotNet.Filters Assembly BenchmarkDotNet.dll public class NameFilter : SimpleFilter, IFilter Inheritance object SimpleFilter NameFilter Implements IFilter Inherited Members SimpleFilter.Predicate(BenchmarkCase) Constructors NameFilter(Func<string, bool>) public NameFilter(Func<string, bool> predicate) Parameters predicate Func<string, bool>"
  },
  "api/BenchmarkDotNet.Filters.SimpleFilter.html": {
    "href": "api/BenchmarkDotNet.Filters.SimpleFilter.html",
    "title": "Class SimpleFilter | BenchmarkDotNet",
    "summary": "Class SimpleFilter Namespace BenchmarkDotNet.Filters Assembly BenchmarkDotNet.dll public class SimpleFilter : IFilter Inheritance object SimpleFilter Implements IFilter Derived NameFilter Constructors SimpleFilter(Func<BenchmarkCase, bool>) public SimpleFilter(Func<BenchmarkCase, bool> predicate) Parameters predicate Func<BenchmarkCase, bool> Methods Predicate(BenchmarkCase) public bool Predicate(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Filters.UnionFilter.html": {
    "href": "api/BenchmarkDotNet.Filters.UnionFilter.html",
    "title": "Class UnionFilter | BenchmarkDotNet",
    "summary": "Class UnionFilter Namespace BenchmarkDotNet.Filters Assembly BenchmarkDotNet.dll public class UnionFilter : IFilter Inheritance object UnionFilter Implements IFilter Constructors UnionFilter(params IFilter[]) public UnionFilter(params IFilter[] filters) Parameters filters IFilter[] Methods Predicate(BenchmarkCase) public bool Predicate(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Helpers.AwaitHelper.html": {
    "href": "api/BenchmarkDotNet.Helpers.AwaitHelper.html",
    "title": "Class AwaitHelper | BenchmarkDotNet",
    "summary": "Class AwaitHelper Namespace BenchmarkDotNet.Helpers Assembly BenchmarkDotNet.dll public static class AwaitHelper Inheritance object AwaitHelper Methods GetResult(Task) public static void GetResult(Task task) Parameters task Task GetResult(ValueTask) public static void GetResult(ValueTask task) Parameters task ValueTask GetResult<T>(Task<T>) public static T GetResult<T>(Task<T> task) Parameters task Task<T> Returns T Type Parameters T GetResult<T>(ValueTask<T>) public static T GetResult<T>(ValueTask<T> task) Parameters task ValueTask<T> Returns T Type Parameters T"
  },
  "api/BenchmarkDotNet.Helpers.DisposeAtProcessTermination.html": {
    "href": "api/BenchmarkDotNet.Helpers.DisposeAtProcessTermination.html",
    "title": "Class DisposeAtProcessTermination | BenchmarkDotNet",
    "summary": "Class DisposeAtProcessTermination Namespace BenchmarkDotNet.Helpers Assembly BenchmarkDotNet.dll Ensures that explicit Dispose is called at termination of the Process. public abstract class DisposeAtProcessTermination : IDisposable Inheritance object DisposeAtProcessTermination Implements IDisposable Remarks This class exists to help in reverting system state where C#'s using statement does not suffice. I.e. when Benchmark's process is aborted via Ctrl-C, Ctrl-Break or via click on the X in the upper right of Window. Usage: Derive your clas that changes system state of this class. Revert system state in override of Dispose() implementation. Use your class in C#'s using statement, to ensure system state is reverted in normal situations. This class ensures your override is also called at process 'abort'. Note: This class is explicitly not responsible for cleanup of Native resources. Of course, derived classes can cleanup their Native resources (usually managed via SafeHandle derived classes), by delegating explicit Disposal to their IDisposable fields. Constructors DisposeAtProcessTermination() public DisposeAtProcessTermination() Methods Dispose() public virtual void Dispose()"
  },
  "api/BenchmarkDotNet.Helpers.ExternalToolsHelper.html": {
    "href": "api/BenchmarkDotNet.Helpers.ExternalToolsHelper.html",
    "title": "Class ExternalToolsHelper | BenchmarkDotNet",
    "summary": "Class ExternalToolsHelper Namespace BenchmarkDotNet.Helpers Assembly BenchmarkDotNet.dll public static class ExternalToolsHelper Inheritance object ExternalToolsHelper Fields MacSystemProfilerData Output of the system_profiler SPSoftwareDataType command. MacOSX only. public static readonly Lazy<Dictionary<string, string>> MacSystemProfilerData Field Value Lazy<Dictionary<string, string>>"
  },
  "api/BenchmarkDotNet.Helpers.FolderNameHelper.html": {
    "href": "api/BenchmarkDotNet.Helpers.FolderNameHelper.html",
    "title": "Class FolderNameHelper | BenchmarkDotNet",
    "summary": "Class FolderNameHelper Namespace BenchmarkDotNet.Helpers Assembly BenchmarkDotNet.dll public static class FolderNameHelper Inheritance object FolderNameHelper Methods ToFolderName(object) public static string ToFolderName(object value) Parameters value object Returns string ToFolderName(Type, bool, bool) public static string ToFolderName(Type type, bool includeNamespace = true, bool includeGenericArgumentsNamespace = false) Parameters type Type includeNamespace bool includeGenericArgumentsNamespace bool Returns string"
  },
  "api/BenchmarkDotNet.Helpers.html": {
    "href": "api/BenchmarkDotNet.Helpers.html",
    "title": "Namespace BenchmarkDotNet.Helpers | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Helpers Classes AwaitHelper DisposeAtProcessTermination Ensures that explicit Dispose is called at termination of the Process. ExternalToolsHelper FolderNameHelper SourceCodeHelper UnitHelper"
  },
  "api/BenchmarkDotNet.Helpers.SourceCodeHelper.html": {
    "href": "api/BenchmarkDotNet.Helpers.SourceCodeHelper.html",
    "title": "Class SourceCodeHelper | BenchmarkDotNet",
    "summary": "Class SourceCodeHelper Namespace BenchmarkDotNet.Helpers Assembly BenchmarkDotNet.dll public static class SourceCodeHelper Inheritance object SourceCodeHelper Methods IsCompilationTimeConstant(object) public static bool IsCompilationTimeConstant(object value) Parameters value object Returns bool IsCompilationTimeConstant(Type) public static bool IsCompilationTimeConstant(Type type) Parameters type Type Returns bool ToSourceCode(object) public static string ToSourceCode(object value) Parameters value object Returns string"
  },
  "api/BenchmarkDotNet.Helpers.UnitHelper.html": {
    "href": "api/BenchmarkDotNet.Helpers.UnitHelper.html",
    "title": "Class UnitHelper | BenchmarkDotNet",
    "summary": "Class UnitHelper Namespace BenchmarkDotNet.Helpers Assembly BenchmarkDotNet.dll public static class UnitHelper Inheritance object UnitHelper Fields DefaultPresentation public static readonly UnitPresentation DefaultPresentation Field Value UnitPresentation Methods ToDefaultString(TimeInterval, string?) public static string ToDefaultString(this TimeInterval timeInterval, string? format = null) Parameters timeInterval TimeInterval format string Returns string"
  },
  "api/BenchmarkDotNet.Jobs.AccuracyMode.html": {
    "href": "api/BenchmarkDotNet.Jobs.AccuracyMode.html",
    "title": "Class AccuracyMode | BenchmarkDotNet",
    "summary": "Class AccuracyMode Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public sealed class AccuracyMode : JobMode<AccuracyMode> Inheritance object CharacteristicObject CharacteristicObject<AccuracyMode> JobMode<AccuracyMode> AccuracyMode Inherited Members JobMode<AccuracyMode>.Default JobMode<AccuracyMode>.Job CharacteristicObject<AccuracyMode>.Apply(CharacteristicObject) CharacteristicObject<AccuracyMode>.Apply(params CharacteristicObject[]) CharacteristicObject<AccuracyMode>.ApplyAndFreeze(CharacteristicObject) CharacteristicObject<AccuracyMode>.ApplyAndFreeze(params CharacteristicObject[]) CharacteristicObject<AccuracyMode>.Freeze() CharacteristicObject<AccuracyMode>.UnfreezeCopy() CharacteristicObject.IdCharacteristic CharacteristicObject.GetCharacteristicsWithValues() CharacteristicObject.HasValue(Characteristic) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver, T) CharacteristicObject.ResolveValue(Characteristic, IResolver) CharacteristicObject.ResolveValue(Characteristic, IResolver, object) CharacteristicObject.ResolveValue<T>(Characteristic<T>, T) CharacteristicObject.ResolveValue(Characteristic, object) CharacteristicObject.ResolveValueAsNullable<T>(Characteristic<T>) CharacteristicObject.ToString() CharacteristicObject.Frozen CharacteristicObject.HasChanges CharacteristicObject.Id Extension Methods CharacteristicHelper.GetAllCharacteristics(CharacteristicObject) CharacteristicHelper.GetThisTypeCharacteristics(CharacteristicObject) Constructors AccuracyMode() public AccuracyMode() Fields AnalyzeLaunchVarianceCharacteristic public static readonly Characteristic<bool> AnalyzeLaunchVarianceCharacteristic Field Value Characteristic<bool> EvaluateOverheadCharacteristic public static readonly Characteristic<bool> EvaluateOverheadCharacteristic Field Value Characteristic<bool> MaxAbsoluteErrorCharacteristic public static readonly Characteristic<TimeInterval> MaxAbsoluteErrorCharacteristic Field Value Characteristic<TimeInterval> MaxRelativeErrorCharacteristic public static readonly Characteristic<double> MaxRelativeErrorCharacteristic Field Value Characteristic<double> MinInvokeCountCharacteristic public static readonly Characteristic<int> MinInvokeCountCharacteristic Field Value Characteristic<int> MinIterationTimeCharacteristic public static readonly Characteristic<TimeInterval> MinIterationTimeCharacteristic Field Value Characteristic<TimeInterval> OutlierModeCharacteristic public static readonly Characteristic<OutlierMode> OutlierModeCharacteristic Field Value Characteristic<OutlierMode> Properties AnalyzeLaunchVariance public bool AnalyzeLaunchVariance { get; set; } Property Value bool EvaluateOverhead Specifies if the overhead should be evaluated (Idle runs) and it's average value subtracted from every result. True by default, very important for nano-benchmarks. public bool EvaluateOverhead { get; set; } Property Value bool MaxAbsoluteError Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error). Doesn't have a default value. If MaxRelativeError is also provided, the smallest value is used as stop criteria. public TimeInterval MaxAbsoluteError { get; set; } Property Value TimeInterval MaxRelativeError Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error). The default value is 0.02. If MaxAbsoluteError is also provided, the smallest value is used as stop criteria. public double MaxRelativeError { get; set; } Property Value double MinInvokeCount Minimum count of benchmark invocations per iteration. The default value is 4. public int MinInvokeCount { get; set; } Property Value int MinIterationTime Minimum time of a single iteration. Unlike Run.IterationTime, this characteristic specifies only the lower limit. In case of need, BenchmarkDotNet can increase this value. The default value is 500 milliseconds. public TimeInterval MinIterationTime { get; set; } Property Value TimeInterval OutlierMode Specifies which outliers should be removed from the distribution. public OutlierMode OutlierMode { get; set; } Property Value OutlierMode"
  },
  "api/BenchmarkDotNet.Jobs.Argument.html": {
    "href": "api/BenchmarkDotNet.Jobs.Argument.html",
    "title": "Class Argument | BenchmarkDotNet",
    "summary": "Class Argument Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public abstract class Argument : IEquatable<Argument> Inheritance object Argument Implements IEquatable<Argument> Derived MonoArgument MsBuildArgument Constructors Argument(string) protected Argument(string value) Parameters value string Properties TextRepresentation public string TextRepresentation { get; } Property Value string Methods Equals(Argument) public bool Equals(Argument other) Parameters other Argument Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Jobs.EnvironmentMode.html": {
    "href": "api/BenchmarkDotNet.Jobs.EnvironmentMode.html",
    "title": "Class EnvironmentMode | BenchmarkDotNet",
    "summary": "Class EnvironmentMode Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public sealed class EnvironmentMode : JobMode<EnvironmentMode> Inheritance object CharacteristicObject CharacteristicObject<EnvironmentMode> JobMode<EnvironmentMode> EnvironmentMode Inherited Members JobMode<EnvironmentMode>.Default JobMode<EnvironmentMode>.Job CharacteristicObject<EnvironmentMode>.Apply(CharacteristicObject) CharacteristicObject<EnvironmentMode>.Apply(params CharacteristicObject[]) CharacteristicObject<EnvironmentMode>.ApplyAndFreeze(CharacteristicObject) CharacteristicObject<EnvironmentMode>.ApplyAndFreeze(params CharacteristicObject[]) CharacteristicObject<EnvironmentMode>.Freeze() CharacteristicObject<EnvironmentMode>.UnfreezeCopy() CharacteristicObject.IdCharacteristic CharacteristicObject.GetCharacteristicsWithValues() CharacteristicObject.HasValue(Characteristic) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver, T) CharacteristicObject.ResolveValue(Characteristic, IResolver) CharacteristicObject.ResolveValue(Characteristic, IResolver, object) CharacteristicObject.ResolveValue<T>(Characteristic<T>, T) CharacteristicObject.ResolveValue(Characteristic, object) CharacteristicObject.ResolveValueAsNullable<T>(Characteristic<T>) CharacteristicObject.ToString() CharacteristicObject.Frozen CharacteristicObject.HasChanges CharacteristicObject.Id Extension Methods CharacteristicHelper.GetAllCharacteristics(CharacteristicObject) CharacteristicHelper.GetThisTypeCharacteristics(CharacteristicObject) Constructors EnvironmentMode() public EnvironmentMode() EnvironmentMode(Runtime) public EnvironmentMode(Runtime runtime) Parameters runtime Runtime EnvironmentMode(string) public EnvironmentMode(string id) Parameters id string EnvironmentMode(string, Jit, Platform) public EnvironmentMode(string id, Jit jit, Platform platform) Parameters id string jit Jit platform Platform Fields AffinityCharacteristic public static readonly Characteristic<nint> AffinityCharacteristic Field Value Characteristic<nint> EnvironmentVariablesCharacteristic public static readonly Characteristic<IReadOnlyList<EnvironmentVariable>> EnvironmentVariablesCharacteristic Field Value Characteristic<IReadOnlyList<EnvironmentVariable>> GcCharacteristic public static readonly Characteristic<GcMode> GcCharacteristic Field Value Characteristic<GcMode> JitCharacteristic public static readonly Characteristic<Jit> JitCharacteristic Field Value Characteristic<Jit> LargeAddressAwareCharacteristic public static readonly Characteristic<bool> LargeAddressAwareCharacteristic Field Value Characteristic<bool> LegacyJitX64 public static readonly EnvironmentMode LegacyJitX64 Field Value EnvironmentMode LegacyJitX86 public static readonly EnvironmentMode LegacyJitX86 Field Value EnvironmentMode PlatformCharacteristic public static readonly Characteristic<Platform> PlatformCharacteristic Field Value Characteristic<Platform> PowerPlanModeCharacteristic public static readonly Characteristic<Guid?> PowerPlanModeCharacteristic Field Value Characteristic<Guid?> RuntimeCharacteristic public static readonly Characteristic<Runtime> RuntimeCharacteristic Field Value Characteristic<Runtime> RyuJitX64 public static readonly EnvironmentMode RyuJitX64 Field Value EnvironmentMode RyuJitX86 public static readonly EnvironmentMode RyuJitX86 Field Value EnvironmentMode Properties Affinity ProcessorAffinity for the benchmark process. See also: https://msdn.microsoft.com/library/system.diagnostics.process.processoraffinity.aspx public nint Affinity { get; set; } Property Value nint EnvironmentVariables public IReadOnlyList<EnvironmentVariable> EnvironmentVariables { get; set; } Property Value IReadOnlyList<EnvironmentVariable> Gc GcMode public GcMode Gc { get; } Property Value GcMode Jit JIT (Just-In-Time compiler) public Jit Jit { get; set; } Property Value Jit LargeAddressAware Specifies that benchmark can handle addresses larger than 2 gigabytes. false: Benchmark uses the default (64-bit: enabled; 32-bit:disabled). This is the default. true: Explicitly specify that benchmark can handle addresses larger than 2 gigabytes. public bool LargeAddressAware { get; set; } Property Value bool Platform Platform (x86 or x64) public Platform Platform { get; set; } Property Value Platform PowerPlanMode Power Plan Mode public Guid? PowerPlanMode { get; set; } Property Value Guid? Remarks Supported only on Windows. Runtime Runtime public Runtime? Runtime { get; set; } Property Value Runtime Methods SetEnvironmentVariable(EnvironmentVariable) Adds the specified variable to EnvironmentVariables. If EnvironmentVariables already contains a variable with the same key, it will be overriden. public void SetEnvironmentVariable(EnvironmentVariable variable) Parameters variable EnvironmentVariable The new environment variable which should be added to EnvironmentVariables"
  },
  "api/BenchmarkDotNet.Jobs.EnvironmentVariable.html": {
    "href": "api/BenchmarkDotNet.Jobs.EnvironmentVariable.html",
    "title": "Class EnvironmentVariable | BenchmarkDotNet",
    "summary": "Class EnvironmentVariable Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public class EnvironmentVariable : IEquatable<EnvironmentVariable> Inheritance object EnvironmentVariable Implements IEquatable<EnvironmentVariable> Constructors EnvironmentVariable(string, string) public EnvironmentVariable(string key, string value) Parameters key string value string Properties Key public string Key { get; } Property Value string Value public string Value { get; } Property Value string Methods Equals(EnvironmentVariable) public bool Equals(EnvironmentVariable other) Parameters other EnvironmentVariable Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Jobs.GcMode.html": {
    "href": "api/BenchmarkDotNet.Jobs.GcMode.html",
    "title": "Class GcMode | BenchmarkDotNet",
    "summary": "Class GcMode Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public sealed class GcMode : JobMode<GcMode>, IEquatable<GcMode> Inheritance object CharacteristicObject CharacteristicObject<GcMode> JobMode<GcMode> GcMode Implements IEquatable<GcMode> Inherited Members JobMode<GcMode>.Default JobMode<GcMode>.Job CharacteristicObject<GcMode>.Apply(CharacteristicObject) CharacteristicObject<GcMode>.Apply(params CharacteristicObject[]) CharacteristicObject<GcMode>.ApplyAndFreeze(CharacteristicObject) CharacteristicObject<GcMode>.ApplyAndFreeze(params CharacteristicObject[]) CharacteristicObject<GcMode>.Freeze() CharacteristicObject<GcMode>.UnfreezeCopy() CharacteristicObject.IdCharacteristic CharacteristicObject.GetCharacteristicsWithValues() CharacteristicObject.HasValue(Characteristic) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver, T) CharacteristicObject.ResolveValue(Characteristic, IResolver) CharacteristicObject.ResolveValue(Characteristic, IResolver, object) CharacteristicObject.ResolveValue<T>(Characteristic<T>, T) CharacteristicObject.ResolveValue(Characteristic, object) CharacteristicObject.ResolveValueAsNullable<T>(Characteristic<T>) CharacteristicObject.ToString() CharacteristicObject.Frozen CharacteristicObject.HasChanges CharacteristicObject.Id Extension Methods CharacteristicHelper.GetAllCharacteristics(CharacteristicObject) CharacteristicHelper.GetThisTypeCharacteristics(CharacteristicObject) GcModeExtensions.WithAllowVeryLargeObjects(GcMode, bool) GcModeExtensions.WithConcurrent(GcMode, bool) GcModeExtensions.WithCpuGroups(GcMode, bool) GcModeExtensions.WithForce(GcMode, bool) GcModeExtensions.WithHeapAffinitizeMask(GcMode, int) GcModeExtensions.WithHeapCount(GcMode, int) GcModeExtensions.WithNoAffinitize(GcMode, bool) GcModeExtensions.WithRetainVm(GcMode, bool) GcModeExtensions.WithServer(GcMode, bool) Constructors GcMode() public GcMode() Fields AllowVeryLargeObjectsCharacteristic public static readonly Characteristic<bool> AllowVeryLargeObjectsCharacteristic Field Value Characteristic<bool> ConcurrentCharacteristic public static readonly Characteristic<bool> ConcurrentCharacteristic Field Value Characteristic<bool> CpuGroupsCharacteristic public static readonly Characteristic<bool> CpuGroupsCharacteristic Field Value Characteristic<bool> ForceCharacteristic public static readonly Characteristic<bool> ForceCharacteristic Field Value Characteristic<bool> HeapAffinitizeMaskCharacteristic public static readonly Characteristic<int> HeapAffinitizeMaskCharacteristic Field Value Characteristic<int> HeapCountCharacteristic public static readonly Characteristic<int> HeapCountCharacteristic Field Value Characteristic<int> NoAffinitizeCharacteristic public static readonly Characteristic<bool> NoAffinitizeCharacteristic Field Value Characteristic<bool> RetainVmCharacteristic public static readonly Characteristic<bool> RetainVmCharacteristic Field Value Characteristic<bool> ServerCharacteristic public static readonly Characteristic<bool> ServerCharacteristic Field Value Characteristic<bool> Properties AllowVeryLargeObjects On 64-bit platforms, enables arrays that are greater than 2 gigabytes (GB) in total size. false: Arrays greater than 2 GB in total size are not enabled. This is the default. true: Arrays greater than 2 GB in total size are enabled on 64-bit platforms. public bool AllowVeryLargeObjects { get; set; } Property Value bool Concurrent Specifies whether the common language runtime runs garbage collection on a separate thread. false: Does not run garbage collection concurrently. true: Runs garbage collection concurrently. This is the default. public bool Concurrent { get; set; } Property Value bool CpuGroups Specifies whether garbage collection supports multiple CPU groups. false: Garbage collection does not support multiple CPU groups. This is the default. true: Garbage collection supports multiple CPU groups, if server garbage collection is enabled. public bool CpuGroups { get; set; } Property Value bool Force Specifies whether the BenchmarkDotNet's benchmark runner forces full garbage collection after each benchmark invocation false: Does not force garbage collection. true: Forces full garbage collection after each benchmark invocation. This is the default. public bool Force { get; set; } Property Value bool HeapAffinitizeMask process mask, see MSDN for more. public int HeapAffinitizeMask { get; set; } Property Value int HeapCount specify the # of Server GC threads/heaps, must be smaller than the # of logical CPUs the process is allowed to run on, ie, if you don't specifically affinitize your process it means the # of total logical CPUs on the machine; otherwise this is the # of logical CPUs you affinitized your process to. public int HeapCount { get; set; } Property Value int NoAffinitize specify true to disable hard affinity of Server GC threads to CPUs public bool NoAffinitize { get; set; } Property Value bool RetainVm Put segments that should be deleted on a standby list for future use instead of releasing them back to the OS The default is false public bool RetainVm { get; set; } Property Value bool Server Specifies whether the common language runtime runs server garbage collection. false: Does not run server garbage collection. This is the default. true: Runs server garbage collection. public bool Server { get; set; } Property Value bool Methods Equals(GcMode) public bool Equals(GcMode other) Parameters other GcMode Returns bool GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/BenchmarkDotNet.Jobs.GcModeExtensions.html": {
    "href": "api/BenchmarkDotNet.Jobs.GcModeExtensions.html",
    "title": "Class GcModeExtensions | BenchmarkDotNet",
    "summary": "Class GcModeExtensions Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public static class GcModeExtensions Inheritance object GcModeExtensions Methods WithAllowVeryLargeObjects(GcMode, bool) On 64-bit platforms, enables arrays that are greater than 2 gigabytes (GB) in total size. false: Arrays greater than 2 GB in total size are not enabled. This is the default. true: Arrays greater than 2 GB in total size are enabled on 64-bit platforms. public static GcMode WithAllowVeryLargeObjects(this GcMode mode, bool value) Parameters mode GcMode value bool Returns GcMode WithConcurrent(GcMode, bool) Specifies whether the common language runtime runs garbage collection on a separate thread. false: Does not run garbage collection concurrently. true: Runs garbage collection concurrently. This is the default. public static GcMode WithConcurrent(this GcMode mode, bool value) Parameters mode GcMode value bool Returns GcMode WithCpuGroups(GcMode, bool) Specifies whether garbage collection supports multiple CPU groups. false: Garbage collection does not support multiple CPU groups. This is the default. true: Garbage collection supports multiple CPU groups, if server garbage collection is enabled. public static GcMode WithCpuGroups(this GcMode mode, bool value) Parameters mode GcMode value bool Returns GcMode WithForce(GcMode, bool) Specifies whether the BenchmarkDotNet's benchmark runner forces full garbage collection after each benchmark invocation false: Does not force garbage collection. true: Forces full garbage collection after each benchmark invocation. This is the default. public static GcMode WithForce(this GcMode mode, bool value) Parameters mode GcMode value bool Returns GcMode WithHeapAffinitizeMask(GcMode, int) process mask, see MSDN for more. public static GcMode WithHeapAffinitizeMask(this GcMode mode, int heapAffinitizeMask) Parameters mode GcMode heapAffinitizeMask int Returns GcMode WithHeapCount(GcMode, int) specify the # of Server GC threads/heaps, must be smaller than the # of logical CPUs the process is allowed to run on, ie, if you don't specifically affinitize your process it means the # of total logical CPUs on the machine; otherwise this is the # of logical CPUs you affinitized your process to. public static GcMode WithHeapCount(this GcMode mode, int heapCount) Parameters mode GcMode heapCount int Returns GcMode WithNoAffinitize(GcMode, bool) specify true to disable hard affinity of Server GC threads to CPUs public static GcMode WithNoAffinitize(this GcMode mode, bool value) Parameters mode GcMode value bool Returns GcMode WithRetainVm(GcMode, bool) Put segments that should be deleted on a standby list for future use instead of releasing them back to the OS The default is false public static GcMode WithRetainVm(this GcMode mode, bool value) Parameters mode GcMode value bool Returns GcMode WithServer(GcMode, bool) Specifies whether the common language runtime runs server garbage collection. false: Does not run server garbage collection. This is the default. true: Runs server garbage collection. public static GcMode WithServer(this GcMode mode, bool value) Parameters mode GcMode value bool Returns GcMode"
  },
  "api/BenchmarkDotNet.Jobs.html": {
    "href": "api/BenchmarkDotNet.Jobs.html",
    "title": "Namespace BenchmarkDotNet.Jobs | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Jobs Classes AccuracyMode Argument EnvironmentMode EnvironmentVariable GcMode GcModeExtensions InfrastructureMode Job JobExtensions JobIdGenerator JobMode<T> MetaMode MonoArgument Argument passed directly to mono when executing benchmarks (mono [options]) example: new MonoArgument(\"--gc=sgen\") MsBuildArgument Argument passed to dotnet cli when restoring and building the project example: new MsBuildArgument(\"/p:MyCustomSetting=123\") NuGetReference NuGetReferenceList An ordered list of NuGet references. Does not allow duplicate references with the same PackageName. RunMode Enums RuntimeMoniker"
  },
  "api/BenchmarkDotNet.Jobs.InfrastructureMode.html": {
    "href": "api/BenchmarkDotNet.Jobs.InfrastructureMode.html",
    "title": "Class InfrastructureMode | BenchmarkDotNet",
    "summary": "Class InfrastructureMode Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public sealed class InfrastructureMode : JobMode<InfrastructureMode> Inheritance object CharacteristicObject CharacteristicObject<InfrastructureMode> JobMode<InfrastructureMode> InfrastructureMode Inherited Members JobMode<InfrastructureMode>.Default JobMode<InfrastructureMode>.Job CharacteristicObject<InfrastructureMode>.Apply(CharacteristicObject) CharacteristicObject<InfrastructureMode>.Apply(params CharacteristicObject[]) CharacteristicObject<InfrastructureMode>.ApplyAndFreeze(CharacteristicObject) CharacteristicObject<InfrastructureMode>.ApplyAndFreeze(params CharacteristicObject[]) CharacteristicObject<InfrastructureMode>.Freeze() CharacteristicObject<InfrastructureMode>.UnfreezeCopy() CharacteristicObject.IdCharacteristic CharacteristicObject.GetCharacteristicsWithValues() CharacteristicObject.HasValue(Characteristic) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver, T) CharacteristicObject.ResolveValue(Characteristic, IResolver) CharacteristicObject.ResolveValue(Characteristic, IResolver, object) CharacteristicObject.ResolveValue<T>(Characteristic<T>, T) CharacteristicObject.ResolveValue(Characteristic, object) CharacteristicObject.ResolveValueAsNullable<T>(Characteristic<T>) CharacteristicObject.ToString() CharacteristicObject.Frozen CharacteristicObject.HasChanges CharacteristicObject.Id Extension Methods CharacteristicHelper.GetAllCharacteristics(CharacteristicObject) CharacteristicHelper.GetThisTypeCharacteristics(CharacteristicObject) Constructors InfrastructureMode() public InfrastructureMode() Fields ArgumentsCharacteristic public static readonly Characteristic<IReadOnlyList<Argument>> ArgumentsCharacteristic Field Value Characteristic<IReadOnlyList<Argument>> BuildConfigurationCharacteristic public static readonly Characteristic<string> BuildConfigurationCharacteristic Field Value Characteristic<string> ClockCharacteristic public static readonly Characteristic<IClock> ClockCharacteristic Field Value Characteristic<IClock> EngineFactoryCharacteristic public static readonly Characteristic<IEngineFactory> EngineFactoryCharacteristic Field Value Characteristic<IEngineFactory> InProcess public static readonly InfrastructureMode InProcess Field Value InfrastructureMode InProcessDontLogOutput public static readonly InfrastructureMode InProcessDontLogOutput Field Value InfrastructureMode NuGetReferencesCharacteristic public static readonly Characteristic<IReadOnlyCollection<NuGetReference>> NuGetReferencesCharacteristic Field Value Characteristic<IReadOnlyCollection<NuGetReference>> ReleaseConfigurationName public const string ReleaseConfigurationName = \"Release\" Field Value string ToolchainCharacteristic public static readonly Characteristic<IToolchain> ToolchainCharacteristic Field Value Characteristic<IToolchain> Properties Arguments public IReadOnlyList<Argument> Arguments { get; set; } Property Value IReadOnlyList<Argument> BuildConfiguration public string BuildConfiguration { get; set; } Property Value string Clock public IClock Clock { get; set; } Property Value IClock EngineFactory this type will be used in the auto-generated program to create engine in separate process it must have parameterless constructor public IEngineFactory EngineFactory { get; set; } Property Value IEngineFactory NuGetReferences public IReadOnlyCollection<NuGetReference> NuGetReferences { get; set; } Property Value IReadOnlyCollection<NuGetReference> Toolchain public IToolchain Toolchain { get; set; } Property Value IToolchain Methods TryGetToolchain(out IToolchain) public bool TryGetToolchain(out IToolchain toolchain) Parameters toolchain IToolchain Returns bool"
  },
  "api/BenchmarkDotNet.Jobs.Job.html": {
    "href": "api/BenchmarkDotNet.Jobs.Job.html",
    "title": "Class Job | BenchmarkDotNet",
    "summary": "Class Job Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public sealed class Job : JobMode<Job> Inheritance object CharacteristicObject CharacteristicObject<Job> JobMode<Job> Job Inherited Members JobMode<Job>.Default JobMode<Job>.Job CharacteristicObject<Job>.Apply(CharacteristicObject) CharacteristicObject<Job>.Apply(params CharacteristicObject[]) CharacteristicObject<Job>.ApplyAndFreeze(CharacteristicObject) CharacteristicObject<Job>.ApplyAndFreeze(params CharacteristicObject[]) CharacteristicObject<Job>.Freeze() CharacteristicObject<Job>.UnfreezeCopy() CharacteristicObject.IdCharacteristic CharacteristicObject.GetCharacteristicsWithValues() CharacteristicObject.HasValue(Characteristic) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver, T) CharacteristicObject.ResolveValue(Characteristic, IResolver) CharacteristicObject.ResolveValue(Characteristic, IResolver, object) CharacteristicObject.ResolveValue<T>(Characteristic<T>, T) CharacteristicObject.ResolveValue(Characteristic, object) CharacteristicObject.ResolveValueAsNullable<T>(Characteristic<T>) CharacteristicObject.ToString() CharacteristicObject.Frozen CharacteristicObject.HasChanges CharacteristicObject.Id Extension Methods CharacteristicHelper.GetAllCharacteristics(CharacteristicObject) CharacteristicHelper.GetThisTypeCharacteristics(CharacteristicObject) JobExtensions.AsBaseline(Job) JobExtensions.AsDefault(Job, bool) JobExtensions.AsMutator(Job) JobExtensions.DontEnforcePowerPlan(Job) JobExtensions.RunOncePerIteration(Job) JobExtensions.WithAffinity(Job, nint) JobExtensions.WithAnalyzeLaunchVariance(Job, bool) JobExtensions.WithArguments(Job, IReadOnlyList<Argument>) JobExtensions.WithBaseline(Job, bool) JobExtensions.WithClock(Job, IClock) JobExtensions.WithCustomBuildConfiguration(Job, string) JobExtensions.WithEngineFactory(Job, IEngineFactory) JobExtensions.WithEnvironmentVariable(Job, EnvironmentVariable) JobExtensions.WithEnvironmentVariable(Job, string, string) JobExtensions.WithEnvironmentVariables(Job, params EnvironmentVariable[]) JobExtensions.WithEvaluateOverhead(Job, bool) JobExtensions.WithGcAllowVeryLargeObjects(Job, bool) JobExtensions.WithGcConcurrent(Job, bool) JobExtensions.WithGcCpuGroups(Job, bool) JobExtensions.WithGcForce(Job, bool) JobExtensions.WithGcMode(Job, GcMode) JobExtensions.WithGcRetainVm(Job, bool) JobExtensions.WithGcServer(Job, bool) JobExtensions.WithHeapAffinitizeMask(Job, int) JobExtensions.WithHeapCount(Job, int) JobExtensions.WithId(Job, string) JobExtensions.WithInvocationCount(Job, long) JobExtensions.WithIterationCount(Job, int) JobExtensions.WithIterationTime(Job, TimeInterval) JobExtensions.WithJit(Job, Jit) JobExtensions.WithLargeAddressAware(Job, bool) JobExtensions.WithLaunchCount(Job, int) JobExtensions.WithMaxAbsoluteError(Job, TimeInterval) JobExtensions.WithMaxIterationCount(Job, int) JobExtensions.WithMaxRelativeError(Job, double) JobExtensions.WithMaxWarmupCount(Job, int) JobExtensions.WithMemoryRandomization(Job, bool) JobExtensions.WithMinInvokeCount(Job, int) JobExtensions.WithMinIterationCount(Job, int) JobExtensions.WithMinIterationTime(Job, TimeInterval) JobExtensions.WithMinWarmupCount(Job, int) JobExtensions.WithNoAffinitize(Job, bool) JobExtensions.WithNuGet(Job, NuGetReferenceList) JobExtensions.WithNuGet(Job, string, string?, Uri?, bool) JobExtensions.WithoutEnvironmentVariables(Job) JobExtensions.WithOutlierMode(Job, OutlierMode) JobExtensions.WithPlatform(Job, Platform) JobExtensions.WithPowerPlan(Job, PowerPlan) JobExtensions.WithPowerPlan(Job, Guid) JobExtensions.WithRuntime(Job, Runtime) JobExtensions.WithStrategy(Job, RunStrategy) JobExtensions.WithToolchain(Job, IToolchain) JobExtensions.WithUnrollFactor(Job, int) JobExtensions.WithWarmupCount(Job, int) Constructors Job() public Job() Job(CharacteristicObject) public Job(CharacteristicObject other) Parameters other CharacteristicObject Job(params CharacteristicObject[]) public Job(params CharacteristicObject[] others) Parameters others CharacteristicObject[] Job(string?) public Job(string? id) Parameters id string Job(string?, CharacteristicObject) public Job(string? id, CharacteristicObject other) Parameters id string other CharacteristicObject Job(string?, params CharacteristicObject[]) public Job(string? id, params CharacteristicObject[] others) Parameters id string others CharacteristicObject[] Fields AccuracyCharacteristic public static readonly Characteristic<AccuracyMode> AccuracyCharacteristic Field Value Characteristic<AccuracyMode> Dry public static readonly Job Dry Field Value Job EnvironmentCharacteristic public static readonly Characteristic<EnvironmentMode> EnvironmentCharacteristic Field Value Characteristic<EnvironmentMode> InProcess public static readonly Job InProcess Field Value Job InProcessDontLogOutput public static readonly Job InProcessDontLogOutput Field Value Job InfrastructureCharacteristic public static readonly Characteristic<InfrastructureMode> InfrastructureCharacteristic Field Value Characteristic<InfrastructureMode> LegacyJitX64 public static readonly Job LegacyJitX64 Field Value Job LegacyJitX86 public static readonly Job LegacyJitX86 Field Value Job LongRun public static readonly Job LongRun Field Value Job MediumRun public static readonly Job MediumRun Field Value Job MetaCharacteristic public static readonly Characteristic<MetaMode> MetaCharacteristic Field Value Characteristic<MetaMode> RunCharacteristic public static readonly Characteristic<RunMode> RunCharacteristic Field Value Characteristic<RunMode> RyuJitX64 public static readonly Job RyuJitX64 Field Value Job RyuJitX86 public static readonly Job RyuJitX86 Field Value Job ShortRun public static readonly Job ShortRun Field Value Job VeryLongRun public static readonly Job VeryLongRun Field Value Job Properties Accuracy public AccuracyMode Accuracy { get; } Property Value AccuracyMode DisplayInfo public string DisplayInfo { get; } Property Value string Environment public EnvironmentMode Environment { get; } Property Value EnvironmentMode FolderInfo public string FolderInfo { get; } Property Value string Infrastructure public InfrastructureMode Infrastructure { get; } Property Value InfrastructureMode Meta public MetaMode Meta { get; } Property Value MetaMode ResolvedId public string ResolvedId { get; } Property Value string Run public RunMode Run { get; } Property Value RunMode"
  },
  "api/BenchmarkDotNet.Jobs.JobExtensions.html": {
    "href": "api/BenchmarkDotNet.Jobs.JobExtensions.html",
    "title": "Class JobExtensions | BenchmarkDotNet",
    "summary": "Class JobExtensions Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public static class JobExtensions Inheritance object JobExtensions Methods AsBaseline(Job) public static Job AsBaseline(this Job job) Parameters job Job Returns Job AsDefault(Job, bool) use it if you want to specify custom default settings for default job used by console arguments parser public static Job AsDefault(this Job job, bool value = true) Parameters job Job value bool Returns Job AsMutator(Job) mutator job should not be added to the config, but instead applied to other jobs in given config public static Job AsMutator(this Job job) Parameters job Job Returns Job DontEnforcePowerPlan(Job) ensures that BenchmarkDotNet does not enforce any power plan public static Job DontEnforcePowerPlan(this Job job) Parameters job Job Returns Job RunOncePerIteration(Job) Run the benchmark exactly once per iteration. public static Job RunOncePerIteration(this Job job) Parameters job Job Returns Job WithAffinity(Job, nint) ProcessorAffinity for the benchmark process. See also: https://msdn.microsoft.com/library/system.diagnostics.process.processoraffinity.aspx public static Job WithAffinity(this Job job, nint affinity) Parameters job Job affinity nint Returns Job WithAnalyzeLaunchVariance(Job, bool) public static Job WithAnalyzeLaunchVariance(this Job job, bool value) Parameters job Job value bool Returns Job WithArguments(Job, IReadOnlyList<Argument>) public static Job WithArguments(this Job job, IReadOnlyList<Argument> arguments) Parameters job Job arguments IReadOnlyList<Argument> Returns Job WithBaseline(Job, bool) public static Job WithBaseline(this Job job, bool value) Parameters job Job value bool Returns Job WithClock(Job, IClock) public static Job WithClock(this Job job, IClock clock) Parameters job Job clock IClock Returns Job WithCustomBuildConfiguration(Job, string) public static Job WithCustomBuildConfiguration(this Job job, string buildConfiguration) Parameters job Job buildConfiguration string Returns Job WithEngineFactory(Job, IEngineFactory) public static Job WithEngineFactory(this Job job, IEngineFactory engineFactory) Parameters job Job engineFactory IEngineFactory Returns Job WithEnvironmentVariable(Job, EnvironmentVariable) Creates a new job based on the given job with additional environment variable. All existed environment variables of the original job will be copied to the new one. If the original job already contains an environment variable with the same key, it will be overriden. public static Job WithEnvironmentVariable(this Job job, EnvironmentVariable environmentVariable) Parameters job Job The original job environmentVariable EnvironmentVariable The new environment variable which should be added for the new job Returns Job The new job with additional environment variable WithEnvironmentVariable(Job, string, string) Creates a new job based on the given job with additional environment variable. All existed environment variables of the original job will be copied to the new one. If the original job already contains an environment variable with the same key, it will be overriden. public static Job WithEnvironmentVariable(this Job job, string key, string value) Parameters job Job The original job key string The key of the new environment variable value string The value of the new environment variable Returns Job The new job with additional environment variable WithEnvironmentVariables(Job, params EnvironmentVariable[]) Creates a new job based on the given job with specified environment variables. It overrides the whole list of environment variables which were defined in the original job. public static Job WithEnvironmentVariables(this Job job, params EnvironmentVariable[] environmentVariables) Parameters job Job The original job environmentVariables EnvironmentVariable[] The environment variables for the new job Returns Job The new job with overriden environment variables Exceptions InvalidOperationException Throws an exception if environmentVariables contains two variables with the same key. WithEvaluateOverhead(Job, bool) Specifies if the overhead should be evaluated (Idle runs) and it's average value subtracted from every result. True by default, very important for nano-benchmarks. public static Job WithEvaluateOverhead(this Job job, bool value) Parameters job Job value bool Returns Job WithGcAllowVeryLargeObjects(Job, bool) On 64-bit platforms, enables arrays that are greater than 2 gigabytes (GB) in total size. false: Arrays greater than 2 GB in total size are not enabled. This is the default. true: Arrays greater than 2 GB in total size are enabled on 64-bit platforms. public static Job WithGcAllowVeryLargeObjects(this Job job, bool value) Parameters job Job value bool Returns Job WithGcConcurrent(Job, bool) Specifies whether the common language runtime runs garbage collection on a separate thread. false: Does not run garbage collection concurrently. true: Runs garbage collection concurrently. This is the default. public static Job WithGcConcurrent(this Job job, bool value) Parameters job Job value bool Returns Job WithGcCpuGroups(Job, bool) Specifies whether garbage collection supports multiple CPU groups. false: Garbage collection does not support multiple CPU groups. This is the default. true: Garbage collection supports multiple CPU groups, if server garbage collection is enabled. public static Job WithGcCpuGroups(this Job job, bool value) Parameters job Job value bool Returns Job WithGcForce(Job, bool) Specifies whether the BenchmarkDotNet's benchmark runner forces full garbage collection after each benchmark invocation false: Does not force garbage collection. true: Forces full garbage collection after each benchmark invocation. This is the default. public static Job WithGcForce(this Job job, bool value) Parameters job Job value bool Returns Job WithGcMode(Job, GcMode) public static Job WithGcMode(this Job job, GcMode gc) Parameters job Job gc GcMode Returns Job WithGcRetainVm(Job, bool) Put segments that should be deleted on a standby list for future use instead of releasing them back to the OS The default is false public static Job WithGcRetainVm(this Job job, bool value) Parameters job Job value bool Returns Job WithGcServer(Job, bool) Specifies whether the common language runtime runs server garbage collection. false: Does not run server garbage collection. This is the default. true: Runs server garbage collection. public static Job WithGcServer(this Job job, bool value) Parameters job Job value bool Returns Job WithHeapAffinitizeMask(Job, int) process mask, see MSDN for more. public static Job WithHeapAffinitizeMask(this Job job, int heapAffinitizeMask) Parameters job Job heapAffinitizeMask int Returns Job WithHeapCount(Job, int) specify the # of Server GC threads/heaps, must be smaller than the # of logical CPUs the process is allowed to run on, ie, if you don't specifically affinitize your process it means the # of total logical CPUs on the machine; otherwise this is the # of logical CPUs you affinitized your process to. public static Job WithHeapCount(this Job job, int heapCount) Parameters job Job heapCount int Returns Job WithId(Job, string) public static Job WithId(this Job job, string id) Parameters job Job id string Returns Job WithInvocationCount(Job, long) Invocation count in a single iteration. If specified, IterationTime will be ignored. If specified, it must be a multiple of UnrollFactor. public static Job WithInvocationCount(this Job job, long count) Parameters job Job count long Returns Job WithIterationCount(Job, int) How many target iterations should be performed. If specified, MinIterationCount will be ignored. If specified, MaxIterationCount will be ignored. public static Job WithIterationCount(this Job job, int count) Parameters job Job count int Returns Job WithIterationTime(Job, TimeInterval) Desired time of execution of an iteration. Used by Pilot stage to estimate the number of invocations per iteration. The default value is 500 milliseconds. public static Job WithIterationTime(this Job job, TimeInterval time) Parameters job Job time TimeInterval Returns Job WithJit(Job, Jit) public static Job WithJit(this Job job, Jit jit) Parameters job Job jit Jit Returns Job WithLargeAddressAware(Job, bool) Specifies that benchmark can handle addresses larger than 2 gigabytes. public static Job WithLargeAddressAware(this Job job, bool value = true) Parameters job Job value bool Returns Job WithLaunchCount(Job, int) How many times we should launch process with target benchmark. public static Job WithLaunchCount(this Job job, int count) Parameters job Job count int Returns Job WithMaxAbsoluteError(Job, TimeInterval) Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error). Doesn't have a default value. If MaxRelativeError is also provided, the smallest value is used as stop criteria. public static Job WithMaxAbsoluteError(this Job job, TimeInterval interval) Parameters job Job interval TimeInterval Returns Job WithMaxIterationCount(Job, int) Maximum count of target iterations that should be performed. The default value is 100. If you set this value to below 15, then MultimodalDistributionAnalyzer is not going to work. public static Job WithMaxIterationCount(this Job job, int count) Parameters job Job count int Returns Job WithMaxRelativeError(Job, double) Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error). The default value is 0.02. If MaxAbsoluteError is also provided, the smallest value is used as stop criteria. public static Job WithMaxRelativeError(this Job job, double value) Parameters job Job value double Returns Job WithMaxWarmupCount(Job, int) Maximum count of warmup iterations that should be performed The default value is 50 public static Job WithMaxWarmupCount(this Job job, int count) Parameters job Job count int Returns Job WithMemoryRandomization(Job, bool) specifies whether Engine should allocate some random-sized memory between iterations it makes [GlobalCleanup] and [GlobalSetup] methods to be executed after every iteration public static Job WithMemoryRandomization(this Job job, bool enable = true) Parameters job Job enable bool Returns Job WithMinInvokeCount(Job, int) Minimum count of benchmark invocations per iteration The default value is 4. public static Job WithMinInvokeCount(this Job job, int value) Parameters job Job value int Returns Job WithMinIterationCount(Job, int) Minimum count of target iterations that should be performed. The default value is 15. If you set this value to below 15, then MultimodalDistributionAnalyzer is not going to work. public static Job WithMinIterationCount(this Job job, int count) Parameters job Job count int Returns Job WithMinIterationTime(Job, TimeInterval) Minimum time of a single iteration. Unlike Run.IterationTime, this characteristic specifies only the lower limit. In case of need, BenchmarkDotNet can increase this value. The default value is 500 milliseconds. public static Job WithMinIterationTime(this Job job, TimeInterval interval) Parameters job Job interval TimeInterval Returns Job WithMinWarmupCount(Job, int) Minimum count of warmup iterations that should be performed The default value is 6 public static Job WithMinWarmupCount(this Job job, int count) Parameters job Job count int Returns Job WithNoAffinitize(Job, bool) specify true to disable hard affinity of Server GC threads to CPUs public static Job WithNoAffinitize(this Job job, bool value) Parameters job Job value bool Returns Job WithNuGet(Job, NuGetReferenceList) Runs the job with a specific NuGet dependencies which will be resolved during the Job build process public static Job WithNuGet(this Job job, NuGetReferenceList nuGetReferences) Parameters job Job nuGetReferences NuGetReferenceList A collection of NuGet dependencies Returns Job WithNuGet(Job, string, string?, Uri?, bool) Runs the job with a specific NuGet dependency which will be resolved during the Job build process public static Job WithNuGet(this Job job, string packageName, string? packageVersion = null, Uri? source = null, bool prerelease = false) Parameters job Job packageName string The NuGet package name packageVersion string (optional)The NuGet package version source Uri (optional)Indicate the URI of the NuGet package source to use during the restore operation. prerelease bool (optional)Allows prerelease packages to be installed. Returns Job WithOutlierMode(Job, OutlierMode) Specifies which outliers should be removed from the distribution public static Job WithOutlierMode(this Job job, OutlierMode value) Parameters job Job value OutlierMode Returns Job WithPlatform(Job, Platform) public static Job WithPlatform(this Job job, Platform platform) Parameters job Job platform Platform Returns Job WithPowerPlan(Job, PowerPlan) Power plan for benchmarks. The default value is HighPerformance. Only available for Windows. public static Job WithPowerPlan(this Job job, PowerPlan powerPlan) Parameters job Job powerPlan PowerPlan Returns Job WithPowerPlan(Job, Guid) Setting power plans by guid. The default value is HighPerformance. Only available for Windows. public static Job WithPowerPlan(this Job job, Guid powerPlanGuid) Parameters job Job powerPlanGuid Guid Returns Job WithRuntime(Job, Runtime) public static Job WithRuntime(this Job job, Runtime runtime) Parameters job Job runtime Runtime Returns Job WithStrategy(Job, RunStrategy) Available values: Throughput, ColdStart and Monitoring. Throughput: default strategy which allows to get good precision level. ColdStart: should be used only for measuring cold start of the application or testing purpose. Monitoring: no overhead evaluating, with several target iterations. Perfect for macrobenchmarks without a steady state with high variance. public static Job WithStrategy(this Job job, RunStrategy strategy) Parameters job Job strategy RunStrategy Returns Job WithToolchain(Job, IToolchain) public static Job WithToolchain(this Job job, IToolchain toolchain) Parameters job Job toolchain IToolchain Returns Job WithUnrollFactor(Job, int) How many times the benchmark method will be invoked per one iteration of a generated loop. The default value is 16. public static Job WithUnrollFactor(this Job job, int factor) Parameters job Job factor int Returns Job WithWarmupCount(Job, int) How many warmup iterations should be performed. public static Job WithWarmupCount(this Job job, int count) Parameters job Job count int Returns Job WithoutEnvironmentVariables(Job) Creates a new job based on the given job without any environment variables. public static Job WithoutEnvironmentVariables(this Job job) Parameters job Job The original job Returns Job The new job which doesn't have any environment variables"
  },
  "api/BenchmarkDotNet.Jobs.JobIdGenerator.html": {
    "href": "api/BenchmarkDotNet.Jobs.JobIdGenerator.html",
    "title": "Class JobIdGenerator | BenchmarkDotNet",
    "summary": "Class JobIdGenerator Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public static class JobIdGenerator Inheritance object JobIdGenerator Methods GenerateRandomId(Job) public static string GenerateRandomId(Job job) Parameters job Job Returns string"
  },
  "api/BenchmarkDotNet.Jobs.JobMode-1.html": {
    "href": "api/BenchmarkDotNet.Jobs.JobMode-1.html",
    "title": "Class JobMode<T> | BenchmarkDotNet",
    "summary": "Class JobMode<T> Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public abstract class JobMode<T> : CharacteristicObject<T> where T : JobMode<T>, new() Type Parameters T Inheritance object CharacteristicObject CharacteristicObject<T> JobMode<T> Derived AccuracyMode EnvironmentMode GcMode InfrastructureMode Job MetaMode RunMode Inherited Members CharacteristicObject<T>.Apply(CharacteristicObject) CharacteristicObject<T>.Apply(params CharacteristicObject[]) CharacteristicObject<T>.ApplyAndFreeze(CharacteristicObject) CharacteristicObject<T>.ApplyAndFreeze(params CharacteristicObject[]) CharacteristicObject<T>.Freeze() CharacteristicObject<T>.UnfreezeCopy() CharacteristicObject<T>.CreateCharacteristic<TC>(string) CharacteristicObject<T>.CreateHiddenCharacteristic<TC>(string) CharacteristicObject<T>.CreateIgnoreOnApplyCharacteristic<TC>(string) CharacteristicObject.IdCharacteristic CharacteristicObject.ResolveId(CharacteristicObject, string) CharacteristicObject.GetCharacteristicsWithValues() CharacteristicObject.HasValue(Characteristic) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver, T) CharacteristicObject.ResolveValue(Characteristic, IResolver) CharacteristicObject.ResolveValue(Characteristic, IResolver, object) CharacteristicObject.ResolveValue<T>(Characteristic<T>, T) CharacteristicObject.ResolveValue(Characteristic, object) CharacteristicObject.ResolveValueAsNullable<T>(Characteristic<T>) CharacteristicObject.ApplyCore(CharacteristicObject) CharacteristicObject.FreezeCore() CharacteristicObject.UnfreezeCopyCore() CharacteristicObject.ToString() CharacteristicObject.OwnerOrSelf CharacteristicObject.Frozen CharacteristicObject.IsPropertyBag CharacteristicObject.HasChanges CharacteristicObject.Id Extension Methods CharacteristicHelper.GetAllCharacteristics(CharacteristicObject) CharacteristicHelper.GetThisTypeCharacteristics(CharacteristicObject) Constructors JobMode() protected JobMode() JobMode(string?) protected JobMode(string? id) Parameters id string Fields Default public static readonly T Default Field Value T Properties Job public Job Job { get; } Property Value Job"
  },
  "api/BenchmarkDotNet.Jobs.MetaMode.html": {
    "href": "api/BenchmarkDotNet.Jobs.MetaMode.html",
    "title": "Class MetaMode | BenchmarkDotNet",
    "summary": "Class MetaMode Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public class MetaMode : JobMode<MetaMode> Inheritance object CharacteristicObject CharacteristicObject<MetaMode> JobMode<MetaMode> MetaMode Inherited Members JobMode<MetaMode>.Default JobMode<MetaMode>.Job CharacteristicObject<MetaMode>.Apply(CharacteristicObject) CharacteristicObject<MetaMode>.Apply(params CharacteristicObject[]) CharacteristicObject<MetaMode>.ApplyAndFreeze(CharacteristicObject) CharacteristicObject<MetaMode>.ApplyAndFreeze(params CharacteristicObject[]) CharacteristicObject<MetaMode>.Freeze() CharacteristicObject<MetaMode>.UnfreezeCopy() CharacteristicObject<MetaMode>.CreateCharacteristic<TC>(string) CharacteristicObject<MetaMode>.CreateHiddenCharacteristic<TC>(string) CharacteristicObject<MetaMode>.CreateIgnoreOnApplyCharacteristic<TC>(string) CharacteristicObject.IdCharacteristic CharacteristicObject.ResolveId(CharacteristicObject, string) CharacteristicObject.GetCharacteristicsWithValues() CharacteristicObject.HasValue(Characteristic) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver, T) CharacteristicObject.ResolveValue(Characteristic, IResolver) CharacteristicObject.ResolveValue(Characteristic, IResolver, object) CharacteristicObject.ResolveValue<T>(Characteristic<T>, T) CharacteristicObject.ResolveValue(Characteristic, object) CharacteristicObject.ResolveValueAsNullable<T>(Characteristic<T>) CharacteristicObject.ApplyCore(CharacteristicObject) CharacteristicObject.FreezeCore() CharacteristicObject.UnfreezeCopyCore() CharacteristicObject.ToString() CharacteristicObject.OwnerOrSelf CharacteristicObject.Frozen CharacteristicObject.IsPropertyBag CharacteristicObject.HasChanges CharacteristicObject.Id Extension Methods CharacteristicHelper.GetAllCharacteristics(CharacteristicObject) CharacteristicHelper.GetThisTypeCharacteristics(CharacteristicObject) Constructors MetaMode() public MetaMode() Fields BaselineCharacteristic public static readonly Characteristic<bool> BaselineCharacteristic Field Value Characteristic<bool> IsDefaultCharacteristic public static readonly Characteristic<bool> IsDefaultCharacteristic Field Value Characteristic<bool> IsMutatorCharacteristic public static readonly Characteristic<bool> IsMutatorCharacteristic Field Value Characteristic<bool> Properties Baseline public bool Baseline { get; set; } Property Value bool IsDefault set to true if you want to specify custom default settings for default job used by console arguments parser public bool IsDefault { get; set; } Property Value bool IsMutator mutator job should not be added to the config, but instead applied to other jobs in given config public bool IsMutator { get; set; } Property Value bool"
  },
  "api/BenchmarkDotNet.Jobs.MonoArgument.html": {
    "href": "api/BenchmarkDotNet.Jobs.MonoArgument.html",
    "title": "Class MonoArgument | BenchmarkDotNet",
    "summary": "Class MonoArgument Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll Argument passed directly to mono when executing benchmarks (mono [options]) example: new MonoArgument(\"--gc=sgen\") public class MonoArgument : Argument, IEquatable<Argument> Inheritance object Argument MonoArgument Implements IEquatable<Argument> Inherited Members Argument.ToString() Argument.Equals(Argument) Argument.Equals(object) Argument.GetHashCode() Argument.TextRepresentation Constructors MonoArgument(string) public MonoArgument(string value) Parameters value string"
  },
  "api/BenchmarkDotNet.Jobs.MsBuildArgument.html": {
    "href": "api/BenchmarkDotNet.Jobs.MsBuildArgument.html",
    "title": "Class MsBuildArgument | BenchmarkDotNet",
    "summary": "Class MsBuildArgument Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll Argument passed to dotnet cli when restoring and building the project example: new MsBuildArgument(\"/p:MyCustomSetting=123\") public class MsBuildArgument : Argument, IEquatable<Argument> Inheritance object Argument MsBuildArgument Implements IEquatable<Argument> Inherited Members Argument.ToString() Argument.Equals(Argument) Argument.Equals(object) Argument.GetHashCode() Argument.TextRepresentation Constructors MsBuildArgument(string) public MsBuildArgument(string value) Parameters value string"
  },
  "api/BenchmarkDotNet.Jobs.NuGetReference.html": {
    "href": "api/BenchmarkDotNet.Jobs.NuGetReference.html",
    "title": "Class NuGetReference | BenchmarkDotNet",
    "summary": "Class NuGetReference Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public class NuGetReference : IEquatable<NuGetReference> Inheritance object NuGetReference Implements IEquatable<NuGetReference> Constructors NuGetReference(string, string, Uri?, bool) public NuGetReference(string packageName, string packageVersion, Uri? source = null, bool prerelease = false) Parameters packageName string packageVersion string source Uri prerelease bool Properties PackageName public string PackageName { get; } Property Value string PackageSource public Uri PackageSource { get; } Property Value Uri PackageVersion public string PackageVersion { get; } Property Value string Prerelease public bool Prerelease { get; } Property Value bool Methods Equals(NuGetReference) Object is equals when the package name and version are the same public bool Equals(NuGetReference other) Parameters other NuGetReference Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Jobs.NuGetReferenceList.html": {
    "href": "api/BenchmarkDotNet.Jobs.NuGetReferenceList.html",
    "title": "Class NuGetReferenceList | BenchmarkDotNet",
    "summary": "Class NuGetReferenceList Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll An ordered list of NuGet references. Does not allow duplicate references with the same PackageName. public class NuGetReferenceList : IReadOnlyCollection<NuGetReference>, IEnumerable<NuGetReference>, IEnumerable Inheritance object NuGetReferenceList Implements IReadOnlyCollection<NuGetReference> IEnumerable<NuGetReference> IEnumerable Extension Methods ConsumerExtensions.Consume<T>(IEnumerable<T>, Consumer) ConsumerExtensions.Consume(IEnumerable, Consumer) Constructors NuGetReferenceList() public NuGetReferenceList() NuGetReferenceList(IReadOnlyCollection<NuGetReference>) public NuGetReferenceList(IReadOnlyCollection<NuGetReference> readOnlyCollection) Parameters readOnlyCollection IReadOnlyCollection<NuGetReference> Properties Count public int Count { get; } Property Value int Methods Add(NuGetReference) public void Add(NuGetReference reference) Parameters reference NuGetReference Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetEnumerator() public IEnumerator<NuGetReference> GetEnumerator() Returns IEnumerator<NuGetReference> GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/BenchmarkDotNet.Jobs.RunMode.html": {
    "href": "api/BenchmarkDotNet.Jobs.RunMode.html",
    "title": "Class RunMode | BenchmarkDotNet",
    "summary": "Class RunMode Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.dll public sealed class RunMode : JobMode<RunMode> Inheritance object CharacteristicObject CharacteristicObject<RunMode> JobMode<RunMode> RunMode Inherited Members JobMode<RunMode>.Default JobMode<RunMode>.Job CharacteristicObject<RunMode>.Apply(CharacteristicObject) CharacteristicObject<RunMode>.Apply(params CharacteristicObject[]) CharacteristicObject<RunMode>.ApplyAndFreeze(CharacteristicObject) CharacteristicObject<RunMode>.ApplyAndFreeze(params CharacteristicObject[]) CharacteristicObject<RunMode>.Freeze() CharacteristicObject<RunMode>.UnfreezeCopy() CharacteristicObject.IdCharacteristic CharacteristicObject.GetCharacteristicsWithValues() CharacteristicObject.HasValue(Characteristic) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver) CharacteristicObject.ResolveValue<T>(Characteristic<T>, IResolver, T) CharacteristicObject.ResolveValue(Characteristic, IResolver) CharacteristicObject.ResolveValue(Characteristic, IResolver, object) CharacteristicObject.ResolveValue<T>(Characteristic<T>, T) CharacteristicObject.ResolveValue(Characteristic, object) CharacteristicObject.ResolveValueAsNullable<T>(Characteristic<T>) CharacteristicObject.ToString() CharacteristicObject.Frozen CharacteristicObject.HasChanges CharacteristicObject.Id Extension Methods CharacteristicHelper.GetAllCharacteristics(CharacteristicObject) CharacteristicHelper.GetThisTypeCharacteristics(CharacteristicObject) Constructors RunMode() public RunMode() Fields Dry public static readonly RunMode Dry Field Value RunMode InvocationCountCharacteristic public static readonly Characteristic<long> InvocationCountCharacteristic Field Value Characteristic<long> IterationCountCharacteristic public static readonly Characteristic<int> IterationCountCharacteristic Field Value Characteristic<int> IterationTimeCharacteristic public static readonly Characteristic<TimeInterval> IterationTimeCharacteristic Field Value Characteristic<TimeInterval> LaunchCountCharacteristic public static readonly Characteristic<int> LaunchCountCharacteristic Field Value Characteristic<int> Long public static readonly RunMode Long Field Value RunMode MaxIterationCountCharacteristic public static readonly Characteristic<int> MaxIterationCountCharacteristic Field Value Characteristic<int> MaxWarmupIterationCountCharacteristic public static readonly Characteristic<int> MaxWarmupIterationCountCharacteristic Field Value Characteristic<int> Medium public static readonly RunMode Medium Field Value RunMode MemoryRandomizationCharacteristic public static readonly Characteristic<bool> MemoryRandomizationCharacteristic Field Value Characteristic<bool> MinIterationCountCharacteristic public static readonly Characteristic<int> MinIterationCountCharacteristic Field Value Characteristic<int> MinWarmupIterationCountCharacteristic public static readonly Characteristic<int> MinWarmupIterationCountCharacteristic Field Value Characteristic<int> RunStrategyCharacteristic public static readonly Characteristic<RunStrategy> RunStrategyCharacteristic Field Value Characteristic<RunStrategy> Short public static readonly RunMode Short Field Value RunMode UnrollFactorCharacteristic public static readonly Characteristic<int> UnrollFactorCharacteristic Field Value Characteristic<int> VeryLong public static readonly RunMode VeryLong Field Value RunMode WarmupCountCharacteristic public static readonly Characteristic<int> WarmupCountCharacteristic Field Value Characteristic<int> Properties InvocationCount Invocation count in a single iteration. If specified, IterationTime will be ignored. If specified, it must be a multiple of UnrollFactor. public long InvocationCount { get; set; } Property Value long IterationCount How many target iterations should be performed If specified, MinIterationCount will be ignored. If specified, MaxIterationCount will be ignored. public int IterationCount { get; set; } Property Value int IterationTime Desired time of execution of an iteration. Used by Pilot stage to estimate the number of invocations per iteration. The default value is 500 milliseconds. public TimeInterval IterationTime { get; set; } Property Value TimeInterval LaunchCount How many times we should launch process with target benchmark. public int LaunchCount { get; set; } Property Value int MaxIterationCount Maximum count of target iterations that should be performed The default value is 100 If you set this value to below 15, then MultimodalDistributionAnalyzer is not going to work public int MaxIterationCount { get; set; } Property Value int MaxWarmupIterationCount Maximum count of warmup iterations that should be performed The default value is 50 public int MaxWarmupIterationCount { get; set; } Property Value int MemoryRandomization specifies whether Engine should allocate some random-sized memory between iterations it makes [GlobalCleanup] and [GlobalSetup] methods to be executed after every iteration public bool MemoryRandomization { get; set; } Property Value bool MinIterationCount Minimum count of target iterations that should be performed The default value is 15 If you set this value to below 15, then MultimodalDistributionAnalyzer is not going to work public int MinIterationCount { get; set; } Property Value int MinWarmupIterationCount Minimum count of warmup iterations that should be performed The default value is 6 public int MinWarmupIterationCount { get; set; } Property Value int RunStrategy Available values: Throughput and ColdStart. Throughput: default strategy which allows to get good precision level. ColdStart: should be used only for measuring cold start of the application or testing purpose. Monitoring: no overhead evaluating, with several target iterations. Perfect for macrobenchmarks without a steady state with high variance. public RunStrategy RunStrategy { get; set; } Property Value RunStrategy UnrollFactor How many times the benchmark method will be invoked per one iteration of a generated loop. public int UnrollFactor { get; set; } Property Value int WarmupCount How many warmup iterations should be performed. public int WarmupCount { get; set; } Property Value int"
  },
  "api/BenchmarkDotNet.Jobs.RuntimeMoniker.html": {
    "href": "api/BenchmarkDotNet.Jobs.RuntimeMoniker.html",
    "title": "Enum RuntimeMoniker | BenchmarkDotNet",
    "summary": "Enum RuntimeMoniker Namespace BenchmarkDotNet.Jobs Assembly BenchmarkDotNet.Annotations.dll public enum RuntimeMoniker Fields HostProcess = 0 the same Runtime as the host Process (default setting) Mono = 2 Mono Mono10_0 = 44 .NET 10 using MonoVM (not CLR which is the default) Mono60 = 40 .NET 6 using MonoVM (not CLR which is the default) Mono70 = 41 .NET 7 using MonoVM (not CLR which is the default) Mono80 = 42 .NET 8 using MonoVM (not CLR which is the default) Mono90 = 43 .NET 9 using MonoVM (not CLR which is the default) MonoAOTLLVM = 34 Mono with the Ahead of Time LLVM Compiler backend MonoAOTLLVMNet10_0 = 39 Mono with the Ahead of Time LLVM Compiler backend and net10.0 MonoAOTLLVMNet60 = 35 Mono with the Ahead of Time LLVM Compiler backend and net6.0 MonoAOTLLVMNet70 = 36 Mono with the Ahead of Time LLVM Compiler backend and net7.0 MonoAOTLLVMNet80 = 37 Mono with the Ahead of Time LLVM Compiler backend and net8.0 MonoAOTLLVMNet90 = 38 Mono with the Ahead of Time LLVM Compiler backend and net9.0 NativeAot10_0 = 26 NativeAOT compiled as net10.0 NativeAot60 = 22 NativeAOT compiled as net6.0 NativeAot70 = 23 NativeAOT compiled as net7.0 NativeAot80 = 24 NativeAOT compiled as net8.0 NativeAot90 = 25 NativeAOT compiled as net9.0 Net10_0 = 21 .NET 10.0 Net461 = 3 .NET 4.6.1 Net462 = 4 .NET 4.6.2 Net47 = 5 .NET 4.7 Net471 = 6 .NET 4.7.1 Net472 = 7 .NET 4.7.2 Net48 = 8 .NET 4.8 Net481 = 9 .NET 4.8.1 Net50 = 16 .NET 5.0 Net60 = 17 .NET 6.0 Net70 = 18 .NET 7.0 Net80 = 19 .NET 8.0 Net90 = 20 .NET 9.0 NetCoreApp20 = 10 .NET Core 2.0 NetCoreApp21 = 11 .NET Core 2.1 NetCoreApp22 = 12 .NET Core 2.2 NetCoreApp30 = 13 .NET Core 3.0 NetCoreApp31 = 14 .NET Core 3.1 [Obsolete(\"Please switch to the 'RuntimeMoniker.Net50'\")] NetCoreApp50 = 15 .NET Core 5.0 aka \".NET 5\" NotRecognized = 1 not recognized, possibly a new version of .NET Core Wasm = 27 WebAssembly with default .Net version WasmNet10_0 = 33 WebAssembly with net10.0 WasmNet50 = 28 WebAssembly with net5.0 WasmNet60 = 29 WebAssembly with net6.0 WasmNet70 = 30 WebAssembly with net7.0 WasmNet80 = 31 WebAssembly with net8.0 WasmNet90 = 32 WebAssembly with net9.0"
  },
  "api/BenchmarkDotNet.Loggers.AccumulationLogger.html": {
    "href": "api/BenchmarkDotNet.Loggers.AccumulationLogger.html",
    "title": "Class AccumulationLogger | BenchmarkDotNet",
    "summary": "Class AccumulationLogger Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll public class AccumulationLogger : ILogger Inheritance object AccumulationLogger Implements ILogger Extension Methods LoggerExtensions.Write(ILogger, string) LoggerExtensions.WriteError(ILogger, string) LoggerExtensions.WriteHeader(ILogger, string) LoggerExtensions.WriteHelp(ILogger, string) LoggerExtensions.WriteHint(ILogger, string) LoggerExtensions.WriteInfo(ILogger, string) LoggerExtensions.WriteLine(ILogger, string) LoggerExtensions.WriteLineError(ILogger, string) LoggerExtensions.WriteLineHeader(ILogger, string) LoggerExtensions.WriteLineHelp(ILogger, string) LoggerExtensions.WriteLineHint(ILogger, string) LoggerExtensions.WriteLineInfo(ILogger, string) LoggerExtensions.WriteLineResult(ILogger, string) LoggerExtensions.WriteLineStatistic(ILogger, string) LoggerExtensions.WriteLineWarning(ILogger, string) LoggerExtensions.WriteResult(ILogger, string) LoggerExtensions.WriteStatistic(ILogger, string) LoggerExtensions.WriteWarning(ILogger, string) Constructors AccumulationLogger() public AccumulationLogger() Properties Id public string Id { get; } Property Value string Priority If there are several loggers with the same Id, only logger with the highest priority will be used. public int Priority { get; } Property Value int Methods ClearLog() public void ClearLog() Flush() public void Flush() GetLog() public string GetLog() Returns string Write(LogKind, string) public virtual void Write(LogKind logKind, string text) Parameters logKind LogKind text string WriteLine() public virtual void WriteLine() WriteLine(LogKind, string) public virtual void WriteLine(LogKind logKind, string text) Parameters logKind LogKind text string"
  },
  "api/BenchmarkDotNet.Loggers.ConsoleLogger.html": {
    "href": "api/BenchmarkDotNet.Loggers.ConsoleLogger.html",
    "title": "Class ConsoleLogger | BenchmarkDotNet",
    "summary": "Class ConsoleLogger Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll public sealed class ConsoleLogger : ILogger Inheritance object ConsoleLogger Implements ILogger Extension Methods LoggerExtensions.Write(ILogger, string) LoggerExtensions.WriteError(ILogger, string) LoggerExtensions.WriteHeader(ILogger, string) LoggerExtensions.WriteHelp(ILogger, string) LoggerExtensions.WriteHint(ILogger, string) LoggerExtensions.WriteInfo(ILogger, string) LoggerExtensions.WriteLine(ILogger, string) LoggerExtensions.WriteLineError(ILogger, string) LoggerExtensions.WriteLineHeader(ILogger, string) LoggerExtensions.WriteLineHelp(ILogger, string) LoggerExtensions.WriteLineHint(ILogger, string) LoggerExtensions.WriteLineInfo(ILogger, string) LoggerExtensions.WriteLineResult(ILogger, string) LoggerExtensions.WriteLineStatistic(ILogger, string) LoggerExtensions.WriteLineWarning(ILogger, string) LoggerExtensions.WriteResult(ILogger, string) LoggerExtensions.WriteStatistic(ILogger, string) LoggerExtensions.WriteWarning(ILogger, string) Constructors ConsoleLogger(bool, Dictionary<LogKind, ConsoleColor>?) public ConsoleLogger(bool unicodeSupport = false, Dictionary<LogKind, ConsoleColor>? colorScheme = null) Parameters unicodeSupport bool colorScheme Dictionary<LogKind, ConsoleColor> Fields Ascii public static readonly ILogger Ascii Field Value ILogger Default public static readonly ILogger Default Field Value ILogger Unicode public static readonly ILogger Unicode Field Value ILogger Properties Id public string Id { get; } Property Value string Priority If there are several loggers with the same Id, only logger with the highest priority will be used. public int Priority { get; } Property Value int Methods CreateGrayScheme() public static Dictionary<LogKind, ConsoleColor> CreateGrayScheme() Returns Dictionary<LogKind, ConsoleColor> Flush() public void Flush() Write(LogKind, string) public void Write(LogKind logKind, string text) Parameters logKind LogKind text string WriteLine() public void WriteLine() WriteLine(LogKind, string) public void WriteLine(LogKind logKind, string text) Parameters logKind LogKind text string"
  },
  "api/BenchmarkDotNet.Loggers.html": {
    "href": "api/BenchmarkDotNet.Loggers.html",
    "title": "Namespace BenchmarkDotNet.Loggers | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Loggers Classes AccumulationLogger ConsoleLogger LinqPadLogger LogCapture LoggerExtensions LoggerWithPrefix Adds prefix for each line NullLogger StreamLogger TextLogger Structs OutputLine Interfaces ILogger Enums LogKind"
  },
  "api/BenchmarkDotNet.Loggers.ILogger.html": {
    "href": "api/BenchmarkDotNet.Loggers.ILogger.html",
    "title": "Interface ILogger | BenchmarkDotNet",
    "summary": "Interface ILogger Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll public interface ILogger Extension Methods LoggerExtensions.Write(ILogger, string) LoggerExtensions.WriteError(ILogger, string) LoggerExtensions.WriteHeader(ILogger, string) LoggerExtensions.WriteHelp(ILogger, string) LoggerExtensions.WriteHint(ILogger, string) LoggerExtensions.WriteInfo(ILogger, string) LoggerExtensions.WriteLine(ILogger, string) LoggerExtensions.WriteLineError(ILogger, string) LoggerExtensions.WriteLineHeader(ILogger, string) LoggerExtensions.WriteLineHelp(ILogger, string) LoggerExtensions.WriteLineHint(ILogger, string) LoggerExtensions.WriteLineInfo(ILogger, string) LoggerExtensions.WriteLineResult(ILogger, string) LoggerExtensions.WriteLineStatistic(ILogger, string) LoggerExtensions.WriteLineWarning(ILogger, string) LoggerExtensions.WriteResult(ILogger, string) LoggerExtensions.WriteStatistic(ILogger, string) LoggerExtensions.WriteWarning(ILogger, string) Properties Id string Id { get; } Property Value string Priority If there are several loggers with the same Id, only logger with the highest priority will be used. int Priority { get; } Property Value int Methods Flush() void Flush() Write(LogKind, string) void Write(LogKind logKind, string text) Parameters logKind LogKind text string WriteLine() void WriteLine() WriteLine(LogKind, string) void WriteLine(LogKind logKind, string text) Parameters logKind LogKind text string"
  },
  "api/BenchmarkDotNet.Loggers.LinqPadLogger.html": {
    "href": "api/BenchmarkDotNet.Loggers.LinqPadLogger.html",
    "title": "Class LinqPadLogger | BenchmarkDotNet",
    "summary": "Class LinqPadLogger Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll public sealed class LinqPadLogger : ILogger Inheritance object LinqPadLogger Implements ILogger Extension Methods LoggerExtensions.Write(ILogger, string) LoggerExtensions.WriteError(ILogger, string) LoggerExtensions.WriteHeader(ILogger, string) LoggerExtensions.WriteHelp(ILogger, string) LoggerExtensions.WriteHint(ILogger, string) LoggerExtensions.WriteInfo(ILogger, string) LoggerExtensions.WriteLine(ILogger, string) LoggerExtensions.WriteLineError(ILogger, string) LoggerExtensions.WriteLineHeader(ILogger, string) LoggerExtensions.WriteLineHelp(ILogger, string) LoggerExtensions.WriteLineHint(ILogger, string) LoggerExtensions.WriteLineInfo(ILogger, string) LoggerExtensions.WriteLineResult(ILogger, string) LoggerExtensions.WriteLineStatistic(ILogger, string) LoggerExtensions.WriteLineWarning(ILogger, string) LoggerExtensions.WriteResult(ILogger, string) LoggerExtensions.WriteStatistic(ILogger, string) LoggerExtensions.WriteWarning(ILogger, string) Fields lazyInstance public static readonly Lazy<LinqPadLogger> lazyInstance Field Value Lazy<LinqPadLogger> Properties Id public string Id { get; } Property Value string Instance public static ILogger Instance { get; } Property Value ILogger IsAvailable public static bool IsAvailable { get; } Property Value bool Priority If there are several loggers with the same Id, only logger with the highest priority will be used. public int Priority { get; } Property Value int Methods Flush() public void Flush() Write(LogKind, string) public void Write(LogKind logKind, string text) Parameters logKind LogKind text string WriteLine() public void WriteLine() WriteLine(LogKind, string) public void WriteLine(LogKind logKind, string text) Parameters logKind LogKind text string"
  },
  "api/BenchmarkDotNet.Loggers.LogCapture.html": {
    "href": "api/BenchmarkDotNet.Loggers.LogCapture.html",
    "title": "Class LogCapture | BenchmarkDotNet",
    "summary": "Class LogCapture Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll public class LogCapture : ILogger Inheritance object LogCapture Implements ILogger Extension Methods LoggerExtensions.Write(ILogger, string) LoggerExtensions.WriteError(ILogger, string) LoggerExtensions.WriteHeader(ILogger, string) LoggerExtensions.WriteHelp(ILogger, string) LoggerExtensions.WriteHint(ILogger, string) LoggerExtensions.WriteInfo(ILogger, string) LoggerExtensions.WriteLine(ILogger, string) LoggerExtensions.WriteLineError(ILogger, string) LoggerExtensions.WriteLineHeader(ILogger, string) LoggerExtensions.WriteLineHelp(ILogger, string) LoggerExtensions.WriteLineHint(ILogger, string) LoggerExtensions.WriteLineInfo(ILogger, string) LoggerExtensions.WriteLineResult(ILogger, string) LoggerExtensions.WriteLineStatistic(ILogger, string) LoggerExtensions.WriteLineWarning(ILogger, string) LoggerExtensions.WriteResult(ILogger, string) LoggerExtensions.WriteStatistic(ILogger, string) LoggerExtensions.WriteWarning(ILogger, string) Constructors LogCapture() public LogCapture() Properties CapturedOutput public IReadOnlyList<OutputLine> CapturedOutput { get; } Property Value IReadOnlyList<OutputLine> Id public string Id { get; } Property Value string Priority If there are several loggers with the same Id, only logger with the highest priority will be used. public int Priority { get; } Property Value int Methods Clear() public void Clear() Flush() public void Flush() Write(LogKind, string) public void Write(LogKind logKind, string text) Parameters logKind LogKind text string WriteLine() public void WriteLine() WriteLine(LogKind, string) public void WriteLine(LogKind logKind, string text) Parameters logKind LogKind text string"
  },
  "api/BenchmarkDotNet.Loggers.LoggerExtensions.html": {
    "href": "api/BenchmarkDotNet.Loggers.LoggerExtensions.html",
    "title": "Class LoggerExtensions | BenchmarkDotNet",
    "summary": "Class LoggerExtensions Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll public static class LoggerExtensions Inheritance object LoggerExtensions Methods Write(ILogger, string) public static void Write(this ILogger logger, string text) Parameters logger ILogger text string WriteError(ILogger, string) public static void WriteError(this ILogger logger, string text) Parameters logger ILogger text string WriteHeader(ILogger, string) public static void WriteHeader(this ILogger logger, string text) Parameters logger ILogger text string WriteHelp(ILogger, string) public static void WriteHelp(this ILogger logger, string text) Parameters logger ILogger text string WriteHint(ILogger, string) public static void WriteHint(this ILogger logger, string text) Parameters logger ILogger text string WriteInfo(ILogger, string) public static void WriteInfo(this ILogger logger, string text) Parameters logger ILogger text string WriteLine(ILogger, string) public static void WriteLine(this ILogger logger, string text) Parameters logger ILogger text string WriteLineError(ILogger, string) public static void WriteLineError(this ILogger logger, string text) Parameters logger ILogger text string WriteLineHeader(ILogger, string) public static void WriteLineHeader(this ILogger logger, string text) Parameters logger ILogger text string WriteLineHelp(ILogger, string) public static void WriteLineHelp(this ILogger logger, string text) Parameters logger ILogger text string WriteLineHint(ILogger, string) public static void WriteLineHint(this ILogger logger, string text) Parameters logger ILogger text string WriteLineInfo(ILogger, string) public static void WriteLineInfo(this ILogger logger, string text) Parameters logger ILogger text string WriteLineResult(ILogger, string) public static void WriteLineResult(this ILogger logger, string text) Parameters logger ILogger text string WriteLineStatistic(ILogger, string) public static void WriteLineStatistic(this ILogger logger, string text) Parameters logger ILogger text string WriteLineWarning(ILogger, string) public static void WriteLineWarning(this ILogger logger, string text) Parameters logger ILogger text string WriteResult(ILogger, string) public static void WriteResult(this ILogger logger, string text) Parameters logger ILogger text string WriteStatistic(ILogger, string) public static void WriteStatistic(this ILogger logger, string text) Parameters logger ILogger text string WriteWarning(ILogger, string) public static void WriteWarning(this ILogger logger, string text) Parameters logger ILogger text string"
  },
  "api/BenchmarkDotNet.Loggers.LoggerWithPrefix.html": {
    "href": "api/BenchmarkDotNet.Loggers.LoggerWithPrefix.html",
    "title": "Class LoggerWithPrefix | BenchmarkDotNet",
    "summary": "Class LoggerWithPrefix Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll Adds prefix for each line public class LoggerWithPrefix : ILogger Inheritance object LoggerWithPrefix Implements ILogger Extension Methods LoggerExtensions.Write(ILogger, string) LoggerExtensions.WriteError(ILogger, string) LoggerExtensions.WriteHeader(ILogger, string) LoggerExtensions.WriteHelp(ILogger, string) LoggerExtensions.WriteHint(ILogger, string) LoggerExtensions.WriteInfo(ILogger, string) LoggerExtensions.WriteLine(ILogger, string) LoggerExtensions.WriteLineError(ILogger, string) LoggerExtensions.WriteLineHeader(ILogger, string) LoggerExtensions.WriteLineHelp(ILogger, string) LoggerExtensions.WriteLineHint(ILogger, string) LoggerExtensions.WriteLineInfo(ILogger, string) LoggerExtensions.WriteLineResult(ILogger, string) LoggerExtensions.WriteLineStatistic(ILogger, string) LoggerExtensions.WriteLineWarning(ILogger, string) LoggerExtensions.WriteResult(ILogger, string) LoggerExtensions.WriteStatistic(ILogger, string) LoggerExtensions.WriteWarning(ILogger, string) Constructors LoggerWithPrefix(ILogger, string) public LoggerWithPrefix(ILogger logger, string prefix) Parameters logger ILogger prefix string Properties Id public string Id { get; } Property Value string Priority If there are several loggers with the same Id, only logger with the highest priority will be used. public int Priority { get; } Property Value int Methods Flush() public void Flush() Write(LogKind, string) public void Write(LogKind logKind, string text) Parameters logKind LogKind text string WriteLine() public void WriteLine() WriteLine(LogKind, string) public void WriteLine(LogKind logKind, string text) Parameters logKind LogKind text string"
  },
  "api/BenchmarkDotNet.Loggers.LogKind.html": {
    "href": "api/BenchmarkDotNet.Loggers.LogKind.html",
    "title": "Enum LogKind | BenchmarkDotNet",
    "summary": "Enum LogKind Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll public enum LogKind Fields Default = 0 Error = 6 Header = 2 Help = 1 Hint = 7 Info = 5 Result = 3 Statistic = 4 Warning = 8"
  },
  "api/BenchmarkDotNet.Loggers.NullLogger.html": {
    "href": "api/BenchmarkDotNet.Loggers.NullLogger.html",
    "title": "Class NullLogger | BenchmarkDotNet",
    "summary": "Class NullLogger Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll public class NullLogger : ILogger Inheritance object NullLogger Implements ILogger Extension Methods LoggerExtensions.Write(ILogger, string) LoggerExtensions.WriteError(ILogger, string) LoggerExtensions.WriteHeader(ILogger, string) LoggerExtensions.WriteHelp(ILogger, string) LoggerExtensions.WriteHint(ILogger, string) LoggerExtensions.WriteInfo(ILogger, string) LoggerExtensions.WriteLine(ILogger, string) LoggerExtensions.WriteLineError(ILogger, string) LoggerExtensions.WriteLineHeader(ILogger, string) LoggerExtensions.WriteLineHelp(ILogger, string) LoggerExtensions.WriteLineHint(ILogger, string) LoggerExtensions.WriteLineInfo(ILogger, string) LoggerExtensions.WriteLineResult(ILogger, string) LoggerExtensions.WriteLineStatistic(ILogger, string) LoggerExtensions.WriteLineWarning(ILogger, string) LoggerExtensions.WriteResult(ILogger, string) LoggerExtensions.WriteStatistic(ILogger, string) LoggerExtensions.WriteWarning(ILogger, string) Fields Instance public static readonly ILogger Instance Field Value ILogger Properties Id public string Id { get; } Property Value string Priority If there are several loggers with the same Id, only logger with the highest priority will be used. public int Priority { get; } Property Value int Methods Flush() public void Flush() Write(LogKind, string) public void Write(LogKind logKind, string text) Parameters logKind LogKind text string WriteLine() public void WriteLine() WriteLine(LogKind, string) public void WriteLine(LogKind logKind, string text) Parameters logKind LogKind text string"
  },
  "api/BenchmarkDotNet.Loggers.OutputLine.html": {
    "href": "api/BenchmarkDotNet.Loggers.OutputLine.html",
    "title": "Struct OutputLine | BenchmarkDotNet",
    "summary": "Struct OutputLine Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll public struct OutputLine Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() Properties Kind public LogKind Kind { readonly get; set; } Property Value LogKind Text public string Text { readonly get; set; } Property Value string"
  },
  "api/BenchmarkDotNet.Loggers.StreamLogger.html": {
    "href": "api/BenchmarkDotNet.Loggers.StreamLogger.html",
    "title": "Class StreamLogger | BenchmarkDotNet",
    "summary": "Class StreamLogger Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll public class StreamLogger : TextLogger, ILogger, IDisposable Inheritance object TextLogger StreamLogger Implements ILogger IDisposable Inherited Members TextLogger.Write(LogKind, string) TextLogger.WriteLine() TextLogger.WriteLine(LogKind, string) TextLogger.Flush() TextLogger.Dispose() TextLogger.Priority Extension Methods LoggerExtensions.Write(ILogger, string) LoggerExtensions.WriteError(ILogger, string) LoggerExtensions.WriteHeader(ILogger, string) LoggerExtensions.WriteHelp(ILogger, string) LoggerExtensions.WriteHint(ILogger, string) LoggerExtensions.WriteInfo(ILogger, string) LoggerExtensions.WriteLine(ILogger, string) LoggerExtensions.WriteLineError(ILogger, string) LoggerExtensions.WriteLineHeader(ILogger, string) LoggerExtensions.WriteLineHelp(ILogger, string) LoggerExtensions.WriteLineHint(ILogger, string) LoggerExtensions.WriteLineInfo(ILogger, string) LoggerExtensions.WriteLineResult(ILogger, string) LoggerExtensions.WriteLineStatistic(ILogger, string) LoggerExtensions.WriteLineWarning(ILogger, string) LoggerExtensions.WriteResult(ILogger, string) LoggerExtensions.WriteStatistic(ILogger, string) LoggerExtensions.WriteWarning(ILogger, string) Constructors StreamLogger(StreamWriter) public StreamLogger(StreamWriter writer) Parameters writer StreamWriter StreamLogger(string, bool) public StreamLogger(string filePath, bool append = false) Parameters filePath string append bool Properties Id public override string Id { get; } Property Value string"
  },
  "api/BenchmarkDotNet.Loggers.TextLogger.html": {
    "href": "api/BenchmarkDotNet.Loggers.TextLogger.html",
    "title": "Class TextLogger | BenchmarkDotNet",
    "summary": "Class TextLogger Namespace BenchmarkDotNet.Loggers Assembly BenchmarkDotNet.dll public class TextLogger : ILogger, IDisposable Inheritance object TextLogger Implements ILogger IDisposable Derived StreamLogger Extension Methods LoggerExtensions.Write(ILogger, string) LoggerExtensions.WriteError(ILogger, string) LoggerExtensions.WriteHeader(ILogger, string) LoggerExtensions.WriteHelp(ILogger, string) LoggerExtensions.WriteHint(ILogger, string) LoggerExtensions.WriteInfo(ILogger, string) LoggerExtensions.WriteLine(ILogger, string) LoggerExtensions.WriteLineError(ILogger, string) LoggerExtensions.WriteLineHeader(ILogger, string) LoggerExtensions.WriteLineHelp(ILogger, string) LoggerExtensions.WriteLineHint(ILogger, string) LoggerExtensions.WriteLineInfo(ILogger, string) LoggerExtensions.WriteLineResult(ILogger, string) LoggerExtensions.WriteLineStatistic(ILogger, string) LoggerExtensions.WriteLineWarning(ILogger, string) LoggerExtensions.WriteResult(ILogger, string) LoggerExtensions.WriteStatistic(ILogger, string) LoggerExtensions.WriteWarning(ILogger, string) Constructors TextLogger(TextWriter) public TextLogger(TextWriter writer) Parameters writer TextWriter Properties Id public virtual string Id { get; } Property Value string Priority If there are several loggers with the same Id, only logger with the highest priority will be used. public int Priority { get; } Property Value int Methods Dispose() public void Dispose() Flush() public void Flush() Write(LogKind, string) public void Write(LogKind logKind, string text) Parameters logKind LogKind text string WriteLine() public void WriteLine() WriteLine(LogKind, string) public void WriteLine(LogKind logKind, string text) Parameters logKind LogKind text string"
  },
  "api/BenchmarkDotNet.Mathematics.ConfidenceLevelExtensions.html": {
    "href": "api/BenchmarkDotNet.Mathematics.ConfidenceLevelExtensions.html",
    "title": "Class ConfidenceLevelExtensions | BenchmarkDotNet",
    "summary": "Class ConfidenceLevelExtensions Namespace BenchmarkDotNet.Mathematics Assembly BenchmarkDotNet.dll public static class ConfidenceLevelExtensions Inheritance object ConfidenceLevelExtensions Methods GetZValue(LegacyConfidenceLevel, int) Calculates Z value (z-star) for confidence interval public static double GetZValue(this LegacyConfidenceLevel level, int n) Parameters level LegacyConfidenceLevel ConfidenceLevel for a confidence interval n int Sample size (n >= 3) Returns double ToPercent(LegacyConfidenceLevel) public static double ToPercent(this LegacyConfidenceLevel level) Parameters level LegacyConfidenceLevel Returns double ToPercentStr(LegacyConfidenceLevel) public static string ToPercentStr(this LegacyConfidenceLevel level) Parameters level LegacyConfidenceLevel Returns string"
  },
  "api/BenchmarkDotNet.Mathematics.html": {
    "href": "api/BenchmarkDotNet.Mathematics.html",
    "title": "Namespace BenchmarkDotNet.Mathematics | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Mathematics Classes ConfidenceLevelExtensions NumeralSystemExtensions PercentileValues Statistics Structs LegacyConfidenceInterval Enums LegacyConfidenceLevel NumeralSystem"
  },
  "api/BenchmarkDotNet.Mathematics.LegacyConfidenceInterval.html": {
    "href": "api/BenchmarkDotNet.Mathematics.LegacyConfidenceInterval.html",
    "title": "Struct LegacyConfidenceInterval | BenchmarkDotNet",
    "summary": "Struct LegacyConfidenceInterval Namespace BenchmarkDotNet.Mathematics Assembly BenchmarkDotNet.dll public struct LegacyConfidenceInterval Inherited Members ValueType.Equals(object) ValueType.GetHashCode() Constructors LegacyConfidenceInterval(double, double, int, LegacyConfidenceLevel) public LegacyConfidenceInterval(double mean, double standardError, int n, LegacyConfidenceLevel level = LegacyConfidenceLevel.L999) Parameters mean double standardError double n int level LegacyConfidenceLevel Properties Level public readonly LegacyConfidenceLevel Level { get; } Property Value LegacyConfidenceLevel Lower public readonly double Lower { get; } Property Value double Margin public readonly double Margin { get; } Property Value double Mean public readonly double Mean { get; } Property Value double N public readonly int N { get; } Property Value int StandardError public readonly double StandardError { get; } Property Value double Upper public readonly double Upper { get; } Property Value double Methods Contains(double) public bool Contains(double value) Parameters value double Returns bool ToString() public override string ToString() Returns string ToString(Func<double, string>, bool) public string ToString(Func<double, string> formatter, bool showLevel = true) Parameters formatter Func<double, string> showLevel bool Returns string ToString(CultureInfo, string, bool) public string ToString(CultureInfo cultureInfo, string format = \"0.##\", bool showLevel = true) Parameters cultureInfo CultureInfo format string showLevel bool Returns string"
  },
  "api/BenchmarkDotNet.Mathematics.LegacyConfidenceLevel.html": {
    "href": "api/BenchmarkDotNet.Mathematics.LegacyConfidenceLevel.html",
    "title": "Enum LegacyConfidenceLevel | BenchmarkDotNet",
    "summary": "Enum LegacyConfidenceLevel Namespace BenchmarkDotNet.Mathematics Assembly BenchmarkDotNet.dll public enum LegacyConfidenceLevel Extension Methods ConfidenceLevelExtensions.GetZValue(LegacyConfidenceLevel, int) ConfidenceLevelExtensions.ToPercent(LegacyConfidenceLevel) ConfidenceLevelExtensions.ToPercentStr(LegacyConfidenceLevel) Fields L50 = 0 50.0% confidence interval L70 = 1 70.0% confidence interval L75 = 2 75.0% confidence interval L80 = 3 80.0% confidence interval L85 = 4 85.0% confidence interval L90 = 5 90.0% confidence interval L92 = 6 92.0% confidence interval L95 = 7 95.0% confidence interval L96 = 8 96.0% confidence interval L97 = 9 97.0% confidence interval L98 = 10 98.0% confidence interval L99 = 11 99.0% confidence interval L999 = 12 99.9% confidence interval"
  },
  "api/BenchmarkDotNet.Mathematics.NumeralSystem.html": {
    "href": "api/BenchmarkDotNet.Mathematics.NumeralSystem.html",
    "title": "Enum NumeralSystem | BenchmarkDotNet",
    "summary": "Enum NumeralSystem Namespace BenchmarkDotNet.Mathematics Assembly BenchmarkDotNet.dll public enum NumeralSystem Extension Methods NumeralSystemExtensions.ToPresentation(NumeralSystem, int) Fields Arabic = 0 Arabic numerals (1, 2, 3, 4, ...) Roman = 1 Roman numerals (I, II, III, IV, ...) Stars = 2 Unary numeral system (*, **, ***, ****, ...)"
  },
  "api/BenchmarkDotNet.Mathematics.NumeralSystemExtensions.html": {
    "href": "api/BenchmarkDotNet.Mathematics.NumeralSystemExtensions.html",
    "title": "Class NumeralSystemExtensions | BenchmarkDotNet",
    "summary": "Class NumeralSystemExtensions Namespace BenchmarkDotNet.Mathematics Assembly BenchmarkDotNet.dll public static class NumeralSystemExtensions Inheritance object NumeralSystemExtensions Methods ToPresentation(NumeralSystem, int) public static string ToPresentation(this NumeralSystem system, int value) Parameters system NumeralSystem value int Returns string"
  },
  "api/BenchmarkDotNet.Mathematics.PercentileValues.html": {
    "href": "api/BenchmarkDotNet.Mathematics.PercentileValues.html",
    "title": "Class PercentileValues | BenchmarkDotNet",
    "summary": "Class PercentileValues Namespace BenchmarkDotNet.Mathematics Assembly BenchmarkDotNet.dll public class PercentileValues Inheritance object PercentileValues Properties P0 public double P0 { get; } Property Value double P100 public double P100 { get; } Property Value double P25 public double P25 { get; } Property Value double P50 public double P50 { get; } Property Value double P67 public double P67 { get; } Property Value double P80 public double P80 { get; } Property Value double P85 public double P85 { get; } Property Value double P90 public double P90 { get; } Property Value double P95 public double P95 { get; } Property Value double Methods Percentile(int) public double Percentile(int percentile) Parameters percentile int Returns double ToString() public override string ToString() Returns string ToString(Func<double, string>) public string ToString(Func<double, string> formatter) Parameters formatter Func<double, string> Returns string ToString(CultureInfo?, string) public string ToString(CultureInfo? cultureInfo, string format = \"0.##\") Parameters cultureInfo CultureInfo format string Returns string"
  },
  "api/BenchmarkDotNet.Mathematics.Statistics.html": {
    "href": "api/BenchmarkDotNet.Mathematics.Statistics.html",
    "title": "Class Statistics | BenchmarkDotNet",
    "summary": "Class Statistics Namespace BenchmarkDotNet.Mathematics Assembly BenchmarkDotNet.dll public class Statistics Inheritance object Statistics Extension Methods StatisticsExtensions.CreateNanosecondFormatter(Statistics, CultureInfo, string) StatisticsExtensions.ToString(Statistics?, CultureInfo, Func<double, string>, bool) Constructors Statistics(Sample) public Statistics(Sample sample) Parameters sample Sample Statistics(IEnumerable<double>) public Statistics(IEnumerable<double> values) Parameters values IEnumerable<double> Statistics(IEnumerable<int>) public Statistics(IEnumerable<int> values) Parameters values IEnumerable<int> Statistics(params double[]) public Statistics(params double[] values) Parameters values double[] Properties AllOutliers public double[] AllOutliers { get; } Property Value double[] ConfidenceInterval public LegacyConfidenceInterval ConfidenceInterval { get; } Property Value LegacyConfidenceInterval InterquartileRange public double InterquartileRange { get; } Property Value double Kurtosis public double Kurtosis { get; } Property Value double LowerFence public double LowerFence { get; } Property Value double LowerOutliers public double[] LowerOutliers { get; } Property Value double[] Max public double Max { get; } Property Value double Mean public double Mean { get; } Property Value double Median public double Median { get; } Property Value double Min public double Min { get; } Property Value double N public int N { get; } Property Value int OriginalValues public IReadOnlyList<double> OriginalValues { get; } Property Value IReadOnlyList<double> Percentiles public PercentileValues Percentiles { get; } Property Value PercentileValues Q1 public double Q1 { get; } Property Value double Q3 public double Q3 { get; } Property Value double Skewness public double Skewness { get; } Property Value double StandardDeviation public double StandardDeviation { get; } Property Value double StandardError public double StandardError { get; } Property Value double UpperFence public double UpperFence { get; } Property Value double UpperOutliers public double[] UpperOutliers { get; } Property Value double[] Variance public double Variance { get; } Property Value double Methods CalcCentralMoment(int) public double CalcCentralMoment(int k) Parameters k int Returns double CanBeInverted() Returns true, if this statistics can be inverted (see Invert()). public bool CanBeInverted() Returns bool DivMean(Statistics?, Statistics?) Mean for [X/Y]. public static double DivMean(Statistics? x, Statistics? y) Parameters x Statistics y Statistics Returns double Divide(Statistics, Statistics) public static Statistics Divide(Statistics x, Statistics y) Parameters x Statistics y Statistics Returns Statistics GetActualOutliers(OutlierMode) public double[] GetActualOutliers(OutlierMode outlierMode) Parameters outlierMode OutlierMode Returns double[] GetConfidenceInterval(ConfidenceLevel) public ConfidenceInterval GetConfidenceInterval(ConfidenceLevel level) Parameters level ConfidenceLevel Returns ConfidenceInterval Invert() Statistics for [1/X]. If Min is less then or equal to 0, returns null. public Statistics Invert() Returns Statistics IsActualOutlier(double, OutlierMode) public bool IsActualOutlier(double value, OutlierMode outlierMode) Parameters value double outlierMode OutlierMode Returns bool IsLowerOutlier(double) public bool IsLowerOutlier(double value) Parameters value double Returns bool IsOutlier(double) public bool IsOutlier(double value) Parameters value double Returns bool IsUpperOutlier(double) public bool IsUpperOutlier(double value) Parameters value double Returns bool MulMean(Statistics, Statistics) Mean for [X*Y]. public static double MulMean(Statistics x, Statistics y) Parameters x Statistics y Statistics Returns double ToString() public override string ToString() Returns string WithoutOutliers() public double[] WithoutOutliers() Returns double[]"
  },
  "api/BenchmarkDotNet.Order.DefaultOrderer.html": {
    "href": "api/BenchmarkDotNet.Order.DefaultOrderer.html",
    "title": "Class DefaultOrderer | BenchmarkDotNet",
    "summary": "Class DefaultOrderer Namespace BenchmarkDotNet.Order Assembly BenchmarkDotNet.dll public class DefaultOrderer : IOrderer Inheritance object DefaultOrderer Implements IOrderer Constructors DefaultOrderer(SummaryOrderPolicy, MethodOrderPolicy) public DefaultOrderer(SummaryOrderPolicy summaryOrderPolicy = SummaryOrderPolicy.Default, MethodOrderPolicy methodOrderPolicy = MethodOrderPolicy.Declared) Parameters summaryOrderPolicy SummaryOrderPolicy methodOrderPolicy MethodOrderPolicy Fields Instance public static readonly IOrderer Instance Field Value IOrderer Properties MethodOrderPolicy public MethodOrderPolicy MethodOrderPolicy { get; } Property Value MethodOrderPolicy SeparateLogicalGroups public bool SeparateLogicalGroups { get; } Property Value bool SummaryOrderPolicy public SummaryOrderPolicy SummaryOrderPolicy { get; } Property Value SummaryOrderPolicy Methods GetExecutionOrder(ImmutableArray<BenchmarkCase>, IEnumerable<BenchmarkLogicalGroupRule>?) public virtual IEnumerable<BenchmarkCase> GetExecutionOrder(ImmutableArray<BenchmarkCase> benchmarkCases, IEnumerable<BenchmarkLogicalGroupRule>? order = null) Parameters benchmarkCases ImmutableArray<BenchmarkCase> order IEnumerable<BenchmarkLogicalGroupRule> Returns IEnumerable<BenchmarkCase> GetHighlightGroupKey(BenchmarkCase) public string GetHighlightGroupKey(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns string GetLogicalGroupKey(ImmutableArray<BenchmarkCase>, BenchmarkCase) public string GetLogicalGroupKey(ImmutableArray<BenchmarkCase> allBenchmarksCases, BenchmarkCase benchmarkCase) Parameters allBenchmarksCases ImmutableArray<BenchmarkCase> benchmarkCase BenchmarkCase Returns string GetLogicalGroupOrder(IEnumerable<IGrouping<string, BenchmarkCase>>, IEnumerable<BenchmarkLogicalGroupRule>?) public virtual IEnumerable<IGrouping<string, BenchmarkCase>> GetLogicalGroupOrder(IEnumerable<IGrouping<string, BenchmarkCase>> logicalGroups, IEnumerable<BenchmarkLogicalGroupRule>? order = null) Parameters logicalGroups IEnumerable<IGrouping<string, BenchmarkCase>> order IEnumerable<BenchmarkLogicalGroupRule> Returns IEnumerable<IGrouping<string, BenchmarkCase>> GetSummaryOrder(ImmutableArray<BenchmarkCase>, Summary) public virtual IEnumerable<BenchmarkCase> GetSummaryOrder(ImmutableArray<BenchmarkCase> benchmarksCases, Summary summary) Parameters benchmarksCases ImmutableArray<BenchmarkCase> summary Summary Returns IEnumerable<BenchmarkCase> GetSummaryOrderForGroup(ImmutableArray<BenchmarkCase>, Summary) protected virtual IEnumerable<BenchmarkCase> GetSummaryOrderForGroup(ImmutableArray<BenchmarkCase> benchmarksCase, Summary summary) Parameters benchmarksCase ImmutableArray<BenchmarkCase> summary Summary Returns IEnumerable<BenchmarkCase>"
  },
  "api/BenchmarkDotNet.Order.html": {
    "href": "api/BenchmarkDotNet.Order.html",
    "title": "Namespace BenchmarkDotNet.Order | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Order Classes DefaultOrderer Interfaces IOrderer Enums MethodOrderPolicy SummaryOrderPolicy"
  },
  "api/BenchmarkDotNet.Order.IOrderer.html": {
    "href": "api/BenchmarkDotNet.Order.IOrderer.html",
    "title": "Interface IOrderer | BenchmarkDotNet",
    "summary": "Interface IOrderer Namespace BenchmarkDotNet.Order Assembly BenchmarkDotNet.dll public interface IOrderer Properties SeparateLogicalGroups bool SeparateLogicalGroups { get; } Property Value bool Methods GetExecutionOrder(ImmutableArray<BenchmarkCase>, IEnumerable<BenchmarkLogicalGroupRule>?) IEnumerable<BenchmarkCase> GetExecutionOrder(ImmutableArray<BenchmarkCase> benchmarksCase, IEnumerable<BenchmarkLogicalGroupRule>? order = null) Parameters benchmarksCase ImmutableArray<BenchmarkCase> order IEnumerable<BenchmarkLogicalGroupRule> Returns IEnumerable<BenchmarkCase> GetHighlightGroupKey(BenchmarkCase) string? GetHighlightGroupKey(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns string GetLogicalGroupKey(ImmutableArray<BenchmarkCase>, BenchmarkCase) string? GetLogicalGroupKey(ImmutableArray<BenchmarkCase> allBenchmarksCases, BenchmarkCase benchmarkCase) Parameters allBenchmarksCases ImmutableArray<BenchmarkCase> benchmarkCase BenchmarkCase Returns string GetLogicalGroupOrder(IEnumerable<IGrouping<string, BenchmarkCase>>, IEnumerable<BenchmarkLogicalGroupRule>?) IEnumerable<IGrouping<string, BenchmarkCase>> GetLogicalGroupOrder(IEnumerable<IGrouping<string, BenchmarkCase>> logicalGroups, IEnumerable<BenchmarkLogicalGroupRule>? order = null) Parameters logicalGroups IEnumerable<IGrouping<string, BenchmarkCase>> order IEnumerable<BenchmarkLogicalGroupRule> Returns IEnumerable<IGrouping<string, BenchmarkCase>> GetSummaryOrder(ImmutableArray<BenchmarkCase>, Summary) IEnumerable<BenchmarkCase> GetSummaryOrder(ImmutableArray<BenchmarkCase> benchmarksCases, Summary summary) Parameters benchmarksCases ImmutableArray<BenchmarkCase> summary Summary Returns IEnumerable<BenchmarkCase>"
  },
  "api/BenchmarkDotNet.Order.MethodOrderPolicy.html": {
    "href": "api/BenchmarkDotNet.Order.MethodOrderPolicy.html",
    "title": "Enum MethodOrderPolicy | BenchmarkDotNet",
    "summary": "Enum MethodOrderPolicy Namespace BenchmarkDotNet.Order Assembly BenchmarkDotNet.dll public enum MethodOrderPolicy Fields Alphabetical = 0 Declared = 1"
  },
  "api/BenchmarkDotNet.Order.SummaryOrderPolicy.html": {
    "href": "api/BenchmarkDotNet.Order.SummaryOrderPolicy.html",
    "title": "Enum SummaryOrderPolicy | BenchmarkDotNet",
    "summary": "Enum SummaryOrderPolicy Namespace BenchmarkDotNet.Order Assembly BenchmarkDotNet.dll public enum SummaryOrderPolicy Fields Declared = 4 Default = 0 FastestToSlowest = 1 Method = 3 SlowestToFastest = 2"
  },
  "api/BenchmarkDotNet.Parameters.html": {
    "href": "api/BenchmarkDotNet.Parameters.html",
    "title": "Namespace BenchmarkDotNet.Parameters | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Parameters Classes ParameterDefinition ParameterDefinitions ParameterExtractor ParameterInstance ParameterInstances"
  },
  "api/BenchmarkDotNet.Parameters.ParameterDefinition.html": {
    "href": "api/BenchmarkDotNet.Parameters.ParameterDefinition.html",
    "title": "Class ParameterDefinition | BenchmarkDotNet",
    "summary": "Class ParameterDefinition Namespace BenchmarkDotNet.Parameters Assembly BenchmarkDotNet.dll public class ParameterDefinition Inheritance object ParameterDefinition Constructors ParameterDefinition(string, bool, object[], bool, Type, int) public ParameterDefinition(string name, bool isStatic, object[] values, bool isArgument, Type parameterType, int priorityInCategory) Parameters name string isStatic bool values object[] isArgument bool parameterType Type priorityInCategory int Properties IsArgument public bool IsArgument { get; } Property Value bool IsStatic public bool IsStatic { get; } Property Value bool Name public string Name { get; } Property Value string ParameterType public Type ParameterType { get; } Property Value Type PriorityInCategory public int PriorityInCategory { get; } Property Value int Values public object[] Values { get; } Property Value object[]"
  },
  "api/BenchmarkDotNet.Parameters.ParameterDefinitions.html": {
    "href": "api/BenchmarkDotNet.Parameters.ParameterDefinitions.html",
    "title": "Class ParameterDefinitions | BenchmarkDotNet",
    "summary": "Class ParameterDefinitions Namespace BenchmarkDotNet.Parameters Assembly BenchmarkDotNet.dll public class ParameterDefinitions Inheritance object ParameterDefinitions Constructors ParameterDefinitions(IReadOnlyList<ParameterDefinition>) public ParameterDefinitions(IReadOnlyList<ParameterDefinition> items) Parameters items IReadOnlyList<ParameterDefinition> Properties Items public IReadOnlyList<ParameterDefinition> Items { get; } Property Value IReadOnlyList<ParameterDefinition> Methods Expand(SummaryStyle) public IReadOnlyList<ParameterInstances> Expand(SummaryStyle summaryStyle) Parameters summaryStyle SummaryStyle Returns IReadOnlyList<ParameterInstances> ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Parameters.ParameterExtractor.html": {
    "href": "api/BenchmarkDotNet.Parameters.ParameterExtractor.html",
    "title": "Class ParameterExtractor | BenchmarkDotNet",
    "summary": "Class ParameterExtractor Namespace BenchmarkDotNet.Parameters Assembly BenchmarkDotNet.dll public static class ParameterExtractor Inheritance object ParameterExtractor"
  },
  "api/BenchmarkDotNet.Parameters.ParameterInstance.html": {
    "href": "api/BenchmarkDotNet.Parameters.ParameterInstance.html",
    "title": "Class ParameterInstance | BenchmarkDotNet",
    "summary": "Class ParameterInstance Namespace BenchmarkDotNet.Parameters Assembly BenchmarkDotNet.dll public class ParameterInstance : IDisposable Inheritance object ParameterInstance Implements IDisposable Constructors ParameterInstance(ParameterDefinition, object, SummaryStyle) public ParameterInstance(ParameterDefinition definition, object value, SummaryStyle summaryStyle) Parameters definition ParameterDefinition value object summaryStyle SummaryStyle Fields NullParameterTextRepresentation public const string NullParameterTextRepresentation = \"?\" Field Value string Properties Definition public ParameterDefinition Definition { get; } Property Value ParameterDefinition IsArgument public bool IsArgument { get; } Property Value bool IsStatic public bool IsStatic { get; } Property Value bool Name public string Name { get; } Property Value string Value public object Value { get; } Property Value object Methods Dispose() public void Dispose() ToDisplayText() public string ToDisplayText() Returns string ToDisplayText(SummaryStyle) public string ToDisplayText(SummaryStyle summary) Parameters summary SummaryStyle Returns string ToSourceCode() public string ToSourceCode() Returns string ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Parameters.ParameterInstances.html": {
    "href": "api/BenchmarkDotNet.Parameters.ParameterInstances.html",
    "title": "Class ParameterInstances | BenchmarkDotNet",
    "summary": "Class ParameterInstances Namespace BenchmarkDotNet.Parameters Assembly BenchmarkDotNet.dll public class ParameterInstances : IEquatable<ParameterInstances>, IDisposable Inheritance object ParameterInstances Implements IEquatable<ParameterInstances> IDisposable Constructors ParameterInstances(IReadOnlyList<ParameterInstance>) public ParameterInstances(IReadOnlyList<ParameterInstance> items) Parameters items IReadOnlyList<ParameterInstance> Properties Count public int Count { get; } Property Value int DisplayInfo public string DisplayInfo { get; } Property Value string FolderInfo public string FolderInfo { get; } Property Value string this[int] public ParameterInstance this[int index] { get; } Parameters index int Property Value ParameterInstance this[string] public object this[string name] { get; } Parameters name string Property Value object Items public IReadOnlyList<ParameterInstance> Items { get; } Property Value IReadOnlyList<ParameterInstance> PrintInfo public string PrintInfo { get; } Property Value string ValueInfo public string ValueInfo { get; } Property Value string Methods Dispose() public void Dispose() Equals(ParameterInstances) public bool Equals(ParameterInstances other) Parameters other ParameterInstances Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetArgument(string) public ParameterInstance GetArgument(string name) Parameters name string Returns ParameterInstance GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/BenchmarkDotNet.Portability.Antivirus.html": {
    "href": "api/BenchmarkDotNet.Portability.Antivirus.html",
    "title": "Class Antivirus | BenchmarkDotNet",
    "summary": "Class Antivirus Namespace BenchmarkDotNet.Portability Assembly BenchmarkDotNet.dll public class Antivirus Inheritance object Antivirus Constructors Antivirus(string, string) public Antivirus(string name, string path) Parameters name string path string Properties Name public string Name { get; } Property Value string Path public string Path { get; } Property Value string Methods ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Portability.CodeGenHelper.html": {
    "href": "api/BenchmarkDotNet.Portability.CodeGenHelper.html",
    "title": "Class CodeGenHelper | BenchmarkDotNet",
    "summary": "Class CodeGenHelper Namespace BenchmarkDotNet.Portability Assembly BenchmarkDotNet.dll public static class CodeGenHelper Inheritance object CodeGenHelper Fields AggressiveOptimizationOption public const MethodImplOptions AggressiveOptimizationOption = AggressiveOptimization Field Value MethodImplOptions AggressiveOptimizationOptionForEmit public const MethodImplAttributes AggressiveOptimizationOptionForEmit = AggressiveOptimization Field Value MethodImplAttributes"
  },
  "api/BenchmarkDotNet.Portability.html": {
    "href": "api/BenchmarkDotNet.Portability.html",
    "title": "Namespace BenchmarkDotNet.Portability | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Portability Classes Antivirus CodeGenHelper HyperV VMware VirtualBox VirtualMachineHypervisor"
  },
  "api/BenchmarkDotNet.Portability.HyperV.html": {
    "href": "api/BenchmarkDotNet.Portability.HyperV.html",
    "title": "Class HyperV | BenchmarkDotNet",
    "summary": "Class HyperV Namespace BenchmarkDotNet.Portability Assembly BenchmarkDotNet.dll public class HyperV : VirtualMachineHypervisor Inheritance object VirtualMachineHypervisor HyperV Inherited Members VirtualMachineHypervisor.ContainsVmIdentifier(string, string) Properties Default public static HyperV Default { get; } Property Value HyperV Name public override string Name { get; } Property Value string Methods IsVirtualMachine(string, string) public override bool IsVirtualMachine(string manufacturer, string model) Parameters manufacturer string model string Returns bool"
  },
  "api/BenchmarkDotNet.Portability.VirtualBox.html": {
    "href": "api/BenchmarkDotNet.Portability.VirtualBox.html",
    "title": "Class VirtualBox | BenchmarkDotNet",
    "summary": "Class VirtualBox Namespace BenchmarkDotNet.Portability Assembly BenchmarkDotNet.dll public class VirtualBox : VirtualMachineHypervisor Inheritance object VirtualMachineHypervisor VirtualBox Inherited Members VirtualMachineHypervisor.ContainsVmIdentifier(string, string) Properties Default public static VirtualBox Default { get; } Property Value VirtualBox Name public override string Name { get; } Property Value string Methods IsVirtualMachine(string, string) public override bool IsVirtualMachine(string manufacturer, string model) Parameters manufacturer string model string Returns bool"
  },
  "api/BenchmarkDotNet.Portability.VirtualMachineHypervisor.html": {
    "href": "api/BenchmarkDotNet.Portability.VirtualMachineHypervisor.html",
    "title": "Class VirtualMachineHypervisor | BenchmarkDotNet",
    "summary": "Class VirtualMachineHypervisor Namespace BenchmarkDotNet.Portability Assembly BenchmarkDotNet.dll public abstract class VirtualMachineHypervisor Inheritance object VirtualMachineHypervisor Derived HyperV VirtualBox VMware Constructors VirtualMachineHypervisor() protected VirtualMachineHypervisor() Properties Name public abstract string Name { get; } Property Value string Methods ContainsVmIdentifier(string, string) protected static bool ContainsVmIdentifier(string systemInformation, string vmIdentifier) Parameters systemInformation string vmIdentifier string Returns bool IsVirtualMachine(string, string) public abstract bool IsVirtualMachine(string manufacturer, string model) Parameters manufacturer string model string Returns bool"
  },
  "api/BenchmarkDotNet.Portability.VMware.html": {
    "href": "api/BenchmarkDotNet.Portability.VMware.html",
    "title": "Class VMware | BenchmarkDotNet",
    "summary": "Class VMware Namespace BenchmarkDotNet.Portability Assembly BenchmarkDotNet.dll public class VMware : VirtualMachineHypervisor Inheritance object VirtualMachineHypervisor VMware Inherited Members VirtualMachineHypervisor.ContainsVmIdentifier(string, string) Properties Default public static VMware Default { get; } Property Value VMware Name public override string Name { get; } Property Value string Methods IsVirtualMachine(string, string) public override bool IsVirtualMachine(string manufacturer, string model) Parameters manufacturer string model string Returns bool"
  },
  "api/BenchmarkDotNet.Properties.BenchmarkDotNetInfo.html": {
    "href": "api/BenchmarkDotNet.Properties.BenchmarkDotNetInfo.html",
    "title": "Class BenchmarkDotNetInfo | BenchmarkDotNet",
    "summary": "Class BenchmarkDotNetInfo Namespace BenchmarkDotNet.Properties Assembly BenchmarkDotNet.dll public class BenchmarkDotNetInfo Inheritance object BenchmarkDotNetInfo Constructors BenchmarkDotNetInfo(Version, string) public BenchmarkDotNetInfo(Version assemblyVersion, string fullVersion) Parameters assemblyVersion Version fullVersion string Fields BenchmarkDotNetCaption public const string BenchmarkDotNetCaption = \"BenchmarkDotNet\" Field Value string Properties AssemblyVersion public Version AssemblyVersion { get; } Property Value Version BrandTitle public string BrandTitle { get; } Property Value string BrandVersion public string BrandVersion { get; } Property Value string FullVersion public string FullVersion { get; } Property Value string Instance public static BenchmarkDotNetInfo Instance { get; } Property Value BenchmarkDotNetInfo IsDevelop public bool IsDevelop { get; } Property Value bool IsNightly public bool IsNightly { get; } Property Value bool IsRelease public bool IsRelease { get; } Property Value bool Methods GetBdnEngineInfo() public EngineInfo GetBdnEngineInfo() Returns EngineInfo"
  },
  "api/BenchmarkDotNet.Properties.html": {
    "href": "api/BenchmarkDotNet.Properties.html",
    "title": "Namespace BenchmarkDotNet.Properties | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Properties Classes BenchmarkDotNetInfo"
  },
  "api/BenchmarkDotNet.Reports.BenchmarkReport.html": {
    "href": "api/BenchmarkDotNet.Reports.BenchmarkReport.html",
    "title": "Class BenchmarkReport | BenchmarkDotNet",
    "summary": "Class BenchmarkReport Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public sealed class BenchmarkReport Inheritance object BenchmarkReport Extension Methods BenchmarkReportExtensions.GetGcInfo(BenchmarkReport) BenchmarkReportExtensions.GetHardwareIntrinsicsInfo(BenchmarkReport) BenchmarkReportExtensions.GetRuntimeInfo(BenchmarkReport) Constructors BenchmarkReport(bool, BenchmarkCase, GenerateResult, BuildResult, IReadOnlyList<ExecuteResult>, IReadOnlyList<Metric>) public BenchmarkReport(bool success, BenchmarkCase benchmarkCase, GenerateResult generateResult, BuildResult buildResult, IReadOnlyList<ExecuteResult> executeResults, IReadOnlyList<Metric> metrics) Parameters success bool benchmarkCase BenchmarkCase generateResult GenerateResult buildResult BuildResult executeResults IReadOnlyList<ExecuteResult> metrics IReadOnlyList<Metric> Properties AllMeasurements public IReadOnlyList<Measurement> AllMeasurements { get; } Property Value IReadOnlyList<Measurement> BenchmarkCase public BenchmarkCase BenchmarkCase { get; } Property Value BenchmarkCase BuildResult public BuildResult BuildResult { get; } Property Value BuildResult ExecuteResults public IReadOnlyList<ExecuteResult> ExecuteResults { get; } Property Value IReadOnlyList<ExecuteResult> GcStats public GcStats GcStats { get; } Property Value GcStats GenerateResult public GenerateResult GenerateResult { get; } Property Value GenerateResult Metrics public IReadOnlyDictionary<string, Metric> Metrics { get; } Property Value IReadOnlyDictionary<string, Metric> ResultStatistics public Statistics? ResultStatistics { get; } Property Value Statistics Success public bool Success { get; } Property Value bool Methods GetResultRuns() public IReadOnlyList<Measurement> GetResultRuns() Returns IReadOnlyList<Measurement> ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Reports.BenchmarkReportExtensions.html": {
    "href": "api/BenchmarkDotNet.Reports.BenchmarkReportExtensions.html",
    "title": "Class BenchmarkReportExtensions | BenchmarkDotNet",
    "summary": "Class BenchmarkReportExtensions Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public static class BenchmarkReportExtensions Inheritance object BenchmarkReportExtensions Methods GetGcInfo(BenchmarkReport) public static string? GetGcInfo(this BenchmarkReport report) Parameters report BenchmarkReport Returns string GetHardwareIntrinsicsInfo(BenchmarkReport) public static string? GetHardwareIntrinsicsInfo(this BenchmarkReport report) Parameters report BenchmarkReport Returns string GetRuntimeInfo(BenchmarkReport) public static string? GetRuntimeInfo(this BenchmarkReport report) Parameters report BenchmarkReport Returns string"
  },
  "api/BenchmarkDotNet.Reports.html": {
    "href": "api/BenchmarkDotNet.Reports.html",
    "title": "Namespace BenchmarkDotNet.Reports | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Reports Classes BenchmarkReport BenchmarkReportExtensions MeasurementExtensions Metric MetricDescriptorEqualityComparer Summary SummaryExtensions SummaryStyle SummaryTable SummaryTable.SummaryTableColumn SummaryTableExtensions Structs Measurement The basic captured statistics for a benchmark Interfaces IMetricDescriptor Enums SummaryTable.SummaryTableColumn.TextJustification"
  },
  "api/BenchmarkDotNet.Reports.IMetricDescriptor.html": {
    "href": "api/BenchmarkDotNet.Reports.IMetricDescriptor.html",
    "title": "Interface IMetricDescriptor | BenchmarkDotNet",
    "summary": "Interface IMetricDescriptor Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public interface IMetricDescriptor Properties DisplayName string DisplayName { get; } Property Value string Id string Id { get; } Property Value string Legend string Legend { get; } Property Value string NumberFormat string NumberFormat { get; } Property Value string PriorityInCategory int PriorityInCategory { get; } Property Value int TheGreaterTheBetter bool TheGreaterTheBetter { get; } Property Value bool Unit string Unit { get; } Property Value string UnitType UnitType UnitType { get; } Property Value UnitType Methods GetIsAvailable(Metric) bool GetIsAvailable(Metric metric) Parameters metric Metric Returns bool"
  },
  "api/BenchmarkDotNet.Reports.Measurement.html": {
    "href": "api/BenchmarkDotNet.Reports.Measurement.html",
    "title": "Struct Measurement | BenchmarkDotNet",
    "summary": "Struct Measurement Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll The basic captured statistics for a benchmark public struct Measurement : IComparable<Measurement> Implements IComparable<Measurement> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() Extension Methods MeasurementExtensions.GetOpsPerSecond(Measurement) MeasurementExtensions.Is(Measurement, IterationMode, IterationStage) MeasurementExtensions.IsOverhead(Measurement) MeasurementExtensions.IsWorkload(Measurement) Constructors Measurement(int, IterationMode, IterationStage, int, long, double) Creates an instance of Measurement struct. public Measurement(int launchIndex, IterationMode iterationMode, IterationStage iterationStage, int iterationIndex, long operations, double nanoseconds) Parameters launchIndex int iterationMode IterationMode iterationStage IterationStage iterationIndex int operations long The number of operations performed. nanoseconds double The total number of nanoseconds it took to perform all operations. Properties IterationIndex public readonly int IterationIndex { get; } Property Value int IterationMode public readonly IterationMode IterationMode { get; } Property Value IterationMode IterationStage public readonly IterationStage IterationStage { get; } Property Value IterationStage LaunchIndex public readonly int LaunchIndex { get; } Property Value int Nanoseconds Gets the total number of nanoseconds it took to perform all operations. public readonly double Nanoseconds { get; } Property Value double Operations Gets the number of operations performed. public readonly long Operations { get; } Property Value long Methods CompareTo(Measurement) public int CompareTo(Measurement other) Parameters other Measurement Returns int GetAverageTime() Gets the average duration of one operation. public TimeInterval GetAverageTime() Returns TimeInterval Parse(string, int) Parses the benchmark statistics from the plain text line. E.g. given the input line: WorkloadTarget 1: 10 op, 1005842518 ns Will extract the number of Operations performed and the total number of Nanoseconds it took to perform them. public static Measurement Parse(string line, int processIndex) Parameters line string The line to parse. processIndex int Process launch index, indexed from one. Returns Measurement An instance of Measurement if parsed successfully. Null in case of any trouble. ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Reports.MeasurementExtensions.html": {
    "href": "api/BenchmarkDotNet.Reports.MeasurementExtensions.html",
    "title": "Class MeasurementExtensions | BenchmarkDotNet",
    "summary": "Class MeasurementExtensions Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public static class MeasurementExtensions Inheritance object MeasurementExtensions Methods GetOpsPerSecond(Measurement) Gets the number of operations performed per second (ops/sec). public static double GetOpsPerSecond(this Measurement report) Parameters report Measurement Returns double Is(Measurement, IterationMode, IterationStage) public static bool Is(this Measurement measurement, IterationMode mode, IterationStage stage) Parameters measurement Measurement mode IterationMode stage IterationStage Returns bool IsOverhead(Measurement) public static bool IsOverhead(this Measurement measurement) Parameters measurement Measurement Returns bool IsWorkload(Measurement) public static bool IsWorkload(this Measurement measurement) Parameters measurement Measurement Returns bool"
  },
  "api/BenchmarkDotNet.Reports.Metric.html": {
    "href": "api/BenchmarkDotNet.Reports.Metric.html",
    "title": "Class Metric | BenchmarkDotNet",
    "summary": "Class Metric Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public class Metric Inheritance object Metric Constructors Metric(IMetricDescriptor, double) public Metric(IMetricDescriptor descriptor, double value) Parameters descriptor IMetricDescriptor value double Properties Descriptor public IMetricDescriptor Descriptor { get; } Property Value IMetricDescriptor Value public double Value { get; } Property Value double"
  },
  "api/BenchmarkDotNet.Reports.MetricDescriptorEqualityComparer.html": {
    "href": "api/BenchmarkDotNet.Reports.MetricDescriptorEqualityComparer.html",
    "title": "Class MetricDescriptorEqualityComparer | BenchmarkDotNet",
    "summary": "Class MetricDescriptorEqualityComparer Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public class MetricDescriptorEqualityComparer : EqualityComparer<IMetricDescriptor>, IEqualityComparer, IEqualityComparer<IMetricDescriptor> Inheritance object EqualityComparer<IMetricDescriptor> MetricDescriptorEqualityComparer Implements IEqualityComparer IEqualityComparer<IMetricDescriptor> Inherited Members EqualityComparer<IMetricDescriptor>.Create(Func<IMetricDescriptor, IMetricDescriptor, bool>, Func<IMetricDescriptor, int>) EqualityComparer<IMetricDescriptor>.Default Constructors MetricDescriptorEqualityComparer() public MetricDescriptorEqualityComparer() Fields Instance public static readonly EqualityComparer<IMetricDescriptor> Instance Field Value EqualityComparer<IMetricDescriptor> Methods Equals(IMetricDescriptor, IMetricDescriptor) public override bool Equals(IMetricDescriptor x, IMetricDescriptor y) Parameters x IMetricDescriptor y IMetricDescriptor Returns bool GetHashCode(IMetricDescriptor) public override int GetHashCode(IMetricDescriptor obj) Parameters obj IMetricDescriptor Returns int"
  },
  "api/BenchmarkDotNet.Reports.Summary.html": {
    "href": "api/BenchmarkDotNet.Reports.Summary.html",
    "title": "Class Summary | BenchmarkDotNet",
    "summary": "Class Summary Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public class Summary Inheritance object Summary Extension Methods ReportExtensions.GetReportFor<T>(Summary, Expression<Action<T>>) ReportExtensions.GetRunsFor<T>(Summary, Expression<Action<T>>) SummaryExtensions.GetColumns(Summary) SummaryExtensions.GetCultureInfo(Summary?) SummaryExtensions.GetLogicalGroupForBenchmark(Summary, BenchmarkCase) Constructors Summary(string, ImmutableArray<BenchmarkReport>, HostEnvironmentInfo, string, string, TimeSpan, CultureInfo, ImmutableArray<ValidationError>, ImmutableArray<IColumnHidingRule>, SummaryStyle?) public Summary(string title, ImmutableArray<BenchmarkReport> reports, HostEnvironmentInfo hostEnvironmentInfo, string resultsDirectoryPath, string logFilePath, TimeSpan totalTime, CultureInfo cultureInfo, ImmutableArray<ValidationError> validationErrors, ImmutableArray<IColumnHidingRule> columnHidingRules, SummaryStyle? summaryStyle = null) Parameters title string reports ImmutableArray<BenchmarkReport> hostEnvironmentInfo HostEnvironmentInfo resultsDirectoryPath string logFilePath string totalTime TimeSpan cultureInfo CultureInfo validationErrors ImmutableArray<ValidationError> columnHidingRules ImmutableArray<IColumnHidingRule> summaryStyle SummaryStyle Properties AllRuntimes public string AllRuntimes { get; } Property Value string BenchmarksCases public ImmutableArray<BenchmarkCase> BenchmarksCases { get; } Property Value ImmutableArray<BenchmarkCase> ColumnHidingRules public ImmutableArray<IColumnHidingRule> ColumnHidingRules { get; } Property Value ImmutableArray<IColumnHidingRule> HasCriticalValidationErrors public bool HasCriticalValidationErrors { get; } Property Value bool HostEnvironmentInfo public HostEnvironmentInfo HostEnvironmentInfo { get; } Property Value HostEnvironmentInfo IsMultipleRuntimes public bool IsMultipleRuntimes { get; } Property Value bool this[BenchmarkCase] Returns a report for the given benchmark or null if there is no a corresponded report. public BenchmarkReport? this[BenchmarkCase benchmarkCase] { get; } Parameters benchmarkCase BenchmarkCase Property Value BenchmarkReport LogFilePath public string LogFilePath { get; } Property Value string Orderer public IOrderer Orderer { get; } Property Value IOrderer Reports public ImmutableArray<BenchmarkReport> Reports { get; } Property Value ImmutableArray<BenchmarkReport> ResultsDirectoryPath public string ResultsDirectoryPath { get; } Property Value string Style public SummaryStyle Style { get; } Property Value SummaryStyle Table public SummaryTable Table { get; } Property Value SummaryTable Title public string Title { get; } Property Value string TotalTime public TimeSpan TotalTime { get; } Property Value TimeSpan ValidationErrors public ImmutableArray<ValidationError> ValidationErrors { get; } Property Value ImmutableArray<ValidationError> Methods GetBaseline(string?) public BenchmarkCase? GetBaseline(string? logicalGroupKey) Parameters logicalGroupKey string Returns BenchmarkCase GetLogicalGroupKey(BenchmarkCase) public string? GetLogicalGroupKey(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns string GetNonBaselines(string) public IEnumerable<BenchmarkCase> GetNonBaselines(string logicalGroupKey) Parameters logicalGroupKey string Returns IEnumerable<BenchmarkCase> GetNumberOfExecutedBenchmarks() public int GetNumberOfExecutedBenchmarks() Returns int HasBaselines() public bool HasBaselines() Returns bool HasReport(BenchmarkCase) public bool HasReport(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns bool IsBaseline(BenchmarkCase) public bool IsBaseline(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns bool"
  },
  "api/BenchmarkDotNet.Reports.SummaryExtensions.html": {
    "href": "api/BenchmarkDotNet.Reports.SummaryExtensions.html",
    "title": "Class SummaryExtensions | BenchmarkDotNet",
    "summary": "Class SummaryExtensions Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public static class SummaryExtensions Inheritance object SummaryExtensions Methods GetColumns(Summary) public static IColumn[] GetColumns(this Summary summary) Parameters summary Summary Returns IColumn[] GetCultureInfo(Summary?) public static CultureInfo GetCultureInfo(this Summary? summary) Parameters summary Summary Returns CultureInfo GetLogicalGroupForBenchmark(Summary, BenchmarkCase) public static IEnumerable<BenchmarkCase> GetLogicalGroupForBenchmark(this Summary summary, BenchmarkCase benchmarkCase) Parameters summary Summary benchmarkCase BenchmarkCase Returns IEnumerable<BenchmarkCase>"
  },
  "api/BenchmarkDotNet.Reports.SummaryStyle.html": {
    "href": "api/BenchmarkDotNet.Reports.SummaryStyle.html",
    "title": "Class SummaryStyle | BenchmarkDotNet",
    "summary": "Class SummaryStyle Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public class SummaryStyle : IEquatable<SummaryStyle> Inheritance object SummaryStyle Implements IEquatable<SummaryStyle> Constructors SummaryStyle(CultureInfo?, bool, SizeUnit?, TimeUnit?, bool, bool, int, RatioStyle, TextJustification, TextJustification) public SummaryStyle(CultureInfo? cultureInfo, bool printUnitsInHeader, SizeUnit? sizeUnit, TimeUnit? timeUnit, bool printUnitsInContent = true, bool printZeroValuesInContent = false, int maxParameterColumnWidth = 20, RatioStyle ratioStyle = RatioStyle.Value, SummaryTable.SummaryTableColumn.TextJustification textColumnJustification = TextJustification.Left, SummaryTable.SummaryTableColumn.TextJustification numericColumnJustification = TextJustification.Right) Parameters cultureInfo CultureInfo printUnitsInHeader bool sizeUnit SizeUnit timeUnit TimeUnit printUnitsInContent bool printZeroValuesInContent bool maxParameterColumnWidth int ratioStyle RatioStyle textColumnJustification SummaryTable.SummaryTableColumn.TextJustification numericColumnJustification SummaryTable.SummaryTableColumn.TextJustification Fields Default public static readonly SummaryStyle Default Field Value SummaryStyle Properties CultureInfo public CultureInfo CultureInfo { get; } Property Value CultureInfo MaxParameterColumnWidth public int MaxParameterColumnWidth { get; } Property Value int NumericColumnJustification public SummaryTable.SummaryTableColumn.TextJustification NumericColumnJustification { get; } Property Value SummaryTable.SummaryTableColumn.TextJustification PrintUnitsInContent public bool PrintUnitsInContent { get; } Property Value bool PrintUnitsInHeader public bool PrintUnitsInHeader { get; } Property Value bool PrintZeroValuesInContent public bool PrintZeroValuesInContent { get; } Property Value bool RatioStyle public RatioStyle RatioStyle { get; } Property Value RatioStyle SizeUnit public SizeUnit? SizeUnit { get; } Property Value SizeUnit TextColumnJustification public SummaryTable.SummaryTableColumn.TextJustification TextColumnJustification { get; } Property Value SummaryTable.SummaryTableColumn.TextJustification TimeUnit public TimeUnit? TimeUnit { get; } Property Value TimeUnit Methods Equals(SummaryStyle) public bool Equals(SummaryStyle other) Parameters other SummaryStyle Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int WithCultureInfo(CultureInfo) public SummaryStyle WithCultureInfo(CultureInfo cultureInfo) Parameters cultureInfo CultureInfo Returns SummaryStyle WithMaxParameterColumnWidth(int) public SummaryStyle WithMaxParameterColumnWidth(int maxParameterColumnWidth) Parameters maxParameterColumnWidth int Returns SummaryStyle WithRatioStyle(RatioStyle) public SummaryStyle WithRatioStyle(RatioStyle ratioStyle) Parameters ratioStyle RatioStyle Returns SummaryStyle WithSizeUnit(SizeUnit) public SummaryStyle WithSizeUnit(SizeUnit sizeUnit) Parameters sizeUnit SizeUnit Returns SummaryStyle WithTimeUnit(TimeUnit) public SummaryStyle WithTimeUnit(TimeUnit timeUnit) Parameters timeUnit TimeUnit Returns SummaryStyle WithZeroMetricValuesInContent() public SummaryStyle WithZeroMetricValuesInContent() Returns SummaryStyle Operators operator ==(SummaryStyle, SummaryStyle) public static bool operator ==(SummaryStyle left, SummaryStyle right) Parameters left SummaryStyle right SummaryStyle Returns bool operator !=(SummaryStyle, SummaryStyle) public static bool operator !=(SummaryStyle left, SummaryStyle right) Parameters left SummaryStyle right SummaryStyle Returns bool"
  },
  "api/BenchmarkDotNet.Reports.SummaryTable.html": {
    "href": "api/BenchmarkDotNet.Reports.SummaryTable.html",
    "title": "Class SummaryTable | BenchmarkDotNet",
    "summary": "Class SummaryTable Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public class SummaryTable Inheritance object SummaryTable Extension Methods SummaryTableExtensions.PrintCommonColumns(SummaryTable, ILogger) SummaryTableExtensions.PrintLine(SummaryTable, string[], ILogger, string, string, bool, bool, MarkdownExporter.MarkdownHighlightStrategy, string, bool) SummaryTableExtensions.PrintLine(SummaryTable, string[], ILogger, string, string) Properties ColumnCount public int ColumnCount { get; } Property Value int Columns public SummaryTable.SummaryTableColumn[] Columns { get; } Property Value SummaryTableColumn[] EffectiveSummaryStyle public SummaryStyle EffectiveSummaryStyle { get; } Property Value SummaryStyle FullContent public string[][] FullContent { get; } Property Value string[][] FullContentStartOfHighlightGroup public bool[] FullContentStartOfHighlightGroup { get; } Property Value bool[] FullContentStartOfLogicalGroup public bool[] FullContentStartOfLogicalGroup { get; } Property Value bool[] FullContentWithHeader public string[][] FullContentWithHeader { get; } Property Value string[][] FullHeader public string[] FullHeader { get; } Property Value string[] IsDefault public bool[] IsDefault { get; } Property Value bool[] SeparateLogicalGroups public bool SeparateLogicalGroups { get; } Property Value bool Summary public Summary Summary { get; } Property Value Summary"
  },
  "api/BenchmarkDotNet.Reports.SummaryTable.SummaryTableColumn.html": {
    "href": "api/BenchmarkDotNet.Reports.SummaryTable.SummaryTableColumn.html",
    "title": "Class SummaryTable.SummaryTableColumn | BenchmarkDotNet",
    "summary": "Class SummaryTable.SummaryTableColumn Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public class SummaryTable.SummaryTableColumn Inheritance object SummaryTable.SummaryTableColumn Constructors SummaryTableColumn(SummaryTable, int, IColumn, bool) public SummaryTableColumn(SummaryTable table, int index, IColumn column, bool hide = false) Parameters table SummaryTable index int column IColumn hide bool Properties Content public string[] Content { get; } Property Value string[] Header public string Header { get; } Property Value string Index public int Index { get; } Property Value int IsDefault public bool IsDefault { get; } Property Value bool Justify public SummaryTable.SummaryTableColumn.TextJustification Justify { get; } Property Value SummaryTable.SummaryTableColumn.TextJustification NeedToShow public bool NeedToShow { get; } Property Value bool OriginalColumn public IColumn OriginalColumn { get; } Property Value IColumn Width public int Width { get; } Property Value int Methods ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Reports.SummaryTable.SummaryTableColumn.TextJustification.html": {
    "href": "api/BenchmarkDotNet.Reports.SummaryTable.SummaryTableColumn.TextJustification.html",
    "title": "Enum SummaryTable.SummaryTableColumn.TextJustification | BenchmarkDotNet",
    "summary": "Enum SummaryTable.SummaryTableColumn.TextJustification Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public enum SummaryTable.SummaryTableColumn.TextJustification Fields Left = 0 Right = 1"
  },
  "api/BenchmarkDotNet.Reports.SummaryTableExtensions.html": {
    "href": "api/BenchmarkDotNet.Reports.SummaryTableExtensions.html",
    "title": "Class SummaryTableExtensions | BenchmarkDotNet",
    "summary": "Class SummaryTableExtensions Namespace BenchmarkDotNet.Reports Assembly BenchmarkDotNet.dll public static class SummaryTableExtensions Inheritance object SummaryTableExtensions Methods PrintCommonColumns(SummaryTable, ILogger) public static void PrintCommonColumns(this SummaryTable table, ILogger logger) Parameters table SummaryTable logger ILogger PrintLine(SummaryTable, string[], ILogger, string, string) public static void PrintLine(this SummaryTable table, string[] line, ILogger logger, string leftDel, string rightDel) Parameters table SummaryTable line string[] logger ILogger leftDel string rightDel string PrintLine(SummaryTable, string[], ILogger, string, string, bool, bool, MarkdownHighlightStrategy, string, bool) public static void PrintLine(this SummaryTable table, string[] line, ILogger logger, string leftDel, string rightDel, bool highlightRow, bool startOfGroup, MarkdownExporter.MarkdownHighlightStrategy startOfGroupHighlightStrategy, string boldMarkupFormat, bool escapeHtml) Parameters table SummaryTable line string[] logger ILogger leftDel string rightDel string highlightRow bool startOfGroup bool startOfGroupHighlightStrategy MarkdownExporter.MarkdownHighlightStrategy boldMarkupFormat string escapeHtml bool"
  },
  "api/BenchmarkDotNet.Running.BenchmarkBuildInfo.html": {
    "href": "api/BenchmarkDotNet.Running.BenchmarkBuildInfo.html",
    "title": "Class BenchmarkBuildInfo | BenchmarkDotNet",
    "summary": "Class BenchmarkBuildInfo Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public class BenchmarkBuildInfo Inheritance object BenchmarkBuildInfo Constructors BenchmarkBuildInfo(BenchmarkCase, ImmutableConfig, int) public BenchmarkBuildInfo(BenchmarkCase benchmarkCase, ImmutableConfig config, int id) Parameters benchmarkCase BenchmarkCase config ImmutableConfig id int Properties BenchmarkCase public BenchmarkCase BenchmarkCase { get; } Property Value BenchmarkCase Config public ImmutableConfig Config { get; } Property Value ImmutableConfig Id public BenchmarkId Id { get; } Property Value BenchmarkId"
  },
  "api/BenchmarkDotNet.Running.BenchmarkCase.html": {
    "href": "api/BenchmarkDotNet.Running.BenchmarkCase.html",
    "title": "Class BenchmarkCase | BenchmarkDotNet",
    "summary": "Class BenchmarkCase Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public class BenchmarkCase : IComparable<BenchmarkCase>, IDisposable Inheritance object BenchmarkCase Implements IComparable<BenchmarkCase> IDisposable Properties Config public ImmutableConfig Config { get; } Property Value ImmutableConfig Descriptor public Descriptor Descriptor { get; } Property Value Descriptor DisplayInfo public string DisplayInfo { get; } Property Value string FolderInfo public string FolderInfo { get; } Property Value string HasArguments public bool HasArguments { get; } Property Value bool HasParameters public bool HasParameters { get; } Property Value bool Job public Job Job { get; } Property Value Job Parameters public ParameterInstances Parameters { get; } Property Value ParameterInstances Methods CompareTo(BenchmarkCase) public int CompareTo(BenchmarkCase other) Parameters other BenchmarkCase Returns int Create(Descriptor, Job, ParameterInstances, ImmutableConfig) public static BenchmarkCase Create(Descriptor descriptor, Job job, ParameterInstances parameters, ImmutableConfig config) Parameters descriptor Descriptor job Job parameters ParameterInstances config ImmutableConfig Returns BenchmarkCase Dispose() public void Dispose() GetRuntime() public Runtime GetRuntime() Returns Runtime ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Running.BenchmarkConverter.html": {
    "href": "api/BenchmarkDotNet.Running.BenchmarkConverter.html",
    "title": "Class BenchmarkConverter | BenchmarkDotNet",
    "summary": "Class BenchmarkConverter Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public static class BenchmarkConverter Inheritance object BenchmarkConverter Methods MethodsToBenchmarks(Type, MethodInfo[], IConfig?) public static BenchmarkRunInfo MethodsToBenchmarks(Type containingType, MethodInfo[] benchmarkMethods, IConfig? config = null) Parameters containingType Type benchmarkMethods MethodInfo[] config IConfig Returns BenchmarkRunInfo TypeToBenchmarks(Type, IConfig?) public static BenchmarkRunInfo TypeToBenchmarks(Type type, IConfig? config = null) Parameters type Type config IConfig Returns BenchmarkRunInfo"
  },
  "api/BenchmarkDotNet.Running.BenchmarkId.html": {
    "href": "api/BenchmarkDotNet.Running.BenchmarkId.html",
    "title": "Struct BenchmarkId | BenchmarkDotNet",
    "summary": "Struct BenchmarkId Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll represents an internal entity used to identify a benchmark within an executable with multiple benchmarks public struct BenchmarkId Constructors BenchmarkId(int, BenchmarkCase) public BenchmarkId(int value, BenchmarkCase benchmarkCase) Parameters value int benchmarkCase BenchmarkCase Properties Value public readonly int Value { get; } Property Value int Methods Equals(BenchmarkId) public bool Equals(BenchmarkId other) Parameters other BenchmarkId Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int ToArguments() public string ToArguments() Returns string ToArguments(string, string) public string ToArguments(string fromBenchmark, string toBenchmark) Parameters fromBenchmark string toBenchmark string Returns string ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Running.BenchmarkPartitioner.html": {
    "href": "api/BenchmarkDotNet.Running.BenchmarkPartitioner.html",
    "title": "Class BenchmarkPartitioner | BenchmarkDotNet",
    "summary": "Class BenchmarkPartitioner Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public static class BenchmarkPartitioner Inheritance object BenchmarkPartitioner Methods CreateForBuild(BenchmarkRunInfo[], IResolver) public static BuildPartition[] CreateForBuild(BenchmarkRunInfo[] supportedBenchmarks, IResolver resolver) Parameters supportedBenchmarks BenchmarkRunInfo[] resolver IResolver Returns BuildPartition[]"
  },
  "api/BenchmarkDotNet.Running.BenchmarkRunInfo.html": {
    "href": "api/BenchmarkDotNet.Running.BenchmarkRunInfo.html",
    "title": "Class BenchmarkRunInfo | BenchmarkDotNet",
    "summary": "Class BenchmarkRunInfo Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public class BenchmarkRunInfo : IDisposable Inheritance object BenchmarkRunInfo Implements IDisposable Constructors BenchmarkRunInfo(BenchmarkCase[], Type, ImmutableConfig) public BenchmarkRunInfo(BenchmarkCase[] benchmarksCase, Type type, ImmutableConfig config) Parameters benchmarksCase BenchmarkCase[] type Type config ImmutableConfig Properties BenchmarksCases public BenchmarkCase[] BenchmarksCases { get; } Property Value BenchmarkCase[] Config public ImmutableConfig Config { get; } Property Value ImmutableConfig Type public Type Type { get; } Property Value Type Methods Dispose() public void Dispose()"
  },
  "api/BenchmarkDotNet.Running.BenchmarkRunner.html": {
    "href": "api/BenchmarkDotNet.Running.BenchmarkRunner.html",
    "title": "Class BenchmarkRunner | BenchmarkDotNet",
    "summary": "Class BenchmarkRunner Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public static class BenchmarkRunner Inheritance object BenchmarkRunner Methods Run(BenchmarkRunInfo) public static Summary Run(BenchmarkRunInfo benchmarkRunInfo) Parameters benchmarkRunInfo BenchmarkRunInfo Returns Summary Run(BenchmarkRunInfo[]) public static Summary[] Run(BenchmarkRunInfo[] benchmarkRunInfos) Parameters benchmarkRunInfos BenchmarkRunInfo[] Returns Summary[] Run(Assembly, IConfig?, string[]?) public static Summary[] Run(Assembly assembly, IConfig? config = null, string[]? args = null) Parameters assembly Assembly config IConfig args string[] Returns Summary[] Run(Type, IConfig?, string[]?) public static Summary Run(Type type, IConfig? config = null, string[]? args = null) Parameters type Type config IConfig args string[] Returns Summary Run(Type, MethodInfo[], IConfig?) public static Summary Run(Type type, MethodInfo[] methods, IConfig? config = null) Parameters type Type methods MethodInfo[] config IConfig Returns Summary Run(Type[], IConfig?, string[]?) public static Summary[] Run(Type[] types, IConfig? config = null, string[]? args = null) Parameters types Type[] config IConfig args string[] Returns Summary[] Run<T>(IConfig?, string[]?) public static Summary Run<T>(IConfig? config = null, string[]? args = null) Parameters config IConfig args string[] Returns Summary Type Parameters T"
  },
  "api/BenchmarkDotNet.Running.BenchmarkSwitcher.html": {
    "href": "api/BenchmarkDotNet.Running.BenchmarkSwitcher.html",
    "title": "Class BenchmarkSwitcher | BenchmarkDotNet",
    "summary": "Class BenchmarkSwitcher Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public class BenchmarkSwitcher Inheritance object BenchmarkSwitcher Constructors BenchmarkSwitcher(Assembly) public BenchmarkSwitcher(Assembly assembly) Parameters assembly Assembly BenchmarkSwitcher(Assembly[]) public BenchmarkSwitcher(Assembly[] assemblies) Parameters assemblies Assembly[] BenchmarkSwitcher(Type[]) public BenchmarkSwitcher(Type[] types) Parameters types Type[] Methods FromAssemblies(Assembly[]) public static BenchmarkSwitcher FromAssemblies(Assembly[] assemblies) Parameters assemblies Assembly[] Returns BenchmarkSwitcher FromAssembly(Assembly) public static BenchmarkSwitcher FromAssembly(Assembly assembly) Parameters assembly Assembly Returns BenchmarkSwitcher FromTypes(Type[]) public static BenchmarkSwitcher FromTypes(Type[] types) Parameters types Type[] Returns BenchmarkSwitcher Run(string[]?, IConfig?) public IEnumerable<Summary> Run(string[]? args = null, IConfig? config = null) Parameters args string[] config IConfig Returns IEnumerable<Summary> RunAll(IConfig?, string[]?) Run all available benchmarks. public IEnumerable<Summary> RunAll(IConfig? config = null, string[]? args = null) Parameters config IConfig args string[] Returns IEnumerable<Summary> RunAllJoined(IConfig?, string[]?) Run all available benchmarks and join them to a single summary public Summary RunAllJoined(IConfig? config = null, string[]? args = null) Parameters config IConfig args string[] Returns Summary With(Assembly) public BenchmarkSwitcher With(Assembly assembly) Parameters assembly Assembly Returns BenchmarkSwitcher With(Assembly[]) public BenchmarkSwitcher With(Assembly[] assemblies) Parameters assemblies Assembly[] Returns BenchmarkSwitcher With(Type) public BenchmarkSwitcher With(Type type) Parameters type Type Returns BenchmarkSwitcher With(Type[]) public BenchmarkSwitcher With(Type[] types) Parameters types Type[] Returns BenchmarkSwitcher"
  },
  "api/BenchmarkDotNet.Running.BuildPartition.html": {
    "href": "api/BenchmarkDotNet.Running.BuildPartition.html",
    "title": "Class BuildPartition | BenchmarkDotNet",
    "summary": "Class BuildPartition Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public class BuildPartition Inheritance object BuildPartition Constructors BuildPartition(BenchmarkBuildInfo[], IResolver) public BuildPartition(BenchmarkBuildInfo[] benchmarks, IResolver resolver) Parameters benchmarks BenchmarkBuildInfo[] resolver IResolver Properties AssemblyLocation public string AssemblyLocation { get; } Property Value string Benchmarks public BenchmarkBuildInfo[] Benchmarks { get; } Property Value BenchmarkBuildInfo[] BuildConfiguration public string BuildConfiguration { get; } Property Value string GenerateMSBuildBinLog public bool GenerateMSBuildBinLog { get; } Property Value bool IsCustomBuildConfiguration public bool IsCustomBuildConfiguration { get; } Property Value bool IsNativeAot public bool IsNativeAot { get; } Property Value bool IsNetFramework public bool IsNetFramework { get; } Property Value bool IsWasm public bool IsWasm { get; } Property Value bool Jit public Jit Jit { get; } Property Value Jit LogBuildOutput public bool LogBuildOutput { get; } Property Value bool Platform public Platform Platform { get; } Property Value Platform ProgramName public string ProgramName { get; } Property Value string RepresentativeBenchmarkCase the benchmarks are grouped by the build settings so you can use this benchmark to get the runtime settings public BenchmarkCase RepresentativeBenchmarkCase { get; } Property Value BenchmarkCase Resolver public IResolver Resolver { get; } Property Value IResolver Runtime public Runtime Runtime { get; } Property Value Runtime Timeout public TimeSpan Timeout { get; } Property Value TimeSpan Methods ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Running.DefaultCategoryDiscoverer.html": {
    "href": "api/BenchmarkDotNet.Running.DefaultCategoryDiscoverer.html",
    "title": "Class DefaultCategoryDiscoverer | BenchmarkDotNet",
    "summary": "Class DefaultCategoryDiscoverer Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public class DefaultCategoryDiscoverer : ICategoryDiscoverer Inheritance object DefaultCategoryDiscoverer Implements ICategoryDiscoverer Constructors DefaultCategoryDiscoverer(bool) public DefaultCategoryDiscoverer(bool inherit = true) Parameters inherit bool Fields Instance public static readonly ICategoryDiscoverer Instance Field Value ICategoryDiscoverer Methods GetCategories(MethodInfo) public virtual string[] GetCategories(MethodInfo method) Parameters method MethodInfo Returns string[]"
  },
  "api/BenchmarkDotNet.Running.Descriptor.html": {
    "href": "api/BenchmarkDotNet.Running.Descriptor.html",
    "title": "Class Descriptor | BenchmarkDotNet",
    "summary": "Class Descriptor Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public class Descriptor : IEquatable<Descriptor> Inheritance object Descriptor Implements IEquatable<Descriptor> Constructors Descriptor(Type, MethodInfo, MethodInfo?, MethodInfo?, MethodInfo?, MethodInfo?, string?, string?, bool, string[]?, int, int) public Descriptor(Type type, MethodInfo workloadMethod, MethodInfo? globalSetupMethod = null, MethodInfo? globalCleanupMethod = null, MethodInfo? iterationSetupMethod = null, MethodInfo? iterationCleanupMethod = null, string? description = null, string? additionalLogic = null, bool baseline = false, string[]? categories = null, int operationsPerInvoke = 1, int methodIndex = 0) Parameters type Type workloadMethod MethodInfo globalSetupMethod MethodInfo globalCleanupMethod MethodInfo iterationSetupMethod MethodInfo iterationCleanupMethod MethodInfo description string additionalLogic string baseline bool categories string[] operationsPerInvoke int methodIndex int Properties AdditionalLogic public string AdditionalLogic { get; } Property Value string Baseline public bool Baseline { get; } Property Value bool Categories public string[] Categories { get; } Property Value string[] DisplayInfo public string DisplayInfo { get; } Property Value string FolderInfo public string FolderInfo { get; } Property Value string GlobalCleanupMethod public MethodInfo? GlobalCleanupMethod { get; } Property Value MethodInfo GlobalSetupMethod public MethodInfo? GlobalSetupMethod { get; } Property Value MethodInfo IterationCleanupMethod public MethodInfo? IterationCleanupMethod { get; } Property Value MethodInfo IterationSetupMethod public MethodInfo? IterationSetupMethod { get; } Property Value MethodInfo MethodIndex public int MethodIndex { get; } Property Value int OperationsPerInvoke public int OperationsPerInvoke { get; } Property Value int Type public Type Type { get; } Property Value Type WorkloadMethod public MethodInfo WorkloadMethod { get; } Property Value MethodInfo WorkloadMethodDisplayInfo public string WorkloadMethodDisplayInfo { get; } Property Value string Methods Equals(Descriptor?) public bool Equals(Descriptor? other) Parameters other Descriptor Returns bool Equals(object?) public override bool Equals(object? obj) Parameters obj object Returns bool GetFilterName() public string GetFilterName() Returns string GetHashCode() public override int GetHashCode() Returns int HasCategory(string) public bool HasCategory(string category) Parameters category string Returns bool ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Running.html": {
    "href": "api/BenchmarkDotNet.Running.html",
    "title": "Namespace BenchmarkDotNet.Running | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Running Classes BenchmarkBuildInfo BenchmarkCase BenchmarkConverter BenchmarkPartitioner BenchmarkRunInfo BenchmarkRunner BenchmarkSwitcher BuildPartition DefaultCategoryDiscoverer Descriptor InvalidBenchmarkDeclarationException TypeFilter Structs BenchmarkId represents an internal entity used to identify a benchmark within an executable with multiple benchmarks Interfaces ICategoryDiscoverer"
  },
  "api/BenchmarkDotNet.Running.ICategoryDiscoverer.html": {
    "href": "api/BenchmarkDotNet.Running.ICategoryDiscoverer.html",
    "title": "Interface ICategoryDiscoverer | BenchmarkDotNet",
    "summary": "Interface ICategoryDiscoverer Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public interface ICategoryDiscoverer Methods GetCategories(MethodInfo) string[] GetCategories(MethodInfo method) Parameters method MethodInfo Returns string[]"
  },
  "api/BenchmarkDotNet.Running.InvalidBenchmarkDeclarationException.html": {
    "href": "api/BenchmarkDotNet.Running.InvalidBenchmarkDeclarationException.html",
    "title": "Class InvalidBenchmarkDeclarationException | BenchmarkDotNet",
    "summary": "Class InvalidBenchmarkDeclarationException Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public class InvalidBenchmarkDeclarationException : Exception, ISerializable Inheritance object Exception InvalidBenchmarkDeclarationException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace Exception.SerializeObjectState Constructors InvalidBenchmarkDeclarationException(string) public InvalidBenchmarkDeclarationException(string message) Parameters message string"
  },
  "api/BenchmarkDotNet.Running.TypeFilter.html": {
    "href": "api/BenchmarkDotNet.Running.TypeFilter.html",
    "title": "Class TypeFilter | BenchmarkDotNet",
    "summary": "Class TypeFilter Namespace BenchmarkDotNet.Running Assembly BenchmarkDotNet.dll public static class TypeFilter Inheritance object TypeFilter Methods Filter(IConfig, IEnumerable<Type>) public static BenchmarkRunInfo[] Filter(IConfig effectiveConfig, IEnumerable<Type> types) Parameters effectiveConfig IConfig types IEnumerable<Type> Returns BenchmarkRunInfo[] GetTypesWithRunnableBenchmarks(IEnumerable<Type>, IEnumerable<Assembly>, ILogger) public static (bool allTypesValid, IReadOnlyList<Type> runnable) GetTypesWithRunnableBenchmarks(IEnumerable<Type> types, IEnumerable<Assembly> assemblies, ILogger logger) Parameters types IEnumerable<Type> assemblies IEnumerable<Assembly> logger ILogger Returns (bool allTypesValid, IReadOnlyList<Type> runnable)"
  },
  "api/BenchmarkDotNet.Toolchains.ArtifactsPaths.html": {
    "href": "api/BenchmarkDotNet.Toolchains.ArtifactsPaths.html",
    "title": "Class ArtifactsPaths | BenchmarkDotNet",
    "summary": "Class ArtifactsPaths Namespace BenchmarkDotNet.Toolchains Assembly BenchmarkDotNet.dll public class ArtifactsPaths Inheritance object ArtifactsPaths Derived InProcessEmitArtifactsPath Constructors ArtifactsPaths(string, string, string, string, string, string, string, string, string, string, string, string) public ArtifactsPaths(string rootArtifactsFolderPath, string buildArtifactsDirectoryPath, string binariesDirectoryPath, string publishDirectoryPath, string programCodePath, string appConfigPath, string nuGetConfigPath, string projectFilePath, string buildScriptFilePath, string executablePath, string programName, string packagesDirectoryName) Parameters rootArtifactsFolderPath string buildArtifactsDirectoryPath string binariesDirectoryPath string publishDirectoryPath string programCodePath string appConfigPath string nuGetConfigPath string projectFilePath string buildScriptFilePath string executablePath string programName string packagesDirectoryName string Fields Empty public static readonly ArtifactsPaths Empty Field Value ArtifactsPaths Properties AppConfigPath public string AppConfigPath { get; } Property Value string BinariesDirectoryPath public string BinariesDirectoryPath { get; } Property Value string BuildArtifactsDirectoryPath public string BuildArtifactsDirectoryPath { get; } Property Value string BuildScriptFilePath public string BuildScriptFilePath { get; } Property Value string ExecutablePath public string ExecutablePath { get; } Property Value string NuGetConfigPath public string NuGetConfigPath { get; } Property Value string PackagesDirectoryName public string PackagesDirectoryName { get; } Property Value string ProgramCodePath public string ProgramCodePath { get; } Property Value string ProgramName public string ProgramName { get; } Property Value string ProjectFilePath public string ProjectFilePath { get; } Property Value string PublishDirectoryPath public string PublishDirectoryPath { get; } Property Value string RootArtifactsFolderPath public string RootArtifactsFolderPath { get; } Property Value string"
  },
  "api/BenchmarkDotNet.Toolchains.CoreRt.CoreRtToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.CoreRt.CoreRtToolchain.html",
    "title": "Class CoreRtToolchain | BenchmarkDotNet",
    "summary": "Class CoreRtToolchain Namespace BenchmarkDotNet.Toolchains.CoreRt Assembly BenchmarkDotNet.dll [Obsolete(\"Please use NativeAotToolchain instead.\", true)] public class CoreRtToolchain Inheritance object CoreRtToolchain Constructors CoreRtToolchain() public CoreRtToolchain()"
  },
  "api/BenchmarkDotNet.Toolchains.CoreRt.CoreRtToolchainBuilder.html": {
    "href": "api/BenchmarkDotNet.Toolchains.CoreRt.CoreRtToolchainBuilder.html",
    "title": "Class CoreRtToolchainBuilder | BenchmarkDotNet",
    "summary": "Class CoreRtToolchainBuilder Namespace BenchmarkDotNet.Toolchains.CoreRt Assembly BenchmarkDotNet.dll [Obsolete(\"Please use NativeAotToolchainBuilder instead.\", true)] public class CoreRtToolchainBuilder Inheritance object CoreRtToolchainBuilder Constructors CoreRtToolchainBuilder() public CoreRtToolchainBuilder()"
  },
  "api/BenchmarkDotNet.Toolchains.CoreRt.html": {
    "href": "api/BenchmarkDotNet.Toolchains.CoreRt.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.CoreRt | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.CoreRt Classes CoreRtToolchain CoreRtToolchainBuilder"
  },
  "api/BenchmarkDotNet.Toolchains.CoreRun.CoreRunGenerator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.CoreRun.CoreRunGenerator.html",
    "title": "Class CoreRunGenerator | BenchmarkDotNet",
    "summary": "Class CoreRunGenerator Namespace BenchmarkDotNet.Toolchains.CoreRun Assembly BenchmarkDotNet.dll public class CoreRunGenerator : CsProjGenerator, IGenerator, IEquatable<CsProjGenerator> Inheritance object GeneratorBase DotNetCliGenerator CsProjGenerator CoreRunGenerator Implements IGenerator IEquatable<CsProjGenerator> Inherited Members CsProjGenerator.GetBuildArtifactsDirectoryPath(BuildPartition, string) CsProjGenerator.GetProjectFilePath(string) CsProjGenerator.GenerateProject(BuildPartition, ArtifactsPaths, ILogger) CsProjGenerator.GetRuntimeSettings(GcMode, IResolver) CsProjGenerator.GetProjectFilePath(Type, ILogger) CsProjGenerator.Equals(object) CsProjGenerator.Equals(CsProjGenerator) CsProjGenerator.GetHashCode() CsProjGenerator.RuntimeFrameworkVersion DotNetCliGenerator.GetExecutableExtension() DotNetCliGenerator.GenerateBuildScript(BuildPartition, ArtifactsPaths) DotNetCliGenerator.TargetFrameworkMoniker DotNetCliGenerator.CliPath DotNetCliGenerator.PackagesPath DotNetCliGenerator.IsNetCore GeneratorBase.GenerateProject(BuildPartition, ILogger, string) GeneratorBase.GetPublishDirectoryPath(string, string) GeneratorBase.GenerateNuGetConfig(ArtifactsPaths) GeneratorBase.GenerateAppConfig(BuildPartition, ArtifactsPaths) GeneratorBase.GenerateCode(BuildPartition, ArtifactsPaths) GeneratorBase.GetExecutablePath(string, string) Constructors CoreRunGenerator(FileInfo, FileInfo, string, string, string) public CoreRunGenerator(FileInfo sourceCoreRun, FileInfo copyCoreRun, string targetFrameworkMoniker, string cliPath, string packagesPath) Parameters sourceCoreRun FileInfo copyCoreRun FileInfo targetFrameworkMoniker string cliPath string packagesPath string Methods CopyAllRequiredFiles(ArtifactsPaths) if you need to copy some extra files to make the benchmarks work you should override this method protected override void CopyAllRequiredFiles(ArtifactsPaths artifactsPaths) Parameters artifactsPaths ArtifactsPaths GetArtifactsToCleanup(ArtifactsPaths) returns a list of artifacts that should be removed after running the benchmarks protected override string[] GetArtifactsToCleanup(ArtifactsPaths artifactsPaths) Parameters artifactsPaths ArtifactsPaths Returns string[] GetBinariesDirectoryPath(string, string) returns a path where executable should be found after the build (usually \\bin) protected override string GetBinariesDirectoryPath(string buildArtifactsDirectoryPath, string configuration) Parameters buildArtifactsDirectoryPath string configuration string Returns string GetPackagesDirectoryPath(string) returns a path to the folder where NuGet packages should be restored protected override string GetPackagesDirectoryPath(string buildArtifactsDirectoryPath) Parameters buildArtifactsDirectoryPath string Returns string"
  },
  "api/BenchmarkDotNet.Toolchains.CoreRun.CoreRunPublisher.html": {
    "href": "api/BenchmarkDotNet.Toolchains.CoreRun.CoreRunPublisher.html",
    "title": "Class CoreRunPublisher | BenchmarkDotNet",
    "summary": "Class CoreRunPublisher Namespace BenchmarkDotNet.Toolchains.CoreRun Assembly BenchmarkDotNet.dll public class CoreRunPublisher : IBuilder Inheritance object CoreRunPublisher Implements IBuilder Constructors CoreRunPublisher(FileInfo, FileInfo?) public CoreRunPublisher(FileInfo coreRun, FileInfo? customDotNetCliPath = null) Parameters coreRun FileInfo customDotNetCliPath FileInfo Methods Build(GenerateResult, BuildPartition, ILogger) public BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger) Parameters generateResult GenerateResult buildPartition BuildPartition logger ILogger Returns BuildResult"
  },
  "api/BenchmarkDotNet.Toolchains.CoreRun.CoreRunToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.CoreRun.CoreRunToolchain.html",
    "title": "Class CoreRunToolchain | BenchmarkDotNet",
    "summary": "Class CoreRunToolchain Namespace BenchmarkDotNet.Toolchains.CoreRun Assembly BenchmarkDotNet.dll public class CoreRunToolchain : IToolchain Inheritance object CoreRunToolchain Implements IToolchain Constructors CoreRunToolchain(FileInfo, bool, string, FileInfo?, DirectoryInfo?, string) creates a CoreRunToolchain which is using provided CoreRun to execute .NET Core apps public CoreRunToolchain(FileInfo coreRun, bool createCopy = true, string targetFrameworkMoniker = \"net8.0\", FileInfo? customDotNetCliPath = null, DirectoryInfo? restorePath = null, string displayName = \"CoreRun\") Parameters coreRun FileInfo the path to CoreRun createCopy bool should a copy of CoreRun be performed? True by default. The toolchain replaces old dependencies in CoreRun folder with newer versions if used by the benchmarks. targetFrameworkMoniker string TFM, net8.0 is the default customDotNetCliPath FileInfo path to dotnet cli, if not provided the one from PATH will be used restorePath DirectoryInfo the directory to restore packages to displayName string display name, CoreRun is the default value Properties Builder public IBuilder Builder { get; } Property Value IBuilder CopyCoreRun public FileInfo CopyCoreRun { get; } Property Value FileInfo CustomDotNetCliPath public FileInfo CustomDotNetCliPath { get; } Property Value FileInfo Executor public IExecutor Executor { get; } Property Value IExecutor Generator public IGenerator Generator { get; } Property Value IGenerator IsInProcess public bool IsInProcess { get; } Property Value bool Name public string Name { get; } Property Value string RestorePath public DirectoryInfo RestorePath { get; } Property Value DirectoryInfo SourceCoreRun public FileInfo SourceCoreRun { get; } Property Value FileInfo Methods ToString() public override string ToString() Returns string Validate(BenchmarkCase, IResolver) public IEnumerable<ValidationError> Validate(BenchmarkCase benchmark, IResolver resolver) Parameters benchmark BenchmarkCase resolver IResolver Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Toolchains.CoreRun.html": {
    "href": "api/BenchmarkDotNet.Toolchains.CoreRun.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.CoreRun | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.CoreRun Classes CoreRunGenerator CoreRunPublisher CoreRunToolchain"
  },
  "api/BenchmarkDotNet.Toolchains.CsProj.CsProjClassicNetToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.CsProj.CsProjClassicNetToolchain.html",
    "title": "Class CsProjClassicNetToolchain | BenchmarkDotNet",
    "summary": "Class CsProjClassicNetToolchain Namespace BenchmarkDotNet.Toolchains.CsProj Assembly BenchmarkDotNet.dll this toolchain is designed for the new .csprojs, to build .NET 4.x benchmarks from the context of .NET Core host process it does not work with the old .csprojs or project.json! public class CsProjClassicNetToolchain : Toolchain, IToolchain Inheritance object Toolchain CsProjClassicNetToolchain Implements IToolchain Inherited Members Toolchain.ToString() Toolchain.Name Toolchain.Generator Toolchain.Builder Toolchain.Executor Toolchain.IsInProcess Fields Net461 public static readonly IToolchain Net461 Field Value IToolchain Net462 public static readonly IToolchain Net462 Field Value IToolchain Net47 public static readonly IToolchain Net47 Field Value IToolchain Net471 public static readonly IToolchain Net471 Field Value IToolchain Net472 public static readonly IToolchain Net472 Field Value IToolchain Net48 public static readonly IToolchain Net48 Field Value IToolchain Net481 public static readonly IToolchain Net481 Field Value IToolchain Methods From(string, string?, string?) public static IToolchain From(string targetFrameworkMoniker, string? packagesPath = null, string? customDotNetCliPath = null) Parameters targetFrameworkMoniker string packagesPath string customDotNetCliPath string Returns IToolchain Validate(BenchmarkCase, IResolver) public override IEnumerable<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver) Parameters benchmarkCase BenchmarkCase resolver IResolver Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Toolchains.CsProj.CsProjCoreToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.CsProj.CsProjCoreToolchain.html",
    "title": "Class CsProjCoreToolchain | BenchmarkDotNet",
    "summary": "Class CsProjCoreToolchain Namespace BenchmarkDotNet.Toolchains.CsProj Assembly BenchmarkDotNet.dll public class CsProjCoreToolchain : Toolchain, IToolchain, IEquatable<CsProjCoreToolchain> Inheritance object Toolchain CsProjCoreToolchain Implements IToolchain IEquatable<CsProjCoreToolchain> Derived MonoToolchain Inherited Members Toolchain.ToString() Toolchain.Name Toolchain.Generator Toolchain.Builder Toolchain.Executor Toolchain.IsInProcess Fields NetCoreApp10_0 public static readonly IToolchain NetCoreApp10_0 Field Value IToolchain NetCoreApp20 public static readonly IToolchain NetCoreApp20 Field Value IToolchain NetCoreApp21 public static readonly IToolchain NetCoreApp21 Field Value IToolchain NetCoreApp22 public static readonly IToolchain NetCoreApp22 Field Value IToolchain NetCoreApp30 public static readonly IToolchain NetCoreApp30 Field Value IToolchain NetCoreApp31 public static readonly IToolchain NetCoreApp31 Field Value IToolchain NetCoreApp50 public static readonly IToolchain NetCoreApp50 Field Value IToolchain NetCoreApp60 public static readonly IToolchain NetCoreApp60 Field Value IToolchain NetCoreApp70 public static readonly IToolchain NetCoreApp70 Field Value IToolchain NetCoreApp80 public static readonly IToolchain NetCoreApp80 Field Value IToolchain NetCoreApp90 public static readonly IToolchain NetCoreApp90 Field Value IToolchain Methods Equals(CsProjCoreToolchain) public bool Equals(CsProjCoreToolchain other) Parameters other CsProjCoreToolchain Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool From(NetCoreAppSettings) public static IToolchain From(NetCoreAppSettings settings) Parameters settings NetCoreAppSettings Returns IToolchain GetHashCode() public override int GetHashCode() Returns int Validate(BenchmarkCase, IResolver) public override IEnumerable<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver) Parameters benchmarkCase BenchmarkCase resolver IResolver Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Toolchains.CsProj.CsProjGenerator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.CsProj.CsProjGenerator.html",
    "title": "Class CsProjGenerator | BenchmarkDotNet",
    "summary": "Class CsProjGenerator Namespace BenchmarkDotNet.Toolchains.CsProj Assembly BenchmarkDotNet.dll public class CsProjGenerator : DotNetCliGenerator, IGenerator, IEquatable<CsProjGenerator> Inheritance object GeneratorBase DotNetCliGenerator CsProjGenerator Implements IGenerator IEquatable<CsProjGenerator> Derived CoreRunGenerator MonoGenerator MonoAotLLVMGenerator WasmGenerator Generator Inherited Members DotNetCliGenerator.GetExecutableExtension() DotNetCliGenerator.GetArtifactsToCleanup(ArtifactsPaths) DotNetCliGenerator.CopyAllRequiredFiles(ArtifactsPaths) DotNetCliGenerator.GetPackagesDirectoryPath(string) DotNetCliGenerator.GenerateBuildScript(BuildPartition, ArtifactsPaths) DotNetCliGenerator.TargetFrameworkMoniker DotNetCliGenerator.CliPath DotNetCliGenerator.PackagesPath DotNetCliGenerator.IsNetCore GeneratorBase.GenerateProject(BuildPartition, ILogger, string) GeneratorBase.GetPublishDirectoryPath(string, string) GeneratorBase.GenerateNuGetConfig(ArtifactsPaths) GeneratorBase.GenerateAppConfig(BuildPartition, ArtifactsPaths) GeneratorBase.GenerateCode(BuildPartition, ArtifactsPaths) GeneratorBase.GetExecutablePath(string, string) Constructors CsProjGenerator(string, string, string, string, bool) public CsProjGenerator(string targetFrameworkMoniker, string cliPath, string packagesPath, string runtimeFrameworkVersion, bool isNetCore = true) Parameters targetFrameworkMoniker string cliPath string packagesPath string runtimeFrameworkVersion string isNetCore bool Properties RuntimeFrameworkVersion public string RuntimeFrameworkVersion { get; } Property Value string Methods Equals(CsProjGenerator) public bool Equals(CsProjGenerator other) Parameters other CsProjGenerator Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GenerateProject(BuildPartition, ArtifactsPaths, ILogger) generates .csproj file with a reference to the project with benchmarks protected override void GenerateProject(BuildPartition buildPartition, ArtifactsPaths artifactsPaths, ILogger logger) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths logger ILogger GetBinariesDirectoryPath(string, string) returns a path where executable should be found after the build (usually \\bin) protected override string GetBinariesDirectoryPath(string buildArtifactsDirectoryPath, string configuration) Parameters buildArtifactsDirectoryPath string configuration string Returns string GetBuildArtifactsDirectoryPath(BuildPartition, string) we need our folder to be on the same level as the project that we want to reference we are limited by xprojs (by default compiles all .cs files in all subfolders, Program.cs could be doubled and fail the build) and also by NuGet internal implementation like looking for global.json file in parent folders protected override string GetBuildArtifactsDirectoryPath(BuildPartition buildPartition, string programName) Parameters buildPartition BuildPartition programName string Returns string GetHashCode() public override int GetHashCode() Returns int GetProjectFilePath(string) returns a path to the auto-generated .csproj file protected override string GetProjectFilePath(string buildArtifactsDirectoryPath) Parameters buildArtifactsDirectoryPath string Returns string GetProjectFilePath(Type, ILogger) returns a path to the project file which defines the benchmarks protected virtual FileInfo GetProjectFilePath(Type benchmarkTarget, ILogger logger) Parameters benchmarkTarget Type logger ILogger Returns FileInfo GetRuntimeSettings(GcMode, IResolver) returns an MSBuild string that defines Runtime settings protected virtual string GetRuntimeSettings(GcMode gcMode, IResolver resolver) Parameters gcMode GcMode resolver IResolver Returns string"
  },
  "api/BenchmarkDotNet.Toolchains.CsProj.html": {
    "href": "api/BenchmarkDotNet.Toolchains.CsProj.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.CsProj | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.CsProj Classes CsProjClassicNetToolchain this toolchain is designed for the new .csprojs, to build .NET 4.x benchmarks from the context of .NET Core host process it does not work with the old .csprojs or project.json! CsProjCoreToolchain CsProjGenerator"
  },
  "api/BenchmarkDotNet.Toolchains.DotNetCli.CustomDotNetCliToolchainBuilder.html": {
    "href": "api/BenchmarkDotNet.Toolchains.DotNetCli.CustomDotNetCliToolchainBuilder.html",
    "title": "Class CustomDotNetCliToolchainBuilder | BenchmarkDotNet",
    "summary": "Class CustomDotNetCliToolchainBuilder Namespace BenchmarkDotNet.Toolchains.DotNetCli Assembly BenchmarkDotNet.dll public abstract class CustomDotNetCliToolchainBuilder Inheritance object CustomDotNetCliToolchainBuilder Derived NativeAotToolchainBuilder Constructors CustomDotNetCliToolchainBuilder() protected CustomDotNetCliToolchainBuilder() Fields Feeds protected readonly Dictionary<string, string> Feeds Field Value Dictionary<string, string> customDotNetCliPath protected string customDotNetCliPath Field Value string displayName protected string displayName Field Value string runtimeFrameworkVersion protected string runtimeFrameworkVersion Field Value string runtimeIdentifier protected string runtimeIdentifier Field Value string useNuGetClearTag protected bool useNuGetClearTag Field Value bool useTempFolderForRestore protected bool useTempFolderForRestore Field Value bool Methods AdditionalNuGetFeed(string, string) it allows you to define an additional NuGet feed, you can seal the feeds list by using the UseNuGetClearTag() method public CustomDotNetCliToolchainBuilder AdditionalNuGetFeed(string feedName, string feedAddress) Parameters feedName string the name of the feed, will be used in the auto-generated NuGet.config file feedAddress string the address of the feed, will be used in the auto-generated NuGet.config file Returns CustomDotNetCliToolchainBuilder DisplayName(string) public CustomDotNetCliToolchainBuilder DisplayName(string newDisplayName) Parameters newDisplayName string the name of the toolchain to be displayed in results Returns CustomDotNetCliToolchainBuilder DotNetCli(string) public CustomDotNetCliToolchainBuilder DotNetCli(string newCustomDotNetCliPath) Parameters newCustomDotNetCliPath string if not provided, the one from PATH will be used Returns CustomDotNetCliToolchainBuilder GetTargetFrameworkMoniker() protected string GetTargetFrameworkMoniker() Returns string RuntimeFrameworkVersion(string) public CustomDotNetCliToolchainBuilder RuntimeFrameworkVersion(string newRuntimeFrameworkVersion) Parameters newRuntimeFrameworkVersion string optional, when set it's copied to the generated .csproj file Returns CustomDotNetCliToolchainBuilder RuntimeIdentifier(string) public CustomDotNetCliToolchainBuilder RuntimeIdentifier(string newRuntimeIdentifier) Parameters newRuntimeIdentifier string if not provided, portable OS-arch will be used (example: \"win-x64\", \"linux-x86\") Returns CustomDotNetCliToolchainBuilder TargetFrameworkMoniker(string) public CustomDotNetCliToolchainBuilder TargetFrameworkMoniker(string targetFrameworkMoniker) Parameters targetFrameworkMoniker string TFM, example: net8.0 Returns CustomDotNetCliToolchainBuilder ToToolchain() public abstract IToolchain ToToolchain() Returns IToolchain UseNuGetClearTag(bool) emits clear tag in the auto-generated NuGet.config file public CustomDotNetCliToolchainBuilder UseNuGetClearTag(bool value) Parameters value bool Returns CustomDotNetCliToolchainBuilder UseTempFolderForRestore(bool) restore to temp folder to keep your CI clean or install same package many times (perhaps with different content but same version number), by default true for local builds https://github.com/dotnet/corefx/blob/master/Documentation/project-docs/dogfooding.md#3---consuming-subsequent-code-changes-by-rebuilding-the-package-alternative-2 public CustomDotNetCliToolchainBuilder UseTempFolderForRestore(bool value) Parameters value bool Returns CustomDotNetCliToolchainBuilder"
  },
  "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliBuilder.html": {
    "href": "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliBuilder.html",
    "title": "Class DotNetCliBuilder | BenchmarkDotNet",
    "summary": "Class DotNetCliBuilder Namespace BenchmarkDotNet.Toolchains.DotNetCli Assembly BenchmarkDotNet.dll public class DotNetCliBuilder : IBuilder Inheritance object DotNetCliBuilder Implements IBuilder Constructors DotNetCliBuilder(string, string?, bool) public DotNetCliBuilder(string targetFrameworkMoniker, string? customDotNetCliPath = null, bool logOutput = false) Parameters targetFrameworkMoniker string customDotNetCliPath string logOutput bool Methods Build(GenerateResult, BuildPartition, ILogger) public BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger) Parameters generateResult GenerateResult buildPartition BuildPartition logger ILogger Returns BuildResult"
  },
  "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliCommand.html": {
    "href": "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliCommand.html",
    "title": "Class DotNetCliCommand | BenchmarkDotNet",
    "summary": "Class DotNetCliCommand Namespace BenchmarkDotNet.Toolchains.DotNetCli Assembly BenchmarkDotNet.dll public class DotNetCliCommand Inheritance object DotNetCliCommand Constructors DotNetCliCommand(string, string, GenerateResult, ILogger, BuildPartition, IReadOnlyList<EnvironmentVariable>, TimeSpan, bool) public DotNetCliCommand(string cliPath, string arguments, GenerateResult generateResult, ILogger logger, BuildPartition buildPartition, IReadOnlyList<EnvironmentVariable> environmentVariables, TimeSpan timeout, bool logOutput = false) Parameters cliPath string arguments string generateResult GenerateResult logger ILogger buildPartition BuildPartition environmentVariables IReadOnlyList<EnvironmentVariable> timeout TimeSpan logOutput bool Properties Arguments public string Arguments { get; } Property Value string BuildPartition public BuildPartition BuildPartition { get; } Property Value BuildPartition CliPath public string CliPath { get; } Property Value string EnvironmentVariables public IReadOnlyList<EnvironmentVariable> EnvironmentVariables { get; } Property Value IReadOnlyList<EnvironmentVariable> GenerateResult public GenerateResult GenerateResult { get; } Property Value GenerateResult LogOutput public bool LogOutput { get; } Property Value bool Logger public ILogger Logger { get; } Property Value ILogger Timeout public TimeSpan Timeout { get; } Property Value TimeSpan Methods AddPackages() public DotNetCliCommandResult AddPackages() Returns DotNetCliCommandResult Build() public DotNetCliCommandResult Build() Returns DotNetCliCommandResult BuildNoRestore() public DotNetCliCommandResult BuildNoRestore() Returns DotNetCliCommandResult Publish() public DotNetCliCommandResult Publish() Returns DotNetCliCommandResult PublishNoRestore() public DotNetCliCommandResult PublishNoRestore() Returns DotNetCliCommandResult Restore() public DotNetCliCommandResult Restore() Returns DotNetCliCommandResult RestoreThenBuild() public BuildResult RestoreThenBuild() Returns BuildResult RestoreThenBuildThenPublish() public BuildResult RestoreThenBuildThenPublish() Returns BuildResult WithArguments(string) public DotNetCliCommand WithArguments(string arguments) Parameters arguments string Returns DotNetCliCommand WithCliPath(string) public DotNetCliCommand WithCliPath(string cliPath) Parameters cliPath string Returns DotNetCliCommand"
  },
  "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliCommandExecutor.html": {
    "href": "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliCommandExecutor.html",
    "title": "Class DotNetCliCommandExecutor | BenchmarkDotNet",
    "summary": "Class DotNetCliCommandExecutor Namespace BenchmarkDotNet.Toolchains.DotNetCli Assembly BenchmarkDotNet.dll public static class DotNetCliCommandExecutor Inheritance object DotNetCliCommandExecutor Methods Execute(DotNetCliCommand) public static DotNetCliCommandResult Execute(DotNetCliCommand parameters) Parameters parameters DotNetCliCommand Returns DotNetCliCommandResult"
  },
  "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliCommandResult.html": {
    "href": "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliCommandResult.html",
    "title": "Struct DotNetCliCommandResult | BenchmarkDotNet",
    "summary": "Struct DotNetCliCommandResult Namespace BenchmarkDotNet.Toolchains.DotNetCli Assembly BenchmarkDotNet.dll public struct DotNetCliCommandResult Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() Properties AllInformation public string AllInformation { get; } Property Value string ExecutionTime public readonly TimeSpan ExecutionTime { get; } Property Value TimeSpan HasNonEmptyErrorMessage public bool HasNonEmptyErrorMessage { get; } Property Value bool IsSuccess public readonly bool IsSuccess { get; } Property Value bool StandardError public readonly string StandardError { get; } Property Value string StandardOutput public readonly string StandardOutput { get; } Property Value string Methods Failure(TimeSpan, string, string) public static DotNetCliCommandResult Failure(TimeSpan time, string standardError, string standardOutput) Parameters time TimeSpan standardError string standardOutput string Returns DotNetCliCommandResult Success(TimeSpan, string) public static DotNetCliCommandResult Success(TimeSpan time, string standardOutput) Parameters time TimeSpan standardOutput string Returns DotNetCliCommandResult ToBuildResult(GenerateResult) public BuildResult ToBuildResult(GenerateResult generateResult) Parameters generateResult GenerateResult Returns BuildResult"
  },
  "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliExecutor.html": {
    "href": "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliExecutor.html",
    "title": "Class DotNetCliExecutor | BenchmarkDotNet",
    "summary": "Class DotNetCliExecutor Namespace BenchmarkDotNet.Toolchains.DotNetCli Assembly BenchmarkDotNet.dll public class DotNetCliExecutor : IExecutor Inheritance object DotNetCliExecutor Implements IExecutor Constructors DotNetCliExecutor(string) public DotNetCliExecutor(string customDotNetCliPath) Parameters customDotNetCliPath string Methods Execute(ExecuteParameters) public ExecuteResult Execute(ExecuteParameters executeParameters) Parameters executeParameters ExecuteParameters Returns ExecuteResult"
  },
  "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliGenerator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliGenerator.html",
    "title": "Class DotNetCliGenerator | BenchmarkDotNet",
    "summary": "Class DotNetCliGenerator Namespace BenchmarkDotNet.Toolchains.DotNetCli Assembly BenchmarkDotNet.dll public abstract class DotNetCliGenerator : GeneratorBase, IGenerator Inheritance object GeneratorBase DotNetCliGenerator Implements IGenerator Derived CsProjGenerator Inherited Members GeneratorBase.GenerateProject(BuildPartition, ILogger, string) GeneratorBase.GetBinariesDirectoryPath(string, string) GeneratorBase.GetPublishDirectoryPath(string, string) GeneratorBase.GetProjectFilePath(string) GeneratorBase.GenerateNuGetConfig(ArtifactsPaths) GeneratorBase.GenerateProject(BuildPartition, ArtifactsPaths, ILogger) GeneratorBase.GenerateAppConfig(BuildPartition, ArtifactsPaths) GeneratorBase.GenerateCode(BuildPartition, ArtifactsPaths) GeneratorBase.GetExecutablePath(string, string) Constructors DotNetCliGenerator(string, string, string, bool) protected DotNetCliGenerator(string targetFrameworkMoniker, string cliPath, string packagesPath, bool isNetCore) Parameters targetFrameworkMoniker string cliPath string packagesPath string isNetCore bool Properties CliPath public string CliPath { get; } Property Value string IsNetCore protected bool IsNetCore { get; } Property Value bool PackagesPath public string PackagesPath { get; } Property Value string TargetFrameworkMoniker public string TargetFrameworkMoniker { get; } Property Value string Methods CopyAllRequiredFiles(ArtifactsPaths) if you need to copy some extra files to make the benchmarks work you should override this method protected override void CopyAllRequiredFiles(ArtifactsPaths artifactsPaths) Parameters artifactsPaths ArtifactsPaths GenerateBuildScript(BuildPartition, ArtifactsPaths) generates a script can be used when debugging compilation issues protected override void GenerateBuildScript(BuildPartition buildPartition, ArtifactsPaths artifactsPaths) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths GetArtifactsToCleanup(ArtifactsPaths) returns a list of artifacts that should be removed after running the benchmarks protected override string[] GetArtifactsToCleanup(ArtifactsPaths artifactsPaths) Parameters artifactsPaths ArtifactsPaths Returns string[] GetBuildArtifactsDirectoryPath(BuildPartition, string) we need our folder to be on the same level as the project that we want to reference we are limited by xprojs (by default compiles all .cs files in all subfolders, Program.cs could be doubled and fail the build) and also by NuGet internal implementation like looking for global.json file in parent folders protected override string GetBuildArtifactsDirectoryPath(BuildPartition buildPartition, string programName) Parameters buildPartition BuildPartition programName string Returns string GetExecutableExtension() returns OS-specific executable extension protected override string GetExecutableExtension() Returns string GetPackagesDirectoryPath(string) returns a path to the folder where NuGet packages should be restored protected override string GetPackagesDirectoryPath(string buildArtifactsDirectoryPath) Parameters buildArtifactsDirectoryPath string Returns string"
  },
  "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliPublisher.html": {
    "href": "api/BenchmarkDotNet.Toolchains.DotNetCli.DotNetCliPublisher.html",
    "title": "Class DotNetCliPublisher | BenchmarkDotNet",
    "summary": "Class DotNetCliPublisher Namespace BenchmarkDotNet.Toolchains.DotNetCli Assembly BenchmarkDotNet.dll public class DotNetCliPublisher : IBuilder Inheritance object DotNetCliPublisher Implements IBuilder Constructors DotNetCliPublisher(string?, string?, IReadOnlyList<EnvironmentVariable>?) public DotNetCliPublisher(string? customDotNetCliPath = null, string? extraArguments = null, IReadOnlyList<EnvironmentVariable>? environmentVariables = null) Parameters customDotNetCliPath string extraArguments string environmentVariables IReadOnlyList<EnvironmentVariable> Methods Build(GenerateResult, BuildPartition, ILogger) public BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger) Parameters generateResult GenerateResult buildPartition BuildPartition logger ILogger Returns BuildResult"
  },
  "api/BenchmarkDotNet.Toolchains.DotNetCli.html": {
    "href": "api/BenchmarkDotNet.Toolchains.DotNetCli.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.DotNetCli | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.DotNetCli Classes CustomDotNetCliToolchainBuilder DotNetCliBuilder DotNetCliCommand DotNetCliCommandExecutor DotNetCliExecutor DotNetCliGenerator DotNetCliPublisher NetCoreAppSettings custom settings used in the auto-generated project.json / .csproj file Structs DotNetCliCommandResult"
  },
  "api/BenchmarkDotNet.Toolchains.DotNetCli.NetCoreAppSettings.html": {
    "href": "api/BenchmarkDotNet.Toolchains.DotNetCli.NetCoreAppSettings.html",
    "title": "Class NetCoreAppSettings | BenchmarkDotNet",
    "summary": "Class NetCoreAppSettings Namespace BenchmarkDotNet.Toolchains.DotNetCli Assembly BenchmarkDotNet.dll custom settings used in the auto-generated project.json / .csproj file public class NetCoreAppSettings Inheritance object NetCoreAppSettings Constructors NetCoreAppSettings(string, string?, string, string?, string?, string?, string?, MonoAotCompilerMode) sample values: net6.0, net8.0 used in the auto-generated .csproj file simply ignored if null or empty display name used for showing the results customize dotnet cli path if default is not desired simply ignored if null the directory to restore packages to path to a custom runtime pack path to Mono AOT compiler Mono AOT compiler moder public NetCoreAppSettings(string targetFrameworkMoniker, string? runtimeFrameworkVersion, string name, string? customDotNetCliPath = null, string? packagesPath = null, string? customRuntimePack = null, string? aotCompilerPath = null, MonoAotCompilerMode aotCompilerMode = MonoAotCompilerMode.mini) Parameters targetFrameworkMoniker string runtimeFrameworkVersion string name string customDotNetCliPath string packagesPath string customRuntimePack string aotCompilerPath string aotCompilerMode MonoAotCompilerMode Fields NetCoreApp10_0 public static readonly NetCoreAppSettings NetCoreApp10_0 Field Value NetCoreAppSettings NetCoreApp20 public static readonly NetCoreAppSettings NetCoreApp20 Field Value NetCoreAppSettings NetCoreApp21 public static readonly NetCoreAppSettings NetCoreApp21 Field Value NetCoreAppSettings NetCoreApp22 public static readonly NetCoreAppSettings NetCoreApp22 Field Value NetCoreAppSettings NetCoreApp30 public static readonly NetCoreAppSettings NetCoreApp30 Field Value NetCoreAppSettings NetCoreApp31 public static readonly NetCoreAppSettings NetCoreApp31 Field Value NetCoreAppSettings NetCoreApp50 public static readonly NetCoreAppSettings NetCoreApp50 Field Value NetCoreAppSettings NetCoreApp60 public static readonly NetCoreAppSettings NetCoreApp60 Field Value NetCoreAppSettings NetCoreApp70 public static readonly NetCoreAppSettings NetCoreApp70 Field Value NetCoreAppSettings NetCoreApp80 public static readonly NetCoreAppSettings NetCoreApp80 Field Value NetCoreAppSettings NetCoreApp90 public static readonly NetCoreAppSettings NetCoreApp90 Field Value NetCoreAppSettings Properties AOTCompilerMode Mono AOT Compiler mode, either 'mini' or 'llvm' public MonoAotCompilerMode AOTCompilerMode { get; } Property Value MonoAotCompilerMode AOTCompilerPath Path to the Mono AOT Compiler public string? AOTCompilerPath { get; } Property Value string CustomDotNetCliPath public string? CustomDotNetCliPath { get; } Property Value string CustomRuntimePack Path to a custom runtime pack. public string? CustomRuntimePack { get; } Property Value string Name display name used for showing the results public string Name { get; } Property Value string PackagesPath The directory to restore packages to. public string? PackagesPath { get; } Property Value string RuntimeFrameworkVersion public string? RuntimeFrameworkVersion { get; } Property Value string TargetFrameworkMoniker sample values: net6.0, net8.0 public string TargetFrameworkMoniker { get; } Property Value string Methods WithCustomDotNetCliPath(string, string?) public NetCoreAppSettings WithCustomDotNetCliPath(string customDotNetCliPath, string? displayName = null) Parameters customDotNetCliPath string displayName string Returns NetCoreAppSettings WithCustomPackagesRestorePath(string, string?) public NetCoreAppSettings WithCustomPackagesRestorePath(string packagesPath, string? displayName = null) Parameters packagesPath string displayName string Returns NetCoreAppSettings"
  },
  "api/BenchmarkDotNet.Toolchains.Executor.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Executor.html",
    "title": "Class Executor | BenchmarkDotNet",
    "summary": "Class Executor Namespace BenchmarkDotNet.Toolchains Assembly BenchmarkDotNet.dll public class Executor : IExecutor Inheritance object Executor Implements IExecutor Constructors Executor() public Executor() Methods Execute(ExecuteParameters) public ExecuteResult Execute(ExecuteParameters executeParameters) Parameters executeParameters ExecuteParameters Returns ExecuteResult"
  },
  "api/BenchmarkDotNet.Toolchains.GeneratorBase.html": {
    "href": "api/BenchmarkDotNet.Toolchains.GeneratorBase.html",
    "title": "Class GeneratorBase | BenchmarkDotNet",
    "summary": "Class GeneratorBase Namespace BenchmarkDotNet.Toolchains Assembly BenchmarkDotNet.dll public abstract class GeneratorBase : IGenerator Inheritance object GeneratorBase Implements IGenerator Derived DotNetCliGenerator Generator Constructors GeneratorBase() protected GeneratorBase() Methods CopyAllRequiredFiles(ArtifactsPaths) if you need to copy some extra files to make the benchmarks work you should override this method protected virtual void CopyAllRequiredFiles(ArtifactsPaths artifactsPaths) Parameters artifactsPaths ArtifactsPaths GenerateAppConfig(BuildPartition, ArtifactsPaths) generates an app.config file next to the executable with benchmarks protected virtual void GenerateAppConfig(BuildPartition buildPartition, ArtifactsPaths artifactsPaths) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths GenerateBuildScript(BuildPartition, ArtifactsPaths) generates a script can be used when debugging compilation issues protected abstract void GenerateBuildScript(BuildPartition buildPartition, ArtifactsPaths artifactsPaths) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths GenerateCode(BuildPartition, ArtifactsPaths) generates the C# source code with all required boilerplate. You most probably do NOT need to override this method!! protected virtual void GenerateCode(BuildPartition buildPartition, ArtifactsPaths artifactsPaths) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths GenerateNuGetConfig(ArtifactsPaths) generates NuGet.Config file to make sure that BDN is using the right NuGet feeds protected virtual void GenerateNuGetConfig(ArtifactsPaths artifactsPaths) Parameters artifactsPaths ArtifactsPaths GenerateProject(BuildPartition, ILogger, string) public GenerateResult GenerateProject(BuildPartition buildPartition, ILogger logger, string rootArtifactsFolderPath) Parameters buildPartition BuildPartition logger ILogger rootArtifactsFolderPath string Returns GenerateResult GenerateProject(BuildPartition, ArtifactsPaths, ILogger) generates .csproj file with a reference to the project with benchmarks protected virtual void GenerateProject(BuildPartition buildPartition, ArtifactsPaths artifactsPaths, ILogger logger) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths logger ILogger GetArtifactsToCleanup(ArtifactsPaths) returns a list of artifacts that should be removed after running the benchmarks protected abstract string[] GetArtifactsToCleanup(ArtifactsPaths artifactsPaths) Parameters artifactsPaths ArtifactsPaths Returns string[] GetBinariesDirectoryPath(string, string) returns a path where executable should be found after the build (usually \\bin) protected virtual string GetBinariesDirectoryPath(string buildArtifactsDirectoryPath, string configuration) Parameters buildArtifactsDirectoryPath string configuration string Returns string GetBuildArtifactsDirectoryPath(BuildPartition, string) returns a path to the folder where auto-generated project and code are going to be placed protected abstract string GetBuildArtifactsDirectoryPath(BuildPartition assemblyLocation, string programName) Parameters assemblyLocation BuildPartition programName string Returns string GetExecutableExtension() returns OS-specific executable extension protected virtual string GetExecutableExtension() Returns string GetExecutablePath(string, string) protected virtual string GetExecutablePath(string binariesDirectoryPath, string programName) Parameters binariesDirectoryPath string programName string Returns string GetPackagesDirectoryPath(string) returns a path to the folder where NuGet packages should be restored protected virtual string GetPackagesDirectoryPath(string buildArtifactsDirectoryPath) Parameters buildArtifactsDirectoryPath string Returns string GetProjectFilePath(string) returns a path to the auto-generated .csproj file protected virtual string GetProjectFilePath(string buildArtifactsDirectoryPath) Parameters buildArtifactsDirectoryPath string Returns string GetPublishDirectoryPath(string, string) returns a path where the publish directory should be found after the build (usually \\publish) protected virtual string GetPublishDirectoryPath(string buildArtifactsDirectoryPath, string configuration) Parameters buildArtifactsDirectoryPath string configuration string Returns string"
  },
  "api/BenchmarkDotNet.Toolchains.html": {
    "href": "api/BenchmarkDotNet.Toolchains.html",
    "title": "Namespace BenchmarkDotNet.Toolchains | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains Classes ArtifactsPaths Executor GeneratorBase Toolchain Interfaces IBuilder IExecutor IGenerator IToolchain"
  },
  "api/BenchmarkDotNet.Toolchains.IBuilder.html": {
    "href": "api/BenchmarkDotNet.Toolchains.IBuilder.html",
    "title": "Interface IBuilder | BenchmarkDotNet",
    "summary": "Interface IBuilder Namespace BenchmarkDotNet.Toolchains Assembly BenchmarkDotNet.dll public interface IBuilder Methods Build(GenerateResult, BuildPartition, ILogger) BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger) Parameters generateResult GenerateResult buildPartition BuildPartition logger ILogger Returns BuildResult"
  },
  "api/BenchmarkDotNet.Toolchains.IExecutor.html": {
    "href": "api/BenchmarkDotNet.Toolchains.IExecutor.html",
    "title": "Interface IExecutor | BenchmarkDotNet",
    "summary": "Interface IExecutor Namespace BenchmarkDotNet.Toolchains Assembly BenchmarkDotNet.dll public interface IExecutor Methods Execute(ExecuteParameters) ExecuteResult Execute(ExecuteParameters executeParameters) Parameters executeParameters ExecuteParameters Returns ExecuteResult"
  },
  "api/BenchmarkDotNet.Toolchains.IGenerator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.IGenerator.html",
    "title": "Interface IGenerator | BenchmarkDotNet",
    "summary": "Interface IGenerator Namespace BenchmarkDotNet.Toolchains Assembly BenchmarkDotNet.dll public interface IGenerator Methods GenerateProject(BuildPartition, ILogger, string) GenerateResult GenerateProject(BuildPartition buildPartition, ILogger logger, string rootArtifactsFolderPath) Parameters buildPartition BuildPartition logger ILogger rootArtifactsFolderPath string Returns GenerateResult"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.InProcess.Emit | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.InProcess.Emit Classes InProcessEmitArtifactsPath InProcessEmitBuilder InProcessEmitExecutor Implementation of IExecutor for in-process benchmarks. InProcessEmitGenerator InProcessEmitToolchain"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.ConsumableTypeInfo.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.ConsumableTypeInfo.html",
    "title": "Class ConsumableTypeInfo | BenchmarkDotNet",
    "summary": "Class ConsumableTypeInfo Namespace BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation Assembly BenchmarkDotNet.dll public class ConsumableTypeInfo Inheritance object ConsumableTypeInfo Constructors ConsumableTypeInfo(Type) public ConsumableTypeInfo(Type methodReturnType) Parameters methodReturnType Type Properties GetResultMethod public MethodInfo? GetResultMethod { get; } Property Value MethodInfo IsAwaitable public bool IsAwaitable { get; } Property Value bool IsByRef public bool IsByRef { get; } Property Value bool IsConsumable public bool IsConsumable { get; } Property Value bool IsVoid public bool IsVoid { get; } Property Value bool OriginMethodReturnType public Type OriginMethodReturnType { get; } Property Value Type OverheadMethodReturnType public Type OverheadMethodReturnType { get; } Property Value Type WorkloadConsumableField public FieldInfo? WorkloadConsumableField { get; } Property Value FieldInfo WorkloadMethodReturnType public Type WorkloadMethodReturnType { get; } Property Value Type"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation Classes ConsumableTypeInfo RunnableConstants A helper type that emits code that matches BenchmarkType.txt template. IMPORTANT: this type IS NOT thread safe. RunnableProgram RunnableReuse Enums RunnableActionKind"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableActionKind.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableActionKind.html",
    "title": "Enum RunnableActionKind | BenchmarkDotNet",
    "summary": "Enum RunnableActionKind Namespace BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation Assembly BenchmarkDotNet.dll public enum RunnableActionKind Fields Overhead = 0 Workload = 1"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableConstants.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableConstants.html",
    "title": "Class RunnableConstants | BenchmarkDotNet",
    "summary": "Class RunnableConstants Namespace BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation Assembly BenchmarkDotNet.dll A helper type that emits code that matches BenchmarkType.txt template. IMPORTANT: this type IS NOT thread safe. public class RunnableConstants Inheritance object RunnableConstants Constructors RunnableConstants() public RunnableConstants() Fields ArgFieldPrefix public const string ArgFieldPrefix = \"__argField\" Field Value string ArgParamPrefix public const string ArgParamPrefix = \"arg\" Field Value string ConsumerFieldName public const string ConsumerFieldName = \"consumer\" Field Value string Dummy1MethodName public const string Dummy1MethodName = \"Dummy1\" Field Value string Dummy2MethodName public const string Dummy2MethodName = \"Dummy2\" Field Value string Dummy3MethodName public const string Dummy3MethodName = \"Dummy3\" Field Value string DummyParamName public const string DummyParamName = \"_\" Field Value string DummyUnrollFactor public const int DummyUnrollFactor = 64 Field Value int DummyVarFieldName public const string DummyVarFieldName = \"dummyVar\" Field Value string DynamicAssemblySuffix public const string DynamicAssemblySuffix = \"Emitted\" Field Value string EmittedTypePrefix public const string EmittedTypePrefix = \"BenchmarkDotNet.Autogenerated.Runnable_\" Field Value string ForDisassemblyDiagnoserMethodName public const string ForDisassemblyDiagnoserMethodName = \"__ForDisassemblyDiagnoser__\" Field Value string GlobalCleanupActionFieldName public const string GlobalCleanupActionFieldName = \"globalCleanupAction\" Field Value string GlobalCleanupMethodName public const string GlobalCleanupMethodName = \"GlobalCleanup\" Field Value string GlobalSetupActionFieldName public const string GlobalSetupActionFieldName = \"globalSetupAction\" Field Value string GlobalSetupMethodName public const string GlobalSetupMethodName = \"GlobalSetup\" Field Value string InvokeCountParamName public const string InvokeCountParamName = \"invokeCount\" Field Value string IsByRefLikeAttributeTypeName public const string IsByRefLikeAttributeTypeName = \"System.Runtime.CompilerServices.IsByRefLikeAttribute\" Field Value string IterationCleanupActionFieldName public const string IterationCleanupActionFieldName = \"iterationCleanupAction\" Field Value string IterationCleanupMethodName public const string IterationCleanupMethodName = \"IterationCleanup\" Field Value string IterationSetupActionFieldName public const string IterationSetupActionFieldName = \"iterationSetupAction\" Field Value string IterationSetupMethodName public const string IterationSetupMethodName = \"IterationSetup\" Field Value string NonGenericKeepAliveWithoutBoxingMethodName public const string NonGenericKeepAliveWithoutBoxingMethodName = \"NonGenericKeepAliveWithoutBoxing\" Field Value string NotElevenFieldName public const string NotElevenFieldName = \"NotEleven\" Field Value string OpImplicitMethodName public const string OpImplicitMethodName = \"op_Implicit\" Field Value string OverheadActionNoUnrollMethodName public const string OverheadActionNoUnrollMethodName = \"OverheadActionNoUnroll\" Field Value string OverheadActionUnrollMethodName public const string OverheadActionUnrollMethodName = \"OverheadActionUnroll\" Field Value string OverheadDelegateFieldName public const string OverheadDelegateFieldName = \"overheadDelegate\" Field Value string OverheadDelegateTypeSuffix public const string OverheadDelegateTypeSuffix = \"OverheadDelegate\" Field Value string OverheadImplementationMethodName public const string OverheadImplementationMethodName = \"__Overhead\" Field Value string RunMethodName public const string RunMethodName = \"Run\" Field Value string TrickTheJitCoreMethodName public const string TrickTheJitCoreMethodName = \"__TrickTheJIT__\" Field Value string WorkloadActionNoUnrollMethodName public const string WorkloadActionNoUnrollMethodName = \"WorkloadActionNoUnroll\" Field Value string WorkloadActionUnrollMethodName public const string WorkloadActionUnrollMethodName = \"WorkloadActionUnroll\" Field Value string WorkloadDefaultValueHolderFieldName public const string WorkloadDefaultValueHolderFieldName = \"workloadDefaultValueHolder\" Field Value string WorkloadDelegateFieldName public const string WorkloadDelegateFieldName = \"workloadDelegate\" Field Value string WorkloadDelegateTypeSuffix public const string WorkloadDelegateTypeSuffix = \"WorkloadDelegate\" Field Value string WorkloadImplementationMethodName public const string WorkloadImplementationMethodName = \"__Workload\" Field Value string"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableProgram.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableProgram.html",
    "title": "Class RunnableProgram | BenchmarkDotNet",
    "summary": "Class RunnableProgram Namespace BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation Assembly BenchmarkDotNet.dll public class RunnableProgram Inheritance object RunnableProgram Constructors RunnableProgram() public RunnableProgram() Methods Run(BenchmarkId, Assembly, BenchmarkCase, IHost) public static int Run(BenchmarkId benchmarkId, Assembly partitionAssembly, BenchmarkCase benchmarkCase, IHost host) Parameters benchmarkId BenchmarkId partitionAssembly Assembly benchmarkCase BenchmarkCase host IHost Returns int"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableReuse.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation.RunnableReuse.html",
    "title": "Class RunnableReuse | BenchmarkDotNet",
    "summary": "Class RunnableReuse Namespace BenchmarkDotNet.Toolchains.InProcess.Emit.Implementation Assembly BenchmarkDotNet.dll public static class RunnableReuse Inheritance object RunnableReuse Methods FillObjectMembers<T>(T, BenchmarkCase) public static void FillObjectMembers<T>(T instance, BenchmarkCase benchmarkCase) Parameters instance T benchmarkCase BenchmarkCase Type Parameters T PrepareForRun<T>(T, BenchmarkCase, IHost) public static (Job, EngineParameters, IEngineFactory) PrepareForRun<T>(T instance, BenchmarkCase benchmarkCase, IHost host) Parameters instance T benchmarkCase BenchmarkCase host IHost Returns (Job, EngineParameters, IEngineFactory) Type Parameters T"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitArtifactsPath.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitArtifactsPath.html",
    "title": "Class InProcessEmitArtifactsPath | BenchmarkDotNet",
    "summary": "Class InProcessEmitArtifactsPath Namespace BenchmarkDotNet.Toolchains.InProcess.Emit Assembly BenchmarkDotNet.dll public class InProcessEmitArtifactsPath : ArtifactsPaths Inheritance object ArtifactsPaths InProcessEmitArtifactsPath Inherited Members ArtifactsPaths.Empty ArtifactsPaths.RootArtifactsFolderPath ArtifactsPaths.BuildArtifactsDirectoryPath ArtifactsPaths.BinariesDirectoryPath ArtifactsPaths.PublishDirectoryPath ArtifactsPaths.ProgramCodePath ArtifactsPaths.AppConfigPath ArtifactsPaths.NuGetConfigPath ArtifactsPaths.ProjectFilePath ArtifactsPaths.BuildScriptFilePath ArtifactsPaths.ExecutablePath ArtifactsPaths.ProgramName ArtifactsPaths.PackagesDirectoryName Constructors InProcessEmitArtifactsPath(Assembly, ArtifactsPaths) public InProcessEmitArtifactsPath(Assembly generatedAssembly, ArtifactsPaths baseArtifacts) Parameters generatedAssembly Assembly baseArtifacts ArtifactsPaths Properties GeneratedAssembly public Assembly GeneratedAssembly { get; } Property Value Assembly"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitBuilder.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitBuilder.html",
    "title": "Class InProcessEmitBuilder | BenchmarkDotNet",
    "summary": "Class InProcessEmitBuilder Namespace BenchmarkDotNet.Toolchains.InProcess.Emit Assembly BenchmarkDotNet.dll public class InProcessEmitBuilder : IBuilder Inheritance object InProcessEmitBuilder Implements IBuilder Constructors InProcessEmitBuilder() public InProcessEmitBuilder() Methods Build(GenerateResult, BuildPartition, ILogger) public BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger) Parameters generateResult GenerateResult buildPartition BuildPartition logger ILogger Returns BuildResult"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitExecutor.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitExecutor.html",
    "title": "Class InProcessEmitExecutor | BenchmarkDotNet",
    "summary": "Class InProcessEmitExecutor Namespace BenchmarkDotNet.Toolchains.InProcess.Emit Assembly BenchmarkDotNet.dll Implementation of IExecutor for in-process benchmarks. public class InProcessEmitExecutor : IExecutor Inheritance object InProcessEmitExecutor Implements IExecutor Constructors InProcessEmitExecutor(TimeSpan, bool) Initializes a new instance of the InProcessEmitExecutor class. public InProcessEmitExecutor(TimeSpan timeout, bool logOutput) Parameters timeout TimeSpan Timeout for the run. logOutput bool true if the output should be logged. Fields DefaultTimeout Default timeout for in-process benchmarks. public static readonly TimeSpan DefaultTimeout Field Value TimeSpan Properties ExecutionTimeout Timeout for the run. public TimeSpan ExecutionTimeout { get; } Property Value TimeSpan The timeout for the run. LogOutput Gets a value indicating whether the output should be logged. public bool LogOutput { get; } Property Value bool true if the output should be logged; otherwise, false. Methods Execute(ExecuteParameters) Executes the specified benchmark. public ExecuteResult Execute(ExecuteParameters executeParameters) Parameters executeParameters ExecuteParameters Returns ExecuteResult"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitGenerator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitGenerator.html",
    "title": "Class InProcessEmitGenerator | BenchmarkDotNet",
    "summary": "Class InProcessEmitGenerator Namespace BenchmarkDotNet.Toolchains.InProcess.Emit Assembly BenchmarkDotNet.dll public class InProcessEmitGenerator : IGenerator Inheritance object InProcessEmitGenerator Implements IGenerator Constructors InProcessEmitGenerator() public InProcessEmitGenerator() Methods GenerateProject(BuildPartition, ILogger, string) public GenerateResult GenerateProject(BuildPartition buildPartition, ILogger logger, string rootArtifactsFolderPath) Parameters buildPartition BuildPartition logger ILogger rootArtifactsFolderPath string Returns GenerateResult"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.Emit.InProcessEmitToolchain.html",
    "title": "Class InProcessEmitToolchain | BenchmarkDotNet",
    "summary": "Class InProcessEmitToolchain Namespace BenchmarkDotNet.Toolchains.InProcess.Emit Assembly BenchmarkDotNet.dll public class InProcessEmitToolchain : Toolchain, IToolchain Inheritance object Toolchain InProcessEmitToolchain Implements IToolchain Inherited Members Toolchain.Validate(BenchmarkCase, IResolver) Toolchain.ToString() Toolchain.Name Toolchain.Generator Toolchain.Builder Toolchain.Executor Constructors InProcessEmitToolchain(bool) Initializes a new instance of the InProcessEmitToolchain class. public InProcessEmitToolchain(bool logOutput) Parameters logOutput bool true if the output should be logged. InProcessEmitToolchain(TimeSpan, bool) Initializes a new instance of the InProcessEmitToolchain class. public InProcessEmitToolchain(TimeSpan timeout, bool logOutput) Parameters timeout TimeSpan Timeout for the run. logOutput bool true if the output should be logged. Fields DontLogOutput The toolchain instance without output logging. public static readonly IToolchain DontLogOutput Field Value IToolchain Instance The default toolchain instance. public static readonly IToolchain Instance Field Value IToolchain Properties IsInProcess public override bool IsInProcess { get; } Property Value bool"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.InProcess | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.InProcess Classes InProcessHost Host API for in-process benchmarks. InProcessValidator Validator to be used together with InProcessNoEmitToolchain or InProcessEmitToolchain to proof that the config matches the environment."
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.InProcessHost.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.InProcessHost.html",
    "title": "Class InProcessHost | BenchmarkDotNet",
    "summary": "Class InProcessHost Namespace BenchmarkDotNet.Toolchains.InProcess Assembly BenchmarkDotNet.dll Host API for in-process benchmarks. public sealed class InProcessHost : IHost, IDisposable Inheritance object InProcessHost Implements IHost IDisposable Extension Methods HostExtensions.AfterAll(IHost) HostExtensions.AfterMainRun(IHost) HostExtensions.BeforeAnythingElse(IHost) HostExtensions.BeforeMainRun(IHost) HostExtensions.WriteLine(IHost, string, params object[]) Constructors InProcessHost(BenchmarkCase, ILogger, IDiagnoser) Creates a new instance of InProcessHost. public InProcessHost(BenchmarkCase benchmarkCase, ILogger logger, IDiagnoser diagnoser) Parameters benchmarkCase BenchmarkCase Current benchmark. logger ILogger Logger for informational output. diagnoser IDiagnoser Diagnosers, if attached. Properties Config Current config public IConfig Config { get; set; } Property Value IConfig IsDiagnoserAttached True if there are diagnosers attached. public bool IsDiagnoserAttached { get; } Property Value bool True if there are diagnosers attached. RunResults Results of the run. public RunResults RunResults { get; } Property Value RunResults Results of the run. Methods Dispose() public void Dispose() ReportResults(RunResults) Submits run results to the host. public void ReportResults(RunResults runResults) Parameters runResults RunResults The run results. SendError(string) public void SendError(string message) Parameters message string SendSignal(HostSignal) Sends notification signal to the host. public void SendSignal(HostSignal hostSignal) Parameters hostSignal HostSignal The signal to send. Write(string) Passes text to the host. public void Write(string message) Parameters message string Text to write. WriteLine() Passes new line to the host. public void WriteLine() WriteLine(string) Passes text (new line appended) to the host. public void WriteLine(string message) Parameters message string Text to write. See Also IHost"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.InProcessValidator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.InProcessValidator.html",
    "title": "Class InProcessValidator | BenchmarkDotNet",
    "summary": "Class InProcessValidator Namespace BenchmarkDotNet.Toolchains.InProcess Assembly BenchmarkDotNet.dll Validator to be used together with InProcessNoEmitToolchain or InProcessEmitToolchain to proof that the config matches the environment. public class InProcessValidator : IValidator Inheritance object InProcessValidator Implements IValidator Fields DontFailOnError The instance of validator that does NOT fail on error. public static readonly IValidator DontFailOnError Field Value IValidator FailOnError The instance of validator that DOES fail on error. public static readonly IValidator FailOnError Field Value IValidator Properties TreatsWarningsAsErrors Gets a value indicating whether warnings are treated as errors. public bool TreatsWarningsAsErrors { get; } Property Value bool true if the validator should treat warnings as errors; otherwise, false. Methods Validate(BenchmarkCase) public static IEnumerable<ValidationError> Validate(BenchmarkCase benchmarkCase) Parameters benchmarkCase BenchmarkCase Returns IEnumerable<ValidationError> Validate(ValidationParameters) Proofs that benchmarks' jobs match the environment. public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters The validation parameters. Returns IEnumerable<ValidationError> Enumerable of validation errors. See Also IValidator"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkAction.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkAction.html",
    "title": "Class BenchmarkAction | BenchmarkDotNet",
    "summary": "Class BenchmarkAction Namespace BenchmarkDotNet.Toolchains.InProcess.NoEmit Assembly BenchmarkDotNet.dll Common API to run the Setup/Clean/Idle/Run methods public abstract class BenchmarkAction Inheritance object BenchmarkAction Constructors BenchmarkAction() protected BenchmarkAction() Properties InvokeNoUnroll public Action<long> InvokeNoUnroll { get; protected set; } Property Value Action<long> InvokeSingle Gets or sets invoke single callback. public Action InvokeSingle { get; protected set; } Property Value Action Invoke single callback. InvokeUnroll Gets or sets invoke multiple times callback. public Action<long> InvokeUnroll { get; protected set; } Property Value Action<long> Invoke multiple times callback. LastRunResult Gets the last run result. public virtual object LastRunResult { get; } Property Value object The last run result."
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkActionFactory.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.BenchmarkActionFactory.html",
    "title": "Class BenchmarkActionFactory | BenchmarkDotNet",
    "summary": "Class BenchmarkActionFactory Namespace BenchmarkDotNet.Toolchains.InProcess.NoEmit Assembly BenchmarkDotNet.dll Helper class that creates BenchmarkAction instances. public static class BenchmarkActionFactory Inheritance object BenchmarkActionFactory Methods CreateDummy() Creates a dummy benchmark action. public static BenchmarkAction CreateDummy() Returns BenchmarkAction Dummy benchmark action. CreateGlobalCleanup(Descriptor, object) Creates global cleanup benchmark action. public static BenchmarkAction CreateGlobalCleanup(Descriptor descriptor, object instance) Parameters descriptor Descriptor Descriptor info. instance object Instance of target. Returns BenchmarkAction Cleanup benchmark action. CreateGlobalSetup(Descriptor, object) Creates global setup benchmark action. public static BenchmarkAction CreateGlobalSetup(Descriptor descriptor, object instance) Parameters descriptor Descriptor Descriptor info. instance object Instance of target. Returns BenchmarkAction Setup benchmark action. CreateIterationCleanup(Descriptor, object) Creates global cleanup benchmark action. public static BenchmarkAction CreateIterationCleanup(Descriptor descriptor, object instance) Parameters descriptor Descriptor Descriptor info. instance object Instance of target. Returns BenchmarkAction Cleanup benchmark action. CreateIterationSetup(Descriptor, object) Creates global setup benchmark action. public static BenchmarkAction CreateIterationSetup(Descriptor descriptor, object instance) Parameters descriptor Descriptor Descriptor info. instance object Instance of target. Returns BenchmarkAction Setup benchmark action. CreateOverhead(Descriptor, object, int) Creates idle benchmark action. public static BenchmarkAction CreateOverhead(Descriptor descriptor, object instance, int unrollFactor) Parameters descriptor Descriptor Descriptor info. instance object Instance of target. unrollFactor int Unroll factor. Returns BenchmarkAction Idle benchmark action. CreateWorkload(Descriptor, object, int) Creates run benchmark action. public static BenchmarkAction CreateWorkload(Descriptor descriptor, object instance, int unrollFactor) Parameters descriptor Descriptor Descriptor info. instance object Instance of target. unrollFactor int Unroll factor. Returns BenchmarkAction Run benchmark action."
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.InProcess.NoEmit | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.InProcess.NoEmit Classes BenchmarkAction Common API to run the Setup/Clean/Idle/Run methods BenchmarkActionFactory Helper class that creates BenchmarkAction instances. InProcessNoEmitBuilder In process (no emit) toolchain builder InProcessNoEmitExecutor Implementation of IExecutor for in-process (no emit) toolchain. InProcessNoEmitGenerator Implementation of IGenerator for in-process (no emit) toolchain. InProcessNoEmitToolchain A toolchain to run the benchmarks in-process (no emit)."
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitBuilder.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitBuilder.html",
    "title": "Class InProcessNoEmitBuilder | BenchmarkDotNet",
    "summary": "Class InProcessNoEmitBuilder Namespace BenchmarkDotNet.Toolchains.InProcess.NoEmit Assembly BenchmarkDotNet.dll In process (no emit) toolchain builder public class InProcessNoEmitBuilder : IBuilder Inheritance object InProcessNoEmitBuilder Implements IBuilder Constructors InProcessNoEmitBuilder() public InProcessNoEmitBuilder() Methods Build(GenerateResult, BuildPartition, ILogger) always returns success public BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger) Parameters generateResult GenerateResult buildPartition BuildPartition logger ILogger Returns BuildResult See Also IBuilder"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitExecutor.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitExecutor.html",
    "title": "Class InProcessNoEmitExecutor | BenchmarkDotNet",
    "summary": "Class InProcessNoEmitExecutor Namespace BenchmarkDotNet.Toolchains.InProcess.NoEmit Assembly BenchmarkDotNet.dll Implementation of IExecutor for in-process (no emit) toolchain. public class InProcessNoEmitExecutor : IExecutor Inheritance object InProcessNoEmitExecutor Implements IExecutor Constructors InProcessNoEmitExecutor(TimeSpan, bool) Initializes a new instance of the InProcessNoEmitExecutor class. public InProcessNoEmitExecutor(TimeSpan timeout, bool logOutput) Parameters timeout TimeSpan Timeout for the run. logOutput bool true if the output should be logged. Fields DefaultTimeout Default timeout for in-process benchmarks. public static readonly TimeSpan DefaultTimeout Field Value TimeSpan Properties ExecutionTimeout Timeout for the run. public TimeSpan ExecutionTimeout { get; } Property Value TimeSpan The timeout for the run. LogOutput Gets a value indicating whether the output should be logged. public bool LogOutput { get; } Property Value bool true if the output should be logged; otherwise, false. Methods Execute(ExecuteParameters) Executes the specified benchmark. public ExecuteResult Execute(ExecuteParameters executeParameters) Parameters executeParameters ExecuteParameters Returns ExecuteResult"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitGenerator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitGenerator.html",
    "title": "Class InProcessNoEmitGenerator | BenchmarkDotNet",
    "summary": "Class InProcessNoEmitGenerator Namespace BenchmarkDotNet.Toolchains.InProcess.NoEmit Assembly BenchmarkDotNet.dll Implementation of IGenerator for in-process (no emit) toolchain. public class InProcessNoEmitGenerator : IGenerator Inheritance object InProcessNoEmitGenerator Implements IGenerator Constructors InProcessNoEmitGenerator() public InProcessNoEmitGenerator() Methods GenerateProject(BuildPartition, ILogger, string) returns a success public GenerateResult GenerateProject(BuildPartition buildPartition, ILogger logger, string rootArtifactsFolderPath) Parameters buildPartition BuildPartition logger ILogger rootArtifactsFolderPath string Returns GenerateResult"
  },
  "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.InProcess.NoEmit.InProcessNoEmitToolchain.html",
    "title": "Class InProcessNoEmitToolchain | BenchmarkDotNet",
    "summary": "Class InProcessNoEmitToolchain Namespace BenchmarkDotNet.Toolchains.InProcess.NoEmit Assembly BenchmarkDotNet.dll A toolchain to run the benchmarks in-process (no emit). public sealed class InProcessNoEmitToolchain : IToolchain Inheritance object InProcessNoEmitToolchain Implements IToolchain Constructors InProcessNoEmitToolchain(bool) Initializes a new instance of the InProcessNoEmitToolchain class. public InProcessNoEmitToolchain(bool logOutput) Parameters logOutput bool true if the output should be logged. InProcessNoEmitToolchain(TimeSpan, bool) Initializes a new instance of the InProcessNoEmitToolchain class. public InProcessNoEmitToolchain(TimeSpan timeout, bool logOutput) Parameters timeout TimeSpan Timeout for the run. logOutput bool true if the output should be logged. Fields DontLogOutput The toolchain instance without output logging. public static readonly IToolchain DontLogOutput Field Value IToolchain Instance The default toolchain instance. public static readonly IToolchain Instance Field Value IToolchain Properties Builder The builder. public IBuilder Builder { get; } Property Value IBuilder The builder. Executor The executor. public IExecutor Executor { get; } Property Value IExecutor The executor. Generator The generator. public IGenerator Generator { get; } Property Value IGenerator The generator. IsInProcess public bool IsInProcess { get; } Property Value bool Name Name of the toolchain. public string Name { get; } Property Value string The name of the toolchain. Methods ToString() Returns a string that represents this instance. public override string ToString() Returns string A string that represents this instance. Validate(BenchmarkCase, IResolver) public IEnumerable<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver) Parameters benchmarkCase BenchmarkCase resolver IResolver Returns IEnumerable<ValidationError> See Also IToolchain"
  },
  "api/BenchmarkDotNet.Toolchains.IToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.IToolchain.html",
    "title": "Interface IToolchain | BenchmarkDotNet",
    "summary": "Interface IToolchain Namespace BenchmarkDotNet.Toolchains Assembly BenchmarkDotNet.dll public interface IToolchain Properties Builder IBuilder Builder { get; } Property Value IBuilder Executor IExecutor Executor { get; } Property Value IExecutor Generator IGenerator Generator { get; } Property Value IGenerator IsInProcess bool IsInProcess { get; } Property Value bool Name string Name { get; } Property Value string Methods Validate(BenchmarkCase, IResolver) IEnumerable<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver) Parameters benchmarkCase BenchmarkCase resolver IResolver Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Toolchains.Mono.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Mono.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.Mono | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.Mono Classes MonoAotBuilder MonoAotToolchain MonoGenerator MonoPublisher MonoToolchain"
  },
  "api/BenchmarkDotNet.Toolchains.Mono.MonoAotBuilder.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Mono.MonoAotBuilder.html",
    "title": "Class MonoAotBuilder | BenchmarkDotNet",
    "summary": "Class MonoAotBuilder Namespace BenchmarkDotNet.Toolchains.Mono Assembly BenchmarkDotNet.dll public class MonoAotBuilder : IBuilder Inheritance object MonoAotBuilder Implements IBuilder Constructors MonoAotBuilder() public MonoAotBuilder() Methods Build(GenerateResult, BuildPartition, ILogger) public BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger) Parameters generateResult GenerateResult buildPartition BuildPartition logger ILogger Returns BuildResult"
  },
  "api/BenchmarkDotNet.Toolchains.Mono.MonoAotToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Mono.MonoAotToolchain.html",
    "title": "Class MonoAotToolchain | BenchmarkDotNet",
    "summary": "Class MonoAotToolchain Namespace BenchmarkDotNet.Toolchains.Mono Assembly BenchmarkDotNet.dll public class MonoAotToolchain : Toolchain, IToolchain Inheritance object Toolchain MonoAotToolchain Implements IToolchain Inherited Members Toolchain.ToString() Toolchain.Name Toolchain.Generator Toolchain.Builder Toolchain.Executor Toolchain.IsInProcess Constructors MonoAotToolchain() public MonoAotToolchain() Fields Instance public static readonly IToolchain Instance Field Value IToolchain Methods Validate(BenchmarkCase, IResolver) public override IEnumerable<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver) Parameters benchmarkCase BenchmarkCase resolver IResolver Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Toolchains.Mono.MonoGenerator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Mono.MonoGenerator.html",
    "title": "Class MonoGenerator | BenchmarkDotNet",
    "summary": "Class MonoGenerator Namespace BenchmarkDotNet.Toolchains.Mono Assembly BenchmarkDotNet.dll public class MonoGenerator : CsProjGenerator, IGenerator, IEquatable<CsProjGenerator> Inheritance object GeneratorBase DotNetCliGenerator CsProjGenerator MonoGenerator Implements IGenerator IEquatable<CsProjGenerator> Inherited Members CsProjGenerator.GetBuildArtifactsDirectoryPath(BuildPartition, string) CsProjGenerator.GetProjectFilePath(string) CsProjGenerator.GetBinariesDirectoryPath(string, string) CsProjGenerator.GenerateProject(BuildPartition, ArtifactsPaths, ILogger) CsProjGenerator.GetProjectFilePath(Type, ILogger) CsProjGenerator.Equals(object) CsProjGenerator.Equals(CsProjGenerator) CsProjGenerator.GetHashCode() CsProjGenerator.RuntimeFrameworkVersion DotNetCliGenerator.GetExecutableExtension() DotNetCliGenerator.GetArtifactsToCleanup(ArtifactsPaths) DotNetCliGenerator.CopyAllRequiredFiles(ArtifactsPaths) DotNetCliGenerator.GetPackagesDirectoryPath(string) DotNetCliGenerator.GenerateBuildScript(BuildPartition, ArtifactsPaths) DotNetCliGenerator.TargetFrameworkMoniker DotNetCliGenerator.CliPath DotNetCliGenerator.PackagesPath DotNetCliGenerator.IsNetCore GeneratorBase.GenerateProject(BuildPartition, ILogger, string) GeneratorBase.GetPublishDirectoryPath(string, string) GeneratorBase.GenerateNuGetConfig(ArtifactsPaths) GeneratorBase.GenerateAppConfig(BuildPartition, ArtifactsPaths) GeneratorBase.GenerateCode(BuildPartition, ArtifactsPaths) GeneratorBase.GetExecutablePath(string, string) Constructors MonoGenerator(string, string, string, string) public MonoGenerator(string targetFrameworkMoniker, string cliPath, string packagesPath, string runtimeFrameworkVersion) Parameters targetFrameworkMoniker string cliPath string packagesPath string runtimeFrameworkVersion string Methods GetRuntimeSettings(GcMode, IResolver) returns an MSBuild string that defines Runtime settings protected override string GetRuntimeSettings(GcMode gcMode, IResolver resolver) Parameters gcMode GcMode resolver IResolver Returns string"
  },
  "api/BenchmarkDotNet.Toolchains.Mono.MonoPublisher.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Mono.MonoPublisher.html",
    "title": "Class MonoPublisher | BenchmarkDotNet",
    "summary": "Class MonoPublisher Namespace BenchmarkDotNet.Toolchains.Mono Assembly BenchmarkDotNet.dll public class MonoPublisher : IBuilder Inheritance object MonoPublisher Implements IBuilder Constructors MonoPublisher(string) public MonoPublisher(string customDotNetCliPath) Parameters customDotNetCliPath string Methods Build(GenerateResult, BuildPartition, ILogger) public BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger) Parameters generateResult GenerateResult buildPartition BuildPartition logger ILogger Returns BuildResult"
  },
  "api/BenchmarkDotNet.Toolchains.Mono.MonoToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Mono.MonoToolchain.html",
    "title": "Class MonoToolchain | BenchmarkDotNet",
    "summary": "Class MonoToolchain Namespace BenchmarkDotNet.Toolchains.Mono Assembly BenchmarkDotNet.dll public class MonoToolchain : CsProjCoreToolchain, IToolchain, IEquatable<CsProjCoreToolchain>, IEquatable<MonoToolchain> Inheritance object Toolchain CsProjCoreToolchain MonoToolchain Implements IToolchain IEquatable<CsProjCoreToolchain> IEquatable<MonoToolchain> Inherited Members CsProjCoreToolchain.NetCoreApp20 CsProjCoreToolchain.NetCoreApp21 CsProjCoreToolchain.NetCoreApp22 CsProjCoreToolchain.NetCoreApp30 CsProjCoreToolchain.NetCoreApp31 CsProjCoreToolchain.NetCoreApp50 CsProjCoreToolchain.NetCoreApp60 CsProjCoreToolchain.NetCoreApp70 CsProjCoreToolchain.NetCoreApp80 CsProjCoreToolchain.NetCoreApp90 CsProjCoreToolchain.NetCoreApp10_0 CsProjCoreToolchain.Validate(BenchmarkCase, IResolver) CsProjCoreToolchain.Equals(CsProjCoreToolchain) Toolchain.ToString() Toolchain.Name Toolchain.Generator Toolchain.Builder Toolchain.Executor Toolchain.IsInProcess Fields Mono10_0 public static readonly IToolchain Mono10_0 Field Value IToolchain Mono60 public static readonly IToolchain Mono60 Field Value IToolchain Mono70 public static readonly IToolchain Mono70 Field Value IToolchain Mono80 public static readonly IToolchain Mono80 Field Value IToolchain Mono90 public static readonly IToolchain Mono90 Field Value IToolchain Methods Equals(MonoToolchain) public bool Equals(MonoToolchain other) Parameters other MonoToolchain Returns bool Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool From(NetCoreAppSettings) public static IToolchain From(NetCoreAppSettings settings) Parameters settings NetCoreAppSettings Returns IToolchain GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/BenchmarkDotNet.Toolchains.MonoAotLLVM.html": {
    "href": "api/BenchmarkDotNet.Toolchains.MonoAotLLVM.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.MonoAotLLVM | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.MonoAotLLVM Classes MonoAotLLVMGenerator MonoAotLLVMToolChain Enums MonoAotCompilerMode"
  },
  "api/BenchmarkDotNet.Toolchains.MonoAotLLVM.MonoAotCompilerMode.html": {
    "href": "api/BenchmarkDotNet.Toolchains.MonoAotLLVM.MonoAotCompilerMode.html",
    "title": "Enum MonoAotCompilerMode | BenchmarkDotNet",
    "summary": "Enum MonoAotCompilerMode Namespace BenchmarkDotNet.Toolchains.MonoAotLLVM Assembly BenchmarkDotNet.dll public enum MonoAotCompilerMode Fields llvm = 1 mini = 0 wasm = 2"
  },
  "api/BenchmarkDotNet.Toolchains.MonoAotLLVM.MonoAotLLVMGenerator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.MonoAotLLVM.MonoAotLLVMGenerator.html",
    "title": "Class MonoAotLLVMGenerator | BenchmarkDotNet",
    "summary": "Class MonoAotLLVMGenerator Namespace BenchmarkDotNet.Toolchains.MonoAotLLVM Assembly BenchmarkDotNet.dll public class MonoAotLLVMGenerator : CsProjGenerator, IGenerator, IEquatable<CsProjGenerator> Inheritance object GeneratorBase DotNetCliGenerator CsProjGenerator MonoAotLLVMGenerator Implements IGenerator IEquatable<CsProjGenerator> Inherited Members CsProjGenerator.GetBuildArtifactsDirectoryPath(BuildPartition, string) CsProjGenerator.GetProjectFilePath(string) CsProjGenerator.GetRuntimeSettings(GcMode, IResolver) CsProjGenerator.GetProjectFilePath(Type, ILogger) CsProjGenerator.Equals(object) CsProjGenerator.Equals(CsProjGenerator) CsProjGenerator.GetHashCode() CsProjGenerator.RuntimeFrameworkVersion DotNetCliGenerator.GetExecutableExtension() DotNetCliGenerator.GetArtifactsToCleanup(ArtifactsPaths) DotNetCliGenerator.CopyAllRequiredFiles(ArtifactsPaths) DotNetCliGenerator.GetPackagesDirectoryPath(string) DotNetCliGenerator.GenerateBuildScript(BuildPartition, ArtifactsPaths) DotNetCliGenerator.TargetFrameworkMoniker DotNetCliGenerator.CliPath DotNetCliGenerator.PackagesPath DotNetCliGenerator.IsNetCore GeneratorBase.GenerateProject(BuildPartition, ILogger, string) GeneratorBase.GenerateNuGetConfig(ArtifactsPaths) GeneratorBase.GenerateAppConfig(BuildPartition, ArtifactsPaths) GeneratorBase.GenerateCode(BuildPartition, ArtifactsPaths) Constructors MonoAotLLVMGenerator(string, string, string, string, string, MonoAotCompilerMode) public MonoAotLLVMGenerator(string targetFrameworkMoniker, string cliPath, string packagesPath, string customRuntimePack, string aotCompilerPath, MonoAotCompilerMode aotCompilerMode) Parameters targetFrameworkMoniker string cliPath string packagesPath string customRuntimePack string aotCompilerPath string aotCompilerMode MonoAotCompilerMode Methods GenerateProject(BuildPartition, ArtifactsPaths, ILogger) generates .csproj file with a reference to the project with benchmarks protected override void GenerateProject(BuildPartition buildPartition, ArtifactsPaths artifactsPaths, ILogger logger) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths logger ILogger GetBinariesDirectoryPath(string, string) returns a path where executable should be found after the build (usually \\bin) protected override string GetBinariesDirectoryPath(string buildArtifactsDirectoryPath, string configuration) Parameters buildArtifactsDirectoryPath string configuration string Returns string GetExecutablePath(string, string) protected override string GetExecutablePath(string binariesDirectoryPath, string programName) Parameters binariesDirectoryPath string programName string Returns string GetPublishDirectoryPath(string, string) returns a path where the publish directory should be found after the build (usually \\publish) protected override string GetPublishDirectoryPath(string buildArtifactsDirectoryPath, string configuration) Parameters buildArtifactsDirectoryPath string configuration string Returns string"
  },
  "api/BenchmarkDotNet.Toolchains.MonoAotLLVM.MonoAotLLVMToolChain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.MonoAotLLVM.MonoAotLLVMToolChain.html",
    "title": "Class MonoAotLLVMToolChain | BenchmarkDotNet",
    "summary": "Class MonoAotLLVMToolChain Namespace BenchmarkDotNet.Toolchains.MonoAotLLVM Assembly BenchmarkDotNet.dll public class MonoAotLLVMToolChain : Toolchain, IToolchain Inheritance object Toolchain MonoAotLLVMToolChain Implements IToolchain Inherited Members Toolchain.ToString() Toolchain.Name Toolchain.Generator Toolchain.Builder Toolchain.Executor Toolchain.IsInProcess Constructors MonoAotLLVMToolChain(string, IGenerator, IBuilder, IExecutor, string) public MonoAotLLVMToolChain(string name, IGenerator generator, IBuilder builder, IExecutor executor, string customDotNetCliPath) Parameters name string generator IGenerator builder IBuilder executor IExecutor customDotNetCliPath string Methods From(NetCoreAppSettings) public static IToolchain From(NetCoreAppSettings netCoreAppSettings) Parameters netCoreAppSettings NetCoreAppSettings Returns IToolchain Validate(BenchmarkCase, IResolver) public override IEnumerable<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver) Parameters benchmarkCase BenchmarkCase resolver IResolver Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Toolchains.MonoWasm.html": {
    "href": "api/BenchmarkDotNet.Toolchains.MonoWasm.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.MonoWasm | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.MonoWasm Classes WasmGenerator WasmToolchain"
  },
  "api/BenchmarkDotNet.Toolchains.MonoWasm.WasmGenerator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.MonoWasm.WasmGenerator.html",
    "title": "Class WasmGenerator | BenchmarkDotNet",
    "summary": "Class WasmGenerator Namespace BenchmarkDotNet.Toolchains.MonoWasm Assembly BenchmarkDotNet.dll public class WasmGenerator : CsProjGenerator, IGenerator, IEquatable<CsProjGenerator> Inheritance object GeneratorBase DotNetCliGenerator CsProjGenerator WasmGenerator Implements IGenerator IEquatable<CsProjGenerator> Inherited Members CsProjGenerator.GetBuildArtifactsDirectoryPath(BuildPartition, string) CsProjGenerator.GetProjectFilePath(string) CsProjGenerator.GetRuntimeSettings(GcMode, IResolver) CsProjGenerator.GetProjectFilePath(Type, ILogger) CsProjGenerator.Equals(object) CsProjGenerator.Equals(CsProjGenerator) CsProjGenerator.GetHashCode() CsProjGenerator.RuntimeFrameworkVersion DotNetCliGenerator.GetExecutableExtension() DotNetCliGenerator.GetArtifactsToCleanup(ArtifactsPaths) DotNetCliGenerator.CopyAllRequiredFiles(ArtifactsPaths) DotNetCliGenerator.GetPackagesDirectoryPath(string) DotNetCliGenerator.GenerateBuildScript(BuildPartition, ArtifactsPaths) DotNetCliGenerator.TargetFrameworkMoniker DotNetCliGenerator.CliPath DotNetCliGenerator.PackagesPath DotNetCliGenerator.IsNetCore GeneratorBase.GenerateProject(BuildPartition, ILogger, string) GeneratorBase.GetPublishDirectoryPath(string, string) GeneratorBase.GenerateNuGetConfig(ArtifactsPaths) GeneratorBase.GenerateAppConfig(BuildPartition, ArtifactsPaths) GeneratorBase.GenerateCode(BuildPartition, ArtifactsPaths) Constructors WasmGenerator(string, string, string, string, bool) public WasmGenerator(string targetFrameworkMoniker, string cliPath, string packagesPath, string customRuntimePack, bool aot) Parameters targetFrameworkMoniker string cliPath string packagesPath string customRuntimePack string aot bool Methods GenerateProject(BuildPartition, ArtifactsPaths, ILogger) generates .csproj file with a reference to the project with benchmarks protected override void GenerateProject(BuildPartition buildPartition, ArtifactsPaths artifactsPaths, ILogger logger) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths logger ILogger GenerateProjectFile(BuildPartition, ArtifactsPaths, bool, ILogger) protected void GenerateProjectFile(BuildPartition buildPartition, ArtifactsPaths artifactsPaths, bool aot, ILogger logger) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths aot bool logger ILogger GetBinariesDirectoryPath(string, string) returns a path where executable should be found after the build (usually \\bin) protected override string GetBinariesDirectoryPath(string buildArtifactsDirectoryPath, string configuration) Parameters buildArtifactsDirectoryPath string configuration string Returns string GetExecutablePath(string, string) protected override string GetExecutablePath(string binariesDirectoryPath, string programName) Parameters binariesDirectoryPath string programName string Returns string"
  },
  "api/BenchmarkDotNet.Toolchains.MonoWasm.WasmToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.MonoWasm.WasmToolchain.html",
    "title": "Class WasmToolchain | BenchmarkDotNet",
    "summary": "Class WasmToolchain Namespace BenchmarkDotNet.Toolchains.MonoWasm Assembly BenchmarkDotNet.dll public class WasmToolchain : Toolchain, IToolchain Inheritance object Toolchain WasmToolchain Implements IToolchain Inherited Members Toolchain.ToString() Toolchain.Name Toolchain.Generator Toolchain.Builder Toolchain.Executor Toolchain.IsInProcess Methods From(NetCoreAppSettings) public static IToolchain From(NetCoreAppSettings netCoreAppSettings) Parameters netCoreAppSettings NetCoreAppSettings Returns IToolchain Validate(BenchmarkCase, IResolver) public override IEnumerable<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver) Parameters benchmarkCase BenchmarkCase resolver IResolver Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Toolchains.NativeAot.Generator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.NativeAot.Generator.html",
    "title": "Class Generator | BenchmarkDotNet",
    "summary": "Class Generator Namespace BenchmarkDotNet.Toolchains.NativeAot Assembly BenchmarkDotNet.dll generates new csproj file for self-contained NativeAOT app based on https://github.com/dotnet/corert/blob/7f902d4d8b1c3280e60f5e06c71951a60da173fb/Documentation/how-to-build-and-run-ilcompiler-in-console-shell-prompt.md#compiling-source-to-native-code-using-the-ilcompiler-you-built and https://github.com/dotnet/corert/tree/7f902d4d8b1c3280e60f5e06c71951a60da173fb/samples/HelloWorld#add-corert-to-your-project public class Generator : CsProjGenerator, IGenerator, IEquatable<CsProjGenerator> Inheritance object GeneratorBase DotNetCliGenerator CsProjGenerator Generator Implements IGenerator IEquatable<CsProjGenerator> Inherited Members CsProjGenerator.GetProjectFilePath(string) CsProjGenerator.GetRuntimeSettings(GcMode, IResolver) CsProjGenerator.GetProjectFilePath(Type, ILogger) CsProjGenerator.Equals(object) CsProjGenerator.Equals(CsProjGenerator) CsProjGenerator.GetHashCode() CsProjGenerator.RuntimeFrameworkVersion DotNetCliGenerator.CopyAllRequiredFiles(ArtifactsPaths) DotNetCliGenerator.GetPackagesDirectoryPath(string) DotNetCliGenerator.TargetFrameworkMoniker DotNetCliGenerator.CliPath DotNetCliGenerator.PackagesPath DotNetCliGenerator.IsNetCore GeneratorBase.GenerateProject(BuildPartition, ILogger, string) GeneratorBase.GetPublishDirectoryPath(string, string) GeneratorBase.GenerateAppConfig(BuildPartition, ArtifactsPaths) GeneratorBase.GenerateCode(BuildPartition, ArtifactsPaths) GeneratorBase.GetExecutablePath(string, string) Methods GenerateBuildScript(BuildPartition, ArtifactsPaths) generates a script can be used when debugging compilation issues protected override void GenerateBuildScript(BuildPartition buildPartition, ArtifactsPaths artifactsPaths) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths GenerateNuGetConfig(ArtifactsPaths) generates NuGet.Config file to make sure that BDN is using the right NuGet feeds protected override void GenerateNuGetConfig(ArtifactsPaths artifactsPaths) Parameters artifactsPaths ArtifactsPaths GenerateProject(BuildPartition, ArtifactsPaths, ILogger) generates .csproj file with a reference to the project with benchmarks protected override void GenerateProject(BuildPartition buildPartition, ArtifactsPaths artifactsPaths, ILogger logger) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths logger ILogger GetArtifactsToCleanup(ArtifactsPaths) returns a list of artifacts that should be removed after running the benchmarks protected override string[] GetArtifactsToCleanup(ArtifactsPaths artifactsPaths) Parameters artifactsPaths ArtifactsPaths Returns string[] GetBinariesDirectoryPath(string, string) returns a path where executable should be found after the build (usually \\bin) protected override string GetBinariesDirectoryPath(string buildArtifactsDirectoryPath, string configuration) Parameters buildArtifactsDirectoryPath string configuration string Returns string GetBuildArtifactsDirectoryPath(BuildPartition, string) we need our folder to be on the same level as the project that we want to reference we are limited by xprojs (by default compiles all .cs files in all subfolders, Program.cs could be doubled and fail the build) and also by NuGet internal implementation like looking for global.json file in parent folders protected override string GetBuildArtifactsDirectoryPath(BuildPartition buildPartition, string programName) Parameters buildPartition BuildPartition programName string Returns string GetExecutableExtension() returns OS-specific executable extension protected override string GetExecutableExtension() Returns string GetRdXmlFiles(Type, ILogger) public IEnumerable<string> GetRdXmlFiles(Type benchmarkTarget, ILogger logger) Parameters benchmarkTarget Type logger ILogger Returns IEnumerable<string>"
  },
  "api/BenchmarkDotNet.Toolchains.NativeAot.html": {
    "href": "api/BenchmarkDotNet.Toolchains.NativeAot.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.NativeAot | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.NativeAot Classes Generator generates new csproj file for self-contained NativeAOT app based on https://github.com/dotnet/corert/blob/7f902d4d8b1c3280e60f5e06c71951a60da173fb/Documentation/how-to-build-and-run-ilcompiler-in-console-shell-prompt.md#compiling-source-to-native-code-using-the-ilcompiler-you-built and https://github.com/dotnet/corert/tree/7f902d4d8b1c3280e60f5e06c71951a60da173fb/samples/HelloWorld#add-corert-to-your-project NativeAotToolchain NativeAotToolchainBuilder"
  },
  "api/BenchmarkDotNet.Toolchains.NativeAot.NativeAotToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.NativeAot.NativeAotToolchain.html",
    "title": "Class NativeAotToolchain | BenchmarkDotNet",
    "summary": "Class NativeAotToolchain Namespace BenchmarkDotNet.Toolchains.NativeAot Assembly BenchmarkDotNet.dll public class NativeAotToolchain : Toolchain, IToolchain Inheritance object Toolchain NativeAotToolchain Implements IToolchain Inherited Members Toolchain.ToString() Toolchain.Name Toolchain.Generator Toolchain.Builder Toolchain.Executor Toolchain.IsInProcess Fields Net10_0 compiled as net10.0, targets latest NativeAOT build from the .NET 10 feed: https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet10/nuget/v3/index.json public static readonly IToolchain Net10_0 Field Value IToolchain Net60 compiled as net6.0, targets experimental 6.0.0-* NativeAOT build from the https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-experimental/nuget/v3/index.json public static readonly IToolchain Net60 Field Value IToolchain Net70 compiled as net7.0, targets latest NativeAOT build from the NuGet.org feed public static readonly IToolchain Net70 Field Value IToolchain Net80 compiled as net8.0, targets latest NativeAOT build from the NuGet.org feed: \"https://api.nuget.org/v3/index.json\" public static readonly IToolchain Net80 Field Value IToolchain Net90 compiled as net9.0, targets latest NativeAOT build from the .NET 9 feed: https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet9/nuget/v3/index.json public static readonly IToolchain Net90 Field Value IToolchain Methods CreateBuilder() public static NativeAotToolchainBuilder CreateBuilder() Returns NativeAotToolchainBuilder GetExtraArguments(string) public static string GetExtraArguments(string runtimeIdentifier) Parameters runtimeIdentifier string Returns string Validate(BenchmarkCase, IResolver) public override IEnumerable<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver) Parameters benchmarkCase BenchmarkCase resolver IResolver Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Toolchains.NativeAot.NativeAotToolchainBuilder.html": {
    "href": "api/BenchmarkDotNet.Toolchains.NativeAot.NativeAotToolchainBuilder.html",
    "title": "Class NativeAotToolchainBuilder | BenchmarkDotNet",
    "summary": "Class NativeAotToolchainBuilder Namespace BenchmarkDotNet.Toolchains.NativeAot Assembly BenchmarkDotNet.dll public class NativeAotToolchainBuilder : CustomDotNetCliToolchainBuilder Inheritance object CustomDotNetCliToolchainBuilder NativeAotToolchainBuilder Inherited Members CustomDotNetCliToolchainBuilder.Feeds CustomDotNetCliToolchainBuilder.runtimeIdentifier CustomDotNetCliToolchainBuilder.customDotNetCliPath CustomDotNetCliToolchainBuilder.displayName CustomDotNetCliToolchainBuilder.runtimeFrameworkVersion CustomDotNetCliToolchainBuilder.useNuGetClearTag CustomDotNetCliToolchainBuilder.useTempFolderForRestore CustomDotNetCliToolchainBuilder.AdditionalNuGetFeed(string, string) CustomDotNetCliToolchainBuilder.UseNuGetClearTag(bool) CustomDotNetCliToolchainBuilder.TargetFrameworkMoniker(string) CustomDotNetCliToolchainBuilder.GetTargetFrameworkMoniker() CustomDotNetCliToolchainBuilder.DotNetCli(string) CustomDotNetCliToolchainBuilder.RuntimeIdentifier(string) CustomDotNetCliToolchainBuilder.RuntimeFrameworkVersion(string) CustomDotNetCliToolchainBuilder.DisplayName(string) CustomDotNetCliToolchainBuilder.UseTempFolderForRestore(bool) Constructors NativeAotToolchainBuilder() public NativeAotToolchainBuilder() Methods Create() public static NativeAotToolchainBuilder Create() Returns NativeAotToolchainBuilder IlcGenerateCompleteTypeMetadata(bool) This controls the generation of complete type metadata. This option is enabled by default. This is a compilation mode that prevents a situation where some members of a type are visible to reflection at runtime, but others aren't, because they weren't compiled. public NativeAotToolchainBuilder IlcGenerateCompleteTypeMetadata(bool value) Parameters value bool Returns NativeAotToolchainBuilder IlcGenerateStackTraceData(bool) This controls generation of stack trace metadata that provides textual names in stack traces. This option is enabled by default. This is for example the text string one gets by calling Exception.ToString() on a caught exception. With this option disabled, stack traces will still be generated, but will be based on reflection metadata alone (they might be less complete). public NativeAotToolchainBuilder IlcGenerateStackTraceData(bool value) Parameters value bool Returns NativeAotToolchainBuilder IlcInstructionSet(string) By default, the compiler targets the minimum instruction set supported by the target OS and architecture. This option allows targeting newer instruction sets for better performance. The native binary will require the instruction sets to be supported by the hardware in order to run. For example, avx2,bmi2,fma,pclmul,popcnt,aes will produce binary that takes advantage of instruction sets that are typically present on current Intel and AMD processors. public NativeAotToolchainBuilder IlcInstructionSet(string value) Parameters value string Specify empty string (\"\", not null) to use the defaults. Returns NativeAotToolchainBuilder IlcOptimizationPreference(string) Options related to code generation. public NativeAotToolchainBuilder IlcOptimizationPreference(string value = \"Speed\") Parameters value string \"Speed\" to favor code execution speed (default), \"Size\" to favor smaller code size Returns NativeAotToolchainBuilder PackagesRestorePath(string) The directory to restore packages to (optional). public NativeAotToolchainBuilder PackagesRestorePath(string packagesRestorePath) Parameters packagesRestorePath string Returns NativeAotToolchainBuilder RootAllApplicationAssemblies(bool) This controls the compiler behavior where all code in the application assemblies is considered dynamically reachable. This option is disabled by default. Enabling this option (true) has a significant effect on the size of the resulting executable because it prevents removal of unused code that would otherwise happen. public NativeAotToolchainBuilder RootAllApplicationAssemblies(bool value) Parameters value bool Returns NativeAotToolchainBuilder ToToolchain() public override IToolchain ToToolchain() Returns IToolchain UseLocalBuild(DirectoryInfo) creates a NativeAOT toolchain targeting local build of ILCompiler Based on https://github.com/dotnet/runtime/blob/main/docs/workflow/building/coreclr/nativeaot.md public NativeAotToolchainBuilder UseLocalBuild(DirectoryInfo ilcPackages) Parameters ilcPackages DirectoryInfo the path to shipping packages, example: \"C:\\runtime\\artifacts\\packages\\Release\\Shipping\" Returns NativeAotToolchainBuilder UseNuGet(string, string) creates a NativeAOT toolchain targeting NuGet build of Microsoft.DotNet.ILCompiler Based on https://github.com/dotnet/runtimelab/blob/d0a37893a67c125f9b0cd8671846ff7d867df241/samples/HelloWorld/README.md#add-corert-to-your-project public NativeAotToolchainBuilder UseNuGet(string microsoftDotNetILCompilerVersion = \"\", string nuGetFeedUrl = \"https://api.nuget.org/v3/index.json\") Parameters microsoftDotNetILCompilerVersion string the version of Microsoft.DotNet.ILCompiler which should be used. The default is empty which maps to latest version. nuGetFeedUrl string url to NuGet feed, The default is: \"https://api.nuget.org/v3/index.json\" Returns NativeAotToolchainBuilder"
  },
  "api/BenchmarkDotNet.Toolchains.Parameters.ExecuteParameters.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Parameters.ExecuteParameters.html",
    "title": "Class ExecuteParameters | BenchmarkDotNet",
    "summary": "Class ExecuteParameters Namespace BenchmarkDotNet.Toolchains.Parameters Assembly BenchmarkDotNet.dll public class ExecuteParameters Inheritance object ExecuteParameters Constructors ExecuteParameters(BuildResult, BenchmarkCase, BenchmarkId, ILogger, IResolver, int, IDiagnoser?) public ExecuteParameters(BuildResult buildResult, BenchmarkCase benchmarkCase, BenchmarkId benchmarkId, ILogger logger, IResolver resolver, int launchIndex, IDiagnoser? diagnoser = null) Parameters buildResult BuildResult benchmarkCase BenchmarkCase benchmarkId BenchmarkId logger ILogger resolver IResolver launchIndex int diagnoser IDiagnoser Properties BenchmarkCase public BenchmarkCase BenchmarkCase { get; } Property Value BenchmarkCase BenchmarkId public BenchmarkId BenchmarkId { get; } Property Value BenchmarkId BuildResult public BuildResult BuildResult { get; } Property Value BuildResult Diagnoser public IDiagnoser Diagnoser { get; } Property Value IDiagnoser LaunchIndex public int LaunchIndex { get; } Property Value int Logger public ILogger Logger { get; } Property Value ILogger Resolver public IResolver Resolver { get; } Property Value IResolver"
  },
  "api/BenchmarkDotNet.Toolchains.Parameters.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Parameters.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.Parameters | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.Parameters Classes ExecuteParameters"
  },
  "api/BenchmarkDotNet.Toolchains.Results.BuildResult.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Results.BuildResult.html",
    "title": "Class BuildResult | BenchmarkDotNet",
    "summary": "Class BuildResult Namespace BenchmarkDotNet.Toolchains.Results Assembly BenchmarkDotNet.dll public class BuildResult : GenerateResult Inheritance object GenerateResult BuildResult Inherited Members GenerateResult.Success(ArtifactsPaths, IReadOnlyCollection<string>) GenerateResult.Failure(ArtifactsPaths, IReadOnlyCollection<string>, Exception) GenerateResult.ArtifactsPaths GenerateResult.IsGenerateSuccess GenerateResult.GenerateException GenerateResult.ArtifactsToCleanup Properties ErrorMessage public string ErrorMessage { get; } Property Value string IsBuildSuccess public bool IsBuildSuccess { get; } Property Value bool Methods Failure(GenerateResult, Exception) public static BuildResult Failure(GenerateResult generateResult, Exception exception) Parameters generateResult GenerateResult exception Exception Returns BuildResult Failure(GenerateResult, string) public static BuildResult Failure(GenerateResult generateResult, string errorMessage) Parameters generateResult GenerateResult errorMessage string Returns BuildResult Success(GenerateResult) public static BuildResult Success(GenerateResult generateResult) Parameters generateResult GenerateResult Returns BuildResult ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Toolchains.Results.ExecuteResult.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Results.ExecuteResult.html",
    "title": "Class ExecuteResult | BenchmarkDotNet",
    "summary": "Class ExecuteResult Namespace BenchmarkDotNet.Toolchains.Results Assembly BenchmarkDotNet.dll public class ExecuteResult Inheritance object ExecuteResult Constructors ExecuteResult(bool, int?, int?, IReadOnlyList<string>, IReadOnlyList<string>, IReadOnlyList<string>, int) public ExecuteResult(bool foundExecutable, int? exitCode, int? processId, IReadOnlyList<string> results, IReadOnlyList<string> prefixedLines, IReadOnlyList<string> standardOutput, int launchIndex) Parameters foundExecutable bool exitCode int? processId int? results IReadOnlyList<string> prefixedLines IReadOnlyList<string> standardOutput IReadOnlyList<string> launchIndex int Properties Errors public IReadOnlyList<string> Errors { get; } Property Value IReadOnlyList<string> ExitCode public int? ExitCode { get; } Property Value int? FoundExecutable public bool FoundExecutable { get; } Property Value bool IsSuccess public bool IsSuccess { get; } Property Value bool Measurements public IReadOnlyList<Measurement> Measurements { get; } Property Value IReadOnlyList<Measurement> PrefixedLines Lines reported by the Benchmark process that are starting with \"//\" public IReadOnlyList<string> PrefixedLines { get; } Property Value IReadOnlyList<string> ProcessId public int? ProcessId { get; } Property Value int? Results Lines reported by the Benchmark process that are not starting with \"//\" public IReadOnlyList<string> Results { get; } Property Value IReadOnlyList<string> StandardOutput All lines printed to standard output by the Benchmark process public IReadOnlyList<string> StandardOutput { get; } Property Value IReadOnlyList<string> Methods LogIssues(ILogger, BuildResult) public void LogIssues(ILogger logger, BuildResult buildResult) Parameters logger ILogger buildResult BuildResult ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Toolchains.Results.GenerateResult.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Results.GenerateResult.html",
    "title": "Class GenerateResult | BenchmarkDotNet",
    "summary": "Class GenerateResult Namespace BenchmarkDotNet.Toolchains.Results Assembly BenchmarkDotNet.dll public class GenerateResult Inheritance object GenerateResult Derived BuildResult Constructors GenerateResult(ArtifactsPaths, bool, Exception, IReadOnlyCollection<string>) public GenerateResult(ArtifactsPaths artifactsPaths, bool isGenerateSuccess, Exception generateException, IReadOnlyCollection<string> artifactsToCleanup) Parameters artifactsPaths ArtifactsPaths isGenerateSuccess bool generateException Exception artifactsToCleanup IReadOnlyCollection<string> Properties ArtifactsPaths public ArtifactsPaths ArtifactsPaths { get; } Property Value ArtifactsPaths ArtifactsToCleanup public IReadOnlyCollection<string> ArtifactsToCleanup { get; } Property Value IReadOnlyCollection<string> GenerateException public Exception GenerateException { get; } Property Value Exception IsGenerateSuccess public bool IsGenerateSuccess { get; } Property Value bool Methods Failure(ArtifactsPaths, IReadOnlyCollection<string>, Exception?) public static GenerateResult Failure(ArtifactsPaths artifactsPaths, IReadOnlyCollection<string> artifactsToCleanup, Exception? exception = null) Parameters artifactsPaths ArtifactsPaths artifactsToCleanup IReadOnlyCollection<string> exception Exception Returns GenerateResult Success(ArtifactsPaths, IReadOnlyCollection<string>) public static GenerateResult Success(ArtifactsPaths artifactsPaths, IReadOnlyCollection<string> artifactsToCleanup) Parameters artifactsPaths ArtifactsPaths artifactsToCleanup IReadOnlyCollection<string> Returns GenerateResult ToString() public override string ToString() Returns string"
  },
  "api/BenchmarkDotNet.Toolchains.Results.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Results.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.Results | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.Results Classes BuildResult ExecuteResult GenerateResult"
  },
  "api/BenchmarkDotNet.Toolchains.Roslyn.Builder.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Roslyn.Builder.html",
    "title": "Class Builder | BenchmarkDotNet",
    "summary": "Class Builder Namespace BenchmarkDotNet.Toolchains.Roslyn Assembly BenchmarkDotNet.dll public class Builder : IBuilder Inheritance object Builder Implements IBuilder Constructors Builder() public Builder() Fields Instance public static readonly IBuilder Instance Field Value IBuilder Methods Build(GenerateResult, BuildPartition, ILogger) public BuildResult Build(GenerateResult generateResult, BuildPartition buildPartition, ILogger logger) Parameters generateResult GenerateResult buildPartition BuildPartition logger ILogger Returns BuildResult"
  },
  "api/BenchmarkDotNet.Toolchains.Roslyn.Generator.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Roslyn.Generator.html",
    "title": "Class Generator | BenchmarkDotNet",
    "summary": "Class Generator Namespace BenchmarkDotNet.Toolchains.Roslyn Assembly BenchmarkDotNet.dll public class Generator : GeneratorBase, IGenerator Inheritance object GeneratorBase Generator Implements IGenerator Inherited Members GeneratorBase.GenerateProject(BuildPartition, ILogger, string) GeneratorBase.GetBinariesDirectoryPath(string, string) GeneratorBase.GetPublishDirectoryPath(string, string) GeneratorBase.GetExecutableExtension() GeneratorBase.GetProjectFilePath(string) GeneratorBase.CopyAllRequiredFiles(ArtifactsPaths) GeneratorBase.GenerateNuGetConfig(ArtifactsPaths) GeneratorBase.GenerateProject(BuildPartition, ArtifactsPaths, ILogger) GeneratorBase.GetPackagesDirectoryPath(string) GeneratorBase.GenerateAppConfig(BuildPartition, ArtifactsPaths) GeneratorBase.GenerateCode(BuildPartition, ArtifactsPaths) GeneratorBase.GetExecutablePath(string, string) Constructors Generator() public Generator() Methods GenerateBuildScript(BuildPartition, ArtifactsPaths) generates a script can be used when debugging compilation issues protected override void GenerateBuildScript(BuildPartition buildPartition, ArtifactsPaths artifactsPaths) Parameters buildPartition BuildPartition artifactsPaths ArtifactsPaths GetArtifactsToCleanup(ArtifactsPaths) returns a list of artifacts that should be removed after running the benchmarks protected override string[] GetArtifactsToCleanup(ArtifactsPaths artifactsPaths) Parameters artifactsPaths ArtifactsPaths Returns string[] GetBuildArtifactsDirectoryPath(BuildPartition, string) returns a path to the folder where auto-generated project and code are going to be placed protected override string GetBuildArtifactsDirectoryPath(BuildPartition buildPartition, string programName) Parameters buildPartition BuildPartition programName string Returns string"
  },
  "api/BenchmarkDotNet.Toolchains.Roslyn.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Roslyn.html",
    "title": "Namespace BenchmarkDotNet.Toolchains.Roslyn | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Toolchains.Roslyn Classes Builder Generator RoslynToolchain Build a benchmark program with the Roslyn compiler."
  },
  "api/BenchmarkDotNet.Toolchains.Roslyn.RoslynToolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Roslyn.RoslynToolchain.html",
    "title": "Class RoslynToolchain | BenchmarkDotNet",
    "summary": "Class RoslynToolchain Namespace BenchmarkDotNet.Toolchains.Roslyn Assembly BenchmarkDotNet.dll Build a benchmark program with the Roslyn compiler. public class RoslynToolchain : Toolchain, IToolchain Inheritance object Toolchain RoslynToolchain Implements IToolchain Inherited Members Toolchain.ToString() Toolchain.Name Toolchain.Generator Toolchain.Builder Toolchain.Executor Toolchain.IsInProcess Constructors RoslynToolchain() public RoslynToolchain() Fields Instance public static readonly IToolchain Instance Field Value IToolchain Methods Validate(BenchmarkCase, IResolver) public override IEnumerable<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver) Parameters benchmarkCase BenchmarkCase resolver IResolver Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Toolchains.Toolchain.html": {
    "href": "api/BenchmarkDotNet.Toolchains.Toolchain.html",
    "title": "Class Toolchain | BenchmarkDotNet",
    "summary": "Class Toolchain Namespace BenchmarkDotNet.Toolchains Assembly BenchmarkDotNet.dll public class Toolchain : IToolchain Inheritance object Toolchain Implements IToolchain Derived CsProjClassicNetToolchain CsProjCoreToolchain InProcessEmitToolchain MonoAotToolchain MonoAotLLVMToolChain WasmToolchain NativeAotToolchain RoslynToolchain Constructors Toolchain(string, IGenerator, IBuilder, IExecutor) public Toolchain(string name, IGenerator generator, IBuilder builder, IExecutor executor) Parameters name string generator IGenerator builder IBuilder executor IExecutor Properties Builder public IBuilder Builder { get; } Property Value IBuilder Executor public IExecutor Executor { get; } Property Value IExecutor Generator public IGenerator Generator { get; } Property Value IGenerator IsInProcess public virtual bool IsInProcess { get; } Property Value bool Name public string Name { get; } Property Value string Methods ToString() public override string ToString() Returns string Validate(BenchmarkCase, IResolver) public virtual IEnumerable<ValidationError> Validate(BenchmarkCase benchmarkCase, IResolver resolver) Parameters benchmarkCase BenchmarkCase resolver IResolver Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.BaselineValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.BaselineValidator.html",
    "title": "Class BaselineValidator | BenchmarkDotNet",
    "summary": "Class BaselineValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class BaselineValidator : IValidator Inheritance object BaselineValidator Implements IValidator Fields FailOnError public static readonly BaselineValidator FailOnError Field Value BaselineValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters input) Parameters input ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.CompilationValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.CompilationValidator.html",
    "title": "Class CompilationValidator | BenchmarkDotNet",
    "summary": "Class CompilationValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class CompilationValidator : IValidator Inheritance object CompilationValidator Implements IValidator Fields FailOnError public static readonly IValidator FailOnError Field Value IValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.ConfigValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.ConfigValidator.html",
    "title": "Class ConfigValidator | BenchmarkDotNet",
    "summary": "Class ConfigValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class ConfigValidator : IValidator Inheritance object ConfigValidator Implements IValidator Fields DontFailOnError public static readonly IValidator DontFailOnError Field Value IValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.DeferredExecutionValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.DeferredExecutionValidator.html",
    "title": "Class DeferredExecutionValidator | BenchmarkDotNet",
    "summary": "Class DeferredExecutionValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class DeferredExecutionValidator : IValidator Inheritance object DeferredExecutionValidator Implements IValidator Fields DontFailOnError public static readonly IValidator DontFailOnError Field Value IValidator FailOnError public static readonly IValidator FailOnError Field Value IValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.DiagnosersValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.DiagnosersValidator.html",
    "title": "Class DiagnosersValidator | BenchmarkDotNet",
    "summary": "Class DiagnosersValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class DiagnosersValidator : IValidator Inheritance object DiagnosersValidator Implements IValidator Fields Composite public static readonly IValidator Composite Field Value IValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.ExecutionValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.ExecutionValidator.html",
    "title": "Class ExecutionValidator | BenchmarkDotNet",
    "summary": "Class ExecutionValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class ExecutionValidator : ExecutionValidatorBase, IValidator Inheritance object ExecutionValidatorBase ExecutionValidator Implements IValidator Inherited Members ExecutionValidatorBase.Validate(ValidationParameters) ExecutionValidatorBase.GetDisplayExceptionMessage(Exception) ExecutionValidatorBase.TreatsWarningsAsErrors Fields DontFailOnError public static readonly ExecutionValidator DontFailOnError Field Value ExecutionValidator FailOnError public static readonly ExecutionValidator FailOnError Field Value ExecutionValidator Methods ExecuteBenchmarks(object, IEnumerable<BenchmarkCase>, List<ValidationError>) protected override void ExecuteBenchmarks(object benchmarkTypeInstance, IEnumerable<BenchmarkCase> benchmarks, List<ValidationError> errors) Parameters benchmarkTypeInstance object benchmarks IEnumerable<BenchmarkCase> errors List<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.ExecutionValidatorBase.html": {
    "href": "api/BenchmarkDotNet.Validators.ExecutionValidatorBase.html",
    "title": "Class ExecutionValidatorBase | BenchmarkDotNet",
    "summary": "Class ExecutionValidatorBase Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public abstract class ExecutionValidatorBase : IValidator Inheritance object ExecutionValidatorBase Implements IValidator Derived ExecutionValidator ReturnValueValidator Constructors ExecutionValidatorBase(bool) protected ExecutionValidatorBase(bool failOnError) Parameters failOnError bool Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods ExecuteBenchmarks(object, IEnumerable<BenchmarkCase>, List<ValidationError>) protected abstract void ExecuteBenchmarks(object benchmarkTypeInstance, IEnumerable<BenchmarkCase> benchmarks, List<ValidationError> errors) Parameters benchmarkTypeInstance object benchmarks IEnumerable<BenchmarkCase> errors List<ValidationError> GetDisplayExceptionMessage(Exception) protected static string GetDisplayExceptionMessage(Exception ex) Parameters ex Exception Returns string Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.GenericBenchmarksValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.GenericBenchmarksValidator.html",
    "title": "Class GenericBenchmarksValidator | BenchmarkDotNet",
    "summary": "Class GenericBenchmarksValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class GenericBenchmarksValidator : IValidator Inheritance object GenericBenchmarksValidator Implements IValidator Constructors GenericBenchmarksValidator() public GenericBenchmarksValidator() Fields DontFailOnError public static readonly IValidator DontFailOnError Field Value IValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.html": {
    "href": "api/BenchmarkDotNet.Validators.html",
    "title": "Namespace BenchmarkDotNet.Validators | BenchmarkDotNet",
    "summary": "Namespace BenchmarkDotNet.Validators Classes BaselineValidator CompilationValidator ConfigValidator DeferredExecutionValidator DiagnosersValidator ExecutionValidator ExecutionValidatorBase GenericBenchmarksValidator JitOptimizationsValidator ParamsAllValuesValidator ParamsValidator ReturnValueValidator RunModeValidator SetupCleanupValidator ShadowCopyValidator ValidationError ValidationErrorReporter ValidationParameters Interfaces IValidator"
  },
  "api/BenchmarkDotNet.Validators.IValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.IValidator.html",
    "title": "Interface IValidator | BenchmarkDotNet",
    "summary": "Interface IValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public interface IValidator Properties TreatsWarningsAsErrors bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.JitOptimizationsValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.JitOptimizationsValidator.html",
    "title": "Class JitOptimizationsValidator | BenchmarkDotNet",
    "summary": "Class JitOptimizationsValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class JitOptimizationsValidator : IValidator Inheritance object JitOptimizationsValidator Implements IValidator Fields DontFailOnError public static readonly IValidator DontFailOnError Field Value IValidator FailOnError public static readonly IValidator FailOnError Field Value IValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.ParamsAllValuesValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.ParamsAllValuesValidator.html",
    "title": "Class ParamsAllValuesValidator | BenchmarkDotNet",
    "summary": "Class ParamsAllValuesValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class ParamsAllValuesValidator : IValidator Inheritance object ParamsAllValuesValidator Implements IValidator Fields FailOnError public static readonly ParamsAllValuesValidator FailOnError Field Value ParamsAllValuesValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters input) Parameters input ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.ParamsValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.ParamsValidator.html",
    "title": "Class ParamsValidator | BenchmarkDotNet",
    "summary": "Class ParamsValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class ParamsValidator : IValidator Inheritance object ParamsValidator Implements IValidator Constructors ParamsValidator() public ParamsValidator() Fields FailOnError public static readonly ParamsValidator FailOnError Field Value ParamsValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters input) Parameters input ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.ReturnValueValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.ReturnValueValidator.html",
    "title": "Class ReturnValueValidator | BenchmarkDotNet",
    "summary": "Class ReturnValueValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class ReturnValueValidator : ExecutionValidatorBase, IValidator Inheritance object ExecutionValidatorBase ReturnValueValidator Implements IValidator Inherited Members ExecutionValidatorBase.Validate(ValidationParameters) ExecutionValidatorBase.GetDisplayExceptionMessage(Exception) ExecutionValidatorBase.TreatsWarningsAsErrors Properties DontFailOnError public static ReturnValueValidator DontFailOnError { get; } Property Value ReturnValueValidator FailOnError public static ReturnValueValidator FailOnError { get; } Property Value ReturnValueValidator Methods ExecuteBenchmarks(object, IEnumerable<BenchmarkCase>, List<ValidationError>) protected override void ExecuteBenchmarks(object benchmarkTypeInstance, IEnumerable<BenchmarkCase> benchmarks, List<ValidationError> errors) Parameters benchmarkTypeInstance object benchmarks IEnumerable<BenchmarkCase> errors List<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.RunModeValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.RunModeValidator.html",
    "title": "Class RunModeValidator | BenchmarkDotNet",
    "summary": "Class RunModeValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class RunModeValidator : IValidator Inheritance object RunModeValidator Implements IValidator Fields FailOnError public static readonly IValidator FailOnError Field Value IValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.SetupCleanupValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.SetupCleanupValidator.html",
    "title": "Class SetupCleanupValidator | BenchmarkDotNet",
    "summary": "Class SetupCleanupValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class SetupCleanupValidator : IValidator Inheritance object SetupCleanupValidator Implements IValidator Fields FailOnError public static readonly SetupCleanupValidator FailOnError Field Value SetupCleanupValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters input) Parameters input ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.ShadowCopyValidator.html": {
    "href": "api/BenchmarkDotNet.Validators.ShadowCopyValidator.html",
    "title": "Class ShadowCopyValidator | BenchmarkDotNet",
    "summary": "Class ShadowCopyValidator Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class ShadowCopyValidator : IValidator Inheritance object ShadowCopyValidator Implements IValidator Fields DontFailOnError public static readonly IValidator DontFailOnError Field Value IValidator Properties TreatsWarningsAsErrors public bool TreatsWarningsAsErrors { get; } Property Value bool Methods Validate(ValidationParameters) public IEnumerable<ValidationError> Validate(ValidationParameters validationParameters) Parameters validationParameters ValidationParameters Returns IEnumerable<ValidationError>"
  },
  "api/BenchmarkDotNet.Validators.ValidationError.html": {
    "href": "api/BenchmarkDotNet.Validators.ValidationError.html",
    "title": "Class ValidationError | BenchmarkDotNet",
    "summary": "Class ValidationError Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class ValidationError : IEquatable<ValidationError> Inheritance object ValidationError Implements IEquatable<ValidationError> Constructors ValidationError(bool, string, BenchmarkCase?) public ValidationError(bool isCritical, string message, BenchmarkCase? benchmarkCase = null) Parameters isCritical bool message string benchmarkCase BenchmarkCase Properties BenchmarkCase public BenchmarkCase? BenchmarkCase { get; } Property Value BenchmarkCase IsCritical public bool IsCritical { get; } Property Value bool Message public string Message { get; } Property Value string Methods Equals(ValidationError?) public bool Equals(ValidationError? other) Parameters other ValidationError Returns bool Equals(object?) public override bool Equals(object? obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int ToString() public override string ToString() Returns string Operators operator ==(ValidationError, ValidationError) public static bool operator ==(ValidationError left, ValidationError right) Parameters left ValidationError right ValidationError Returns bool operator !=(ValidationError, ValidationError) public static bool operator !=(ValidationError left, ValidationError right) Parameters left ValidationError right ValidationError Returns bool"
  },
  "api/BenchmarkDotNet.Validators.ValidationErrorReporter.html": {
    "href": "api/BenchmarkDotNet.Validators.ValidationErrorReporter.html",
    "title": "Class ValidationErrorReporter | BenchmarkDotNet",
    "summary": "Class ValidationErrorReporter Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public static class ValidationErrorReporter Inheritance object ValidationErrorReporter Fields ConsoleErrorPrefix public const string ConsoleErrorPrefix = \"// ERROR: \" Field Value string Methods ReportIfAny(IEnumerable<ValidationError>, IHost) public static bool ReportIfAny(IEnumerable<ValidationError> validationErrors, IHost host) Parameters validationErrors IEnumerable<ValidationError> host IHost Returns bool"
  },
  "api/BenchmarkDotNet.Validators.ValidationParameters.html": {
    "href": "api/BenchmarkDotNet.Validators.ValidationParameters.html",
    "title": "Class ValidationParameters | BenchmarkDotNet",
    "summary": "Class ValidationParameters Namespace BenchmarkDotNet.Validators Assembly BenchmarkDotNet.dll public class ValidationParameters Inheritance object ValidationParameters Constructors ValidationParameters(IReadOnlyList<BenchmarkCase>, ImmutableConfig) public ValidationParameters(IReadOnlyList<BenchmarkCase> benchmarks, ImmutableConfig config) Parameters benchmarks IReadOnlyList<BenchmarkCase> config ImmutableConfig Properties Benchmarks public IReadOnlyList<BenchmarkCase> Benchmarks { get; } Property Value IReadOnlyList<BenchmarkCase> Config public ImmutableConfig Config { get; } Property Value ImmutableConfig Operators implicit operator ValidationParameters(BenchmarkCase[]) public static implicit operator ValidationParameters(BenchmarkCase[] benchmarksCase) Parameters benchmarksCase BenchmarkCase[] Returns ValidationParameters implicit operator ValidationParameters(BenchmarkRunInfo) public static implicit operator ValidationParameters(BenchmarkRunInfo benchmarkRunInfo) Parameters benchmarkRunInfo BenchmarkRunInfo Returns ValidationParameters"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "BenchmarkDotNet API Reference | BenchmarkDotNet",
    "summary": "BenchmarkDotNet API Reference"
  },
  "articles/configs/analysers.html": {
    "href": "articles/configs/analysers.html",
    "title": "Analysers | BenchmarkDotNet",
    "summary": "Analysers An analyser can analyse summary of your benchmarks and produce some useful warnings. For example, EnvironmentAnalyser warns you, if you build your application in the DEBUG mode or run it with an attached debugger."
  },
  "articles/configs/columns.html": {
    "href": "articles/configs/columns.html",
    "title": "Columns | BenchmarkDotNet",
    "summary": "Columns A column is a column in the summary table. Default columns In this section, default columns (which be added to the Summary table by default) are presented. Some of columns are optional, i.e. they can be omitted (it depends on the measurements from the summary). Target There are 3 default columns which describes the target benchmark: Namespace, Type, Method. Namespace and Type will be omitted when all the benchmarks have the same namespace or type name. Method column always be a part of the summary table. Job There are many different job characteristics, but the summary includes only characteristics which has at least one non-default value. Statistics There are also a lot of different statistics which can be considered. It will be really hard to analyse the summary table, if all of the available statistics will be shown. Fortunately, BenchmarkDotNet has some heuristics for statistics columns and shows only important columns. For example, if all of the standard deviations are zero (we run our benchmarks against Dry job), this column will be omitted. The standard error will be shown only for cases when we are failed to achieve required accuracy level. Only Mean will be always shown. If the distribution looks strange, BenchmarkDotNet could also print additional columns like Median or P95 (95th percentile). If you need specific statistics, you always could add them manually. Params If you have params, the corresponded columns will be automatically added. Diagnosers If you turned on diagnosers which providers additional columns, they will be also included in the summary page. Custom columns Of course, you can define own custom columns and use it everywhere. Here is the definition of TagColumn: using System; using BenchmarkDotNet.Reports; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Columns { public class TagColumn : IColumn { private readonly Func<string, string> getTag; public string Id { get; } public string ColumnName { get; } public TagColumn(string columnName, Func<string, string> getTag) { this.getTag = getTag; ColumnName = columnName; Id = nameof(TagColumn) + \".\" + ColumnName; } public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) => false; public string GetValue(Summary summary, BenchmarkCase benchmarkCase) => getTag(benchmarkCase.Descriptor?.WorkloadMethod?.Name ?? \"\"); public bool IsAvailable(Summary summary) => true; public bool AlwaysShow => true; public ColumnCategory Category => ColumnCategory.Custom; public int PriorityInCategory => 0; public bool IsNumeric => false; public UnitType UnitType => UnitType.Dimensionless; public string Legend => $\"Custom '{ColumnName}' tag column\"; public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) => GetValue(summary, benchmarkCase); public override string ToString() => ColumnName; } } Sample: IntroTagColumn In the following example, we introduce two new columns which contains a tag based on a benchmark method name. Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Columns; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { // You can add custom tags per each method using Columns [Config(typeof(Config))] public class IntroTagColumn { private class Config : ManualConfig { public Config() { AddJob(Job.Dry); AddColumn(new TagColumn(\"Kind\", name => name.Substring(0, 3))); AddColumn(new TagColumn(\"Number\", name => name.Substring(3))); } } [Benchmark] public void Foo1() => Thread.Sleep(10); [Benchmark] public void Foo12() => Thread.Sleep(10); [Benchmark] public void Bar3() => Thread.Sleep(10); [Benchmark] public void Bar34() => Thread.Sleep(10); } } Output | Method | Mean | Kind | Number | | ------ | ---------- | ---- | ------ | | Bar34 | 10.3636 ms | Bar | 34 | | Bar3 | 10.4662 ms | Bar | 3 | | Foo12 | 10.1377 ms | Foo | 12 | | Foo1 | 10.2814 ms | Foo | 1 | Links Columns The permanent link to this sample: BenchmarkDotNet.Samples.IntroTagColumn"
  },
  "articles/configs/configoptions.html": {
    "href": "articles/configs/configoptions.html",
    "title": "Config Options | BenchmarkDotNet",
    "summary": "Config Options The config options let you customize some behavior of BenchmarkDotNet - mainly regarding the output. Available config options are: ConfigOptions.Default - No configuration option is set - this is the default. ConfigOptions.KeepBenchmarkFiles - All auto-generated files should be kept after running the benchmarks (by default they are removed). ConfigOptions.JoinSummary - All benchmarks results should be joined into a single summary (by default we have a summary per type). ConfigOptions.StopOnFirstError - Benchmarking should be stopped after the first error (by default it's not). ConfigOptions.DisableOptimizationsValidator - Mandatory optimizations validator should be entirely turned off. ConfigOptions.DontOverwriteResults - The exported result files should not be overwritten (by default they are overwritten). ConfigOptions.DisableLogFile - Disables the log file written on disk. All of these options could be combined and are available as CLI (Comand Line Interface) option (except DisableOptimizationsValidator), see Console Arguments for further information how to use the CLI. Any of these options could be used either in object style config or fluent style config: Object style config public class Config : ManualConfig { public Config() { // Using the WithOptions() factory method: this.WithOptions(ConfigOptions.JoinSummary) .WithOptions(ConfigOptions.DisableLogFile); // Or (The ConfigOptions Enum is defined as a BitField) this.WithOptions(ConfigOptions.JoinSummary | ConfigOptions.DisableLogFile); } } Fluent style config public static void Run() { BenchmarkRunner .Run<Benchmarks>( ManualConfig .Create(DefaultConfig.Instance) .WithOptions(ConfigOptions.JoinSummary) .WithOptions(ConfigOptions.DisableLogFile) // or .WithOptions(ConfigOptions.JoinSummary | ConfigOptions.DisableLogFile)); }"
  },
  "articles/configs/configs.html": {
    "href": "articles/configs/configs.html",
    "title": "Configs | BenchmarkDotNet",
    "summary": "Configs Config is a set of so called jobs, columns, exporters, loggers, diagnosers, analysers, validators that help you to build your benchmark. Built-in configuration There are two built-in ways to set your config: Object style [Config(typeof(Config))] public class MyClassWithBenchmarks { private class Config : ManualConfig { public Config() { AddJob(new Job1(), new Job2()); AddColumn(new Column1(), new Column2()); AddColumnProvider(new ColumnProvider1(), new ColumnProvider2()); AddExporter(new Exporter1(), new Exporter2()); AddLogger(new Logger1(), new Logger2()); AddDiagnoser(new Diagnoser1(), new Diagnoser2()); AddAnalyser(new Analyser1(), new Analyser2()); AddValidator(new Validator2(),new Validator2()); AddHardwareCounters(HardwareCounter enum1, HardwareCounter enum2); AddFilter(new Filter1(), new Filter2()); AddLogicalGroupRules(BenchmarkLogicalGroupRule enum1, BenchmarkLogicalGroupRule enum2); } } [Benchmark] public void Benchmark1() { } [Benchmark] public void Benchmark2() { } } Sample: IntroConfigSource You can define own config attribute. Source code using System; using System.Linq; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [MyConfigSource(Jit.LegacyJit, Jit.RyuJit)] public class IntroConfigSource { /// <summary> /// Dry-x64 jobs for specific jits /// </summary> private class MyConfigSourceAttribute : Attribute, IConfigSource { public IConfig Config { get; } public MyConfigSourceAttribute(params Jit[] jits) { var jobs = jits .Select(jit => new Job(Job.Dry) { Environment = { Jit = jit, Platform = Platform.X64 } }) .ToArray(); Config = ManualConfig.CreateEmpty().AddJob(jobs); } } [Benchmark] public void Foo() { Thread.Sleep(10); } } } Links Configs The permanent link to this sample: BenchmarkDotNet.Samples.IntroConfigSource Sample: IntroConfigUnion Source code using System.Threading; using BenchmarkDotNet.Analysers; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Columns; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Exporters; using BenchmarkDotNet.Exporters.Csv; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Loggers; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] public class IntroConfigUnion { private class Config : ManualConfig { public Config() { AddJob(Job.Dry); AddLogger(ConsoleLogger.Default); AddColumn(TargetMethodColumn.Method, StatisticColumn.Max); AddExporter(RPlotExporter.Default, CsvExporter.Default); AddAnalyser(EnvironmentAnalyser.Default); UnionRule = ConfigUnionRule.AlwaysUseLocal; } } [Benchmark] public void Foo() { Thread.Sleep(10); } } } Links Configs The permanent link to this sample: BenchmarkDotNet.Samples.IntroConfigUnion Sample: IntroFluentConfigBuilder There is no need to create new Config type, you can simply use fluent interface. Source code using System; using System.Security.Cryptography; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; using BenchmarkDotNet.Validators; namespace BenchmarkDotNet.Samples { public class Algo_Md5VsSha256 { private const int N = 10000; private readonly byte[] data; private readonly MD5 md5 = MD5.Create(); private readonly SHA256 sha256 = SHA256.Create(); public Algo_Md5VsSha256() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark(Baseline = true)] public byte[] Md5() => md5.ComputeHash(data); [Benchmark] public byte[] Sha256() => sha256.ComputeHash(data); } public class IntroFluentConfigBuilder { public static void Run() { BenchmarkRunner .Run<Algo_Md5VsSha256>( DefaultConfig.Instance .AddJob(Job.Default.WithRuntime(ClrRuntime.Net462)) .AddJob(Job.Default.WithRuntime(CoreRuntime.Core80)) .AddValidator(ExecutionValidator.FailOnError)); } } } Links Configs The permanent link to this sample: BenchmarkDotNet.Samples.IntroFluentConfigBuilder"
  },
  "articles/configs/diagnosers.html": {
    "href": "articles/configs/diagnosers.html",
    "title": "Diagnosers | BenchmarkDotNet",
    "summary": "Diagnosers A diagnoser can attach to your benchmark and get some useful info. The current Diagnosers are: GC and Memory Allocation (MemoryDiagnoser) which is cross platform, built-in and is not enabled by default anymore. Please see Adam Sitnik's blog post for all the details. JIT Stats Diagnoser. You can find this diagnoser in a separate package with diagnosers for Windows (BenchmarkDotNet.Diagnostics.Windows): JIT Inlining Events (InliningDiagnoser). You can find this diagnoser in a separate package with diagnosers for Windows (BenchmarkDotNet.Diagnostics.Windows): JIT Tail Call Events (TailCallDiagnoser). You can find this diagnoser as well as the (InliningDiagnoser) in a separate package with diagnosers for Windows (BenchmarkDotNet.Diagnostics.Windows): Please see this post for all the details. Hardware Counter Diagnoser. You can find this diagnoser in a separate package with diagnosers for Windows (BenchmarkDotNet.Diagnostics.Windows): . Please see Adam Sitnik's blog post for all the details. Disassembly Diagnoser. It allows you to disassemble the benchmarked code to asm, IL and C#/F#. Please see Adam Sitnik's blog post for all the details. ETW Profiler (EtwProfiler). It allows you to not only benchmark, but also profile the code. It's using TraceEvent, which internally uses ETW and exports all the information to a trace file. The trace file contains all of the stack traces captured by the profiler, PDBs to resolve symbols for both native and managed code and captured GC, JIT and CLR events. Please use one of the free tools: PerfView or Windows Performance Analyzer to analyze and visualize the data from trace file. You can find this diagnoser in a separate package with diagnosers for Windows (BenchmarkDotNet.Diagnostics.Windows): Please see Adam Sitnik's blog post for all the details. Concurrency Visualizer Profiler (ConcurrencyVisualizerProfiler) It uses EtwProfiler to profile the code using ETW and create not only .etl file but also a CVTrace file which can be opened by Concurrency Visualizer plugin from Visual Studio. Please see Adam Sitnik's blog post for all the details. Native Memory Profiler (NativeMemoryProfiler) It uses EtwProfiler to profile the code using ETW and adds the extra columns Allocated native memory and Native memory leak. Please see Wojciech Nagórski's blog post for all the details. Event Pipe Profiler (EventPipeProfiler). It is a cross-platform profiler that allows profile .NET code on every platform - Windows, Linux, macOS. Please see Wojciech Nagórski's blog post for all the details. Threading Diagnoser (ThreadingDiagnoser) - .NET Core 3.0+ diagnoser that reports some Threading statistics. Exception Diagnoser (ExceptionDiagnoser) - a diagnoser that reports the frequency of exceptions thrown during the operation. Usage Below is a sample output from the GC and Memory Allocation diagnoser, note the extra columns on the right-hand side (\"Gen 0\", \"Gen 1\", \"Gen 2\" and \"Allocated\"): Method | Mean | StdErr | Median | Gen 0 | Allocated | ----------------- |------------ |----------- |------------ |------- |---------- | 'new byte[10kB]' | 884.4896 ns | 46.3528 ns | 776.4237 ns | 0.1183 | 10 kB | A config example: private class Config : ManualConfig { public Config() { AddDiagnoser(MemoryDiagnoser.Default); AddDiagnoser(new InliningDiagnoser()); AddDiagnoser(new EtwProfiler()); AddDiagnoser(ThreadingDiagnoser.Default); AddDiagnoser(ExceptionDiagnoser.Default); } } You can also use one of the following attributes (apply it on a class that contains Benchmarks): [MemoryDiagnoser] [InliningDiagnoser] [TailCallDiagnoser] [EtwProfiler] [ConcurrencyVisualizerProfiler] [NativeMemoryProfiler] [ThreadingDiagnoser] [ExceptionDiagnoser] In BenchmarkDotNet, 1kB = 1024B, 1MB = 1024kB, and so on. The column Gen X means number of GC collections per 1000 operations for that generation. Restrictions In order to not affect main results we perform a separate run if any diagnoser is used. That's why it might take more time to execute benchmarks. MemoryDiagnoser: In order to get the number of allocated bytes in cross platform way we are using GC.GetAllocatedBytesForCurrentThread which recently got exposed for netcoreapp1.1. That's why BenchmarkDotNet does not support netcoreapp1.0 from version 0.10.1. MemoryDiagnoser is 99.5% accurate about allocated memory when using default settings or Job.ShortRun (or any longer job than it). Threading Diagnoser: Works only for .NET Core 3.0+ HardwareCounters: Windows 8+ only (we plan to add Unix support in the future) No Hyper-V (Virtualization) support Requires running as Admin (ETW Kernel Session) No InProcessToolchain support (#394) EtwProfiler, ConcurrencyVisualizerProfiler and NativeMemoryProfiler: Windows only Requires running as Admin (ETW Kernel Session) No InProcessToolchain support (#394) Disassembly Diagnoser: .NET Core disassembler works only on Windows Mono disassembler does not support recursive disassembling and produces output without IL and C#. Indirect calls are not tracked. To be able to compare different platforms, you need to target AnyCPU <PlatformTarget>AnyCPU</PlatformTarget> To get the corresponding C#/F# code from disassembler you need to configure your project in following way: <DebugType>pdbonly</DebugType> <DebugSymbols>true</DebugSymbols> Sample: IntroHardwareCounters This diagnoser is not enabled in explicit way as the other diagnosers. You need to specify [HardwareCounters] and we choose the right diagnoser in the runtime. Source code using System; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnosers; namespace BenchmarkDotNet.Samples { [HardwareCounters( HardwareCounter.BranchMispredictions, HardwareCounter.BranchInstructions)] public class IntroHardwareCounters { private const int N = 32767; private readonly int[] sorted, unsorted; public IntroHardwareCounters() { var random = new Random(0); unsorted = new int[N]; sorted = new int[N]; for (int i = 0; i < N; i++) sorted[i] = unsorted[i] = random.Next(256); Array.Sort(sorted); } private static int Branch(int[] data) { int sum = 0; for (int i = 0; i < N; i++) if (data[i] >= 128) sum += data[i]; return sum; } private static int Branchless(int[] data) { int sum = 0; for (int i = 0; i < N; i++) { int t = (data[i] - 128) >> 31; sum += ~t & data[i]; } return sum; } [Benchmark] public int SortedBranch() => Branch(sorted); [Benchmark] public int UnsortedBranch() => Branch(unsorted); [Benchmark] public int SortedBranchless() => Branchless(sorted); [Benchmark] public int UnsortedBranchless() => Branchless(unsorted); } } Output Method Mean Mispredict rate BranchInstructions/Op BranchMispredictions/Op SortedBranch 21.4539 us 0,04% 70121 24 UnsortedBranch 136.1139 us 23,70% 68788 16301 SortedBranchless 28.6705 us 0,06% 35711 22 UnsortedBranchless 28.9336 us 0,05% 35578 17 Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroHardwareCounters Sample: IntroDisassemblyRyuJit Source code using System.Linq; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(printSource: true)] [RyuJitX64Job] public class IntroDisassemblyRyuJit { private int[] field = Enumerable.Range(0, 100).ToArray(); [Benchmark] public int SumLocal() { var local = field; // we use local variable that points to the field int sum = 0; for (int i = 0; i < local.Length; i++) sum += local[i]; return sum; } [Benchmark] public int SumField() { int sum = 0; for (int i = 0; i < field.Length; i++) sum += field[i]; return sum; } } } Output Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassemblyRyuJit Sample: IntroDisassembly Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnosers; using System.Linq; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(printInstructionAddresses: true, syntax: DisassemblySyntax.Masm)] public class IntroDisassembly { private int[] field = Enumerable.Range(0, 100).ToArray(); [Benchmark] public int SumLocal() { var local = field; // we use local variable that points to the field int sum = 0; for (int i = 0; i < local.Length; i++) sum += local[i]; return sum; } [Benchmark] public int SumField() { int sum = 0; for (int i = 0; i < field.Length; i++) sum += field[i]; return sum; } } } Output ; .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.7.3110.0 05452718 BenchmarkDotNet.Samples.IntroDisassembly.Sum() IL_0000: ldc.r8 0 IL_0009: stloc.0 0545271c d9ee fldz IL_000a: ldc.i4.0 IL_000b: stloc.1 IL_000c: br.s IL_0017 0545271e 33c0 xor eax,eax IL_000e: ldloc.0 IL_000f: ldloc.1 IL_0010: conv.r8 IL_0011: add IL_0012: stloc.0 05452720 8945fc mov dword ptr [ebp-4],eax 05452723 db45fc fild dword ptr [ebp-4] 05452726 dec1 faddp st(1),st IL_0013: ldloc.1 IL_0014: ldc.i4.1 IL_0015: add IL_0016: stloc.1 05452728 40 inc eax IL_0017: ldloc.1 IL_0018: ldc.i4.s 64 IL_001a: blt.s IL_000e 05452729 83f840 cmp eax,40h 0545272c 7cf2 jl 05452720 IL_001c: ldloc.0 IL_001d: ret 0545272e 8be5 mov esp,ebp ; .NET Core 2.1.0 (CoreCLR 4.6.26515.07, CoreFX 4.6.26515.06), 64bit RyuJIT 00007ffa`6c621320 BenchmarkDotNet.Samples.IntroDisassembly.Sum() IL_0000: ldc.r8 0 IL_0009: stloc.0 00007ffa`6c621323 c4e17857c0 vxorps xmm0,xmm0,xmm0 IL_000a: ldc.i4.0 IL_000b: stloc.1 IL_000c: br.s IL_0017 00007ffa`6c621328 33c0 xor eax,eax IL_000e: ldloc.0 IL_000f: ldloc.1 IL_0010: conv.r8 IL_0011: add IL_0012: stloc.0 00007ffa`6c62132a c4e17057c9 vxorps xmm1,xmm1,xmm1 00007ffa`6c62132f c4e1732ac8 vcvtsi2sd xmm1,xmm1,eax 00007ffa`6c621334 c4e17b58c1 vaddsd xmm0,xmm0,xmm1 IL_0013: ldloc.1 IL_0014: ldc.i4.1 IL_0015: add IL_0016: stloc.1 00007ffa`6c621339 ffc0 inc eax IL_0017: ldloc.1 IL_0018: ldc.i4.s 64 IL_001a: blt.s IL_000e 00007ffa`6c62133b 83f840 cmp eax,40h 00007ffa`6c62133e 7cea jl 00007ffa`6c62132a IL_001c: ldloc.0 IL_001d: ret 00007ffa`6c621340 c3 ret Mono 5.12.0 (Visual Studio), 64bit Sum sub $0x18,%rsp mov %rsi,(%rsp) xorpd %xmm0,%xmm0 movsd %xmm0,0x8(%rsp) xor %esi,%esi jmp 2e xchg %ax,%ax movsd 0x8(%rsp),%xmm0 cvtsi2sd %esi,%xmm1 addsd %xmm1,%xmm0 movsd %xmm0,0x8(%rsp) inc %esi cmp $0x40,%esi jl 18 movsd 0x8(%rsp),%xmm0 mov (%rsp),%rsi add $0x18,%rsp retq Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassembly Sample: IntroDisassemblyAllJits You can use a single config to compare the generated assembly code for ALL JITs. But to allow benchmarking any target platform architecture the project which defines benchmarks has to target AnyCPU. <PropertyGroup> <PlatformTarget>AnyCPU</PlatformTarget> </PropertyGroup> Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Diagnosers; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [Config(typeof(MultipleJits))] public class IntroDisassemblyAllJits { public class MultipleJits : ManualConfig { public MultipleJits() { AddJob(Job.ShortRun.WithPlatform(Platform.X86).WithRuntime(new MonoRuntime(name: \"Mono x86\", customPath: @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithPlatform(Platform.X64).WithRuntime(new MonoRuntime(name: \"Mono x64\", customPath: @\"C:\\Program Files\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithJit(Jit.LegacyJit).WithPlatform(Platform.X86).WithRuntime(ClrRuntime.Net462)); AddJob(Job.ShortRun.WithJit(Jit.LegacyJit).WithPlatform(Platform.X64).WithRuntime(ClrRuntime.Net462)); AddJob(Job.ShortRun.WithJit(Jit.RyuJit).WithPlatform(Platform.X64).WithRuntime(ClrRuntime.Net462)); // RyuJit for .NET Core 5.0 AddJob(Job.ShortRun.WithJit(Jit.RyuJit).WithPlatform(Platform.X64).WithRuntime(CoreRuntime.Core50)); AddDiagnoser(new DisassemblyDiagnoser(new DisassemblyDiagnoserConfig(maxDepth: 3, exportDiff: true))); } } private Increment increment = new Increment(); [Benchmark] public int CallVirtualMethod() => increment.OperateTwice(10); public abstract class Operation // abstract unary integer operation { public abstract int Operate(int input); public int OperateTwice(int input) => Operate(Operate(input)); // two virtual calls to Operate } public sealed class Increment : Operation // concrete, sealed operation: increment by fixed amount { public readonly int Amount; public Increment(int amount = 1) { Amount = amount; } public override int Operate(int input) => input + Amount; } } } Output The disassembly result can be obtained here. The file was too big to embed it in this doc page. Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassemblyAllJits Sample: IntroDisassemblyDry Getting only the Disassembly without running the benchmarks for a long time. Sometimes you might be interested only in the disassembly, not the results of the benchmarks. In that case you can use Job.Dry which runs the benchmark only once. Source code using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(maxDepth: 3)] [DryJob] public class IntroDisassemblyDry { [Benchmark] public void Foo() { } } } Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassemblyDry Sample: IntroTailcall You need to use the TailcallDiagnoser attribute to configure it. The available options are: logFailuresOnly: Track only the methods that failed to get tail called. True by default. filterByNamespace : Track only the methods from declaring type's namespace. Set to false if you want to see all Jit tail events. True by default. Restrictions Windows only x64 Source code using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [Diagnostics.Windows.Configs.TailCallDiagnoser] [LegacyJitX86Job, LegacyJitX64Job, RyuJitX64Job] public class IntroTailcall { [Benchmark] public long Calc() => FactorialWithoutTailing(7) - FactorialWithTailing(7); private static long FactorialWithoutTailing(int depth) => depth == 0 ? 1 : depth * FactorialWithoutTailing(depth - 1); private static long FactorialWithTailing(int pos, int depth) => pos == 0 ? depth : FactorialWithTailing(pos - 1, depth * pos); private static long FactorialWithTailing(int depth) => FactorialWithTailing(depth - 1, depth); } } Output // * Diagnostic Output - TailCallDiagnoser * -------------------- -------------------- Jit_TailCalling.Calc: LegacyJitX64(Jit=LegacyJit, Platform=X64, Runtime=Clr) -------------------- -------------------- Jit_TailCalling.Calc: LegacyJitX86(Jit=LegacyJit, Platform=X86, Runtime=Clr) -------------------- -------------------- Jit_TailCalling.Calc: RyuJitX64(Jit=RyuJit, Platform=X64) -------------------- Caller: <null>.<null> - <null> Callee: BenchmarkDotNet.Samples.JIT.Jit_TailCalling.FactorialWithTailing - int64 (int32,int32) Tail prefix: False Tail call type: RecursiveLoop ------------------- Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroTailcall Sample: IntroJitStatsDiagnoser This diagnoser shows various stats from the JIT compiler that were collected during entire benchmark run (warmup phase and BenchmarkDotNet-generated boilerplate code are included): Amount of JITted methods. Amount of tiered methods. How much memory JIT allocated during the benchmark. Restrictions Windows only Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [Diagnostics.Windows.Configs.JitStatsDiagnoser] public class IntroJitStatsDiagnoser { [Benchmark] public void Sleep() => Thread.Sleep(10); } } Output Method Mean Error StdDev Methods JITted Methods Tiered JIT allocated memory Sleep 15.50 ms 0.052 ms 0.048 ms 1,102 214 221,736 B Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroJitStatsDiagnoser Sample: IntroNativeMemory The NativeMemoryProfiler uses EtwProfiler to profile the code using ETW and adds the extra columns Allocated native memory and Native memory leak to the benchmark results table. Source code using System; using System.Drawing; using System.Runtime.InteropServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnostics.Windows.Configs; namespace BenchmarkDotNet.Samples { [ShortRunJob] [NativeMemoryProfiler] [MemoryDiagnoser] public class IntroNativeMemory { [Benchmark] public void BitmapWithLeaks() { var flag = new Bitmap(200, 100); var graphics = Graphics.FromImage(flag); var blackPen = new Pen(Color.Black, 3); graphics.DrawLine(blackPen, 100, 100, 500, 100); } [Benchmark] public void Bitmap() { using (var flag = new Bitmap(200, 100)) { using (var graphics = Graphics.FromImage(flag)) { using (var blackPen = new Pen(Color.Black, 3)) { graphics.DrawLine(blackPen, 100, 100, 500, 100); } } } } private const int Size = 20; // Greater value could cause System.OutOfMemoryException for test with memory leaks. private int ArraySize = Size * Marshal.SizeOf(typeof(int)); [Benchmark] public unsafe void AllocHGlobal() { IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize); Span<byte> unmanaged = new Span<byte>(unmanagedHandle.ToPointer(), ArraySize); Marshal.FreeHGlobal(unmanagedHandle); } [Benchmark] public unsafe void AllocHGlobalWithLeaks() { IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize); Span<byte> unmanaged = new Span<byte>(unmanagedHandle.ToPointer(), ArraySize); } } } Output Method Mean Error StdDev Gen 0 Gen 1 Gen 2 Allocated Allocated native memory Native memory leak BitmapWithLeaks 73,456.43 ns 22,498.10 ns 1,233.197 ns - - - 177 B 13183 B 11615 B Bitmap 91,590.08 ns 101,468.12 ns 5,561.810 ns - - - 180 B 12624 B - AllocHGlobal 79.91 ns 43.93 ns 2.408 ns - - - - 80 B - AllocHGlobalWithLeaks 103.50 ns 153.21 ns 8.398 ns - - - - 80 B 80 B Profiling memory leaks The BenchmarkDotNet repeats benchmarking function many times. Sometimes it can cause a memory overflow. In this case, the BenchmarkDotNet shows the message: OutOfMemoryException! BenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects. If your benchmark allocates memory and keeps it alive, you are creating a memory leak. You should redesign your benchmark and remove the side-effects. You can use `OperationsPerInvoke`, `IterationSetup` and `IterationCleanup` to do that. In this case, you should try to reduce the number of invocation, by adding [ShortRunJob] attribute or using Job.Short for custom configuration. Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroNativeMemory Sample: IntroThreadingDiagnoser The ThreadingDiagnoser uses new APIs exposed in .NET Core 3.0 to report: Completed Work Items: The number of work items that have been processed in ThreadPool (per single operation) Lock Contentions: The number of times there was contention upon trying to take a Monitor's lock (per single operation) Source code using BenchmarkDotNet.Attributes; using System.Threading; namespace BenchmarkDotNet.Samples { [ThreadingDiagnoser] // ENABLE the diagnoser public class IntroThreadingDiagnoser { [Benchmark] public void CompleteOneWorkItem() { ManualResetEvent done = new ManualResetEvent(initialState: false); ThreadPool.QueueUserWorkItem(m => (m as ManualResetEvent).Set(), done); done.WaitOne(); } } } Output Method Mean StdDev Median Completed Work Items Lock Contentions CompleteOneWorkItem 8,073.5519 ns 69.7261 ns 8,111.6074 ns 1.0000 - Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroThreadingDiagnoser Sample: IntroExceptionDiagnoser The ExceptionDiagnoser uses AppDomain.FirstChanceException API to report: Exception frequency: The number of exceptions thrown during the operations divided by the number of operations. Source code using BenchmarkDotNet.Attributes; using System; namespace BenchmarkDotNet.Samples { [ExceptionDiagnoser] public class IntroExceptionDiagnoser { [Benchmark] public void ThrowExceptionRandomly() { try { if (new Random().Next(0, 5) > 1) { throw new Exception(); } } catch { // ignored } } } } Output Method Mean Error StdDev Exception frequency ThrowExceptionRandomly 4.936 us 0.1542 us 0.4499 us 0.1381 Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroExceptionDiagnoser"
  },
  "articles/configs/exporters.html": {
    "href": "articles/configs/exporters.html",
    "title": "Exporters | BenchmarkDotNet",
    "summary": "Exporters An exporter allows you to export results of your benchmark in different formats. By default, files with results will be located in .\\BenchmarkDotNet.Artifacts\\results directory, but this can be changed via the ArtifactsPath property in the IConfig. Default exporters are: csv, html and markdown. Sample: IntroExport BenchmarkDotNet has a lot of predefined exporters. Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [ShortRunJob] [MediumRunJob] [KeepBenchmarkFiles] [AsciiDocExporter] [CsvExporter] [CsvMeasurementsExporter] [HtmlExporter] [PlainExporter] [RPlotExporter] [JsonExporterAttribute.Brief] [JsonExporterAttribute.BriefCompressed] [JsonExporterAttribute.Full] [JsonExporterAttribute.FullCompressed] [MarkdownExporterAttribute.Default] [MarkdownExporterAttribute.GitHub] [MarkdownExporterAttribute.StackOverflow] [MarkdownExporterAttribute.Atlassian] [XmlExporterAttribute.Brief] [XmlExporterAttribute.BriefCompressed] [XmlExporterAttribute.Full] [XmlExporterAttribute.FullCompressed] public class IntroExport { private Random random = new Random(42); [Benchmark(Baseline = true)] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep50Noisy() => Thread.Sleep(random.Next(100)); } } Links Exporters The permanent link to this sample: BenchmarkDotNet.Samples.IntroExport Sample: IntroExportJson BenchmarkDotNet has a set of json exporters. You can customize the following properties of these exporters: fileNameSuffix: a string which be placed in the end of target file name. indentJson=false/true: should we format json or not. excludeMeasurements=false/true: should we exclude detailed information about measurements or not (the final summary with statistics will be in the json file anyway). Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Exporters.Json; namespace BenchmarkDotNet.Samples { // *** Attribute style *** [DryJob] [JsonExporterAttribute.Brief] [JsonExporterAttribute.Full] [JsonExporterAttribute.BriefCompressed] [JsonExporterAttribute.FullCompressed] [JsonExporter(\"-custom\", indentJson: true, excludeMeasurements: true)] public class IntroExportJson { [Benchmark] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep20() => Thread.Sleep(20); } // *** Object style *** [Config(typeof(Config))] public class IntroJsonExportObjectStyle { private class Config : ManualConfig { public Config() { AddExporter(JsonExporter.Brief); AddExporter(JsonExporter.Brief); AddExporter(JsonExporter.Full); AddExporter(JsonExporter.BriefCompressed); AddExporter(JsonExporter.FullCompressed); AddExporter(JsonExporter.Custom(\"-custom\", indentJson: true, excludeMeasurements: true)); } } [Benchmark] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep20() => Thread.Sleep(20); } } Output Example of IntroJsonExport-report-brief.json: { \"Title\":\"IntroJsonExport\", \"HostEnvironmentInfo\":{ \"BenchmarkDotNetCaption\":\"BenchmarkDotNet-Dev.Core\", \"BenchmarkDotNetVersion\":\"0.9.9.0\", \"OsVersion\":\"Microsoft Windows NT 6.2.9200.0\", \"ProcessorName\":{ \"IsValueCreated\":true, \"Value\":\"Intel(R) Core(TM) i7-4702MQ CPU 2.20GHz\" }, \"ProcessorCount\":8, \"ClrVersion\":\"MS.NET 4.0.30319.42000\", \"Architecture\":\"64-bit\", \"HasAttachedDebugger\":false, \"HasRyuJit\":true, \"Configuration\":\"RELEASE\", \"JitModules\":\"clrjit-v4.6.1586.0\", \"DotNetCliVersion\":\"1.0.0-preview2-003121\", \"ChronometerFrequency\":2143474, \"HardwareTimerKind\":\"Tsc\" }, \"Benchmarks\":[ { \"ShortInfo\":\"IntroJsonExport_Sleep10\", \"Namespace\":\"BenchmarkDotNet.Samples.Intro\", \"Type\":\"IntroJsonExport\", \"Method\":\"Sleep10\", \"MethodTitle\":\"Sleep10\", \"Parameters\":\"\", \"Properties\":{ \"Mode\":\"Throughput\", \"Platform\":\"Host\", \"Jit\":\"Host\", \"Runtime\":\"Host\", \"GcMode\":\"Host\", \"WarmupCount\":\"Auto\", \"IterationCount\":\"Auto\", \"LaunchCount\":\"Auto\", \"IterationTime\":\"Auto\", \"Affinity\":\"Auto\" }, \"Statistics\":{ \"N\":20, \"Min\":10265993.7209375, \"LowerFence\":10255329.082734371, \"Q1\":10337369.528437499, \"Median\":10360382.6953125, \"Mean\":10362283.085796878, \"Q3\":10392063.158906251, \"UpperFence\":10474103.60460938, \"Max\":10436008.3209375, \"InterquartileRange\":54693.630468752235, \"Outliers\":[ ], \"StandardError\":10219.304338928456, \"Variance\":2088683623.4328396, \"StandardDeviation\":45702.118369205156, \"Skewness\":-0.1242777170069375, \"Kurtosis\":2.31980277935226, \"ConfidenceInterval\":{ \"Mean\":10362283.085796878, \"Error\":10219.304338928456, \"Level\":6, \"Margin\":20029.836504299772, \"Lower\":10342253.249292579, \"Upper\":10382312.922301177 }, \"Percentiles\":{ \"P0\":10265993.7209375, \"P25\":10338555.905625, \"P50\":10360382.6953125, \"P67\":10373496.555659376, \"P80\":10400703.4841875, \"P85\":10417280.326718749, \"P90\":10424125.595812501, \"P95\":10435620.51609375, \"P100\":10436008.3209375 } } },{ \"ShortInfo\":\"IntroJsonExport_Sleep20\", \"Namespace\":\"BenchmarkDotNet.Samples.Intro\", \"Type\":\"IntroJsonExport\", \"Method\":\"Sleep20\", \"MethodTitle\":\"Sleep20\", \"Parameters\":\"\", \"Properties\":{ \"Mode\":\"Throughput\", \"Platform\":\"Host\", \"Jit\":\"Host\", \"Runtime\":\"Host\", \"GcMode\":\"Host\", \"WarmupCount\":\"Auto\", \"IterationCount\":\"Auto\", \"LaunchCount\":\"Auto\", \"IterationTime\":\"Auto\", \"Affinity\":\"Auto\" }, \"Statistics\":{ \"N\":20, \"Min\":20258672.37, \"LowerFence\":20206333.269843742, \"Q1\":20325342.761249997, \"Median\":20362636.192500003, \"Mean\":20360791.931687497, \"Q3\":20404682.4221875, \"UpperFence\":20523691.913593754, \"Max\":20422396.073125, \"InterquartileRange\":79339.66093750298, \"Outliers\":[ ], \"StandardError\":10728.817907277158, \"Variance\":2302150673.7502208, \"StandardDeviation\":47980.732317777525, \"Skewness\":-0.50826238372439869, \"Kurtosis\":2.11050327966268, \"ConfidenceInterval\":{ \"Mean\":20360791.931687497, \"Error\":10728.817907277158, \"Level\":6, \"Margin\":21028.48309826323, \"Lower\":20339763.448589232, \"Upper\":20381820.414785761 }, \"Percentiles\":{ \"P0\":20258672.37, \"P25\":20327638.975312497, \"P50\":20362636.192500003, \"P67\":20391669.3762875, \"P80\":20406370.68625, \"P85\":20412542.034406248, \"P90\":20414412.5376875, \"P95\":20416606.697718751, \"P100\":20422396.073125 } } } ] } Links Exporters The permanent link to this sample: BenchmarkDotNet.Samples.IntroExportJson Sample: IntroExportXml BenchmarkDotNet has a set of XML exporters. You can customize the following properties of these exporters: fileNameSuffix: a string which be placed in the end of target file name. indentXml=false/true: should we format xml or not. excludeMeasurements=false/true: should we exclude detailed information about measurements or not (the final summary with statistics will be in the XML file anyway). Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DryJob] [XmlExporterAttribute.Brief] [XmlExporterAttribute.Full] [XmlExporterAttribute.BriefCompressed] [XmlExporterAttribute.FullCompressed] [XmlExporter(\"-custom\", indentXml: true, excludeMeasurements: true)] public class IntroExportXml { [Benchmark] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep20() => Thread.Sleep(20); } } Output Example of IntroXmlExport-report-brief.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <Summary> <Title>IntroXmlExport</Title> <HostEnvironmentInfo> <BenchmarkDotNetCaption>BenchmarkDotNet</BenchmarkDotNetCaption> <BenchmarkDotNetVersion>0.10.9.20170805-develop</BenchmarkDotNetVersion> <OsVersion>Windows 10 Redstone 2 (10.0.15063)</OsVersion> <ProcessorName>Intel Core i7-3770K CPU 3.50GHz (Ivy Bridge)</ProcessorName> <ProcessorCount>8</ProcessorCount> <RuntimeVersion>.NET Framework 4.7 (CLR 4.0.30319.42000)</RuntimeVersion> <Architecture>64bit</Architecture> <HasAttachedDebugger>False</HasAttachedDebugger> <HasRyuJit>True</HasRyuJit> <Configuration>RELEASE</Configuration> <JitModules>clrjit-v4.7.2101.1</JitModules> <DotNetSdkVersion>1.0.4</DotNetSdkVersion> <ChronometerFrequency> <Hertz>3410220</Hertz> </ChronometerFrequency> <HardwareTimerKind>Tsc</HardwareTimerKind> </HostEnvironmentInfo> <Benchmarks> <Benchmark> <DisplayInfo>IntroXmlExport.Sleep10: DefaultJob</DisplayInfo> <Namespace>BenchmarkDotNet.Samples.Intro</Namespace> <Type>IntroXmlExport</Type> <Method>Sleep10</Method> <MethodTitle>Sleep10</MethodTitle> <Statistics> <N>15</N> <Min>10989865.8785938</Min> <LowerFence>10989836.0967969</LowerFence> <Q1>10990942.6053125</Q1> <Median>10991249.5870313</Median> <Mean>10991270.0524583</Mean> <Q3>10991680.2776563</Q3> <UpperFence>10992786.7861719</UpperFence> <Max>10992115.5501563</Max> <InterquartileRange>737.672343749553</InterquartileRange> <StandardError>148.484545262958</StandardError> <Variance>330714.902729213</Variance> <StandardDeviation>575.07817097262</StandardDeviation> <Skewness>-0.67759778074187</Skewness> <Kurtosis>3.14296703520386</Kurtosis> <ConfidenceInterval> <N>15</N> <Mean>10991270.0524583</Mean> <StandardError>148.484545262958</StandardError> <Level>L999</Level> <Margin>614.793505974065</Margin> <Lower>10990655.2589524</Lower> <Upper>10991884.8459643</Upper> </ConfidenceInterval> <Percentiles> <P0>10989865.8785938</P0> <P25>10991027.3689063</P25> <P50>10991249.5870313</P50> <P67>10991489.490875</P67> <P80>10991696.7722187</P80> <P85>10991754.5031875</P85> <P90>10991933.1939688</P90> <P95>10992067.441125</P95> <P100>10992115.5501563</P100> </Percentiles> </Statistics> </Benchmark> </Benchmarks> </Summary> Links Exporters The permanent link to this sample: BenchmarkDotNet.Samples.IntroExportXml Plots You can install R to automatically get nice plots of your benchmark results. First, make sure Rscript.exe or Rscript is in your path, or define an R_HOME environment variable pointing to the R installation directory. eg: If Rscript is located in /path/to/R/R-1.2.3/bin/Rscript, then R_HOME must point to /path/to/R/R-1.2.3/, it should not point to /path/to/R/R-1.2.3/bin Use RPlotExporter.Default and CsvMeasurementsExporter.Default in your config, and the BuildPlots.R script in your bin directory will take care of the rest. Examples: <BenchmarkName>-barplot.png <BenchmarkName>-boxplot.png <BenchmarkName>-<MethodName>-density.png <BenchmarkName>-<MethodName>-facetTimeline.png <BenchmarkName>-<MethodName>-facetTimelineSmooth.png <BenchmarkName>-<MethodName>-<JobName>-timelineSmooth.png <BenchmarkName>-<MethodName>-<JobName>-timelineSmooth.png A config example in C#: public class Config : ManualConfig { public Config() { Add(CsvMeasurementsExporter.Default); Add(RPlotExporter.Default); } } A config example in F#: module MyBenchmark open BenchmarkDotNet.Attributes open BenchmarkDotNet.Configs open BenchmarkDotNet.Exporters open BenchmarkDotNet.Exporters.Csv open MyProjectUnderTest type MyConfig() as this = inherit ManualConfig() do this.Add(CsvMeasurementsExporter.Default) this.Add(RPlotExporter.Default) [< MemoryDiagnoser; Config(typeof<MyConfig>); RPlotExporter >] type MyPerformanceTests() = let someTestData = getTestDataAsList () [<Benchmark>] member __.SomeTestCase() = someTestData |> myFunctionUnderTest CSV The CSV file format is often used to graph the output or to analyze the results programmatically. The CSV exporter may be configured to produce sanitized output, where cell values are numerals and their units are predefined. The CSV exporter and other compatible exporters may consume an instance of ISummaryStyle that defines how the output should look like: Property Remarks Default PrintUnitsInHeader If true, units will be displayed in the header row false PrintUnitsInContent If true, units will be appended to the value true TimeUnit If null, unit will be automatically selected null SizeUnit If null, unit will be automatically selected null Example of CSV exporter configured to always use microseconds, kilobytes, and to render units only in column headers: var exporter = new CsvExporter( CsvSeparator.CurrentCulture, new SummaryStyle( cultureInfo: System.Globalization.CultureInfo.CurrentCulture, printUnitsInHeader: true, printUnitsInContent: false, timeUnit: Perfolizer.Horology.TimeUnit.Microsecond, sizeUnit: SizeUnit.KB )); var config = ManualConfig.CreateMinimumViable().AddExporter(exporter); Excerpt from the resulting CSV file: Method,...,Mean [us],Error [us],StdDev [us],Min [us],Max [us],Allocated [KB] Benchmark,...,\"37,647.6\",\"32,717.9\",\"21,640.9\",\"11,209.2\",\"59,492.6\",1.58"
  },
  "articles/configs/filters.html": {
    "href": "articles/configs/filters.html",
    "title": "Filters | BenchmarkDotNet",
    "summary": "Filters Sometimes you don't want to run all of your benchmarks. In this case, you can filter some of them with the help of filters. Predefined filters: Filter Type Filters benchmarks by Console argument Console example GlobFilter Provided glob pattern filter --filter Serializer.ToStream AttributesFilter Provided attribute names attribute --attribute STAThread AllCategoriesFilter All Provided category names categories --allCategories Priority1 CoreFX AnyCategoriesFilter Any provided category names anycategories --anyCategories Json Xml SimpleFilter Provided lambda predicate - NameFilter Provided lambda predicate - UnionFilter Logical AND - DisjunctionFilter Logical OR - Sample: IntroFilters You can either use one of the predefined Filter types or create a custom type which implements IFilter interface. Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Filters; namespace BenchmarkDotNet.Samples { [DryJob] [Config(typeof(Config))] public class IntroFilters { private class Config : ManualConfig { // We will benchmark ONLY method with // names (which contains \"A\" OR \"1\") AND (have length < 3) public Config() { // benchmark with names which contains \"A\" OR \"1\" AddFilter(new DisjunctionFilter( new NameFilter(name => name.Contains(\"A\")), new NameFilter(name => name.Contains(\"1\")) )); // benchmark with names with length < 3 AddFilter(new NameFilter(name => name.Length < 3)); } } [Benchmark] public void A1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void A2() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void A3() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void B1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void B2() => Thread.Sleep(10); [Benchmark] public void B3() => Thread.Sleep(10); [Benchmark] public void C1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void C2() => Thread.Sleep(10); [Benchmark] public void C3() => Thread.Sleep(10); [Benchmark] public void Aaa() => Thread.Sleep(10); } } Links Filters The permanent link to this sample: BenchmarkDotNet.Samples.IntroFilters Sample: IntroCategories Combined together with [BenchmarkCategory] attribute, you can group the benchmarks into categories and filter them by categories. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DryJob] [CategoriesColumn] [BenchmarkCategory(\"Awesome\")] [AnyCategoriesFilter(\"A\", \"1\")] public class IntroCategories { [Benchmark] [BenchmarkCategory(\"A\", \"1\")] public void A1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] [BenchmarkCategory(\"A\", \"2\")] public void A2() => Thread.Sleep(10); // Will be benchmarked [Benchmark] [BenchmarkCategory(\"B\", \"1\")] public void B1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] [BenchmarkCategory(\"B\", \"2\")] public void B2() => Thread.Sleep(10); } } Command line examples: --allCategories=A,B --anyCategories=A,B Links Filters The permanent link to this sample: BenchmarkDotNet.Samples.IntroCategories Sample: IntroJoin If you are using BenchmarkSwitcher and want to run all the benchmarks with a category from all types and join them into one summary table, use the --join option (or BenchmarkSwitcher.RunAllJoined): Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { // Run BenchmarkSwitcher with arguments: \"--join --category=IntroJoinA\" [DryJob] public class IntroJoin1 { [Benchmark] [BenchmarkCategory(\"IntroJoinA\")] public void A() => Thread.Sleep(10); [Benchmark] [BenchmarkCategory(\"IntroJoinB\")] public void B() => Thread.Sleep(10); } [DryJob] public class IntroJoin2 { [Benchmark] [BenchmarkCategory(\"IntroJoinA\")] public void A() => Thread.Sleep(10); [Benchmark] [BenchmarkCategory(\"IntroJoinB\")] public void B() => Thread.Sleep(10); } } Command line --join --allCategories=IntroJoinA Output | Type | Method | Mean | Error | |----------- |------- |---------:|------:| | IntroJoin1 | A | 10.99 ms | NA | | IntroJoin2 | A | 12.50 ms | NA | Links Filters The permanent link to this sample: BenchmarkDotNet.Samples.IntroJoin"
  },
  "articles/configs/jobs.html": {
    "href": "articles/configs/jobs.html",
    "title": "Jobs | BenchmarkDotNet",
    "summary": "Jobs Basically, a job describes how to run your benchmark. Practically, it's a set of characteristics which can be specified. You can specify one or several jobs for your benchmarks. Characteristics There are several categories of characteristics which you can specify. Let's consider each category in detail. Id It's a single string characteristic. It allows to name your job. This name will be used in logs and a part of a folder name with generated files for this job. Id doesn't affect benchmark results, but it can be useful for diagnostics. If you don't specify Id, random value will be chosen based on other characteristics Environment Environment specifies an environment of the job. You can specify the following characteristics: Platform: x86 or x64 Runtime: Clr: Full .NET Framework (available only on Windows) Core: CoreCLR (x-plat) Mono: Mono (x-plat) Jit: LegacyJit (available only for Runtime.Clr) RyuJit (available only for Runtime.Clr and Runtime.Core) Llvm (available only for Runtime.Mono) Affinity: Affinity of a benchmark process GcMode: settings of Garbage Collector Server: true (Server mode) or false (Workstation mode) Concurrent: true (Concurrent mode) or false (NonConcurrent mode) CpuGroups: Specifies whether garbage collection supports multiple CPU groups Force: Specifies whether the BenchmarkDotNet's benchmark runner forces full garbage collection after each benchmark invocation AllowVeryLargeObjects: On 64-bit platforms, enables arrays that are greater than 2 gigabytes (GB) in total size LargeAddressAware: Specifies that benchmark can handle addresses larger than 2 gigabytes. See also: Sample: IntroLargeAddressAware and LARGEADDRESSAWARE false: Benchmark uses the defaults (64-bit: enabled; 32-bit: disabled). true: Explicitly specify that benchmark can handle addresses larger than 2 gigabytes. EnvironmentVariables: customized environment variables for target benchmark. See also: BenchmarkDotNet.Samples.IntroEnvVars BenchmarkDotNet will use host process environment characteristics for non specified values. Run In this category, you can specify how to benchmark each method. RunStrategy: Throughput: default strategy which allows to get good precision level ColdStart: should be used only for measuring cold start of the application or testing purpose Monitoring: A mode without overhead evaluating, with several target iterations LaunchCount: how many times we should launch process with target benchmark WarmupCount: how many warmup iterations should be performed IterationCount: how many target iterations should be performed (if specified, BenchmarkDotNet.Jobs.RunMode.MinIterationCount and BenchmarkDotNet.Jobs.RunMode.MaxIterationCount will be ignored) IterationTime: desired time of a single iteration UnrollFactor: how many times the benchmark method will be invoked per one iteration of a generated loop InvocationCount: count of invocation in a single iteration (if specified, IterationTime will be ignored), must be a multiple of UnrollFactor MinIterationCount: Minimum count of target iterations that should be performed, the default value is 15 MaxIterationCount: Maximum count of target iterations that should be performed, the default value is 100 MinWarmupIterationCount: Minimum count of warmup iterations that should be performed, the default value is 6 MaxWarmupIterationCount: Maximum count of warmup iterations that should be performed, the default value is 50 Usually, you shouldn't specify such characteristics like LaunchCount, WarmupCount, IterationCount, or IterationTime because BenchmarkDotNet has a smart algorithm to choose these values automatically based on received measurements. You can specify it for testing purposes or when you are damn sure that you know the right characteristics for your benchmark (when you set IterationCount = 20 you should understand why 20 is a good value for your case). Accuracy If you want to change the accuracy level, you should use the following characteristics instead of manually adjusting values of WarmupCount, IterationCount, and so on. MaxRelativeError, MaxAbsoluteError: Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error). In these two characteristics, the error means half of 99.9% confidence interval. MaxAbsoluteError is an absolute TimeInterval; doesn't have a default value. MaxRelativeError defines max acceptable ((<half of CI 99.9%>) / Mean). MinIterationTime: Minimum time of a single iteration. Unlike Run.IterationTime, this characteristic specifies only the lower limit. In case of need, BenchmarkDotNet can increase this value. MinInvokeCount: Minimum about of target method invocation. Default value if 4 but you can decrease this value for cases when single invocations takes a lot of time. EvaluateOverhead: if your benchmark method takes nanoseconds, BenchmarkDotNet overhead can significantly affect measurements. If this characteristic is enabled, the overhead will be evaluated and subtracted from the result measurements. Default value is true. WithOutlierMode: sometimes you could have outliers in your measurements. Usually these are unexpected outliers which arose because of other processes activities. By default (OutlierMode.RemoveUpper), all upper outliers (which is larger than Q3) will be removed from the result measurements. However, some of benchmarks have expected outliers. In these situation, you expect that some of invocation can produce outliers measurements (e.g. in case of network activities, cache operations, and so on). If you want to see result statistics with these outliers, you should use OutlierMode.DontRemove. If you can also choose OutlierMode.RemoveLower (outliers which are smaller than Q1 will be removed) or OutlierMode.RemoveAll (all outliers will be removed). See also: @BenchmarkDotNet.Mathematics.OutlierMode AnalyzeLaunchVariance: this characteristic makes sense only if Run.LaunchCount is default. If this mode is enabled and, BenchmarkDotNet will try to perform several launches and detect if there is a variance between launches. If this mode is disable, only one launch will be performed. Infrastructure Usually, you shouldn't specify any characteristics from this section, it can be used for advanced cases only. Toolchain: a toolchain which generates source code for target benchmark methods, builds it, and executes it. BenchmarkDotNet has own toolchains for .NET, .NET Core, Mono and CoreRT projects. If you want, you can define own toolchain. Clock: a clock which will be used for measurements. BenchmarkDotNet automatically choose the best available clock source, but you can specify own clock source. EngineFactory: a provider for measurement engine which performs all the measurement magic. If you don't trust BenchmarkDotNet, you can define own engine and implement all the measurement stages manually. Usage There are several ways to specify a job. Object style You can create own jobs directly from the source code via a custom config: [Config(typeof(Config))] public class MyBenchmarks { private class Config : ManualConfig { public Config() { AddJob( new Job(\"MySuperJob\", RunMode.Dry, EnvironmentMode.RyuJitX64) { Environment = { Runtime = CoreRuntime.Core90 }, Run = { LaunchCount = 5, IterationTime = TimeInterval.Millisecond * 200 }, Accuracy = { MaxRelativeError = 0.01 } }); // The same, using the .With() factory methods: AddJob( Job.Dry .WithPlatform(Platform.X64) .WithJit(Jit.RyuJit) .WithRuntime(CoreRuntime.Core90) .WithLaunchCount(5) .WithIterationTime(TimeInterval.Millisecond * 200) .WithMaxRelativeError(0.01) .WithId(\"MySuperJob\")); } } // Benchmarks } Basically, it's a good idea to start with predefined values (e.g. EnvironmentMode.RyuJitX64 and RunMode.Dry passed as constructor args) and modify rest of the properties using property setters or with help of object initializer syntax. Note that the job cannot be modified after it's added into config. Trying to set a value on property of the frozen job will throw an InvalidOperationException. Use the Job.Frozen property to determine if the code properties can be altered. If you do want to create a new job based on frozen one (all predefined job values are frozen) you can use the .With() extension method var newJob = Job.Dry.WithPlatform(Platform.X64); or pass the frozen value as a constructor argument var newJob = new Job(Job.Dry) { Environment = { Platform = Platform.X64 } }; or use the .Apply() method on unfrozen job var newJob = new Job() { Environment = { Platform = Platform.X64 } }.Apply(Job.Dry); in any case the Id property will not be transfered and you must pass it explicitly (using the .ctor id argument or the .WithId() extension method). Attribute style You can also add new jobs via attributes. Examples: [DryJob] [MonoJob] [SimpleJob(RuntimeMoniker.Net90)] [SimpleJob(RuntimeMoniker.NetCoreApp31)] [LegacyJitX86Job, LegacyJitX64Job, RyuJitX64Job] [SimpleJob(RunStrategy.ColdStart, launchCount: 1, warmupCount: 5, iterationCount: 5, id: \"FastAndDirtyJob\")] public class MyBenchmarkClass Note that each of the attributes identifies a separate job, the sample above will result in 8 different jobs, not a single merged job. Attribute style for merging jobs Sometimes you want to apply some changes to other jobs, without adding a new job to a config (which results in one extra benchmark run). To do that you can use following predefined job mutator attributes: [EvaluateOverhead] [GcConcurrent] [GcForce] [GcServer] [InnerIterationCount] [InvocationCount] [IterationCount] [IterationTime] [MaxAbsoluteError] [MaxIterationCount] [MaxRelativeError] [MinInvokeCount] [MinIterationCount] [MinIterationTime] [Outliers] [ProcessCount] [RunOncePerIteration] [WarmupCount] [MinWarmupCount] [MaxWarmupCount] So following example: [ClrJob, CoreJob] [GcServer(true)] public class MyBenchmarkClass Is going to be merged to a config with two jobs: CoreJob with GcServer=true ClrJob with GcServer=true Custom attributes You can also create your own custom attributes with your favourite set of jobs. Example: [AttributeUsage(AttributeTargets.Class | AttributeTargets.Assembly)] public class MySuperJobAttribute : Attribute, IConfigSource { protected MySuperJobAttribute() { var job = new Job(\"MySuperJob\", RunMode.Core); job.Env.Platform = Platform.X64; Config = ManualConfig.CreateEmpty().AddJob(job); } public IConfig Config { get; } } [MySuperJob] public class MyBenchmarks Sample: IntroGcMode Source code using System.Runtime.CompilerServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Order; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [MemoryDiagnoser] public class IntroGcMode { private class Config : ManualConfig { public Config() { AddJob(Job.MediumRun.WithGcServer(true).WithGcForce(true).WithId(\"ServerForce\")); AddJob(Job.MediumRun.WithGcServer(true).WithGcForce(false).WithId(\"Server\")); AddJob(Job.MediumRun.WithGcServer(false).WithGcForce(true).WithId(\"Workstation\")); AddJob(Job.MediumRun.WithGcServer(false).WithGcForce(false).WithId(\"WorkstationForce\")); } } [Benchmark(Description = \"new byte[10kB]\")] public byte[] Allocate() { return new byte[10000]; } [Benchmark(Description = \"stackalloc byte[10kB]\")] public unsafe void AllocateWithStackalloc() { var array = stackalloc byte[10000]; Consume(array); } [MethodImpl(MethodImplOptions.NoInlining)] private static unsafe void Consume(byte* input) { } } } Output Links Jobs The permanent link to this sample: BenchmarkDotNet.Samples.IntroGcMode"
  },
  "articles/configs/loggers.html": {
    "href": "articles/configs/loggers.html",
    "title": "Loggers | BenchmarkDotNet",
    "summary": "Loggers A logger allows you to log results of your benchmark. By default, you can see log on console and in a file (<BenchmarkName>.log)."
  },
  "articles/configs/orderers.html": {
    "href": "articles/configs/orderers.html",
    "title": "Orderers | BenchmarkDotNet",
    "summary": "Orderers Orderers allows customizing the order of benchmark results in the summary table. Sample: IntroOrderAttr Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Order; namespace BenchmarkDotNet.Samples { [Orderer(SummaryOrderPolicy.FastestToSlowest, MethodOrderPolicy.Declared)] [DryJob] public class IntroOrderAttr { [Params(1, 2, 3)] public int X { get; set; } [Benchmark] public void Slow() => Thread.Sleep(X * 100); [Benchmark] public void Fast() => Thread.Sleep(X * 50); } } Links Orderers The permanent link to this sample: BenchmarkDotNet.Samples.IntroOrderAttr Sample: IntroOrderManual Source code using System.Collections.Generic; using System.Collections.Immutable; using System.Linq; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Order; using BenchmarkDotNet.Reports; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [DryJob] [RankColumn] public class IntroOrderManual { private class Config : ManualConfig { public Config() => Orderer = new FastestToSlowestOrderer(); private class FastestToSlowestOrderer : IOrderer { public IEnumerable<BenchmarkCase> GetExecutionOrder(ImmutableArray<BenchmarkCase> benchmarksCase, IEnumerable<BenchmarkLogicalGroupRule>? order = null) => from benchmark in benchmarksCase orderby benchmark.Parameters[\"X\"] descending, benchmark.Descriptor.WorkloadMethodDisplayInfo select benchmark; public IEnumerable<BenchmarkCase> GetSummaryOrder(ImmutableArray<BenchmarkCase> benchmarksCase, Summary summary) => from benchmark in benchmarksCase orderby summary[benchmark].ResultStatistics.Mean select benchmark; public string GetHighlightGroupKey(BenchmarkCase benchmarkCase) => null; public string GetLogicalGroupKey(ImmutableArray<BenchmarkCase> allBenchmarksCases, BenchmarkCase benchmarkCase) => benchmarkCase.Job.DisplayInfo + \"_\" + benchmarkCase.Parameters.DisplayInfo; public IEnumerable<IGrouping<string, BenchmarkCase>> GetLogicalGroupOrder(IEnumerable<IGrouping<string, BenchmarkCase>> logicalGroups, IEnumerable<BenchmarkLogicalGroupRule>? order = null) => logicalGroups.OrderBy(it => it.Key); public bool SeparateLogicalGroups => true; } } [Params(1, 2, 3)] public int X { get; set; } [Benchmark] public void Fast() => Thread.Sleep(X * 50); [Benchmark] public void Slow() => Thread.Sleep(X * 100); } } Links Orderers The permanent link to this sample: BenchmarkDotNet.Samples.IntroOrderManual"
  },
  "articles/configs/powerplans.html": {
    "href": "articles/configs/powerplans.html",
    "title": "Power Plans | BenchmarkDotNet",
    "summary": "Power Plans BenchmarkDotNet forces Windows OS to execute on the High-Performance power plan. You can disable this feature by modify PowerPlanMode property. You can see it in the BenchmarkDotNet.Samples.IntroPowerPlan. Please note. During an execution, BenchmarkDotNet saves the current power plan and applies it according to the PowerPlanMode property. When all of the benchmarks finish, a previous power plan comes back. However, if someone killed process or energy was plugged off, we could stay with the High-Performance power plan. In this situation, we should return it manually in Windows Control Panel or by powercfg command. Links Power policy settings: https://learn.microsoft.com/windows/win32/power/power-policy-settings Powercfg command: https://learn.microsoft.com/windows-hardware/design/device-experiences/powercfg-command-line-options BenchmarkDotNet.Samples.IntroPowerPlan"
  },
  "articles/configs/toolchains.html": {
    "href": "articles/configs/toolchains.html",
    "title": "Toolchains | BenchmarkDotNet",
    "summary": "Toolchains To achieve process-level isolation, BenchmarkDotNet generates, builds and executes a new console app per every benchmark. A toolchain contains generator, builder, and executor. When you run your benchmarks without specifying the toolchain in an explicit way, the default one is used: Roslyn for Full .NET Framework and Mono dotnet cli for .NET Core and NativeAOT Multiple frameworks support If you want to test multiple frameworks, your project file MUST target all of them and you MUST install the corresponding SDKs: <TargetFrameworks>netcoreapp3.1;net8.0;net48</TargetFrameworks> If you run your benchmarks without specifying any custom settings, BenchmarkDotNet is going to run the benchmarks using the same framework as the host process: dotnet run -c Release -f netcoreapp3.1 # is going to run the benchmarks using .NET Core 3.1 dotnet run -c Release -f net8.0 # is going to run the benchmarks using .NET 8.0 dotnet run -c Release -f net48 # is going to run the benchmarks using .NET 4.8 mono $pathToExe # is going to run the benchmarks using Mono from your PATH To run the benchmarks for multiple runtimes with a single command, you need to specify the target framework moniker names via --runtimes|-r console argument: dotnet run -c Release -f net8.0 --runtimes net8.0 netcoreapp3.1 # is going to run the benchmarks using .NET 8.0 and .NET Core 3.1 dotnet run -c Release -f net8.0 --runtimes net8.0 net48 # is going to run the benchmarks using .NET 8.0 and .NET 4.8 What is going to happen if you provide multiple Full .NET Framework monikers? Let's say: dotnet run -c Release -f net461 net472 net48 Full .NET Framework always runs every .NET executable using the latest .NET Framework available on a given machine. If you try to run the benchmarks for a few .NET TFMs, they are all going to be executed using the latest .NET Framework from your machine. The only difference is that they are all going to have different features enabled depending on target version they were compiled for. You can read more about this here and here. This is .NET Framework behavior which can not be controlled by BenchmarkDotNet or any other tool. Note: Console arguments support works only if you pass the args to BenchmarkSwitcher: class Program { static void Main(string[] args) => BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args); // crucial to make it work } You can achieve the same thing using [SimpleJobAttribute]: using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [SimpleJob(RuntimeMoniker.Net48)] [SimpleJob(RuntimeMoniker.Mono)] [SimpleJob(RuntimeMoniker.NetCoreApp31)] [SimpleJob(RuntimeMoniker.Net80)] public class TheClassWithBenchmarks Or using a custom config: using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { class Program { static void Main(string[] args) { var config = DefaultConfig.Instance .AddJob(Job.Default.WithRuntime(CoreRuntime.Core80)) .AddJob(Job.Default.WithRuntime(ClrRuntime.Net48)) .AddJob(Job.Default.WithRuntime(MonoRuntime.Default)); BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args, config); } } } The recommended way of running the benchmarks for multiple runtimes is to use the --runtimes console line argument. By using the console line argument you don't need to edit the source code anytime you want to change the list of runtimes. Moreover, if you share the source code of the benchmark other people can run it even if they don't have the exact same framework version installed. Custom .NET Core Runtime We can run your benchmarks for custom <RuntimeFrameworkVersion> if you want. All you need to do is to create custom toolchain by calling CsProjCoreToolchain.From method, which accepts NetCoreAppSettings. public class MyConfig : ManualConfig { public MyConfig() { Add(Job.Default.With( CsProjCoreToolchain.From( new NetCoreAppSettings( targetFrameworkMoniker: \"net8.0-windows\", runtimeFrameworkVersion: \"8.0.101\", name: \".NET 8.0 Windows\")))); } } Custom .NET Runtime It's possible to benchmark a private build of .NET Runtime. All you need to do is to define a job with the right version of ClrRuntime. BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args, DefaultConfig.Instance.AddJob( Job.ShortRun.WithRuntime(ClrRuntime.CreateForLocalFullNetFrameworkBuild(version: \"4.0\")))); This sends the provided version as a COMPLUS_Version env var to the benchmarked process. Custom dotnet cli path We internally use dotnet cli to build and run .NET Core executables. Sometimes it might be mandatory to use non-default dotnet cli path. An example scenario could be a comparison of RyuJit 32bit vs 64 bit. It required due this limitation of dotnet cli public class CustomPathsConfig : ManualConfig { public CustomPathsConfig() { var dotnetCli32bit = NetCoreAppSettings .NetCoreApp31 .WithCustomDotNetCliPath(@\"C:\\Program Files (x86)\\dotnet\\dotnet.exe\", \"32 bit cli\"); var dotnetCli64bit = NetCoreAppSettings .NetCoreApp31 .WithCustomDotNetCliPath(@\"C:\\Program Files\\dotnet\\dotnet.exe\", \"64 bit cli\"); AddJob(Job.RyuJitX86.WithToolchain(CsProjCoreToolchain.From(dotnetCli32bit)).WithId(\"32 bit cli\")); AddJob(Job.RyuJitX64.WithToolchain(CsProjCoreToolchain.From(dotnetCli64bit)).WithId(\"64 bit cli\")); } } BenchmarkDotNet=v0.10.9.20170910-develop, OS=Windows 10 Redstone 1 (10.0.14393) Processor=Intel Core i7-6600U CPU 2.60GHz (Skylake), ProcessorCount=4 Frequency=2742185 Hz, Resolution=364.6727 ns, Timer=TSC .NET Core SDK=2.1.0-preview1-007074 [Host] : .NET Core 2.0.0 (Framework 4.6.00001.0), 64bit RyuJIT 32 bit cli : .NET Core 2.0.0 (Framework 4.6.00001.0), 32bit RyuJIT 64 bit cli : .NET Core 2.0.0 (Framework 4.6.00001.0), 64bit RyuJIT Jit=RyuJit This feature is now also exposed with the --cli console argument. Example: dotnet run -c Release -- --cli \"C:\\Projects\\machinelearning\\Tools\\dotnetcli\\dotnet.exe\" CoreRun To use CoreRun for running the benchmarks you need to use --coreRun command line argument. You can combine it with --cli described above. This is most probably the easiest and most reliable way of running benchmarks against local CoreFX/CoreCLR builds. Example: dotnet run -c Release -- --coreRun \"C:\\Projects\\corefx\\bin\\testhost\\netcoreapp-Windows_NT-Release-x64\\shared\\Microsoft.NETCore.App\\9.9.9\\CoreRun.exe\" Sample: IntroInProcess InProcessEmitToolchain is our toolchain which does not generate any new executable. It emits IL on the fly and runs it from within the process itself. It can be useful if want to run the benchmarks very fast or if you want to run them for framework which we don't support. An example could be a local build of CoreCLR. Usage [InProcessAttribute] public class TypeWithBenchmarks { } Source code using System.Runtime.CompilerServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Order; using BenchmarkDotNet.Toolchains.InProcess.Emit; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [MemoryDiagnoser] public class IntroInProcess { private class Config : ManualConfig { public Config() { AddJob(Job.MediumRun .WithLaunchCount(1) .WithId(\"OutOfProc\")); AddJob(Job.MediumRun .WithLaunchCount(1) .WithToolchain(InProcessEmitToolchain.Instance) .WithId(\"InProcess\")); } } [Benchmark(Description = \"new byte[10kB]\")] public byte[] Allocate() { return new byte[10000]; } [Benchmark(Description = \"stackalloc byte[10kB]\")] public unsafe void AllocateWithStackalloc() { var array = stackalloc byte[10000]; Consume(array); } [MethodImpl(MethodImplOptions.NoInlining)] private static unsafe void Consume(byte* input) { } } } Output Links Toolchains The permanent link to this sample: BenchmarkDotNet.Samples.IntroInProcess Sample: IntroInProcessWrongEnv Source code using System; using System.Runtime.CompilerServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Order; using BenchmarkDotNet.Toolchains.InProcess; using BenchmarkDotNet.Toolchains.InProcess.Emit; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [MemoryDiagnoser] public class IntroInProcessWrongEnv { private class Config : ManualConfig { public Config() { var wrongPlatform = Environment.Is64BitProcess ? Platform.X64 : Platform.X86; AddJob(Job.MediumRun .WithLaunchCount(1) .WithPlatform(wrongPlatform) .WithToolchain(InProcessEmitToolchain.Instance) .WithId(\"InProcess\")); AddValidator(InProcessValidator.DontFailOnError); } } [Benchmark(Description = \"new byte[10kB]\")] public byte[] Allocate() { return new byte[10000]; } [Benchmark(Description = \"stackalloc byte[10kB]\")] public unsafe void AllocateWithStackalloc() { var array = stackalloc byte[10000]; Consume(array); } [MethodImpl(MethodImplOptions.NoInlining)] private static unsafe void Consume(byte* input) { } } } Output Links Toolchains The permanent link to this sample: BenchmarkDotNet.Samples.IntroInProcessWrongEnv NativeAOT BenchmarkDotNet supports NativeAOT! However, you might want to know how it works to get a better understanding of the results that you get. As every AOT solution, NativeAOT has some limitations like limited reflection support or lack of dynamic assembly loading. Because of that, the host process (what you run from command line) is never an AOT process, but just a regular .NET process. This process (called Host process) uses reflection to read benchmarks metadata (find all [Benchmark] methods etc), generates a new project that references the benchmarks and compiles it using ILCompiler. Such compilation produces a native executable, which is later started by the Host process. This process (called Benchmark or Child process) performs the actual benchmarking and reports the results back to the Host process. By default BenchmarkDotNet uses the latest version of Microsoft.DotNet.ILCompiler to build the NativeAOT benchmark according to this instructions. This is why you need to: install pre-requisites required by NativeAOT compiler target .NET to be able to run NativeAOT benchmarks (example: <TargetFramework>net7.0</TargetFramework> in the .csproj file) run the app as a .NET process (example: dotnet run -c Release -f net7.0). specify the NativeAOT runtime in an explicit way, either by using console line arguments --runtimes nativeaot7.0 (the recommended approach), or by using[SimpleJob] attribute or by using the fluent Job config API Job.ShortRun.With(NativeAotRuntime.Net70): dotnet run -c Release -f net7.0 --runtimes nativeaot7.0 or: var config = DefaultConfig.Instance .AddJob(Job.Default.WithRuntime(NativeAotRuntime.Net70)); // compiles the benchmarks as net7.0 and uses the latest NativeAOT to build a native app BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args, config); or: [SimpleJob(RuntimeMoniker.NativeAot70)] // compiles the benchmarks as net7.0 and uses the latest NativeAOT to build a native app public class TheTypeWithBenchmarks { [Benchmark] // the benchmarks go here } Customization If you want to benchmark some particular version of NativeAOT (or from a different NuGet feed) you have to specify it in an explicit way: var config = DefaultConfig.Instance .AddJob(Job.ShortRun .WithToolchain(NativeAotToolchain.CreateBuilder() .UseNuGet( microsoftDotNetILCompilerVersion: \"7.0.0-*\", // the version goes here nuGetFeedUrl: \"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet7/nuget/v3/index.json\") // this address might change over time .DisplayName(\"NativeAOT NuGet\") .TargetFrameworkMoniker(\"net7.0\") .ToToolchain())); The builder allows to configure more settings: specify packages restore path by using PackagesRestorePath($path) rooting all application assemblies by using RootAllApplicationAssemblies($bool). This is disabled by default. generating complete type metadata by using IlcGenerateCompleteTypeMetadata($bool). This option is enabled by default. generating stack trace metadata by using IlcGenerateStackTraceData($bool). This option is enabled by default. set optimization preference by using IlcOptimizationPreference($value). The default is Speed, you can configure it to Size or nothing set instruction set for the target OS, architecture and hardware by using IlcInstructionSet($value). By default BDN recognizes most of the instruction sets on your machine and enables them. BenchmarkDotNet supports rd.xml files. To get given file respected by BenchmarkDotNet you need to place it in the same folder as the project that defines benchmarks and name it rd.xml or in case of multiple files give them .rd.xml extension. The alternative to rd.xml files is annotating types with DynamicallyAccessedMembers attribute. If given benchmark is not supported by NativeAOT, you need to apply [AotFilter] attribute for it. Example: [Benchmark] [AotFilter(\"Not supported by design.\")] public object CreateInstanceNames() => System.Activator.CreateInstance(_assemblyName, _typeName); Generated files By default BenchmarkDotNet removes the generates files after finishing the run. To keep them on the disk you need to pass --keepFiles true command line argument or apply [KeepBenchmarkFiles] attribute to the class which defines benchmark(s). Then, read the folder from the tool output. In the example below it's D:\\projects\\performance\\artifacts\\bin\\MicroBenchmarks\\Release\\net7.0\\Job-KRLVKQ: // ***** Building 1 exe(s) in Parallel: Start ***** // start dotnet restore -r win-x64 /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in D:\\projects\\performance\\artifacts\\bin\\MicroBenchmarks\\Release\\net7.0\\Job-KRLVKQ // command took 2.74s and exited with 0 // start dotnet build -c Release -r win-x64 --no-restore /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in D:\\projects\\performance\\artifacts\\bin\\MicroBenchmarks\\Release\\net7.0\\Job-KRLVKQ // command took 3.82s and exited with 0 If you go to D:\\projects\\performance\\artifacts\\bin\\MicroBenchmarks\\Release\\net7.0\\Job-KRLVKQ, you can see the generated project file (named BenchmarkDotNet.Autogenerated.csproj), code (file name ends with .notcs) and find the native executable (in the bin\\**\\native subfolder). Example: cd D:\\projects\\performance\\artifacts\\bin\\MicroBenchmarks\\Release\\net7.0\\Job-KRLVKQ cat .\\BenchmarkDotNet.Autogenerated.csproj <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <ImportDirectoryBuildProps>false</ImportDirectoryBuildProps> <ImportDirectoryBuildTargets>false</ImportDirectoryBuildTargets> <OutputType>Exe</OutputType> <TargetFramework>net7.0</TargetFramework> <RuntimeIdentifier>win-x64</RuntimeIdentifier> <RuntimeFrameworkVersion></RuntimeFrameworkVersion> <AssemblyName>Job-KRLVKQ</AssemblyName> <AssemblyTitle>Job-KRLVKQ</AssemblyTitle> <AllowUnsafeBlocks>true</AllowUnsafeBlocks> <PlatformTarget>x64</PlatformTarget> <TreatWarningsAsErrors>False</TreatWarningsAsErrors> <DebugSymbols>false</DebugSymbols> <UseSharedCompilation>false</UseSharedCompilation> <Deterministic>true</Deterministic> <RunAnalyzers>false</RunAnalyzers> <IlcOptimizationPreference>Speed</IlcOptimizationPreference> <TrimMode>link</TrimMode><TrimmerDefaultAction>link</TrimmerDefaultAction> <IlcGenerateCompleteTypeMetadata>True</IlcGenerateCompleteTypeMetadata> <IlcGenerateStackTraceData>True</IlcGenerateStackTraceData> <EnsureNETCoreAppRuntime>false</EnsureNETCoreAppRuntime> <ValidateExecutableReferencesMatchSelfContained>false</ValidateExecutableReferencesMatchSelfContained> </PropertyGroup> <PropertyGroup> <ServerGarbageCollection>false</ServerGarbageCollection> <ConcurrentGarbageCollection>true</ConcurrentGarbageCollection> </PropertyGroup> <ItemGroup> <Compile Include=\"Job-KRLVKQ.notcs\" Exclude=\"bin\\**;obj\\**;**\\*.xproj;packages\\**\" /> </ItemGroup> <ItemGroup> <PackageReference Include=\"Microsoft.DotNet.ILCompiler\" Version=\"7.0.0-*\" /> <ProjectReference Include=\"D:\\projects\\performance\\src\\benchmarks\\micro\\MicroBenchmarks.csproj\" /> </ItemGroup> <ItemGroup> <RdXmlFile Include=\"bdn_generated.rd.xml\" /> </ItemGroup> <ItemGroup> <IlcArg Include=\"--instructionset:base,sse,sse2,sse3,sse4.1,sse4.2,avx,avx2,aes,bmi,bmi2,fma,lzcnt,pclmul,popcnt\" /> </ItemGroup> </Project> Compiling source to native code using the ILCompiler you built If you are a NativeAOT contributor and you want to benchmark your local build of NativeAOT you have to provide necessary info (path to shipping packages). You can do that from command line: dotnet run -c Release -f net7.0 --runtimes nativeaot7.0 --ilcPackages D:\\projects\\runtime\\artifacts\\packages\\Release\\Shipping\\ or explicitly in the code: var config = DefaultConfig.Instance .AddJob(Job.ShortRun .WithToolchain(NativeAotToolchain.CreateBuilder() .UseLocalBuild(@\"C:\\Projects\\runtime\\artifacts\\packages\\Release\\Shipping\\\") .DisplayName(\"NativeAOT local build\") .TargetFrameworkMoniker(\"net7.0\") .ToToolchain())); BenchmarkDotNet is going to follow these instructrions to get it working for you. Note: BenchmarkDotNet is going to run dotnet restore on the auto-generated project and restore the packages to a temporary folder. It might take some time, but the next time you rebuild dotnet/runtime repo and run the same command BenchmarkDotNet is going to use the new ILCompiler package. Wasm BenchmarkDotNet supports Web Assembly on Unix! However, currently you need to build the dotnet runtime yourself to be able to run the benchmarks. For up-to-date docs, you should visit dotnet/runtime repository. The docs below are specific to Ubuntu 18.04 at the moment of writing this document (16/07/2020). Firs of all, you need to install.... npm 10+: curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash - sudo apt install nodejs After this, you need to install jsvu: npm install jsvu -g Add it to PATH: export PATH=\"${HOME}/.jsvu:${PATH}\" And use it to install V8, JavaScriptCore and SpiderMonkey: jsvu --os=linux64 --engines=javascriptcore,spidermonkey,v8 Now you need to install Emscripten: git clone https://github.com/emscripten-core/emsdk.git cd emsdk ./emsdk install latest ./emsdk activate latest source ./emsdk_env.sh The last thing before cloning dotnet/runtime repository is creation of EMSDK_PATH env var used by Mono build scripts: export EMSDK_PATH=$EMSDK Now you need to clone dotnet/runtime repository: git clone https://github.com/dotnet/runtime cd runtime Install all Mono prerequisites: sudo apt-get install cmake llvm-9 clang-9 autoconf automake libtool build-essential python curl git lldb-6.0 liblldb-6.0-dev libunwind8 libunwind8-dev gettext libicu-dev liblttng-ust-dev libssl-dev libnuma-dev libkrb5-dev zlib1g-dev And FINALLY build Mono Runtime with Web Assembly support: ./build.sh --arch wasm --os Browser -c release And that you have .NET 5 feed added to your nuget.config file: <add key=\"dotnet5\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5/nuget/v3/index.json\" /> Now you should be able to run the Wasm benchmarks! Sample: IntroWasm WasmToolchain uses a local Mono Runtime build to run the benchmarks compiled as WebAssembly using V8 JavaScript Engine. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; using BenchmarkDotNet.Toolchains; using BenchmarkDotNet.Toolchains.DotNetCli; using BenchmarkDotNet.Toolchains.MonoWasm; namespace BenchmarkDotNet.Samples { // *** Command Line Arguments *** public class IntroWasmCmdConfig { // the args must contain: // an information that we want to run benchmark as Wasm: // --runtimes Wasm // path to dotnet cli // --cli /home/adam/projects/runtime/dotnet.sh public static void Run(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(IntroWasmCmdConfig).Assembly).Run(args); [Benchmark] public void Foo() { // Benchmark body } } // *** Fluent Config *** public class IntroWasmFluentConfig { public static void Run() { // the Wasm Toolchain requires two mandatory arguments: const string cliPath = @\"/home/adam/projects/runtime/dotnet.sh\"; WasmRuntime runtime = new WasmRuntime(msBuildMoniker: \"net5.0\"); NetCoreAppSettings netCoreAppSettings = new NetCoreAppSettings( targetFrameworkMoniker: \"net5.0\", runtimeFrameworkVersion: null, name: \"Wasm\", customDotNetCliPath: cliPath); IToolchain toolChain = WasmToolchain.From(netCoreAppSettings); BenchmarkRunner.Run<IntroCustomMonoFluentConfig>(DefaultConfig.Instance .AddJob(Job.ShortRun.WithRuntime(runtime).WithToolchain(toolChain))); } [Benchmark] public void Foo() { // Benchmark body } } } Links Toolchains The permanent link to this sample: BenchmarkDotNet.Samples.IntroWasm MonoAotLLVM BenchmarkDotNet supports doing Mono AOT runs with both the Mono-Mini compiler and the Mono-LLVM compiler (which uses llvm on the back end). Using this tool chain requires the following flags: --runtimes monoaotllvm --aotcompilerpath <path to mono aot compiler> --customruntimepack <path to runtime pack> and optionally (defaults to mini) --aotcompilermode <mini|llvm> As of this writing, the mono aot compiler is not available as a seperate download or nuget package. Therefore, it is required to build the compiler in the [dotnet/runtime repository]. The compiler binary (mono-sgen) is built as part of the mono subset, so it can be built (along with the runtime pack) like so (in the root of [dotnet/runtime]). ./build.sh -subset mono+libs -c Release The compiler binary should be generated here (modify for your platform): <runtime root>/artifacts/obj/mono/OSX.x64.Release/mono/mini/mono-sgen And the runtime pack should be generated here: <runtimeroot>artifacts/bin/microsoft.netcore.app.runtime.osx-x64/Release/"
  },
  "articles/configs/validators.html": {
    "href": "articles/configs/validators.html",
    "title": "Validators | BenchmarkDotNet",
    "summary": "Validators A validator can validate your benchmarks before they are executed and produce validation errors. If any of the validation errors is critical, then none of the benchmarks will get executed. Available validators are: BaselineValidator.FailOnError - it checks if more than 1 Benchmark per class has Baseline = true applied. This validator is mandatory. JitOptimizationsValidator.(Dont)FailOnError - it checks whether any of the referenced assemblies is non-optimized. DontFailOnError version is enabled by default. ExecutionValidator.(Dont)FailOnError - it checks if it is possible to run your benchmarks by executing each of them once. Optional. ReturnValueValidator.(Dont)FailOnError - it checks if non-void benchmarks return equal values. Optional."
  },
  "articles/contributing/building.html": {
    "href": "articles/contributing/building.html",
    "title": "Building | BenchmarkDotNet",
    "summary": "Building There are two recommended options to build BenchmarkDotNet from source: Visual Studio Visual Studio (Community, Professional, Enterprise) with .NET 4.6.2 SDK and F# support. .NET 7 SDK. Once all the necessary tools are in place, building is trivial. Simply open solution file BenchmarkDotNet.sln that lives at the base of the repository and run Build action. Command-line Cake (C# Make) is a cross platform build automation system with a C# DSL to do things like compiling code, copy files/folders, running unit tests, compress files and build NuGet packages. The build currently depends on the following prerequisites: Windows: PowerShell version 5 or higher MSBuild version 15.1 or higher .NET Framework 4.6 or higher Linux: Install Mono version 5 or higher Install fsharp package Install packages required to .NET Core SDK gettext libcurl4-openssl-dev libicu-dev libssl-dev libunwind8 macOS Install Mono version 5 or higher Install fsharp package Install the latest version of OpenSSL. In order to run various build tasks from terminal, use build.cmd file in the repository root. build.cmd is a cross-platform script that can be used the same way on Windows, Linux, and macOS. When executed without arguments, it prints help information with list of all available build tasks."
  },
  "articles/contributing/debugging.html": {
    "href": "articles/contributing/debugging.html",
    "title": "Debugging | BenchmarkDotNet",
    "summary": "Debugging There should be two debug profiles available in VS drop down"
  },
  "articles/contributing/disassembler.html": {
    "href": "articles/contributing/disassembler.html",
    "title": "Contributing to Disassembler | BenchmarkDotNet",
    "summary": "Contributing to Disassembler The disassembler might looks scarry, but once you know how it works and how to debug it, it's very easy to develop it. How it works We have 3 disassemblers: Mono x64 for Windows and Linux x86 for Windows The MonoDisassembler is very simple: it spawns Mono with the right arguments to get the asm, Mono prints the output to the console and we just parse it. Single class does the job: MonoDisassembler. When it comes to Windows disassemblers it's not so easy. To obtain the disassm we are using ClrMD. ClrMD can attach only to the process of same bitness (architecture). This is why we have two disassemblers: x64 and x86. The code is the same (single class, linked in two projects) but compiled for two different architectures. We keep both disassemblers in the resources of the BenchmarkDotNet.dll. When we need the disassembler, we search for it in the resources, copy it to the disk and run (it's an exe). On Linux it's simpler (only x64 is supported) and we don't spawn a new process (everything is done in-proc). How to debug the disassembler You need to create a new console app project which executes the code that you would like to disassemble. In this app, you need to run the desired code (to get it jitted) and just don't exit before attaching the disassembler and getting the disassembly. Disassembler requires some arguments to run: id of the process to attach, full type name of the type which contains desired method, name of desired method and few other (see the example below). Personally I use following code to run the console app and print arguments that are required to attach to it: namespace Sample { class Program { static void Main(string[] args) { var result = Benchmark(); // execute the benchmark do method gets jitted Console.WriteLine( $\"{Process.GetCurrentProcess().Id} \" + // process Id $\"\\\"{typeof(Program).FullName}\\\" \" + // full type name $\"{nameof(Benchmark)} \" + // benchmarked method name $\"{bool.FalseString} \" + // print Source \"2 \" + // recursive depth $\"{Path.GetTempFileName()}.xml\"); // result xml file path while(true) { Console.WriteLine(\"Press Ctrl+C to kill the process\"); Console.ReadLine(); // block the exe, attach with Disassembler now } GC.KeepAlive(result); } public static IntPtr Benchmark() { return new IntPtr(42).Multiply(4); } } public static class IntPtrHelper { [MethodImpl(MethodImplOptions.AggressiveInlining)] public unsafe static IntPtr Multiply(this IntPtr a, int factor) { return (sizeof(IntPtr) == sizeof(int)) ? new IntPtr((int)a * factor) : new IntPtr((long)a * factor); } } } Important: Please remember that every new classic .NET project in VS compiles as 32 bit. If you want to check the asm produced for x64 you need to go to the properties of the console app (Alt+Enter) and uncheck \"Prefer 32 bit\" in the \"Build\" tab. Once you configure your app, you should run it. It will give you an output similar to this: 13672 Sample.Program Benchmark True 7 C:\\Users\\adsitnik\\AppData\\Local\\Temp\\tmpDCB9.tmp.xml Now you go to BenchmarkDotNet solution, select desired Disassembler project in the Solution Explorer and Set it as Startup project. After this you go to the project's properties and in the Debug tab copy-paste the arguments for the disassembler. Now when you start debugging, your IDE will spawn new process of the disassembler with the right arguments to attach to the desired exe. You should be able to debug it like any other app. Please keep in mind that you should always use the disassembler for the correct processor architecture. If you fail to debug it, you are most probably using the wrong one."
  },
  "articles/contributing/documentation.html": {
    "href": "articles/contributing/documentation.html",
    "title": "Documentation | BenchmarkDotNet",
    "summary": "Documentation BenchmarkDotNet uses DocFX as a documentation generation tool. Hints If you want to provide a link to API, you can use cross references by UID. For example, [SimpleJobAttribute](xref:BenchmarkDotNet.Attributes.SimpleJobAttribute) and @BenchmarkDotNet.Attributes.SimpleJobAttribute will be transformed to SimpleJobAttribute. Notes DocFX uses the following syntax inside block quote for different types of notes: > [!NOTE] > note content > [!TIP] > tip content > [!WARNING] > warning content > [!IMPORTANT] > important content > [!Caution] > caution content It will be transformed to: Note note content Tip tip content Warning warning content Important important content Caution caution content Building documentation locally You can build documentation locally with the help of the docs-build build task: build.cmd docs-build See also DocFX User Manual DocFX Tutorials: Links and Cross References DocFX Flavored Markdown"
  },
  "articles/contributing/miscellaneous.html": {
    "href": "articles/contributing/miscellaneous.html",
    "title": "| BenchmarkDotNet",
    "summary": "#Miscellaneous topics F# We have full F# support, all you have to do is to run dotnet restore to download the compilers etc. Chat room How can I help? Here is a list of up-for-grabs issues"
  },
  "articles/contributing/running-tests.html": {
    "href": "articles/contributing/running-tests.html",
    "title": "Running Tests | BenchmarkDotNet",
    "summary": "Running Tests To run all tests just run the following command in the repo root: dotnet test -c Release BenchmarkDotNet.sln Most of the tests projects target net461 and net5.0. If the change that you want to test is not specific to any particular runtime, you can run the tests for one of them. dotnet test -c Release -f net5.0 BenchmarkDotNet.sln You should be able to run all of tests from your IDE as well. Verify Tests For some unit tests (e.g. for exporter tests) BenchmarkDotNet uses Verify. The expected value for each test is stored in a *.verified.txt file located near the test source file in the repository. Verify generates verified file's names automatically according test name and its parameters. This files must be added under the source control. It also creates a *.received file for each failed test. You can use diff tools for convenient file comparison. By default you can find test run results on the test runner console as usual. You can comment out the line result.DisableDiff() in VerifySettingsFactory.Create method and then Verify will open KDiff for each failed test. This way you can easily understand what's the difference between verified and received values and choose the correct one."
  },
  "articles/faq.html": {
    "href": "articles/faq.html",
    "title": "FAQ (Frequently asked questions) | BenchmarkDotNet",
    "summary": "FAQ (Frequently asked questions) Q Why can't I install BenchmarkDotNet in Visual Studio 2010/2012/2013? A BenchmarkDotNet requires NuGet 3.x+ and can't be installed in old versions of Visual Studio which use NuGet 2.x. Consider to use Visual Studio 2015/2017 or Rider. See also: BenchmarkDotNet#237, roslyn#12780. Q Why can't I install BenchmarkDotNet in a new .NET Core Console App in Visual Studio 2017? A BenchmarkDotNet supports only netcoreapp2.0+. Some old Visual Studio 2017 can create a new application which targets netcoreapp1.0. You should upgrade it up to 2.0. If you want to target netcoreapp1.0 in your main assembly, it's recommended to create a separated project for benchmarks. Q I created a new .NET Core Console App in Visual Studio 2017. Now I want to run my code on CoreCLR, full .NET Framework, and Mono. How can I do it? A Use the following lines in your .csproj file: <TargetFrameworks>netcoreapp2.0;net46</TargetFrameworks> <PlatformTarget>AnyCPU</PlatformTarget> And mark your benchmark class with the following attributes: [CoreJob, ClrJob, MonoJob] Q My source code targets old versions of .NET Framework or .NET Core, but BenchmarkDotNet requires net461 and netcoreapp2.0. How can I run benchmarks in this case? A It's a good practice to introduce an additional console application (e.g. MyAwesomeLibrary.Benchmarks) which will depend on your code and BenchmarkDotNet. Due to the fact that users usually run benchmarks in a develop environment and don't distribute benchmarks for users, it shouldn't be a problem. Q I wrote a small benchmark, but BenchmarkDotNet requires a lot of time for time measurements. How can I reduce this time? A By default, BenchmarkDotNet automatically chooses a number of iterations which allows achieving the best precision. If you don't need such level of precision and just want to have a quick way to get approximated results, you can specify all parameters manually. For example, you can use the SimpleJob or ShortRunJob attributes: [SimpleJob(launchCount: 1, warmupCount: 3, iterationCount: 5, invocationCount:100, id: \"QuickJob\")] [ShortRunJob] Q My benchmark unexpectedly stopped and I saw the information about error code. What can I do? A BenchmarkDotNet generates, builds and runs new process for every benchmark. This behavior is sometimes interpreted by anti-virus as dangerous, and the process is killed. Use EnvironmentAnalyser to detect antivirus software and configure your benchmark to use InProcessToolchain. Q Can I run benchmark on the virtual machine? A Yes, of course. However, it can affect results because of the shared, physical machine, virtualization process and incorrect Stopwatch.Frequency. If you are unsure whether an application is running on virtual environment, use EnvironmentAnalyser to detect VM hypervisor. Q I have failed to run my benchmarks, I am getting following errors about non-optimized dll. What can I do? Assembly BenchmarkDotNet.Samples which defines benchmarks references non-optimized BenchmarkDotNet If you own this dependency, please, build it in RELEASE. If you don't, you can create custom config with DontFailOnError to disable our custom policy and allow this b Assembly BenchmarkDotNet.Samples which defines benchmarks is non-optimized Benchmark was built without optimization enabled (most probably a DEBUG configuration). Please, build it in RELEASE. A You should always run your benchmarks in RELEASE mode with optimizations enabled (default setting for RELEASE). However if you have to use non-optimized 3rd party assembly you have to create custom config to disable our default policy. public class AllowNonOptimized : ManualConfig { public AllowNonOptimized() { Add(JitOptimizationsValidator.DontFailOnError); // ALLOW NON-OPTIMIZED DLLS Add(DefaultConfig.Instance.GetLoggers().ToArray()); // manual config has no loggers by default Add(DefaultConfig.Instance.GetExporters().ToArray()); // manual config has no exporters by default Add(DefaultConfig.Instance.GetColumnProviders().ToArray()); // manual config has no columns by default } } Q I have failed to run my benchmarks from LINQPad. How can I fix this problem? Assembly LINQPadQuery which defines benchmarks references non-optimized LINQPad Assembly LINQPadQuery which defines benchmarks is non-optimized Benchmark was built without optimization enabled (most probably a DEBUG configuration). Please, build it in RELEASE. A You need to make sure that you are using AnyCPU 5.22.05+ build of LINQPad with optimizations enabled. To enable the optimizations you need to go to Preferences -> Query and select compile with /optimize+ Q I'm trying to use RPlotExporter but there are no any images in the results folder A Try to specify R_LIBS_USER (e.g. R_LIBS_USER=/usr/local/lib/R/ on Linux/macOS, see also: #692) Q My benchmark failed with OutOfMemoryException. How can I fix this problem? A BenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects. If your benchmark allocates memory and keeps it alive, you are creating a memory leak. You should redesign your benchmark and remove the side-effects. You can use OperationsPerInvoke, IterationSetup and IterationCleanup to do that. An example: public class OOM { private StringBuilder buffer = new StringBuilder(); [Benchmark] public void HasSideEffects() { // This method is growing the buffer to infinity // because it's executed millions of times buffer.Append('a'); } [Benchmark(OperationsPerInvoke = 16)] public void HasNoSideEffects() { buffer.Clear(); for (int i = 0; i < 1024; i++) buffer.Append('a'); } }"
  },
  "articles/features/baselines.html": {
    "href": "articles/features/baselines.html",
    "title": "Benchmark and Job Baselines | BenchmarkDotNet",
    "summary": "Benchmark and Job Baselines In order to scale your results, you can mark a benchmark method or a job as a baseline. Let's learn this feature by examples. Sample: IntroBenchmarkBaseline You can mark a method as a baseline with the help of [Benchmark(Baseline = true)]. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroBenchmarkBaseline { [Benchmark] public void Time50() => Thread.Sleep(50); [Benchmark(Baseline = true)] public void Time100() => Thread.Sleep(100); [Benchmark] public void Time150() => Thread.Sleep(150); } } Output As a result, you will have additional Ratio column in the summary table: | Method | Mean | Error | StdDev | Ratio | |-------- |----------:|----------:|----------:|------:| | Time50 | 50.46 ms | 0.0779 ms | 0.0729 ms | 0.50 | | Time100 | 100.39 ms | 0.0762 ms | 0.0713 ms | 1.00 | | Time150 | 150.48 ms | 0.0986 ms | 0.0922 ms | 1.50 | This column contains the mean value of the ratio distribution. For example, in the case of Time50, we divide the first measurement of Time50 into the first measurement of Time100 (it's the baseline), the second measurement of Time50 into the second measurement of Time100, and so on. Next, we calculate the mean of all these values and display it in the Ratio column. For Time50, we have 0.50. The Ratio column was formerly known as Scaled. The old title was a source of misunderstanding and confusion because many developers interpreted it as the ratio of means (e.g., 50.46/100.39 for Time50). The ratio of distribution means and the mean of the ratio distribution are pretty close to each other in most cases, but they are not equal. In @BenchmarkDotNet.Samples.IntroRatioStdDev, you can find an example of how this value can be spoiled by outliers. Links Benchmark and Job Baselines The permanent link to this sample: BenchmarkDotNet.Samples.IntroBenchmarkBaseline Sample: IntroRatioSD The ratio of two benchmarks is not a single number, it's a distribution. In most simple cases, the range of the ratio distribution is narrow, and BenchmarkDotNet displays a single column Ratio with the mean value. However, it also adds the RatioSD column (the standard deviation of the ratio distribution) in complex situations. In the below example, the baseline benchmark is spoiled by a single outlier Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; using Perfolizer.Mathematics.OutlierDetection; namespace BenchmarkDotNet.Samples { // Don't remove outliers [Outliers(OutlierMode.DontRemove)] // Skip jitting, pilot, warmup; measure 10 iterations [SimpleJob(RunStrategy.Monitoring, iterationCount: 10, invocationCount: 1)] public class IntroRatioSD { private int counter; [GlobalSetup] public void Setup() => counter = 0; [Benchmark(Baseline = true)] public void Base() { Thread.Sleep(100); if (++counter % 7 == 0) Thread.Sleep(5000); // Emulate outlier } [Benchmark] public void Slow() => Thread.Sleep(200); [Benchmark] public void Fast() => Thread.Sleep(50); } } Output Here are statistics details for the baseline benchmark: Mean = 600.6054 ms, StdErr = 500.0012 ms (83.25%); N = 10, StdDev = 1,581.1428 ms Min = 100.2728 ms, Q1 = 100.3127 ms, Median = 100.4478 ms, Q3 = 100.5011 ms, Max = 5,100.6163 ms IQR = 0.1884 ms, LowerFence = 100.0301 ms, UpperFence = 100.7837 ms ConfidenceInterval = [-1,789.8568 ms; 2,991.0677 ms] (CI 99.9%), Margin = 2,390.4622 ms (398.01% of Mean) Skewness = 2.28, Kurtosis = 6.57, MValue = 2 -------------------- Histogram -------------------- [-541.891 ms ; 743.427 ms) | @@@@@@@@@ [ 743.427 ms ; 2027.754 ms) | [2027.754 ms ; 3312.082 ms) | [3312.082 ms ; 4458.453 ms) | [4458.453 ms ; 5742.780 ms) | @ --------------------------------------------------- As you can see, a single outlier significantly affected the metrics. Because of this, BenchmarkDotNet adds the Median and the RatioSD columns in the summary table: Method | Mean | Error | StdDev | Median | Ratio | RatioSD | ------- |----------:|--------------:|--------------:|----------:|------:|--------:| Base | 600.61 ms | 2,390.4622 ms | 1,581.1428 ms | 100.45 ms | 1.00 | 0.00 | Slow | 200.50 ms | 0.4473 ms | 0.2959 ms | 200.42 ms | 1.80 | 0.62 | Fast | 50.54 ms | 0.3435 ms | 0.2272 ms | 50.48 ms | 0.45 | 0.16 | Let's look at the Base and Slow benchmarks. The Mean values are 600 and 200 milliseconds; the \"Scaled Mean\" value is 0.3. The Median values are 100 and 200 milliseconds; the \"Scaled Median\" value is 2. Both values are misleading. BenchmarkDotNet evaluates the ratio distribution and displays the mean (1.80) and the standard deviation (0.62). Links Benchmark and Job Baselines The permanent link to this sample: BenchmarkDotNet.Samples.IntroRatioSD Sample: IntroCategoryBaseline The only way to have several baselines in the same class is to separate them by categories and mark the class with [GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)]. Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; namespace BenchmarkDotNet.Samples { [GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)] [CategoriesColumn] public class IntroCategoryBaseline { [BenchmarkCategory(\"Fast\"), Benchmark(Baseline = true)] public void Time50() => Thread.Sleep(50); [BenchmarkCategory(\"Fast\"), Benchmark] public void Time100() => Thread.Sleep(100); [BenchmarkCategory(\"Slow\"), Benchmark(Baseline = true)] public void Time550() => Thread.Sleep(550); [BenchmarkCategory(\"Slow\"), Benchmark] public void Time600() => Thread.Sleep(600); } } Output | Method | Categories | Mean | Error | StdDev | Ratio | |-------- |----------- |----------:|----------:|----------:|------:| | Time50 | Fast | 50.46 ms | 0.0745 ms | 0.0697 ms | 1.00 | | Time100 | Fast | 100.47 ms | 0.0955 ms | 0.0893 ms | 1.99 | | | | | | | | | Time550 | Slow | 550.48 ms | 0.0525 ms | 0.0492 ms | 1.00 | | Time600 | Slow | 600.45 ms | 0.0396 ms | 0.0331 ms | 1.09 | Links Benchmark and Job Baselines The permanent link to this sample: BenchmarkDotNet.Samples.IntroCategoryBaseline Sample: IntroJobBaseline If you want to compare several runtime configuration, you can mark one of your jobs with baseline = true. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [SimpleJob(runtimeMoniker: RuntimeMoniker.Net462, baseline: true)] [SimpleJob(runtimeMoniker: RuntimeMoniker.Mono)] [SimpleJob(runtimeMoniker: RuntimeMoniker.Net50)] public class IntroJobBaseline { [Benchmark] public int SplitJoin() => string.Join(\",\", new string[1000]).Split(',').Length; } } Output BenchmarkDotNet=v0.10.12, OS=Windows 10 Redstone 3 [1709, Fall Creators Update] (10.0.16299.192) Processor=Intel Core i7-6700HQ CPU 2.60GHz (Skylake), ProcessorCount=8 Frequency=2531249 Hz, Resolution=395.0619 ns, Timer=TSC .NET Core SDK=2.0.3 [Host] : .NET Core 2.0.3 (Framework 4.6.25815.02), 64bit RyuJIT Job-MXFYPZ : .NET Framework 4.7 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.2600.0 Core : .NET Core 2.0.3 (Framework 4.6.25815.02), 64bit RyuJIT Mono : Mono 5.4.0 (Visual Studio), 64bit Method | Runtime | Mean | Error | StdDev | Ratio | RatioSD | ---------- |-------- |---------:|----------:|----------:|------:|--------:| SplitJoin | Clr | 19.42 us | 0.2447 us | 0.1910 us | 1.00 | 0.00 | SplitJoin | Core | 13.00 us | 0.2183 us | 0.1935 us | 0.67 | 0.01 | SplitJoin | Mono | 39.14 us | 0.7763 us | 1.3596 us | 2.02 | 0.07 | Links Benchmark and Job Baselines The permanent link to this sample: BenchmarkDotNet.Samples.IntroJobBaseline"
  },
  "articles/features/disassembler.html": {
    "href": "articles/features/disassembler.html",
    "title": "Disassembler | BenchmarkDotNet",
    "summary": "Disassembler Can be enabled by using [DisassemblyDiagnoser] or command line args: -d or --disasm. The configuration options available from code level are: maxDepth: Includes called methods to given level. 1 by default, indexed from 1. To print just the benchmark set it to 0. This option is also available from the console arguments level --disasmDepth. printSource: C#|F#|VB source code will be printed. False by default. printInstructionAddresses: Print instruction addresses. False by default. exportGithubMarkdown: Exports to GitHub markdown. True by default. exportHtml: Exports to HTML with clickable links. False by default. exportCombinedDisassemblyReport: Exports all benchmarks to a single HTML report. Makes it easy to compare different runtimes or methods (each becomes a column in HTML table). exportDiff: Exports a diff of the assembly code to the Github markdown format. False by default. Requirements Disassembly Diagnoser requires following settings in your .csproj file: <PropertyGroup> <PlatformTarget>AnyCPU</PlatformTarget> <DebugType>pdbonly</DebugType> <DebugSymbols>true</DebugSymbols> </PropertyGroup> To get the source code we need to locate and read the .pdb files. This is why we need DebugType and DebugSymbols settings. To compare different platforms the project which defines benchmarks has to target AnyCPU. Disassembly Diagnoser for Mono on Windows If you want to get a disassembly listing for Mono on Windows, you need as and x86_64-w64-mingw32-objdump.exe tools. If you don't have it, you will get a warning like follows: It's impossible to get Mono disasm because you don't have some required tools: 'as' is not recognized as an internal or external command 'x86_64-w64-mingw32-objdump.exe' is not recognized as an internal or external command The easiest way to get these tools: Download and install Cygwin On the \"Select Packages\" screen, search for binutils Install binutils and mingw64-x86_64-binutils Add cygwin64\\bin\\ (or cygwin\\bin\\) in %PATH% Sample: IntroDisassembly Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnosers; using System.Linq; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(printInstructionAddresses: true, syntax: DisassemblySyntax.Masm)] public class IntroDisassembly { private int[] field = Enumerable.Range(0, 100).ToArray(); [Benchmark] public int SumLocal() { var local = field; // we use local variable that points to the field int sum = 0; for (int i = 0; i < local.Length; i++) sum += local[i]; return sum; } [Benchmark] public int SumField() { int sum = 0; for (int i = 0; i < field.Length; i++) sum += field[i]; return sum; } } } Output ; .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.7.3110.0 05452718 BenchmarkDotNet.Samples.IntroDisassembly.Sum() IL_0000: ldc.r8 0 IL_0009: stloc.0 0545271c d9ee fldz IL_000a: ldc.i4.0 IL_000b: stloc.1 IL_000c: br.s IL_0017 0545271e 33c0 xor eax,eax IL_000e: ldloc.0 IL_000f: ldloc.1 IL_0010: conv.r8 IL_0011: add IL_0012: stloc.0 05452720 8945fc mov dword ptr [ebp-4],eax 05452723 db45fc fild dword ptr [ebp-4] 05452726 dec1 faddp st(1),st IL_0013: ldloc.1 IL_0014: ldc.i4.1 IL_0015: add IL_0016: stloc.1 05452728 40 inc eax IL_0017: ldloc.1 IL_0018: ldc.i4.s 64 IL_001a: blt.s IL_000e 05452729 83f840 cmp eax,40h 0545272c 7cf2 jl 05452720 IL_001c: ldloc.0 IL_001d: ret 0545272e 8be5 mov esp,ebp ; .NET Core 2.1.0 (CoreCLR 4.6.26515.07, CoreFX 4.6.26515.06), 64bit RyuJIT 00007ffa`6c621320 BenchmarkDotNet.Samples.IntroDisassembly.Sum() IL_0000: ldc.r8 0 IL_0009: stloc.0 00007ffa`6c621323 c4e17857c0 vxorps xmm0,xmm0,xmm0 IL_000a: ldc.i4.0 IL_000b: stloc.1 IL_000c: br.s IL_0017 00007ffa`6c621328 33c0 xor eax,eax IL_000e: ldloc.0 IL_000f: ldloc.1 IL_0010: conv.r8 IL_0011: add IL_0012: stloc.0 00007ffa`6c62132a c4e17057c9 vxorps xmm1,xmm1,xmm1 00007ffa`6c62132f c4e1732ac8 vcvtsi2sd xmm1,xmm1,eax 00007ffa`6c621334 c4e17b58c1 vaddsd xmm0,xmm0,xmm1 IL_0013: ldloc.1 IL_0014: ldc.i4.1 IL_0015: add IL_0016: stloc.1 00007ffa`6c621339 ffc0 inc eax IL_0017: ldloc.1 IL_0018: ldc.i4.s 64 IL_001a: blt.s IL_000e 00007ffa`6c62133b 83f840 cmp eax,40h 00007ffa`6c62133e 7cea jl 00007ffa`6c62132a IL_001c: ldloc.0 IL_001d: ret 00007ffa`6c621340 c3 ret Mono 5.12.0 (Visual Studio), 64bit Sum sub $0x18,%rsp mov %rsi,(%rsp) xorpd %xmm0,%xmm0 movsd %xmm0,0x8(%rsp) xor %esi,%esi jmp 2e xchg %ax,%ax movsd 0x8(%rsp),%xmm0 cvtsi2sd %esi,%xmm1 addsd %xmm1,%xmm0 movsd %xmm0,0x8(%rsp) inc %esi cmp $0x40,%esi jl 18 movsd 0x8(%rsp),%xmm0 mov (%rsp),%rsi add $0x18,%rsp retq Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassembly Sample: IntroDisassemblyRyuJit Source code using System.Linq; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(printSource: true)] [RyuJitX64Job] public class IntroDisassemblyRyuJit { private int[] field = Enumerable.Range(0, 100).ToArray(); [Benchmark] public int SumLocal() { var local = field; // we use local variable that points to the field int sum = 0; for (int i = 0; i < local.Length; i++) sum += local[i]; return sum; } [Benchmark] public int SumField() { int sum = 0; for (int i = 0; i < field.Length; i++) sum += field[i]; return sum; } } } Output Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassemblyRyuJit Sample: IntroDisassemblyAllJits You can use a single config to compare the generated assembly code for ALL JITs. But to allow benchmarking any target platform architecture the project which defines benchmarks has to target AnyCPU. <PropertyGroup> <PlatformTarget>AnyCPU</PlatformTarget> </PropertyGroup> Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Diagnosers; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [Config(typeof(MultipleJits))] public class IntroDisassemblyAllJits { public class MultipleJits : ManualConfig { public MultipleJits() { AddJob(Job.ShortRun.WithPlatform(Platform.X86).WithRuntime(new MonoRuntime(name: \"Mono x86\", customPath: @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithPlatform(Platform.X64).WithRuntime(new MonoRuntime(name: \"Mono x64\", customPath: @\"C:\\Program Files\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithJit(Jit.LegacyJit).WithPlatform(Platform.X86).WithRuntime(ClrRuntime.Net462)); AddJob(Job.ShortRun.WithJit(Jit.LegacyJit).WithPlatform(Platform.X64).WithRuntime(ClrRuntime.Net462)); AddJob(Job.ShortRun.WithJit(Jit.RyuJit).WithPlatform(Platform.X64).WithRuntime(ClrRuntime.Net462)); // RyuJit for .NET Core 5.0 AddJob(Job.ShortRun.WithJit(Jit.RyuJit).WithPlatform(Platform.X64).WithRuntime(CoreRuntime.Core50)); AddDiagnoser(new DisassemblyDiagnoser(new DisassemblyDiagnoserConfig(maxDepth: 3, exportDiff: true))); } } private Increment increment = new Increment(); [Benchmark] public int CallVirtualMethod() => increment.OperateTwice(10); public abstract class Operation // abstract unary integer operation { public abstract int Operate(int input); public int OperateTwice(int input) => Operate(Operate(input)); // two virtual calls to Operate } public sealed class Increment : Operation // concrete, sealed operation: increment by fixed amount { public readonly int Amount; public Increment(int amount = 1) { Amount = amount; } public override int Operate(int input) => input + Amount; } } } Output The disassembly result can be obtained here. The file was too big to embed it in this doc page. Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassemblyAllJits Sample: IntroDisassemblyDry Getting only the Disassembly without running the benchmarks for a long time. Sometimes you might be interested only in the disassembly, not the results of the benchmarks. In that case you can use Job.Dry which runs the benchmark only once. Source code using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(maxDepth: 3)] [DryJob] public class IntroDisassemblyDry { [Benchmark] public void Foo() { } } } Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassemblyDry"
  },
  "articles/features/etwprofiler.html": {
    "href": "articles/features/etwprofiler.html",
    "title": "EtwProfiler | BenchmarkDotNet",
    "summary": "EtwProfiler EtwProfiler allows to profile the benchmarked .NET code on Windows and exports the data to a trace file which can be opened with PerfView or Windows Performance Analyzer. How it works EtwProfiler uses TraceEvent library which internally uses Event Tracing for Windows (ETW) to capture stack traces and important .NET Runtime events. Before the process with benchmarked code is started, EtwProfiler starts User and Kernel ETW sessions. Every session writes data to it's own file and captures different data. User session listens for the .NET Runtime events (GC, JIT etc) while the Kernel session gets CPU stacks and Hardware Counter events. After this, the process with benchmarked code is started. During the benchmark execution all the data is captured and written to a trace file. Moreover, BenchmarkDotNet Engine emits it's own events to be able to differentiate jitting, warmup, pilot and actual workload when analyzing the trace file. When the benchmarking is over, both sessions are closed and the two trace files are merged into one. Limitations What we have today comes with following limitations: EtwProfiler works only on Windows (one day we might implement similar thing for Unix using EventPipe) Requires to run as Admin (to create ETW Kernel Session) No InProcessToolchain support To get the best possible managed code symbols you should configure your project in following way: <DebugType>pdbonly</DebugType> <DebugSymbols>true</DebugSymbols> Note On certain machines Intel TDT and Windows Defender can cause CPU samples to be captured with no value. You can correct this problem by disabling the feature using powershell.exe Set-MpPreference -DisableTDTFeature $true. WARNING: Disabling security features will make your machine less secure; do so at your own risk. How to use it? You need to install BenchmarkDotNet.Diagnostics.Windows package. It can be enabled in few ways, some of them: Use the new attribute (apply it on a class that contains Benchmarks): using BenchmarkDotNet.Diagnostics.Windows.Configs; [EtwProfiler] public class TheClassThatContainsBenchmarks { /* benchmarks go here */ } Extend the DefaultConfig.Instance with new instance of EtwProfiler: class Program { static void Main(string[] args) => BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args, DefaultConfig.Instance .AddDiagnoser(new EtwProfiler())); // HERE } Passing -p ETW or --profiler ETW command line argument to BenchmarkSwitcher Configuration To configure the new diagnoser you need to create an instance of EtwProfilerConfig class and pass it to the EtwProfiler constructor. The parameters that EtwProfilerConfig ctor takes are: performExtraBenchmarksRun - if set to true, benchmarks will be executed one more time with the profiler attached. If set to false, there will be no extra run but the results will contain overhead. True by default. bufferSizeInMb - ETW session buffer size, in MB. 256 by default. intervalSelectors - interval per hardware counter, if not provided then default values will be used. kernelKeywords - kernel session keywords, ImageLoad (for native stack frames) and Profile (for CPU Stacks) are the defaults. providers - providers that should be enabled, if not provided then default values will be used. Using PerfView to work with trace files PerfView is a free .NET profiler from Microsoft. If you don't know how to use it you should watch these instructional videos first. If you are familiar with PerfView, then the only thing you need to know is that BenchmarkDotNet performs Jitting by running the code once, Pilot Experiment to determine how many times benchmark should be executed per iteration, non-trivial Warmup and Actual Workload. This is why when you open your trace file in PerfView you will see your benchmark in a few different places of the StackTrace. The simplest way to filter the data to the actual benchmarks runs is to open the CallTree tab, put \"EngineActualStage\" in the Find box, press enter and when PerfView selects EngineActualStage in the CallTree press Alt+R to Set Time Range. If you want to filter the trace to single iteration, then you must go to the Events panel and search for the WorkloadActual/Start and WorkloadActual/Stop events. Open Events window Put \"WorkloadActual\" in the Filter box and hit enter. Press control or shift and choose the Start and Stop events from the left panel. Hit enter. Choose iteration that you want to investigate (events are sorted by time). Select two or more cells from the \"Time MSec\" column. Right click, choose \"Open Cpu Stacks\". Choose the process with benchmarks, right-click, choose \"Drill Into\""
  },
  "articles/features/event-pipe-profiler.html": {
    "href": "articles/features/event-pipe-profiler.html",
    "title": "EventPipeProfiler | BenchmarkDotNet",
    "summary": "EventPipeProfiler EventPipeProfiler is a cross-platform profiler that allows profile .NET code on every platform - Windows, Linux, macOS. Collected data are exported to trace files (.speedscope.json and .nettrace) which can be analyzed using SpeedScope, PerfView, and Visual Studio Profiler. This new profiler is available from the 0.12.1 version. Configuration EventPipeProfiler can be enabled in three ways: Using parameter -p EP or --profiler EP from the console line. Marking the benchmarked class with [EventPipeProfiler(...)] attribute. You can find an example below. Using a custom configuration. You can find an example below. Sample: EventPipeProfiler The EventPipeProfiler can be enabled using the [EventPipeProfiler(...)] attribute. This attribute takes the following profiles: CpuSampling - Useful for tracking CPU usage and general .NET runtime information. This is the default option. GcVerbose - Tracks GC collections and samples object allocations. GcCollect - Tracks GC collections only at very low overhead. Jit - Logging when Just in time (JIT) compilation occurs. Logging of the internal workings of the Just In Time compiler. This is fairly verbose. It details decisions about interesting optimization (like inlining and tail call) Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnosers; namespace BenchmarkDotNet.Samples { [ShortRunJob] [EventPipeProfiler(EventPipeProfile.CpuSampling)] public class IntroEventPipeProfiler { [Benchmark] public void Sleep() => Thread.Sleep(2000); } } Output The output should contain information about the exported trace file which can be analyzed using SpeedScope. // * Diagnostic Output - EventPipeProfiler * Exported 1 trace file(s). Example: C:\\Work\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\BenchmarkDotNet.Artifacts\\BenchmarkDotNet.Samples.IntroEventPipeProfiler.Sleep-20200406-090113.speedscope.json Sample: EventPipeProfilerAdvanced The most advanced and powerful way to use EventPipeProfiler is a custom configuration. As you can see the below configuration adds EventPipeProfiler that constructor can take the profile and/or a list of providers. Both EventPipeProfiler and dotnet trace use the Microsoft.Diagnostics.NETCore.Client package internally. So before you start using the custom configuration of this profiler, it is worth reading the documentation here and here where you can find more information about how to configure provider list. Source code using System.Buffers; using System.Diagnostics.Tracing; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Diagnosers; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using Microsoft.Diagnostics.NETCore.Client; using Microsoft.Diagnostics.Tracing.Parsers; namespace BenchmarkDotNet.Samples { [Config(typeof(CustomConfig))] public class IntroEventPipeProfilerAdvanced { private class CustomConfig : ManualConfig { public CustomConfig() { AddJob(Job.ShortRun.WithRuntime(CoreRuntime.Core50)); var providers = new[] { new EventPipeProvider(ClrTraceEventParser.ProviderName, EventLevel.Verbose, (long) (ClrTraceEventParser.Keywords.Exception | ClrTraceEventParser.Keywords.GC | ClrTraceEventParser.Keywords.Jit | ClrTraceEventParser.Keywords.JitTracing // for the inlining events | ClrTraceEventParser.Keywords.Loader | ClrTraceEventParser.Keywords.NGen)), new EventPipeProvider(\"System.Buffers.ArrayPoolEventSource\", EventLevel.Informational, long.MaxValue), }; AddDiagnoser(new EventPipeProfiler(providers: providers)); } } [Benchmark] public void RentAndReturn_Shared() { var pool = ArrayPool<byte>.Shared; byte[] array = pool.Rent(10000); pool.Return(array); } } } Output The output should contain information about the exported trace file which can be analyzed using SpeedScope. // * Diagnostic Output - EventPipeProfiler * Exported 1 trace file(s). Example: C:\\Work\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\BenchmarkDotNet.Artifacts\\BenchmarkDotNet.Samples.IntroEventPipeProfilerAdvanced.RentAndReturn_Shared-20200406-090136.speedscope.json"
  },
  "articles/features/parameterization.html": {
    "href": "articles/features/parameterization.html",
    "title": "Parameterization | BenchmarkDotNet",
    "summary": "Parameterization Sample: IntroParams You can mark one or several fields or properties in your class by the [Params] attribute. In this attribute, you can specify set of values. Every value must be a compile-time constant. As a result, you will get results for each combination of params values. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroParams { [Params(100, 200)] public int A { get; set; } [Params(10, 20)] public int B { get; set; } [Benchmark] public void Benchmark() => Thread.Sleep(A + B + 5); } } Output | Method | A | B | Mean | Error | StdDev | |---------- |---- |--- |---------:|--------:|--------:| | Benchmark | 100 | 10 | 115.3 ms | 0.13 ms | 0.12 ms | | Benchmark | 100 | 20 | 125.4 ms | 0.14 ms | 0.12 ms | | Benchmark | 200 | 10 | 215.5 ms | 0.19 ms | 0.18 ms | | Benchmark | 200 | 20 | 225.4 ms | 0.17 ms | 0.16 ms | Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroParams Sample: IntroParamsSource In case you want to use a lot of values, you should use [ParamsSource] You can mark one or several fields or properties in your class by the [Params] attribute. In this attribute, you have to specify the name of public method/property which is going to provide the values (something that implements IEnumerable). The source must be within benchmarked type! Source code using System.Collections.Generic; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroParamsSource { // property with public setter [ParamsSource(nameof(ValuesForA))] public int A { get; set; } // public field [ParamsSource(nameof(ValuesForB))] public int B; // public property public IEnumerable<int> ValuesForA => new[] { 100, 200 }; // public static method public static IEnumerable<int> ValuesForB() => new[] { 10, 20 }; [Benchmark] public void Benchmark() => Thread.Sleep(A + B + 5); } } Output | Method | B | A | Mean | Error | StdDev | |---------- |--- |---- |---------:|--------:|--------:| | Benchmark | 10 | 100 | 115.5 ms | 0.17 ms | 0.16 ms | | Benchmark | 10 | 200 | 215.6 ms | 0.15 ms | 0.14 ms | | Benchmark | 20 | 100 | 125.5 ms | 0.19 ms | 0.18 ms | | Benchmark | 20 | 200 | 225.5 ms | 0.23 ms | 0.22 ms | Remarks A remark about IParam. You don't need to use IParam anymore since 0.11.0. Just use complex types as you wish and override ToString method to change the display names used in the results. Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroParamsSource Sample: IntroParamsAllValues If you want to use all possible values of an enum or another type with a small number of values, you can use the [ParamsAllValues] attribute, instead of listing all the values by hand. The types supported by the attribute are: bool any enum that is not marked with [Flags] Nullable<T>, where T is an enum or boolean Source code using BenchmarkDotNet.Attributes; using System.Threading; namespace BenchmarkDotNet.Samples { [DryJob] public class IntroParamsAllValues { public enum CustomEnum { One = 1, Two, Three } [ParamsAllValues] public CustomEnum E { get; set; } [ParamsAllValues] public bool? B { get; set; } [Benchmark] public void Benchmark() { Thread.Sleep( (int)E * 100 + (B == true ? 20 : B == false ? 10 : 0)); } } } Output Method | E | B | Mean | Error | ---------- |------ |------ |---------:|------:| Benchmark | One | ? | 101.4 ms | NA | Benchmark | One | False | 111.1 ms | NA | Benchmark | One | True | 122.0 ms | NA | Benchmark | Two | ? | 201.3 ms | NA | Benchmark | Two | False | 212.1 ms | NA | Benchmark | Two | True | 221.3 ms | NA | Benchmark | Three | ? | 301.4 ms | NA | Benchmark | Three | False | 311.5 ms | NA | Benchmark | Three | True | 320.8 ms | NA | Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroParamsAllValues Sample: IntroParamsPriority In order to sort columns of parameters in the results table you can use the Property Priority inside the params attribute. The priority range is [Int32.MinValue;Int32.MaxValue], lower priorities will appear earlier in the column order. The default priority is set to 0. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroParamsPriority { [Params(100)] public int A { get; set; } [Params(10, Priority = -100)] public int B { get; set; } [Benchmark] public void Benchmark() => Thread.Sleep(A + B + 5); } } Output | Method | B | A | Mean | Error | StdDev | |---------- |--- |---- |---------:|--------:|--------:| | Benchmark | 10 | 100 | 115.4 ms | 0.12 ms | 0.11 ms | Links Priority BaseClass PriorityAttribute.cs Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroParamsPriority Sample: IntroArguments As an alternative to using [Params], you can specify arguments for your benchmarks. There are several ways to do it (described below). The [Arguments] allows you to provide a set of values. Every value must be a compile-time constant (it's C# language limitation for attributes in general). You can also combine [Arguments] with [Params]. As a result, you will get results for each combination of params values. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArguments { [Params(true, false)] // Arguments can be combined with Params public bool AddExtra5Milliseconds; [Benchmark] [Arguments(100, 10)] [Arguments(100, 20)] [Arguments(200, 10)] [Arguments(200, 20)] public void Benchmark(int a, int b) { if (AddExtra5Milliseconds) Thread.Sleep(a + b + 5); else Thread.Sleep(a + b); } } } Output | Method | AddExtra5Miliseconds | a | b | Mean | Error | StdDev | |---------- |--------------------- |---- |--- |---------:|----------:|----------:| | Benchmark | False | 100 | 10 | 110.1 ms | 0.0056 ms | 0.0044 ms | | Benchmark | False | 100 | 20 | 120.1 ms | 0.0155 ms | 0.0138 ms | | Benchmark | False | 200 | 10 | 210.2 ms | 0.0187 ms | 0.0175 ms | | Benchmark | False | 200 | 20 | 220.3 ms | 0.1055 ms | 0.0986 ms | | Benchmark | True | 100 | 10 | 115.3 ms | 0.1375 ms | 0.1286 ms | | Benchmark | True | 100 | 20 | 125.3 ms | 0.1212 ms | 0.1134 ms | | Benchmark | True | 200 | 10 | 215.4 ms | 0.0779 ms | 0.0691 ms | | Benchmark | True | 200 | 20 | 225.4 ms | 0.0775 ms | 0.0725 ms | Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroArguments Sample: IntroArgumentsSource In case you want to use a lot of values, you should use [ArgumentsSource]. You can mark one or several fields or properties in your class by the [ArgumentsSource] attribute. In this attribute, you have to specify the name of public method/property which is going to provide the values (something that implements IEnumerable). The source must be within benchmarked type! Source code using System; using System.Collections.Generic; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArgumentsSource { [Benchmark] [ArgumentsSource(nameof(Numbers))] public double ManyArguments(double x, double y) => Math.Pow(x, y); public IEnumerable<object[]> Numbers() // for multiple arguments it's an IEnumerable of array of objects (object[]) { yield return new object[] { 1.0, 1.0 }; yield return new object[] { 2.0, 2.0 }; yield return new object[] { 4.0, 4.0 }; yield return new object[] { 10.0, 10.0 }; } [Benchmark] [ArgumentsSource(nameof(TimeSpans))] public void SingleArgument(TimeSpan time) => Thread.Sleep(time); public IEnumerable<object> TimeSpans() // for single argument it's an IEnumerable of objects (object) { yield return TimeSpan.FromMilliseconds(10); yield return TimeSpan.FromMilliseconds(100); } } } Output | Method | x | y | Mean | Error | StdDev | |------- |--- |--- |----------:|----------:|----------:| | Pow | 1 | 1 | 9.360 ns | 0.0190 ns | 0.0149 ns | | Pow | 2 | 2 | 40.624 ns | 0.3413 ns | 0.3192 ns | | Pow | 4 | 4 | 40.537 ns | 0.0560 ns | 0.0524 ns | | Pow | 10 | 10 | 40.395 ns | 0.3274 ns | 0.3063 ns | Another example If the values are complex types you need to override ToString method to change the display names used in the results. [DryJob] public class WithNonPrimitiveArgumentsSource { [Benchmark] [ArgumentsSource(nameof(NonPrimitive))] public void Simple(SomeClass someClass, SomeStruct someStruct) { for (int i = 0; i < someStruct.RangeEnd; i++) Console.WriteLine($\"// array.Values[{i}] = {someClass.Values[i]}\"); } public IEnumerable<object[]> NonPrimitive() { yield return new object[] { new SomeClass(Enumerable.Range(0, 10).ToArray()), new SomeStruct(10) }; yield return new object[] { new SomeClass(Enumerable.Range(0, 15).ToArray()), new SomeStruct(15) }; } public class SomeClass { public SomeClass(int[] initialValues) => Values = initialValues.Select(val => val * 2).ToArray(); public int[] Values { get; } public override string ToString() => $\"{Values.Length} items\"; } public struct SomeStruct { public SomeStruct(int rangeEnd) => RangeEnd = rangeEnd; public int RangeEnd { get; } public override string ToString() => $\"{RangeEnd}\"; } } | Method | someClass | someStruct | Mean | Error | |------- |---------- |----------- |---------:|------:| | Simple | 10 items | 10 | 887.2 us | NA | | Simple | 15 items | 15 | 963.1 us | NA | Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroArgumentsSource Sample: IntroArrayParam Warning The cost of creating the arguments is not included in the benchmark. So if you want to pass an array as an argument, we are going to allocate it before running the benchmark, and the benchmark will not include this operation. Source code using System; using System.Collections.Generic; using System.Linq; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArrayParam { [Benchmark] [ArgumentsSource(nameof(Data))] public int ArrayIndexOf(int[] array, int value) => Array.IndexOf(array, value); [Benchmark] [ArgumentsSource(nameof(Data))] public int ManualIndexOf(int[] array, int value) { for (int i = 0; i < array.Length; i++) if (array[i] == value) return i; return -1; } public IEnumerable<object[]> Data() { yield return new object[] { new int[] { 1, 2, 3 }, 4 }; yield return new object[] { Enumerable.Range(0, 100).ToArray(), 4 }; yield return new object[] { Enumerable.Range(0, 100).ToArray(), 101 }; } } } Output | Method | array | value | Mean | Error | StdDev | Allocated | |-------------- |----------- |------ |----------:|----------:|----------:|----------:| | ArrayIndexOf | Array[100] | 4 | 15.558 ns | 0.0638 ns | 0.0597 ns | 0 B | | ManualIndexOf | Array[100] | 4 | 5.345 ns | 0.0668 ns | 0.0625 ns | 0 B | | ArrayIndexOf | Array[3] | 4 | 14.334 ns | 0.1758 ns | 0.1558 ns | 0 B | | ManualIndexOf | Array[3] | 4 | 2.758 ns | 0.0905 ns | 0.1208 ns | 0 B | | ArrayIndexOf | Array[100] | 101 | 78.359 ns | 1.8853 ns | 2.0955 ns | 0 B | | ManualIndexOf | Array[100] | 101 | 80.421 ns | 0.6391 ns | 0.5978 ns | 0 B | Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroArrayParam Sample: IntroArgumentsPriority Like Params also Argument columns can be sorted in the table result through their Priority. The priority should be defined only once for multiple Arguments and will keep their inner order as they are defined in the method. Source code using System.Collections.Generic; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArgumentsPriority { [Params(100, Priority = 0)] // Argument priority can be combined with Params priority public int A { get; set; } [Arguments(5, Priority = -10)] // Define priority just once for multiple argument attributes [Arguments(10)] [Arguments(20)] [Benchmark] public void Benchmark(int b) => Thread.Sleep(A + b); [Benchmark] [ArgumentsSource(nameof(Numbers), Priority = 10)] public void ManyArguments(int c, int d) => Thread.Sleep(A + c + d); public IEnumerable<object[]> Numbers() { yield return new object[] { 1, 2 }; } } } Output | Method | b | A | c | d | Mean | Error | StdDev | |-------------- |--- |---- |-- |-- |---------:|--------:|--------:| | ManyArguments | ? | 100 | 1 | 2 | 103.4 ms | 0.09 ms | 0.08 ms | | Benchmark | 5 | 100 | ? | ? | 105.5 ms | 0.21 ms | 0.19 ms | | Benchmark | 10 | 100 | ? | ? | 110.5 ms | 0.14 ms | 0.14 ms | | Benchmark | 20 | 100 | ? | ? | 120.4 ms | 0.16 ms | 0.15 ms | Links Priority BaseClass PriorityAttribute.cs Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroArgumentsPriority"
  },
  "articles/features/setup-and-cleanup.html": {
    "href": "articles/features/setup-and-cleanup.html",
    "title": "Setup And Cleanup | BenchmarkDotNet",
    "summary": "Setup And Cleanup Sometimes we want to write some logic which should be executed before or after a benchmark, but we don't want to measure it. For this purpose, BenchmarkDotNet provides a set of attributes: [GlobalSetup], [GlobalCleanup], [IterationSetup], [IterationCleanup]. Sample: IntroSetupCleanupGlobal A method which is marked by the [GlobalSetup] attribute will be executed only once per a benchmarked method after initialization of benchmark parameters and before all the benchmark method invocations. A method which is marked by the [GlobalCleanup] attribute will be executed only once per a benchmarked method after all the benchmark method invocations. If you are using some unmanaged resources (e.g., which were created in the GlobalSetup method), they can be disposed in the GlobalCleanup method. Source code using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroSetupCleanupGlobal { [Params(10, 100, 1000)] public int N; private int[] data; [GlobalSetup] public void GlobalSetup() { data = new int[N]; // executed once per each N value } [Benchmark] public int Logic() { int res = 0; for (int i = 0; i < N; i++) res += data[i]; return res; } [GlobalCleanup] public void GlobalCleanup() { // Disposing logic } } } Links Setup And Cleanup The permanent link to this sample: BenchmarkDotNet.Samples.IntroSetupCleanupGlobal Sample: IntroSetupCleanupIteration A method which is marked by the [IterationSetup] attribute will be executed exactly once before each benchmark invocation, forcing UnrollFactor=1 and InvocationCount=1 (we have changed that in 0.11.0). It's not recommended to use this attribute in microbenchmarks because it can spoil the results. However, if you are writing a macrobenchmark (e.g. a benchmark which takes at least 100ms) and you want to prepare some data before each invocation, [IterationSetup] can be useful. A method which is marked by the [IterationCleanup] attribute will be executed exactly once after each invocation. This attribute has the same set of constraint with [IterationSetup]: it's not recommended to use [IterationCleanup] in microbenchmarks. Source code using System; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.Monitoring, launchCount: 1, warmupCount: 2, iterationCount: 3)] public class IntroSetupCleanupIteration { private int setupCounter; private int cleanupCounter; [IterationSetup] public void IterationSetup() => Console.WriteLine($\"// IterationSetup ({++setupCounter})\"); [IterationCleanup] public void IterationCleanup() => Console.WriteLine($\"// IterationCleanup ({++cleanupCounter})\"); [GlobalSetup] public void GlobalSetup() => Console.WriteLine(\"// \" + \"GlobalSetup\"); [GlobalCleanup] public void GlobalCleanup() => Console.WriteLine(\"// \" + \"GlobalCleanup\"); [Benchmark] public void Benchmark() => Console.WriteLine(\"// \" + \"Benchmark\"); } } The order of method calls // GlobalSetup // IterationSetup (1) // IterationSetup Jitting // IterationCleanup (1) // IterationCleanup Jitting // IterationSetup (2) // MainWarmup1 // Benchmark // MainWarmup1 // IterationCleanup (2) // MainWarmup1 // IterationSetup (3) // MainWarmup2 // Benchmark // MainWarmup2 // IterationCleanup (3) // MainWarmup2 // IterationSetup (4) // MainTarget1 // Benchmark // MainTarget1 // IterationCleanup (4) // MainTarget1 // IterationSetup (5) // MainTarget2 // Benchmark // MainTarget2 // IterationCleanup (5) // MainTarget2 // IterationSetup (6) // MainTarget3 // Benchmark // MainTarget3 // IterationCleanup (6) // MainTarget3 // GlobalCleanup Links Setup And Cleanup The permanent link to this sample: BenchmarkDotNet.Samples.IntroSetupCleanupIteration Sample: IntroSetupCleanupTarget Sometimes it's useful to run setup or cleanups for specific benchmarks. All four setup and cleanup attributes have a Target property that allow the setup/cleanup method to be run for one or more specific benchmark methods. Source code using System; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.Monitoring, launchCount: 0, warmupCount: 0, iterationCount: 1)] public class IntroSetupCleanupTarget { [GlobalSetup(Target = nameof(BenchmarkA))] public void GlobalSetupA() => Console.WriteLine(\"// \" + \"GlobalSetup A\"); [Benchmark] public void BenchmarkA() => Console.WriteLine(\"// \" + \"Benchmark A\"); [GlobalSetup(Targets = new[] { nameof(BenchmarkB), nameof(BenchmarkC) })] public void GlobalSetupB() => Console.WriteLine(\"// \" + \"GlobalSetup B\"); [Benchmark] public void BenchmarkB() => Console.WriteLine(\"// \" + \"Benchmark B\"); [Benchmark] public void BenchmarkC() => Console.WriteLine(\"// \" + \"Benchmark C\"); [Benchmark] public void BenchmarkD() => Console.WriteLine(\"// \" + \"Benchmark D\"); } } The order of method calls // GlobalSetup A // Benchmark A // GlobalSetup B // Benchmark B // GlobalSetup B // Benchmark C // Benchmark D Links Setup And Cleanup The permanent link to this sample: BenchmarkDotNet.Samples.IntroSetupCleanupTarget"
  },
  "articles/features/statistics.html": {
    "href": "articles/features/statistics.html",
    "title": "Statistics | BenchmarkDotNet",
    "summary": "Statistics Sample: IntroStatisticsColumns Source code using System; using System.Security.Cryptography; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [MediumRunJob, SkewnessColumn, KurtosisColumn] public class IntroStatisticsColumns { private const int N = 10000; private readonly byte[] data; private readonly MD5 md5 = MD5.Create(); private readonly SHA256 sha256 = SHA256.Create(); public IntroStatisticsColumns() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark(Baseline = true)] public byte[] Md5A() => md5.ComputeHash(data); [Benchmark] public byte[] Md5B() => md5.ComputeHash(data); [Benchmark] public byte[] Sha256() => sha256.ComputeHash(data); } } Output Method Mean Error StdDev Skewness Kurtosis Ratio RatioSD Md5A 15.91 us 0.0807 us 0.1209 us 0.4067 1.646 1.00 0.00 Md5B 15.89 us 0.0709 us 0.1062 us 0.5893 2.141 1.00 0.01 Sha256 36.62 us 0.6390 us 0.9564 us 1.1363 4.014 2.30 0.06 Links Statistics The permanent link to this sample: BenchmarkDotNet.Samples.IntroStatisticsColumns Sample: IntroPercentiles The percentile represents a higher boundary for specified percentage of the measurements. For example, 95th percentile = 500ms means that 95% of all samples are not slower than 500ms. This metric is not very useful in microbenchmarks, as the values from consequent runs have a very narrow distribution. However, real-world scenarios often have so-called long tail distribution (due to IO delays, locks, memory access latency and so on), so the average execution time cannot be trusted. The percentiles allow to include the tail of distribution into the comparison. However, it requires some preparations steps. At first, you should have enough runs to count percentiles from. The IterationCount in the config should be set to 10-20 runs at least. Second, the count of iterations for each run should not be very high, or the peak timings will be averaged. The IterationTime = 25 works fine for most cases; for long-running benchmarks the Mode = Mode.SingleRun will be the best choice. However, feel free to experiment with the config values. Third, if you want to be sure that measurements are repeatable, set the LaunchCount to 3 or higher. And last, don't forget to include the columns into the config. They are not included by default (as said above, these are not too useful for most of the benchmarks). There're predefined StatisticColumn.P0..StatisticColumn.P100 for absolute timing percentiles. Example Run the IntroPercentiles sample. It contains three benchmark methods. First delays for 20 ms constantly. The second has random delays for 10..30 ms. And the third delays for 10ms 85 times of 100 and delays for 40ms 15 times of 100. Here's the output from the benchmark (some columns removed for brevity): Method Median StdDev Ratio P0 P50 P80 P85 P95 P100 ConstantDelays 20.3813 ms 0.2051 ms 1.00 20.0272 ms 20.3813 ms 20.4895 ms 20.4954 ms 20.5869 ms 21.1471 ms RandomDelays 19.8055 ms 5.7556 ms 0.97 10.0793 ms 19.8055 ms 25.4173 ms 26.5187 ms 29.0313 ms 29.4550 ms RareDelays 10.3385 ms 11.4828 ms 0.51 10.0157 ms 10.3385 ms 10.5211 ms 40.0560 ms 40.3992 ms 40.4674 ms Also, it's very easy to screw the results with incorrect setup. For example, the same code being run with new Job { IterationCount = 5, IterationTime = 500 } completely hides the peak values: Method Median StdDev Ratio P0 P50 P80 P85 P95 P100 ConstantDelays 20.2692 ms 0.0308 ms 1.00 20.1986 ms 20.2692 ms 20.2843 ms 20.2968 ms 20.3097 ms 20.3122 ms RandomDelays 18.9965 ms 0.8601 ms 0.94 18.1339 ms 18.9965 ms 19.8126 ms 19.8278 ms 20.4485 ms 20.9466 ms RareDelays 14.0912 ms 2.8619 ms 0.70 10.2606 ms 14.0912 ms 15.7653 ms 17.3862 ms 18.6728 ms 18.6940 ms Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Columns; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { // Using percentiles for adequate timings representation [Config(typeof(Config))] [SimpleJob(RunStrategy.ColdStart, launchCount: 4, warmupCount: 3, iterationCount: 20, id: \"MyJob\")] public class IntroPercentiles { // To share between runs. // DO NOT do this in production code. The System.Random IS NOT thread safe. private static readonly Random Rnd = new Random(); private class Config : ManualConfig { public Config() { AddColumn( StatisticColumn.P0, StatisticColumn.P25, StatisticColumn.P50, StatisticColumn.P67, StatisticColumn.P80, StatisticColumn.P85, StatisticColumn.P90, StatisticColumn.P95, StatisticColumn.P100); } } [Benchmark(Baseline = true)] public void ConstantDelays() => Thread.Sleep(20); [Benchmark] public void RandomDelays() => Thread.Sleep(10 + (int) (20 * Rnd.NextDouble())); [Benchmark] public void RareDelays() { int rndTime = 10; // Bigger delays for 15% of the runs if (Rnd.NextDouble() > 0.85) { rndTime += 30; } Thread.Sleep(rndTime); } } } Links Statistics The permanent link to this sample: BenchmarkDotNet.Samples.IntroPercentiles Sample: IntroRankColumn Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Mathematics; using BenchmarkDotNet.Order; namespace BenchmarkDotNet.Samples { [ShortRunJob] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [RankColumn(NumeralSystem.Arabic)] [RankColumn(NumeralSystem.Roman)] [RankColumn(NumeralSystem.Stars)] public class IntroRankColumn { [Params(1, 2)] public int Factor; [Benchmark] public void Foo() => Thread.Sleep(Factor * 100); [Benchmark] public void Bar() => Thread.Sleep(Factor * 200); } } Output Method | Factor | Mean | Error | StdDev | Rank | Rank | Rank | ------- |------- |---------:|---------:|----------:|-----:|-----:|-----:| Foo | 1 | 100.8 ms | 2.250 ms | 0.1272 ms | 1 | I | * | Foo | 2 | 200.8 ms | 4.674 ms | 0.2641 ms | 2 | II | ** | Bar | 1 | 200.9 ms | 2.012 ms | 0.1137 ms | 2 | II | ** | Bar | 2 | 400.7 ms | 4.509 ms | 0.2548 ms | 3 | III | *** | Links Statistics The permanent link to this sample: BenchmarkDotNet.Samples.IntroRankColumn Sample: IntroMultimodal Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [MValueColumn] [SimpleJob(RunStrategy.Throughput, 1, 0, -1, 1, \"MyJob\")] public class IntroMultimodal { private readonly Random rnd = new Random(42); private void Multimodal(int n) => Thread.Sleep((rnd.Next(n) + 1) * 100); [Benchmark] public void Unimodal() => Multimodal(1); [Benchmark] public void Bimodal() => Multimodal(2); [Benchmark] public void Trimodal() => Multimodal(3); [Benchmark] public void Quadrimodal() => Multimodal(4); } } Output Method | Mean | Error | StdDev | Median | MValue | ------------ |---------:|-----------:|------------:|---------:|-------:| Unimodal | 100.5 ms | 0.0713 ms | 0.0667 ms | 100.5 ms | 2.000 | Bimodal | 144.5 ms | 16.9165 ms | 49.8787 ms | 100.6 ms | 3.571 | Trimodal | 182.5 ms | 27.4285 ms | 80.8734 ms | 200.5 ms | 4.651 | Quadrimodal | 226.6 ms | 37.2269 ms | 109.7644 ms | 200.7 ms | 5.882 | // * Warnings * MultimodalDistribution IntroMultimodal.Bimodal: MainJob -> It seems that the distribution is bimodal (mValue = 3.57) IntroMultimodal.Trimodal: MainJob -> It seems that the distribution is multimodal (mValue = 4.65) IntroMultimodal.Quadrimodal: MainJob -> It seems that the distribution is multimodal (mValue = 5.88) Links Statistics The permanent link to this sample: BenchmarkDotNet.Samples.IntroMultimodal Sample: IntroOutliers Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; using Perfolizer.Mathematics.OutlierDetection; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] public class IntroOutliers { private class Config : ManualConfig { public Config() { var jobBase = Job.Default.WithWarmupCount(0).WithIterationCount(10).WithInvocationCount(1).WithUnrollFactor(1); AddJob(jobBase.WithOutlierMode(OutlierMode.DontRemove).WithId(\"DontRemoveOutliers\")); AddJob(jobBase.WithOutlierMode(OutlierMode.RemoveUpper).WithId(\"RemoveUpperOutliers\")); } } private int counter; [Benchmark] public void Foo() { counter++; int noise = counter % 10 == 0 ? 500 : 0; Thread.Sleep(100 + noise); } } } Output Method | Job | OutlierMode | Mean | Error | StdDev | ------- |-------------------- |------------ |---------:|------------:|------------:| Foo | DontRemoveOutliers | DontRemove | 150.5 ms | 239.1911 ms | 158.2101 ms | Foo | RemoveUpperOutliers | RemoveUpper | 100.5 ms | 0.1931 ms | 0.1149 ms | // * Hints * Outliers IntroOutliers.Foo: DontRemoveOutliers -> 1 outlier was detected IntroOutliers.Foo: RemoveUpperOutliers -> 1 outlier was removed Links Statistics The permanent link to this sample: BenchmarkDotNet.Samples.IntroOutliers"
  },
  "articles/features/vsprofiler.html": {
    "href": "articles/features/vsprofiler.html",
    "title": "Running with Visual Studio profiler | BenchmarkDotNet",
    "summary": "Running with Visual Studio profiler Visual Studio supports profiler integration with BenchmarkDotNet on Windows through its Microsoft.VisualStudio.BenchmarkDotNetDiagnosers NuGet package. Once installed, Visual Studio specific diagnosers will capture performance data in runs and automatically open traces if launched through Visual Studio How it works First, install the Microsoft.VisualStudio.BenchmarkDotNetDiagnosers NuGet package in your benchmarking project. Next add one or more of the Visual Studio diagnosers to your benchmark to capture the relevant profiling information while benchmarking. Lastly, run your benchmarks and a diagsession will be generated. If run from Visual Studio the diagsession will automatically be opened. Available Diagnosers [CPUUsageDiagnoser] - Enables the CPU Usage tool. [DatabaseDiagnoser] - Enables the Database tool [DotNetCountersDiagnoser] - Enables the .NET Counters tool [DotNetObjectAllocDiagnoser] - Enables the .NET Object Allocation tool. When using this tool, you must also specify [DotNetObjectAllocJobConfiguration] on the benchmark. If this is missing the run will fail and you will receive an error indicating you need to add it. [EventsDiagnoser] - Enables the Events tool [FileIODiagnoser] - Enables the File IO tool How to use it? After installing the Microsoft.VisualStudio.BenchmarkDotNetDiagnosers NuGet package add the following code as a benchmark: using System; using System.Security.Cryptography; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; using Microsoft.VSDiagnostics; namespace MyBenchmarks { [CPUUsageDiagnoser] public class Md5VsSha256 { private const int N = 10000; private readonly byte[] data; private readonly SHA256 sha256 = SHA256.Create(); private readonly MD5 md5 = MD5.Create(); public Md5VsSha256() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark] public byte[] Sha256() => sha256.ComputeHash(data); [Benchmark] public byte[] Md5() => md5.ComputeHash(data); } public class Program { public static void Main(string[] args) { var summary = BenchmarkRunner.Run(typeof(Program).Assembly); } } } In this case we have added the [CpuUsageDiagnoser] to capture a CPU sampling trace. From here run the benchmark in Visual Studio (Ctrl+F5), and after the benchmark run the resulting diagsession will be displayed. Double clicking on one of the benchmark rows shown under the Benchmarks tab will filter the time selection to the specific benchmark allowing you to better isolate and investigate."
  },
  "articles/features/vstest.html": {
    "href": "articles/features/vstest.html",
    "title": "Running with VSTest | BenchmarkDotNet",
    "summary": "Running with VSTest BenchmarkDotNet supports discovering and executing benchmarks through VSTest. This provides an alternative user experience to running benchmarks with the CLI and may be preferable for those who like their IDE's VSTest integrations that they may have used when running unit tests. Below is an example of running some benchmarks from the BenchmarkDotNet samples project in Visual Studio's Test Explorer. About VSTest VSTest is one of the most popular test platforms in use in the .NET ecosystem, with test frameworks such as MSTest, xUnit, and NUnit providing support for it. Many IDEs, including Visual Studio and Rider, provide UIs for running tests through VSTest which some users may find more accessible than running them through the command line. It may seem counterintuitive to run performance tests on a platform that is designed for unit tests that expect a boolean outcome of \"Passed\" or \"Failed\". However, VSTest provides good value as a protocol for discovering and executing tests. In addition, we can still make use of this boolean output to indicate if the benchmark had validation errors that caused it to fail to run. Caveats and things to know The benchmark measurements may be affected by the VSTest host and your IDE! If you want to have accurate measurements, it is recommended to run benchmarks through the CLI without other processes on the machine impacting performance. This does not mean that the measurements are useless though, it will still be able to provide useful measurements during development when comparing different approaches. The test adapter will not display or execute benchmarks if optimizations are disabled. Please ensure you are compiling in Release mode or with Optimize set to true. Using an InProcess toolchain will let you run your benchmarks with optimizations disabled and will let you attach the debugger as well. The VSTest adapter will not call your application's entry point. If you use the entry point to customize how your benchmarks are run, you will need to do this through other means such as an assembly-level IConfigSource, as shown here. The test adapter will generate an entry point for you automatically. The generated entry point will pass the command line arguments and the current assembly into BenchmarkSwitcher, so you can still use it in your CLI as well as in VSTest. This means you can delete your entry point and only need to define your benchmarks. If you want to use a custom entry point, you can still do so by setting GenerateProgramFile to false in your project file. Getting started Step 1. Install the NuGet packages. You need to install two packages into your benchmark project: BenchmarkDotNet.TestAdapter: Implements the VSTest protocol for BenchmarkDotNet Microsoft.NET.Test.Sdk: Includes all the pieces needed for the VSTest host to run and load the VSTest adapter. Step 2. Make sure that the entry point is configured correctly. As mentioned in the caveats section, BenchmarkDotNet.TestAdapter will generate an entry point for you automatically. So, if you have an entry point already, you will either need to delete it or set GenerateProgramFile to false in your project file to continue using your existing one. Here is an example of a .csproj file based on the default Console Application template: <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <OutputType>Exe</OutputType> <TargetFramework>net8.0</TargetFramework> <ImplicitUsings>enable</ImplicitUsings> <Nullable>enable</Nullable> <!-- Disable entry point generation as this project has it's own entry point --> <GenerateProgramFile>false</GenerateProgramFile> </PropertyGroup> <ItemGroup> <PackageReference Include=\"BenchmarkDotNet.TestAdapter\" Version=\"0.13.12\" /> <PackageReference Include=\"Microsoft.NET.Test.Sdk\" Version=\"17.8.0\" /> </ItemGroup> </Project> Step 3. Make sure that your IDE supports VSTest integration. In Visual Studio, everything works out of the box. In Rider/R# 2023.3, the VSTest integration should be activated: Go to the \"Unit Testing\" settings page. Rider: Settings -> Build, Execution, Deployment -> Unit Testing -> VSTest R#: Extensions -> ReSharper -> Options -> Tools -> Unit Testing -> Test Frameworks -> VSTest Make sure that the \"Enable VSTest adapter support\" checkbox is checked. In future versions of Rider, this should be enabled by default. Step 4. Switch to the Release configuration. As mentioned above, the TestAdapter is not able to discover and run benchmarks with optimizations disabled (by design). Step 5. Build the project. In order to discover the benchmarks, the VSTest adapter needs to be able to find the assembly. Once you build the project, you should observe the discovered benchmarks in your IDE's Unit Test Explorer. If you correctly performed all the steps above, you should be able to run your benchmarks in your IDE using embedded unit testing features. If this doesn't work for you, don't hesitate to file a new GitHub issue. Setting a default configuration Previously, it was common for the default configuration to be defined inside the entry point. Since the entry point is not used when running benchmarks through VSTest, the default configuration must be specified using a Config attribute that is set on the assembly instead. First, create a class that extends ManualConfig or IConfig which sets the default configuration you want: class MyDefaultConfig : ManualConfig { public MyDefaultConfig() { AddJob(Job.Dry); AddLogger(Loggers.ConsoleLogger.Default); AddValidator(JitOptimizationsValidator.DontFailOnError); } } Then, set an assembly attribute with the following. [assembly: Config(typeof(MyDefaultConfig))] By convention, assembly attributes are usually defined inside AssemblyInfo.cs in a directory called Properties. Viewing the results The full output from BenchmarkDotNet that you would have been used to seeing in the past will be sent to the \"Tests\" output of your IDE. Use this view if you want to see the tabular view that compares multiple benchmarks with each other or if you want to see the results for each individual iteration. One more place where you can view the results is in each individual test's output messages. In Visual Studio, this can be viewed by clicking on the test in the Test Explorer after running it and looking at the Test Detail Summary. Since this only displays statistics for a single benchmark case, it does not show the tabulated view that compares multiple benchmark cases. Instead, it displays a histogram and various other useful statistics. Not all IDEs support displaying these output messages, so you may only be able to view the results using the \"Tests\" output."
  },
  "articles/guides/choosing-run-strategy.html": {
    "href": "articles/guides/choosing-run-strategy.html",
    "title": "Choosing RunStrategy | BenchmarkDotNet",
    "summary": "Choosing RunStrategy If you run a benchmark, you always (explicitly or implicitly) use a job. Each Job has the RunStrategy parameter which allows switching between different benchmark modes. The default RunStrategy is Throughput, and it works fine for most cases. However, other strategies are also useful in some specific cases. Throughput Throughput is the default RunStrategy, works perfectly for microbenchmarking. It's automatically choosing the amount of operation in main iterations based on a set of pilot iterations. The amount of iterations will also be chosen automatically based on accuracy job settings. A benchmark method should have a steady state. Of course, you can manually set all the characteristics. An example: [SimpleJob(launchCount: 3, warmupCount: 10, iterationCount: 30)] public class MyBenchmarkClass Sample: IntroColdStart If you want to measure cold start (without the pilot and warmup stage), the ColdStart strategy is your choice. Usage [SimpleJob(RunStrategy.ColdStart, launchCount:50)] public class MyBenchmarkClass Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.ColdStart, iterationCount: 5)] [MinColumn, MaxColumn, MeanColumn, MedianColumn] public class IntroColdStart { private bool firstCall; [Benchmark] public void Foo() { if (firstCall == false) { firstCall = true; Console.WriteLine(\"// First call\"); Thread.Sleep(1000); } else Thread.Sleep(10); } } } Output Result 1: 1 op, 1002034900.00 ns, 1.0020 s/op Result 2: 1 op, 10219700.00 ns, 10.2197 ms/op Result 3: 1 op, 10406200.00 ns, 10.4062 ms/op Result 4: 1 op, 10473900.00 ns, 10.4739 ms/op Result 5: 1 op, 10449400.00 ns, 10.4494 ms/op Method | Mean | Error | StdDev | Min | Max | Median | ------- |---------:|-----------:|---------:|---------:|-----------:|---------:| Foo | 208.7 ms | 1,707.4 ms | 443.5 ms | 10.22 ms | 1,002.0 ms | 10.45 ms | Links Choosing RunStrategy The permanent link to this sample: BenchmarkDotNet.Samples.IntroColdStart Sample: IntroMonitoring If a benchmark method takes at least 100ms, you can also use the Monitoring strategy. In this case, the pilot stage will be omitted, by default you get 1 iteration = 1 operation (or you can manually set amount of operation in an iteration). Also you can use [IterationSetup] and [IterationCleanup] in this case: it shouldn't affect time measurements (but it can affect results of MemoryDiagnoser). It's a perfect mode for benchmarks which doesn't have a steady state and the performance distribution is tricky: Monitoring will help you to collect a set of measurements and get statistics. Usage [SimpleJob(RunStrategy.Monitoring, launchCount: 10, warmupCount: 0, iterationCount: 100)] public class MyBenchmarkClass Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.Monitoring, iterationCount: 10, id: \"MonitoringJob\")] [MinColumn, Q1Column, Q3Column, MaxColumn] public class IntroMonitoring { private Random random = new Random(42); [Benchmark] public void Foo() { Thread.Sleep(random.Next(10) * 10); } } } Output Result 1: 1 op, 61552600.00 ns, 61.5526 ms/op Result 2: 1 op, 10141700.00 ns, 10.1417 ms/op Result 3: 1 op, 10482900.00 ns, 10.4829 ms/op Result 4: 1 op, 50410900.00 ns, 50.4109 ms/op Result 5: 1 op, 10421400.00 ns, 10.4214 ms/op Result 6: 1 op, 20556100.00 ns, 20.5561 ms/op Result 7: 1 op, 70473200.00 ns, 70.4732 ms/op Result 8: 1 op, 50581700.00 ns, 50.5817 ms/op Result 9: 1 op, 10559000.00 ns, 10.5590 ms/op Result 10: 1 op, 70496300.00 ns, 70.4963 ms/op Method Mean Error StdDev Min Q1 Q3 Max Foo 36.57 ms 40.03 ms 26.47 ms 10.14 ms 10.48 ms 61.55 ms 70.50 ms Links Choosing RunStrategy The permanent link to this sample: BenchmarkDotNet.Samples.IntroMonitoring"
  },
  "articles/guides/console-args.html": {
    "href": "articles/guides/console-args.html",
    "title": "How to use console arguments | BenchmarkDotNet",
    "summary": "How to use console arguments BenchmarkSwitcher supports various console arguments, to make it work you need to pass the args to switcher: class Program { static void Main(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args); } Note: the docs that you are currently reading might get outdated, to get the most up-to-date info about supported console arguments run the benchmarks with --help. Filter The --filter or just -f allows you to filter the benchmarks by their full name (namespace.typeName.methodName) using glob patterns. Examples: Run all benchmarks from System.Memory namespace: -f 'System.Memory*' Run all benchmarks: -f '*' Run all benchmarks from ClassA and ClassB -f '*ClassA*' '*ClassB*' Note: If you would like to join all the results into a single summary, you need to put --join. For example: -f '*ClassA*' '*ClassB*' --join List of benchmarks The --list allows you to print all of the available benchmark names. Available options are: flat - prints list of the available benchmarks: --list flat BenchmarkDotNet.Samples.Algo_Md5VsSha256.Md5 BenchmarkDotNet.Samples.Algo_Md5VsSha256.Sha256 BenchmarkDotNet.Samples.IntroArguments.Benchmark BenchmarkDotNet.Samples.IntroArgumentsSource.SingleArgument BenchmarkDotNet.Samples.IntroArgumentsSource.ManyArguments BenchmarkDotNet.Samples.IntroArrayParam.ArrayIndexOf BenchmarkDotNet.Samples.IntroArrayParam.ManualIndexOf BenchmarkDotNet.Samples.IntroBasic.Sleep [...] tree - prints tree of the available benchmarks: --list tree BenchmarkDotNet └─Samples ├─Algo_Md5VsSha256 │ ├─Md5 │ └─Sha256 ├─IntroArguments │ └─Benchmark ├─IntroArgumentsSource │ ├─SingleArgument │ └─ManyArguments ├─IntroArrayParam │ ├─ArrayIndexOf │ └─ManualIndexOf ├─IntroBasic │ ├─Sleep [...] The --list option works with the --filter option. Examples: --list flat --filter *IntroSetupCleanup* prints: BenchmarkDotNet.Samples.IntroSetupCleanupGlobal.Logic BenchmarkDotNet.Samples.IntroSetupCleanupIteration.Benchmark BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkA BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkB BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkC BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkD --list tree --filter *IntroSetupCleanup* prints: BenchmarkDotNet └─Samples ├─IntroSetupCleanupGlobal │ └─Logic ├─IntroSetupCleanupIteration │ └─Benchmark └─IntroSetupCleanupTarget ├─BenchmarkA ├─BenchmarkB ├─BenchmarkC └─BenchmarkD Categories You can also filter the benchmarks by categories: --anyCategories - runs all benchmarks that belong to any of the provided categories --allCategories- runs all benchmarks that belong to all provided categories Diagnosers -m, --memory - enables MemoryDiagnoser and prints memory statistics -t, --threading - enables ThreadingDiagnoser and prints threading statistics -d, --disasm- enables DisassemblyDiagnoser and exports diassembly of benchmarked code. When you enable this option, you can use: --disasmDepth - Sets the recursive depth for the disassembler. --disasmDiff - Generates diff reports for the disassembler. Runtimes The --runtimes or just -r allows you to run the benchmarks for selected Runtimes. Available options are: Clr - BDN will either use Roslyn (if you run it as .NET app) or latest installed .NET SDK to build the benchmarks (if you run it as .NET Core app). Core - if you run it as .NET Core app, BDN will use the same target framework moniker, if you run it as .NET app it's going to use net8.0. Mono - it's going to use the Mono from $Path, you can override it with --monoPath. net46, net461, net462, net47, net471, net472, net48, net481 - to build and run benchmarks against specific .NET Framework version. netcoreapp3.1, net5.0, net6.0, net7.0, net8.0 - to build and run benchmarks against specific .NET (Core) version. nativeaot5.0, nativeaot6.0, nativeaot7.0, nativeaot8.0 - to build and run benchmarks using NativeAOT. Can be customized with additional options: --ilcPackages, --ilCompilerVersion. mono6.0, mono7.0, mono8.0 - to build and run benchmarks with .Net 6+ using MonoVM. Example: run the benchmarks for .NET 4.7.2 and .NET 8.0: dotnet run -c Release -- --runtimes net472 net8.0 Example: run the benchmarks for .NET Core 3.1 and latest .NET SDK installed on your PC: dotnet run -c Release -f netcoreapp3.1 -- --runtimes clr core But same command executed with -f net6.0 is going to run the benchmarks for .NET 6.0: dotnet run -c Release -f net6.0 -- --runtimes clr core Number of invocations and iterations --launchCount - how many times we should launch process with target benchmark. The default is 1. --warmupCount - how many warmup iterations should be performed. If you set it, the minWarmupCount and maxWarmupCount are ignored. By default calculated by the heuristic. --minWarmupCount - minimum count of warmup iterations that should be performed. The default is 6. --maxWarmupCount - maximum count of warmup iterations that should be performed. The default is 50. --iterationTime - desired time of execution of an iteration. Used by Pilot stage to estimate the number of invocations per iteration. 500ms by default. --iterationCount - how many target iterations should be performed. By default calculated by the heuristic. --minIterationCount - minimum number of iterations to run. The default is 15. --maxIterationCount - maximum number of iterations to run. The default is 100. --invocationCount - invocation count in a single iteration. By default calculated by the heuristic. --unrollFactor - how many times the benchmark method will be invoked per one iteration of a generated loop. 16 by default --runOncePerIteration - run the benchmark exactly once per iteration. False by default. Example: run single warmup iteration, from 9 to 12 actual workload iterations. dotnet run -c Release -- --warmupCount 1 --minIterationCount 9 --maxIterationCount 12 Specifying custom default settings for console argument parser If you want to have a possibility to specify custom default Job settings programmatically and optionally overwrite it with console line arguments, then you should create a global config with single job marked as .AsDefault and pass it to BenchmarkSwitcher together with the console line arguments. Example: run single warmup iteration by default. static void Main(string[] args) => BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args, GetGlobalConfig()); static IConfig GetGlobalConfig() => DefaultConfig.Instance .With(Job.Default .WithWarmupCount(1) .AsDefault()); // the KEY to get it working Now, the default settings are: WarmupCount=1 but you might still overwrite it from console args like in the example below: dotnet run -c Release -- --warmupCount 2 Response files support Benchmark.NET supports parsing parameters via response files. for example you can create file run.rsp with following content --warmupCount 1 --minIterationCount 9 --maxIterationCount 12 and run it using dotnet run -c Release -- @run.rsp. It would be equivalent to running following command line dotnet run -c Release -- --warmupCount 1 --minIterationCount 9 --maxIterationCount 12 Statistical Test To perform a Mann–Whitney U Test and display the results in a dedicated column you need to provide the Threshold: --statisticalTest- Threshold for Mann–Whitney U Test. Examples: 5%, 10ms, 100ns, 1s Example: run Mann–Whitney U test with relative ratio of 5% for all benchmarks for .NET 6.0 (base) vs .NET 8.0 (diff). .NET 6.0 will be baseline because it was first. dotnet run -c Release -- --filter * --runtimes net6.0 net8.0 --statisticalTest 5% More -j, --job (Default: Default) Dry/Short/Medium/Long or Default. -e, --exporters GitHub/StackOverflow/RPlot/CSV/JSON/HTML/XML. -i, --inProcess (default: false) run benchmarks in the same process, without spawning child process per benchmark. -a, --artifacts valid path to an accessible directory where output artifacts will be stored. --outliers (default: RemoveUpper) DontRemove/RemoveUpper/RemoveLower/RemoveAll. --affinity affinity mask to set for the benchmark process. --allStats (default: false) Displays all statistics (min, max & more). --allCategories categories to run. If few are provided, only the benchmarks which belong to all of them are going to be executed. --attribute run all methods with given attribute (applied to class or method). --monoPath optional path to Mono which should be used for running benchmarks. --cli path to dotnet cli (optional). --packages the directory to restore packages to (optional). --coreRun path(s) to CoreRun (optional). --ilcPackages path to ILCompiler for NativeAOT. --info prints environment configuration including BenchmarkDotNet, OS, CPU and .NET version --stopOnFirstError stop on first error. --help display this help screen. --version display version information. --keepFiles (default: false) determines if all auto-generated files should be kept or removed after running the benchmarks. --noOverwrite (default: false) determines if the exported result files should not be overwritten. --disableLogFile disables the log file. --maxWidth max parameter column width, the default is 20. --envVars colon separated environment variables (key:value). --strategy the RunStrategy that should be used. Throughput/ColdStart/Monitoring. --platform the Platform that should be used. If not specified, the host process platform is used (default). AnyCpu/X86/X64/Arm/Arm64/LoongArch64. --runOncePerIteration run the benchmark exactly once per iteration. --buildTimeout build timeout in seconds. --wakeLock prevents the system from entering sleep or turning off the display. None/System/Display. --wasmEngine full path to a java script engine used to run the benchmarks, used by Wasm toolchain. --wasmMainJS path to the test-main.js file used by Wasm toolchain. Mandatory when using \"--runtimes wasm\" --expose_wasm arguments for the JavaScript engine used by Wasm toolchain. --customRuntimePack specify the path to a custom runtime pack. Only used for wasm currently."
  },
  "articles/guides/customizing-runtime.html": {
    "href": "articles/guides/customizing-runtime.html",
    "title": "Customizing Runtime | BenchmarkDotNet",
    "summary": "Customizing Runtime Currently, we have only information about customizing Mono in this section. If you want to customize .NET Core, read an article about Toolchains. Sample: IntroCustomMono BenchmarkDotNet allows you to compare different runtimes, including Mono. If you apply [MonoJob] attribute to your class we use your default mono runtime. If you want to compare different versions of Mono you need to provide use the custom paths. You can do this today by using the overloaded ctor of MonoJob attribute or by specifying the runtime in a fluent way. The mono runtime can also operate as an ahead-of-time compiler. Using mono's AOT mode requires providing the AOT compilation arguments, as well as the path to mono's corlib. (See IntroCustomMonoObjectStyleAot in the below example). Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { // *** Attribute Style *** [MonoJob(\"Mono x64\", @\"C:\\Program Files\\Mono\\bin\\mono.exe\")] [MonoJob(\"Mono x86\", @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\")] public class IntroCustomMono { [Benchmark] public void Foo() { // Benchmark body } } // *** Object Style *** [Config(typeof(Config))] public class IntroCustomMonoObjectStyle { private class Config : ManualConfig { public Config() { AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x64\", @\"C:\\Program Files\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x86\", @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\"))); } } [Benchmark] public void Foo() { // Benchmark body } } // ** Object Style, Using AOT ** [Config(typeof(Config))] public class IntroCustomMonoObjectStyleAot { private class Config : ManualConfig { public void AddMono (string name, string mono_top_dir) { var aot_compile_args = \"--aot=llvm\"; var mono_bcl = $@\"{mono_top_dir}\\lib\\mono\\4.5\"; var mono_bin = $@\"{mono_top_dir}\\bin\\mono.exe\"; AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( name, mono_bin, aot_compile_args, mono_bcl))); } public Config() { AddMono(\"Mono x64\", @\"C:\\Program Files\\Mono\"); AddMono(\"Mono x86\", @\"C:\\Program Files (x86)\\Mono\"); } } [Benchmark] public void Foo() { // Benchmark body } } // *** Fluent Config *** public class IntroCustomMonoFluentConfig { public static void Run() { BenchmarkRunner.Run<IntroCustomMonoFluentConfig>(ManualConfig .CreateMinimumViable() .AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x64\", @\"C:\\Program Files\\Mono\\bin\\mono.exe\"))) .AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x86\", @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\")))); } [Benchmark] public void Foo() { // Benchmark body } } } Links Customizing Runtime The permanent link to this sample: BenchmarkDotNet.Samples.IntroCustomMono Sample: IntroCustomMonoArguments Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [Config(typeof(ConfigWithCustomArguments))] public class IntroCustomMonoArguments { public class ConfigWithCustomArguments : ManualConfig { public ConfigWithCustomArguments() { // --optimize=MODE , -O=mode // MODE is a comma separated list of optimizations. They also allow // optimizations to be turned off by prefixing the optimization // name with a minus sign. AddJob(Job.Default .WithRuntime(MonoRuntime.Default) .WithArguments(new[] { new MonoArgument(\"--optimize=inline\") }) .WithId(\"Inlining enabled\")); AddJob(Job.Default .WithRuntime(MonoRuntime.Default) .WithArguments(new[] { new MonoArgument(\"--optimize=-inline\") }) .WithId(\"Inlining disabled\")); } } [Benchmark] public void Sample() { ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); } private void ShouldGetInlined() { } } } Output | Method | Job | Arguments | Mean | StdDev | |------- |------------------ |------------------- |-----------:|----------:| | Sample | Inlining disabled | --optimize=-inline | 19.4252 ns | 0.4525 ns | | Sample | Inlining enabled | --optimize=inline | 0.0000 ns | 0.0000 ns | Links Customizing Runtime The permanent link to this sample: BenchmarkDotNet.Samples.IntroCustomMonoArguments Sample: IntroEnvVars You can configure custom environment variables for the process that is running your benchmarks. One reason for doing this might be checking out how different compilation, threading, garbage collector settings affect the performance of .NET Core. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [Config(typeof(ConfigWithCustomEnvVars))] public class IntroEnvVars { private class ConfigWithCustomEnvVars : ManualConfig { public ConfigWithCustomEnvVars() { AddJob(Job.Default.WithRuntime(CoreRuntime.Core80).WithId(\"Inlining enabled\")); AddJob(Job.Default.WithRuntime(CoreRuntime.Core80) .WithEnvironmentVariables([ new EnvironmentVariable(\"DOTNET_JitNoInline\", \"1\"), new EnvironmentVariable(\"COMPlus_JitNoInline\", \"1\") ]) .WithId(\"Inlining disabled\")); } } [Benchmark] public void Foo() { // Benchmark body } } } Links Customizing Runtime Configs Jobs The permanent link to this sample: BenchmarkDotNet.Samples.IntroEnvVars Sample: IntroStaThread If the code you want to benchmark requires [System.STAThread] then you need to apply this attribute to the benchmarked method. BenchmarkDotNet will generate an executable with [STAThread] applied to its Main method. Using this feature on .NET Core requires .NET Core 2.1 or newer. Older versions will not work due to this bug. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroStaThread { [Benchmark, System.STAThread] public void CheckForSTA() { if (Thread.CurrentThread.GetApartmentState() != ApartmentState.STA) { throw new ThreadStateException( \"The current threads apartment state is not STA\"); } } } } Links Customizing Runtime The permanent link to this sample: BenchmarkDotNet.Samples.IntroStaThread"
  },
  "articles/guides/dotnet-new-templates.html": {
    "href": "articles/guides/dotnet-new-templates.html",
    "title": "BenchmarkDotNet templates | BenchmarkDotNet",
    "summary": "BenchmarkDotNet templates BenchmarkDotNet provides project templates to setup your benchmarks easily. The template exists for each major .NET language (C#, F# and VB) with equivalent features and structure. How to install the templates The templates requires the .NET Core SDK. Once installed, run the following command to install the templates: dotnet new install BenchmarkDotNet.Templates If you want to uninstall all BenchmarkDotNet templates: dotnet new uninstall BenchmarkDotNet.Templates The template is a nuget package distributed over nuget: BenchmarkDotNet.Templates. Basic usage To create a new C# benchmark library project from the template, run: dotnet new benchmark If you'd like to create F# or VB project, you can specify project language with -lang option: dotnet new benchmark -lang F# dotnet new benchmark -lang VB Project template specific options The template projects has five additional options - all of them are optional. By default a console app project targeting net6.0 is created. This lets you run the benchmarks from console (dotnet run) or from your favorite IDE. The option -f or --framework changes the target framework: dotnet new benchmark -f net472 You can specify --console-app=false to create a class library project targeting netstandard2.0 by default: dotnet new benchmark --console-app=false The option -b or --benchmarkName sets the name of the benchmark class: dotnet new benchmark -b Md5VsSha256 BenchmarkDotNet lets you create a dedicated configuration class (see Configs) to customize the execution of your benchmarks. To create a benchmark project with a configuration class, use the option -c or --config: dotnet new benchmark -c The option --no-restore if specified, skips the automatic nuget restore after the project is created: dotnet new benchmark --no-restore Use the -h or --help option to display all possible arguments with a description and the default values: dotnet new benchmark --help How to run the benchmarks Please read how to run your benchmarks. The relationship of BenchmarkDotNet and BenchmarkDotNet.Templates The version of the template nuget package is synced with the BenchmarkDotNet package. For instance, the template version 0.11.5 is referencing BenchmarkDotnet 0.11.15 - there is no floating version behavior. Note: This will maybe change when BenchmarkDotNet reaches 1.x. References For more info about the dotnet new CLI, please read the documentation."
  },
  "articles/guides/getting-started.html": {
    "href": "articles/guides/getting-started.html",
    "title": "Getting started | BenchmarkDotNet",
    "summary": "Getting started To get started with BenchmarkDotNet, please follow these steps. Step 1. Create a project Create a new console application. Step 2. Installation Install BenchmarkDotNet via the NuGet package: BenchmarkDotNet > dotnet add package BenchmarkDotNet Read more about BenchmarkDotNet NuGet packages: Installing NuGet packages Step 3. Design a benchmark Write a class with methods that you want to measure and mark them with the Benchmark attribute. In the following example, we compare MD5 and SHA256 cryptographic hash functions: using System; using System.Security.Cryptography; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; namespace MyBenchmarks { public class Md5VsSha256 { private const int N = 10000; private readonly byte[] data; private readonly SHA256 sha256 = SHA256.Create(); private readonly MD5 md5 = MD5.Create(); public Md5VsSha256() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark] public byte[] Sha256() => sha256.ComputeHash(data); [Benchmark] public byte[] Md5() => md5.ComputeHash(data); } public class Program { public static void Main(string[] args) { var summary = BenchmarkRunner.Run<Md5VsSha256>(); } } } The BenchmarkRunner.Run<Md5VsSha256>() call runs your benchmarks and prints results to the console. Step 4. Run benchmarks Start your console application to run the benchmarks. The application must be built in the Release configuration. > dotnet run -c Release Step 5. View results View the results. Here is an example of output from the above benchmark: BenchmarkDotNet=v0.13.2, OS=Windows 10 (10.0.19045.2251) Intel Core i7-4770HQ CPU 2.20GHz (Haswell), 1 CPU, 8 logical and 4 physical cores .NET SDK=7.0.100 [Host] : .NET 7.0.0 (7.0.22.51805), X64 RyuJIT AVX2 DefaultJob : .NET 7.0.0 (7.0.22.51805), X64 RyuJIT AVX2 | Method | Mean | Error | StdDev | |------- |---------:|---------:|---------:| | Sha256 | 51.57 us | 0.311 us | 0.291 us | | Md5 | 21.91 us | 0.138 us | 0.129 us | Step 6. Analyze results BenchmarkDotNet will automatically create basic reports in the .\\BenchmarkDotNet.Artifacts\\results folder that can be shared and analyzed. To help analyze performance in further depth, you can configure your benchmark to collect and output more detailed information. Benchmark configuration can be conveniently changed by adding attributes to the class containing your benchmarks. For example: Diagnosers GC allocations: [MemoryDiagnoser] Code size and disassembly: [DisassemblyDiagnoser] Threading statistics: [ThreadingDiagnoser] Exporters CSV reports with raw data: [CsvMeasurementsExporter] JSON reports with raw data: [JsonExporter] Plots (if you have installed R): [RPlotExporter] For more information, see Configs. Next steps BenchmarkDotNet provides features which aid high-quality performance research. If you want to know more about BenchmarkDotNet features, check out the Overview page. If you have any questions, check out the FAQ page. If you didn't find an answer for your question on this page, ask it on Gitter or create an issue on GitHub."
  },
  "articles/guides/good-practices.html": {
    "href": "articles/guides/good-practices.html",
    "title": "Good Practices | BenchmarkDotNet",
    "summary": "Good Practices Use the Release build without an attached debugger Never use the Debug build for benchmarking. Never. The debug version of the target method can run 10–100 times slower. The release mode means that you should have <Optimize>true</Optimize> in your csproj file or use /optimize for csc. Also, never use an attached debugger (e.g. Visual Studio or WinDbg) during the benchmarking. The best way is build our benchmark in the Release mode and run it from the command line. Try different environments Please, don't extrapolate your results. Or do it very carefully. I remind you again: the results in different environments may vary significantly. If a Foo1 method is faster than a Foo2 method for CLR4, .NET Framework 4.5, x64, RyuJIT, Windows, it means that the Foo1 method is faster than the Foo2 method for CLR4, .NET Framework 4.5, x64, RyuJIT, Windows and nothing else. And you can not say anything about methods performance for CLR 2 or .NET Framework 4.6 or LegacyJIT-x64 or x86 or Linux+Mono until you try it. Avoid dead code elimination You should also use the result of calculation. For example, if you run the following code: void Foo() { Math.Exp(1); } then JIT can eliminate this code because the result of Math.Exp is not used. The better way is use it like this: double Foo() { return Math.Exp(1); } Power settings and other applications Turn off all of the applications except the benchmark process and the standard OS processes. If you run benchmark and work in the Visual Studio at the same time, it can negatively affect to benchmark results. If you use laptop for benchmarking, keep it plugged in and use the maximum performance mode."
  },
  "articles/guides/how-it-works.html": {
    "href": "articles/guides/how-it-works.html",
    "title": "How it works | BenchmarkDotNet",
    "summary": "How it works BenchmarkDotNet follows the following steps to run your benchmarks: BenchmarkRunner generates an isolated project per each runtime settings and builds it in Release mode. Next, we take each method/job/params combination and try to measure its performance by launching benchmark process several times (LaunchCount). An invocation of the workload method is an operation. A bunch of operation is an iteration. If you have an IterationSetup method, it will be invoked before each iteration, but not between operations. We have the following type of iterations: Pilot: The best operation count will be chosen. OverheadWarmup, OverheadWorkload: BenchmarkDotNet overhead will be evaluated. ActualWarmup: Warmup of the workload method. ActualWorkload: Actual measurements. Result = ActualWorkload - <MedianOverhead> After all of the measurements, BenchmarkDotNet creates: An instance of the Summary class that contains all information about benchmark runs. A set of files that contains summary in human-readable and machine-readable formats. A set of plots. Pseudocode If you don't understand our \"count terminology\", then you might find following pseudocode useful: IEnumerable<Results> Run(Benchmark benchmark) { var toolchain = benchmark.GetToolchain(); var autoGeneratedProject = toolchain.Generate(benchmark); var exe = toolchain.Build(autoGeneratedProject); foreach (var runIndex in LaunchCount) // LaunchCount = 1 by default yield return ParseResults(Process.Start(exe).Output); // calls ActualRun in a separate process } Result ActualRun(Method method, Job job) { GlobalSetup(); int unrollFactor = job.Run.UnrollFactor; // 16 by default long perfectInvocationCount = Pilot(method, unrollFactor); WarmupStage(EMPTY_METHOD, perfectInvocationCount, unrollFactor); // EMPTY_METHOD has same return type and arguments as benchmark var overhead = ActualStage(EMPTY_METHOD, perfectInvocationCount, unrollFactor); WarmupStage(method, perfectInvocationCount, unrollFactor); var result = ActualStage(method, perfectInvocationCount); if (MemoryDiagnoser.IsEnabled) var gcStats = MeasureGcStats(method, perfectInvocationCount, unrollFactor); GlobalCleanup(); return (result - Median(overhead), gcStats); } long Pilot(Method method, int unrollFactor) { // invokeCount is the equivalent of InnerIterationCount from xunit-performance long invokeCount = minInvokeCount; while (true) { var measurement = RunIteration(method, invokeCount, unrollFactor); if (heuristic.IsPilotRequirementMet(measurement)) break; invokeCount *= 2; } return invokeCount; } void Warmup(Method method, long invokeCount, int unrollFactor) { while (true) { var measurement = RunIteration(method, invokeCount, unrollFactor); if (heuristic.IsWarmupRequirementMet(measurement)) break; } } IEnuberable<Measurement> Workload(Method method, long invokeCount, int unrollFactor) { while (true) { var measurement = RunIteration(method, invokeCount, unrollFactor); if (measurement.IsNotOutlier) yield return measurement; if (heuristic.IsWorkloadRequirementMet(measurement)) yield break; } } // every iteration invokes the method (invokeCount / unrollFactor) times Measurement RunIteration(Method method, long invokeCount, long unrollFactor) { IterationSetup(); MemoryCleanup(); var clock = Clock.Start(); for (long i = 0; i < invokeCount / unrollFactor; i++) { // we perform manual loop unrolling!! method(); // 1st call method(); // 2nd call method(); // (unrollFactor - 1)'th call method(); // unrollFactor'th call } var clockSpan = clock.GetElapsed(); IterationCleanup(); MemoryCleanup(); return Measurement(clockSpan); } GcStats MeasureGcStats(Method method, long invokeCount, long unrollFacto) { // we enable monitoring after workload actual run, for this single iteration which is executed at the end // so even if we enable AppDomain monitoring in separate process // it does not matter, because we have already obtained the results! EnableMonitoring(); IterationSetup(); var initialGcStats = GcStats.ReadInitial(); // we do NOT start any clock here, because the enabled monitoring might have some overhead // so we just get the gc stats and ignore the timing // it's last thing the process does before it dies, so also enabled monitoring is not an issue for next benchmarks // because each of them is going to be executed in a new process for (long i = 0; i < invokeCount / unrollFactor; i++) { // we perform manual loop unrolling!! method(); // 1st call method(); // 2nd call method(); // (unrollFactor - 1)'th call method(); // unrollFactor'th call } var finalGcStats = GcStats.ReadFinal(); IterationCleanup(); return finalGcStats - initialGcStats; // the result is the difference between the stats collected after and before running the extra iteration }"
  },
  "articles/guides/how-to-run.html": {
    "href": "articles/guides/how-to-run.html",
    "title": "How to run your benchmarks | BenchmarkDotNet",
    "summary": "How to run your benchmarks There are several ways to run your benchmarks. What is important is that BenchmarkDotNet works only with Console Apps. It does not support any other kind of application like ASP.NET, Azure WebJobs, etc. Types If you have just a few types with benchmarks, you can use BenchmarkRunner: var summary = BenchmarkRunner.Run<MyBenchmarkClass>(); var summary = BenchmarkRunner.Run(typeof(MyBenchmarkClass)); The disadvantage of BenchmarkRunner is that it always runs all benchmarks in a given type (or assembly) and to change the type you need to modify the source code. But it's great for a quick start. BenchmarkSwitcher If you have more types and you want to choose which benchmark to run (either by using console line arguments or console input) you should use BenchmarkSwitcher: static void Main(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args); Also you can use the config command style to specify some config from command line (more How to use console arguments): dotnet run -c Release -- --job short --runtimes net472 net7.0 --filter *BenchmarkClass1* The most important thing about BenchmarkSwitcher is that you need to pass the args from Main to the Run method. If you don't, it won't parse the arguments."
  },
  "articles/guides/nuget.html": {
    "href": "articles/guides/nuget.html",
    "title": "Installing NuGet packages | BenchmarkDotNet",
    "summary": "Installing NuGet packages Packages We have the following set of NuGet packages (you can install it directly from nuget.org): BenchmarkDotNet: BenchmarkDotNet infrastructure and logic. This is all you need to run benchmarks. BenchmarkDotNet.Annotations: Basic BenchmarkDotNet annotations for your benchmarks. BenchmarkDotNet.Diagnostics.Windows: an additional optional package that provides a set of Windows diagnosers. BenchmarkDotNet.Diagnostics.dotTrace: an additional optional package that provides DotTraceDiagnoser. BenchmarkDotNet.Diagnostics.dotMemory: an additional optional package that provides DotMemoryDiagnoser. BenchmarkDotNet.Templates: Templates for BenchmarkDotNet. You might find other NuGet packages that start with BenchmarkDotNet name, but they are internal BDN packages that should not be installed manually. All that matters are the three packages mentioned above. Versioning system and feeds We have 3 kinds of versions: stable, nightly, and develop. You can get the current version from the source code via BenchmarkDotNetInfo.FullVersion and the full title via BenchmarkDotNetInfo.FullTitle. Stable These versions are available from the official NuGet feed. <packageSources> <add key=\"api.nuget.org\" value=\"https://api.nuget.org/v3/index.json\" protocolVersion=\"3\" /> </packageSources> Nightly If you want to use a nightly version of the BenchmarkDotNet, add the https://www.myget.org/F/benchmarkdotnet/api/v3/index.json feed in the <packageSources> section of your NuGet.config: <packageSources> <add key=\"bdn-nightly\" value=\"https://www.myget.org/F/benchmarkdotnet/api/v3/index.json\" /> </packageSources> Now you can install the packages from the bdn-nightly feed. Develop You also can build BenchmarkDotNet from source code: build.cmd pack"
  },
  "articles/guides/troubleshooting.html": {
    "href": "articles/guides/troubleshooting.html",
    "title": "Troubleshooting | BenchmarkDotNet",
    "summary": "Troubleshooting BenchmarkDotNet You need to be aware of the fact that to ensure process-level isolation BenchmarkDotNet generates, builds and executes every benchmark in a dedicated process. For .NET and Mono we generate a C# file and compile it using Roslyn. For .NET Core and NativeAOT we generate not only C# file but also a project file which later is restored and build with dotnet cli. If your project has some non-trivial build settings like a .props and .target files or native dependencies things might not work well out of the box. How do you know that BenchmarkDotNet has failed to build the project? BDN is going to tell you about it. An example: // Validating benchmarks: // ***** BenchmarkRunner: Start ***** // ***** Found 1 benchmark(s) in total ***** // ***** Building 1 exe(s) in Parallel: Start ***** // start dotnet restore /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in C:\\Projects\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\bin\\Release\\netcoreapp2.1\\c6045772-d3c7-4dbe-ab37-4aca6dcb6ec4 // command took 0.51s and exited with 1 // ***** Done, took 00:00:00 (0.66 sec) ***** // Found 1 benchmarks: // IntroBasic.Sleep: DefaultJob // Build Error: Standard output: Standard error: C:\\Projects\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\bin\\Release\\netcoreapp2.1\\c6045772-d3c7-4dbe-ab37-4aca6dcb6ec4\\BenchmarkDotNet.Autogenerated.csproj(36,1): error MSB4025: The project file could not be loaded. Unexpected end of file while parsing Comment has occurred. Line 36, position 1. // BenchmarkDotNet has failed to build the auto-generated boilerplate code. // It can be found in C:\\Projects\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\bin\\Release\\netcoreapp2.1\\c6045772-d3c7-4dbe-ab37-4aca6dcb6ec4 // Please follow the troubleshooting guide: https://benchmarkdotnet.org/articles/guides/troubleshooting.html If the error message is not clear enough, you need to investigate it further. How to troubleshoot the build process: Run the benchmarks with --logBuildOutput command line argument. Read the error message. If it does not contain the answer to your problem, please continue to the next step. Go to the build artifacts folder (path printed by BDN). The folder should contain: a file with source code (ends with .notcs to make sure IDE don't include it in other projects by default) a project file (.csproj) a script file (.bat on Windows, .sh for other OSes) which should be doing exactly the same thing as BDN does: dotnet restore dotnet build (with some parameters like -c Release) Run the script, read the error message. From here you continue with the troubleshooting like it was a project in your solution. The recommended order of solving build issues: Change the right settings in your project file which defines benchmarks to get it working. Customize the Job settings using available options like job.WithCustomBuildConfiguration($name)or job.With(new Argument[] { new MsBuildArgument(\"/p:SomeProperty=Value\")}). Implement your own IToolchain and generate and build all the right things in your way (you can use existing Builders and Generators and just override some methods to change specific behaviour). Report a bug in BenchmarkDotNet repository. Debugging Benchmarks In the same process If your benchmark builds but fails to run, you can simply debug it. The first thing you should try is to do it in a single process (host process === runner process). Use DebugInProcessConfig static void Main(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args, new DebugInProcessConfig()); Set the breakpoints in your favorite IDE Start debugging the project with benchmarks In a different process Sometimes you won't be able to reproduce the problem in the same process. In this case, you have 3 options: Launch a debugger from the benchmark process using Debugger API [GlobalSetup] public void Setup() { System.Diagnostics.Debugger.Launch(); } Attach a debugger from IDE Modify your benchmark to sleep until the Debugger is not attached and use your favorite IDE to attach the debugger to benchmark process. Do attach to the process which is running the benchmark (the arguments of the process are going to be --benchmarkId $someNumber --benchmarkName $theName), not the host process. [GlobalSetup] public void Setup() { while(!System.Diagnostics.Debugger.IsAttached) Thread.Sleep(TimeSpan.FromMilliseconds(100)); } One of the above, but with a Debug build By default, BDN builds everything in Release. But debugging Release builds even with full symbols might be non-trivial. To enforce BDN to build the benchmark in Debug please use DebugBuildConfig and then attach the debugger."
  },
  "articles/license.html": {
    "href": "articles/license.html",
    "title": "| BenchmarkDotNet",
    "summary": "The MIT License Copyright (c) 2013–2025 .NET Foundation and contributors Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "articles/overview.html": {
    "href": "articles/overview.html",
    "title": "Overview | BenchmarkDotNet",
    "summary": "Overview Install Create new console application and install the BenchmarkDotNet NuGet package. We support: Projects: classic and modern with PackageReferences Runtimes: Full .NET Framework (4.6+), .NET Core (2.0+), Mono, NativeAOT OS: Windows, Linux, MacOS Languages: C#, F#, VB Design a benchmark Create a new console application, write a class with methods that you want to measure, and mark them with the Benchmark attribute. In the following example, we compare the MD5 and SHA256 cryptographic hash functions: using System; using System.Security.Cryptography; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; namespace MyBenchmarks { public class Md5VsSha256 { private const int N = 10000; private readonly byte[] data; private readonly SHA256 sha256 = SHA256.Create(); private readonly MD5 md5 = MD5.Create(); public Md5VsSha256() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark] public byte[] Sha256() => sha256.ComputeHash(data); [Benchmark] public byte[] Md5() => md5.ComputeHash(data); } public class Program { public static void Main(string[] args) { var summary = BenchmarkRunner.Run(typeof(Program).Assembly); } } } The BenchmarkRunner.Run<Md5VsSha256>() call runs your benchmarks and prints results to the console. Note that BenchmarkDotNet will only run benchmarks if the application is built in the Release configuration. This is to prevent unoptimized code from being benchmarked. BenchmarkDotNet will issue an error if you forget to change the configuration. Benchmark results BenchmarkDotNet=v0.13.2, OS=Windows 10 (10.0.19045.2251) Intel Core i7-4770HQ CPU 2.20GHz (Haswell), 1 CPU, 8 logical and 4 physical cores .NET SDK=7.0.100 [Host] : .NET 7.0.0 (7.0.22.51805), X64 RyuJIT AVX2 DefaultJob : .NET 7.0.0 (7.0.22.51805), X64 RyuJIT AVX2 | Method | Mean | Error | StdDev | |------- |---------:|---------:|---------:| | Sha256 | 51.57 us | 0.311 us | 0.291 us | | Md5 | 21.91 us | 0.138 us | 0.129 us | Jobs BenchmarkDotNet can benchmark your code in several environments at once. For example, to compare your benchmark's performance in .NET Framework, .NET Core, Mono and NativeAOT, you can add SimpleJob attributes to the benchmark class: [SimpleJob(RuntimeMoniker.Net481)] [SimpleJob(RuntimeMoniker.Net70)] [SimpleJob(RuntimeMoniker.NativeAot70)] [SimpleJob(RuntimeMoniker.Mono)] public class Md5VsSha256 Example of the result: BenchmarkDotNet=v0.13.2, OS=Windows 10 (10.0.19045.2251) Intel Core i7-4770HQ CPU 2.20GHz (Haswell), 1 CPU, 8 logical and 4 physical cores .NET SDK=7.0.100 [Host] : .NET 7.0.0 (7.0.22.51805), X64 RyuJIT AVX2 .NET 7.0 : .NET 7.0.0 (7.0.22.51805), X64 RyuJIT AVX2 .NET Framework 4.8.1 : .NET Framework 4.8.1 (4.8.9037.0), X64 RyuJIT VectorSize=256 Mono : Mono 6.12.0 (Visual Studio), X64 VectorSize=128 NativeAOT 7.0 : .NET 7.0.0 (7.0.22.51805), X64 RyuJIT AVX2 | Method | Job | Runtime | Mean | Error | StdDev | |------- |--------------------- |--------------------- |----------:|---------:|---------:| | Sha256 | .NET 7.0 | .NET 7.0 | 51.90 us | 0.341 us | 0.302 us | | Md5 | .NET 7.0 | .NET 7.0 | 21.96 us | 0.052 us | 0.049 us | | Sha256 | .NET Framework 4.8.1 | .NET Framework 4.8.1 | 206.33 us | 2.069 us | 1.834 us | | Md5 | .NET Framework 4.8.1 | .NET Framework 4.8.1 | 23.28 us | 0.094 us | 0.083 us | | Sha256 | Mono | Mono | 167.70 us | 1.216 us | 1.137 us | | Md5 | Mono | Mono | 42.12 us | 0.145 us | 0.136 us | | Sha256 | NativeAOT 7.0 | NativeAOT 7.0 | 51.45 us | 0.226 us | 0.200 us | | Md5 | NativeAOT 7.0 | NativeAOT 7.0 | 21.88 us | 0.050 us | 0.041 us | There are many predefined job attributes which you can use. For example, you can compare LegacyJitX86, LegacyJitX64, and RyuJitX64: [LegacyJitX86Job, LegacyJitX64Job, RyuJitX64Job] Or, you can define your own jobs: [Config(typeof(Config))] public class Md5VsSha256 { private class Config : ManualConfig { public Config() { AddJob(new Job(Job.Dry) { Environment = { Jit = Jit.LegacyJit, Platform = Platform.X64 }, Run = { LaunchCount = 3, WarmupCount = 5, IterationCount = 10 }, Accuracy = { MaxRelativeError = 0.01 } }); } } Read more: Jobs, Configs Columns You can add columns to the summary table: [MinColumn, MaxColumn] public class Md5VsSha256 Method Median StdDev Min Max Sha256 131.3200 us 4.6744 us 129.8216 us 147.7630 us Md5 26.2847 us 0.4424 us 25.8442 us 27.4258 us You can also define custom columns based on the full benchmark summary. Read more: Columns Exporters You can export the results of your benchmark in different formats: [MarkdownExporter, AsciiDocExporter, HtmlExporter, CsvExporter, RPlotExporter] public class Md5VsSha256 If you have installed R, RPlotExporter will generate a lot of nice plots: Read more: Exporters Baseline To view the relative performance of your benchmarks, mark one of your benchmark methods as the Baseline: public class Sleeps { [Benchmark] public void Time50() => Thread.Sleep(50); [Benchmark(Baseline = true)] public void Time100() => Thread.Sleep(100); [Benchmark] public void Time150() => Thread.Sleep(150); } A new column will be added to the summary table: Method Median StdDev Ratio Time100 100.2640 ms 0.1238 ms 1.00 Time150 150.2093 ms 0.1034 ms 1.50 Time50 50.2509 ms 0.1153 ms 0.50 Read more: Baselines Params You can mark one or several fields or properties in your class with the Params attribute. In this attribute, you can specify a set of values. BenchmarkDotNet will run benchmarks for each combination of params values. public class IntroParams { [Params(100, 200)] public int A { get; set; } [Params(10, 20)] public int B { get; set; } [Benchmark] public void Benchmark() { Thread.Sleep(A + B + 5); } } Method Median StdDev A B Benchmark 115.3325 ms 0.0242 ms 100 10 Benchmark 125.3282 ms 0.0245 ms 100 20 Benchmark 215.3024 ms 0.0375 ms 200 10 Benchmark 225.2710 ms 0.0434 ms 200 20 Read more: Parameterization Languages You can also write benchmarks in F# or VB. type StringKeyComparison () = let mutable arr : string [] = [||] let dict1 = ConcurrentDictionary<_,_>() let dict2 = ConcurrentDictionary<_,_>(StringComparer.Ordinal) [<Params (100, 500, 1000, 2000)>] member val public DictSize = 0 with get, set [<GlobalSetup>] member self.GlobalSetupData() = dict1.Clear(); dict2.Clear() arr <- getStrings self.DictSize arr |> Array.iter (fun x -> dict1.[x] <- true ; dict2.[x] <- true) [<Benchmark>] member self.StandardLookup () = lookup arr dict1 [<Benchmark>] member self.OrdinalLookup () = lookup arr dict2 Public Class Sample <Params(1, 2)> Public Property A As Integer <Params(3, 4)> Public Property B As Integer <Benchmark> Public Function Benchmark() As Integer return A + B End Function End Class Diagnostics A diagnoser can attach to your benchmarks and collect additional information. Examples of diagnosers built in to BenchmarkDotNet are: Garbge collection and allocation statistics (MemoryDiagnoser). Lock contention and thread pool statistics (ThreadingDiagnoser), which is only available on .NET Core 3.0+. JIT inlining events (InliningDiagnoser). You can find this diagnoser in a separated package with diagnosers for Windows (BenchmarkDotNet.Diagnostics.Windows): Below is a sample benchmark using MemoryDiagnoser. Note the extra columns on the right-hand side (Gen 0 and Allocated): Method | Mean | StdDev | Gen 0 | Allocated | ---------- |----------- |---------- |------- |---------- | Iterative | 31.0739 ns | 0.1091 ns | - | 0 B | LINQ | 83.0435 ns | 1.0103 ns | 0.0069 | 32 B | Read more: Diagnosers BenchmarkRunner There are several ways to run your benchmarks. var summary = BenchmarkRunner.Run<MyBenchmarkClass>(); var summary = BenchmarkRunner.Run(typeof(MyBenchmarkClass)); var summaries = BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args); Read more: How to run your benchmarks"
  },
  "articles/samples/IntroArguments.html": {
    "href": "articles/samples/IntroArguments.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroArguments As an alternative to using [Params], you can specify arguments for your benchmarks. There are several ways to do it (described below). The [Arguments] allows you to provide a set of values. Every value must be a compile-time constant (it's C# language limitation for attributes in general). You can also combine [Arguments] with [Params]. As a result, you will get results for each combination of params values. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArguments { [Params(true, false)] // Arguments can be combined with Params public bool AddExtra5Milliseconds; [Benchmark] [Arguments(100, 10)] [Arguments(100, 20)] [Arguments(200, 10)] [Arguments(200, 20)] public void Benchmark(int a, int b) { if (AddExtra5Milliseconds) Thread.Sleep(a + b + 5); else Thread.Sleep(a + b); } } } Output | Method | AddExtra5Miliseconds | a | b | Mean | Error | StdDev | |---------- |--------------------- |---- |--- |---------:|----------:|----------:| | Benchmark | False | 100 | 10 | 110.1 ms | 0.0056 ms | 0.0044 ms | | Benchmark | False | 100 | 20 | 120.1 ms | 0.0155 ms | 0.0138 ms | | Benchmark | False | 200 | 10 | 210.2 ms | 0.0187 ms | 0.0175 ms | | Benchmark | False | 200 | 20 | 220.3 ms | 0.1055 ms | 0.0986 ms | | Benchmark | True | 100 | 10 | 115.3 ms | 0.1375 ms | 0.1286 ms | | Benchmark | True | 100 | 20 | 125.3 ms | 0.1212 ms | 0.1134 ms | | Benchmark | True | 200 | 10 | 215.4 ms | 0.0779 ms | 0.0691 ms | | Benchmark | True | 200 | 20 | 225.4 ms | 0.0775 ms | 0.0725 ms | Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroArguments"
  },
  "articles/samples/IntroArgumentsPriority.html": {
    "href": "articles/samples/IntroArgumentsPriority.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroArgumentsPriority Like Params also Argument columns can be sorted in the table result through their Priority. The priority should be defined only once for multiple Arguments and will keep their inner order as they are defined in the method. Source code using System.Collections.Generic; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArgumentsPriority { [Params(100, Priority = 0)] // Argument priority can be combined with Params priority public int A { get; set; } [Arguments(5, Priority = -10)] // Define priority just once for multiple argument attributes [Arguments(10)] [Arguments(20)] [Benchmark] public void Benchmark(int b) => Thread.Sleep(A + b); [Benchmark] [ArgumentsSource(nameof(Numbers), Priority = 10)] public void ManyArguments(int c, int d) => Thread.Sleep(A + c + d); public IEnumerable<object[]> Numbers() { yield return new object[] { 1, 2 }; } } } Output | Method | b | A | c | d | Mean | Error | StdDev | |-------------- |--- |---- |-- |-- |---------:|--------:|--------:| | ManyArguments | ? | 100 | 1 | 2 | 103.4 ms | 0.09 ms | 0.08 ms | | Benchmark | 5 | 100 | ? | ? | 105.5 ms | 0.21 ms | 0.19 ms | | Benchmark | 10 | 100 | ? | ? | 110.5 ms | 0.14 ms | 0.14 ms | | Benchmark | 20 | 100 | ? | ? | 120.4 ms | 0.16 ms | 0.15 ms | Links Priority BaseClass PriorityAttribute.cs Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroArgumentsPriority"
  },
  "articles/samples/IntroArgumentsSource.html": {
    "href": "articles/samples/IntroArgumentsSource.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroArgumentsSource In case you want to use a lot of values, you should use [ArgumentsSource]. You can mark one or several fields or properties in your class by the [ArgumentsSource] attribute. In this attribute, you have to specify the name of public method/property which is going to provide the values (something that implements IEnumerable). The source must be within benchmarked type! Source code using System; using System.Collections.Generic; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArgumentsSource { [Benchmark] [ArgumentsSource(nameof(Numbers))] public double ManyArguments(double x, double y) => Math.Pow(x, y); public IEnumerable<object[]> Numbers() // for multiple arguments it's an IEnumerable of array of objects (object[]) { yield return new object[] { 1.0, 1.0 }; yield return new object[] { 2.0, 2.0 }; yield return new object[] { 4.0, 4.0 }; yield return new object[] { 10.0, 10.0 }; } [Benchmark] [ArgumentsSource(nameof(TimeSpans))] public void SingleArgument(TimeSpan time) => Thread.Sleep(time); public IEnumerable<object> TimeSpans() // for single argument it's an IEnumerable of objects (object) { yield return TimeSpan.FromMilliseconds(10); yield return TimeSpan.FromMilliseconds(100); } } } Output | Method | x | y | Mean | Error | StdDev | |------- |--- |--- |----------:|----------:|----------:| | Pow | 1 | 1 | 9.360 ns | 0.0190 ns | 0.0149 ns | | Pow | 2 | 2 | 40.624 ns | 0.3413 ns | 0.3192 ns | | Pow | 4 | 4 | 40.537 ns | 0.0560 ns | 0.0524 ns | | Pow | 10 | 10 | 40.395 ns | 0.3274 ns | 0.3063 ns | Another example If the values are complex types you need to override ToString method to change the display names used in the results. [DryJob] public class WithNonPrimitiveArgumentsSource { [Benchmark] [ArgumentsSource(nameof(NonPrimitive))] public void Simple(SomeClass someClass, SomeStruct someStruct) { for (int i = 0; i < someStruct.RangeEnd; i++) Console.WriteLine($\"// array.Values[{i}] = {someClass.Values[i]}\"); } public IEnumerable<object[]> NonPrimitive() { yield return new object[] { new SomeClass(Enumerable.Range(0, 10).ToArray()), new SomeStruct(10) }; yield return new object[] { new SomeClass(Enumerable.Range(0, 15).ToArray()), new SomeStruct(15) }; } public class SomeClass { public SomeClass(int[] initialValues) => Values = initialValues.Select(val => val * 2).ToArray(); public int[] Values { get; } public override string ToString() => $\"{Values.Length} items\"; } public struct SomeStruct { public SomeStruct(int rangeEnd) => RangeEnd = rangeEnd; public int RangeEnd { get; } public override string ToString() => $\"{RangeEnd}\"; } } | Method | someClass | someStruct | Mean | Error | |------- |---------- |----------- |---------:|------:| | Simple | 10 items | 10 | 887.2 us | NA | | Simple | 15 items | 15 | 963.1 us | NA | Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroArgumentsSource"
  },
  "articles/samples/IntroArrayParam.html": {
    "href": "articles/samples/IntroArrayParam.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroArrayParam Warning The cost of creating the arguments is not included in the benchmark. So if you want to pass an array as an argument, we are going to allocate it before running the benchmark, and the benchmark will not include this operation. Source code using System; using System.Collections.Generic; using System.Linq; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArrayParam { [Benchmark] [ArgumentsSource(nameof(Data))] public int ArrayIndexOf(int[] array, int value) => Array.IndexOf(array, value); [Benchmark] [ArgumentsSource(nameof(Data))] public int ManualIndexOf(int[] array, int value) { for (int i = 0; i < array.Length; i++) if (array[i] == value) return i; return -1; } public IEnumerable<object[]> Data() { yield return new object[] { new int[] { 1, 2, 3 }, 4 }; yield return new object[] { Enumerable.Range(0, 100).ToArray(), 4 }; yield return new object[] { Enumerable.Range(0, 100).ToArray(), 101 }; } } } Output | Method | array | value | Mean | Error | StdDev | Allocated | |-------------- |----------- |------ |----------:|----------:|----------:|----------:| | ArrayIndexOf | Array[100] | 4 | 15.558 ns | 0.0638 ns | 0.0597 ns | 0 B | | ManualIndexOf | Array[100] | 4 | 5.345 ns | 0.0668 ns | 0.0625 ns | 0 B | | ArrayIndexOf | Array[3] | 4 | 14.334 ns | 0.1758 ns | 0.1558 ns | 0 B | | ManualIndexOf | Array[3] | 4 | 2.758 ns | 0.0905 ns | 0.1208 ns | 0 B | | ArrayIndexOf | Array[100] | 101 | 78.359 ns | 1.8853 ns | 2.0955 ns | 0 B | | ManualIndexOf | Array[100] | 101 | 80.421 ns | 0.6391 ns | 0.5978 ns | 0 B | Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroArrayParam"
  },
  "articles/samples/IntroBasic.html": {
    "href": "articles/samples/IntroBasic.html",
    "title": "Sample: IntroBasic | BenchmarkDotNet",
    "summary": "Sample: IntroBasic Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { // It is very easy to use BenchmarkDotNet. You should just create a class public class IntroBasic { // And define a method with the Benchmark attribute [Benchmark] public void Sleep() => Thread.Sleep(10); // You can write a description for your method. [Benchmark(Description = \"Thread.Sleep(10)\")] public void SleepWithDescription() => Thread.Sleep(10); } } Links The permanent link to this sample: Sample: IntroBasic"
  },
  "articles/samples/IntroBenchmarkBaseline.html": {
    "href": "articles/samples/IntroBenchmarkBaseline.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroBenchmarkBaseline You can mark a method as a baseline with the help of [Benchmark(Baseline = true)]. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroBenchmarkBaseline { [Benchmark] public void Time50() => Thread.Sleep(50); [Benchmark(Baseline = true)] public void Time100() => Thread.Sleep(100); [Benchmark] public void Time150() => Thread.Sleep(150); } } Output As a result, you will have additional Ratio column in the summary table: | Method | Mean | Error | StdDev | Ratio | |-------- |----------:|----------:|----------:|------:| | Time50 | 50.46 ms | 0.0779 ms | 0.0729 ms | 0.50 | | Time100 | 100.39 ms | 0.0762 ms | 0.0713 ms | 1.00 | | Time150 | 150.48 ms | 0.0986 ms | 0.0922 ms | 1.50 | This column contains the mean value of the ratio distribution. For example, in the case of Time50, we divide the first measurement of Time50 into the first measurement of Time100 (it's the baseline), the second measurement of Time50 into the second measurement of Time100, and so on. Next, we calculate the mean of all these values and display it in the Ratio column. For Time50, we have 0.50. The Ratio column was formerly known as Scaled. The old title was a source of misunderstanding and confusion because many developers interpreted it as the ratio of means (e.g., 50.46/100.39 for Time50). The ratio of distribution means and the mean of the ratio distribution are pretty close to each other in most cases, but they are not equal. In @BenchmarkDotNet.Samples.IntroRatioStdDev, you can find an example of how this value can be spoiled by outliers. Links Benchmark and Job Baselines The permanent link to this sample: BenchmarkDotNet.Samples.IntroBenchmarkBaseline"
  },
  "articles/samples/IntroCategories.html": {
    "href": "articles/samples/IntroCategories.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroCategories Combined together with [BenchmarkCategory] attribute, you can group the benchmarks into categories and filter them by categories. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DryJob] [CategoriesColumn] [BenchmarkCategory(\"Awesome\")] [AnyCategoriesFilter(\"A\", \"1\")] public class IntroCategories { [Benchmark] [BenchmarkCategory(\"A\", \"1\")] public void A1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] [BenchmarkCategory(\"A\", \"2\")] public void A2() => Thread.Sleep(10); // Will be benchmarked [Benchmark] [BenchmarkCategory(\"B\", \"1\")] public void B1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] [BenchmarkCategory(\"B\", \"2\")] public void B2() => Thread.Sleep(10); } } Command line examples: --allCategories=A,B --anyCategories=A,B Links Filters The permanent link to this sample: BenchmarkDotNet.Samples.IntroCategories"
  },
  "articles/samples/IntroCategoryBaseline.html": {
    "href": "articles/samples/IntroCategoryBaseline.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroCategoryBaseline The only way to have several baselines in the same class is to separate them by categories and mark the class with [GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)]. Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; namespace BenchmarkDotNet.Samples { [GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)] [CategoriesColumn] public class IntroCategoryBaseline { [BenchmarkCategory(\"Fast\"), Benchmark(Baseline = true)] public void Time50() => Thread.Sleep(50); [BenchmarkCategory(\"Fast\"), Benchmark] public void Time100() => Thread.Sleep(100); [BenchmarkCategory(\"Slow\"), Benchmark(Baseline = true)] public void Time550() => Thread.Sleep(550); [BenchmarkCategory(\"Slow\"), Benchmark] public void Time600() => Thread.Sleep(600); } } Output | Method | Categories | Mean | Error | StdDev | Ratio | |-------- |----------- |----------:|----------:|----------:|------:| | Time50 | Fast | 50.46 ms | 0.0745 ms | 0.0697 ms | 1.00 | | Time100 | Fast | 100.47 ms | 0.0955 ms | 0.0893 ms | 1.99 | | | | | | | | | Time550 | Slow | 550.48 ms | 0.0525 ms | 0.0492 ms | 1.00 | | Time600 | Slow | 600.45 ms | 0.0396 ms | 0.0331 ms | 1.09 | Links Benchmark and Job Baselines The permanent link to this sample: BenchmarkDotNet.Samples.IntroCategoryBaseline"
  },
  "articles/samples/IntroCategoryDiscoverer.html": {
    "href": "articles/samples/IntroCategoryDiscoverer.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroCategoryDiscoverer The category discovery strategy can be overridden using an instance of ICategoryDiscoverer. Source code using System; using System.Collections.Generic; using System.Reflection; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { [DryJob] [CategoriesColumn] [CustomCategoryDiscoverer] public class IntroCategoryDiscoverer { private class CustomCategoryDiscoverer : DefaultCategoryDiscoverer { public override string[] GetCategories(MethodInfo method) { var categories = new List<string>(); categories.AddRange(base.GetCategories(method)); categories.Add(\"All\"); categories.Add(method.Name.Substring(0, 1)); return categories.ToArray(); } } [AttributeUsage(AttributeTargets.Class)] private class CustomCategoryDiscovererAttribute : Attribute, IConfigSource { public CustomCategoryDiscovererAttribute() { Config = ManualConfig.CreateEmpty() .WithCategoryDiscoverer(new CustomCategoryDiscoverer()); } public IConfig Config { get; } } [Benchmark] public void Foo() { } [Benchmark] public void Bar() { } } } Output | Method | Categories | Mean | Error | |------- |----------- |---------:|------:| | Bar | All,B | 126.5 us | NA | | Foo | All,F | 114.0 us | NA | Links The permanent link to this sample: BenchmarkDotNet.Samples.IntroCategoryDiscoverer"
  },
  "articles/samples/IntroColdStart.html": {
    "href": "articles/samples/IntroColdStart.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroColdStart If you want to measure cold start (without the pilot and warmup stage), the ColdStart strategy is your choice. Usage [SimpleJob(RunStrategy.ColdStart, launchCount:50)] public class MyBenchmarkClass Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.ColdStart, iterationCount: 5)] [MinColumn, MaxColumn, MeanColumn, MedianColumn] public class IntroColdStart { private bool firstCall; [Benchmark] public void Foo() { if (firstCall == false) { firstCall = true; Console.WriteLine(\"// First call\"); Thread.Sleep(1000); } else Thread.Sleep(10); } } } Output Result 1: 1 op, 1002034900.00 ns, 1.0020 s/op Result 2: 1 op, 10219700.00 ns, 10.2197 ms/op Result 3: 1 op, 10406200.00 ns, 10.4062 ms/op Result 4: 1 op, 10473900.00 ns, 10.4739 ms/op Result 5: 1 op, 10449400.00 ns, 10.4494 ms/op Method | Mean | Error | StdDev | Min | Max | Median | ------- |---------:|-----------:|---------:|---------:|-----------:|---------:| Foo | 208.7 ms | 1,707.4 ms | 443.5 ms | 10.22 ms | 1,002.0 ms | 10.45 ms | Links Choosing RunStrategy The permanent link to this sample: BenchmarkDotNet.Samples.IntroColdStart"
  },
  "articles/samples/IntroComparableComplexParam.html": {
    "href": "articles/samples/IntroComparableComplexParam.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroComparableComplexParam You can implement IComparable (the non generic version) on your complex parameter class if you want custom ordering behavior for your parameter. One use case for this is having a parameter class that overrides ToString(), but also providing a custom ordering behavior that isn't the alphabetical order of the result of ToString(). Source code using System; using System.Collections.Generic; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroComparableComplexParam { [ParamsSource(nameof(ValuesForA))] public ComplexParam? A { get; set; } public IEnumerable<ComplexParam> ValuesForA => new[] { new ComplexParam(1, \"First\"), new ComplexParam(2, \"Second\") }; [Benchmark] public object? Benchmark() => A; // Only non generic IComparable is required to provide custom order behavior, but implementing IComparable<> too is customary. public class ComplexParam : IComparable<ComplexParam>, IComparable { public ComplexParam(int value, string name) { Value = value; Name = name; } public int Value { get; set; } public string Name { get; set; } public override string ToString() => Name; public int CompareTo(ComplexParam? other) => other == null ? 1 : Value.CompareTo(other.Value); public int CompareTo(object obj) => obj is ComplexParam other ? CompareTo(other) : throw new ArgumentException(); } } } Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroComparableComplexParam"
  },
  "articles/samples/IntroConfigSource.html": {
    "href": "articles/samples/IntroConfigSource.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroConfigSource You can define own config attribute. Source code using System; using System.Linq; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [MyConfigSource(Jit.LegacyJit, Jit.RyuJit)] public class IntroConfigSource { /// <summary> /// Dry-x64 jobs for specific jits /// </summary> private class MyConfigSourceAttribute : Attribute, IConfigSource { public IConfig Config { get; } public MyConfigSourceAttribute(params Jit[] jits) { var jobs = jits .Select(jit => new Job(Job.Dry) { Environment = { Jit = jit, Platform = Platform.X64 } }) .ToArray(); Config = ManualConfig.CreateEmpty().AddJob(jobs); } } [Benchmark] public void Foo() { Thread.Sleep(10); } } } Links Configs The permanent link to this sample: BenchmarkDotNet.Samples.IntroConfigSource"
  },
  "articles/samples/IntroConfigUnion.html": {
    "href": "articles/samples/IntroConfigUnion.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroConfigUnion Source code using System.Threading; using BenchmarkDotNet.Analysers; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Columns; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Exporters; using BenchmarkDotNet.Exporters.Csv; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Loggers; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] public class IntroConfigUnion { private class Config : ManualConfig { public Config() { AddJob(Job.Dry); AddLogger(ConsoleLogger.Default); AddColumn(TargetMethodColumn.Method, StatisticColumn.Max); AddExporter(RPlotExporter.Default, CsvExporter.Default); AddAnalyser(EnvironmentAnalyser.Default); UnionRule = ConfigUnionRule.AlwaysUseLocal; } } [Benchmark] public void Foo() { Thread.Sleep(10); } } } Links Configs The permanent link to this sample: BenchmarkDotNet.Samples.IntroConfigUnion"
  },
  "articles/samples/IntroCustomMono.html": {
    "href": "articles/samples/IntroCustomMono.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroCustomMono BenchmarkDotNet allows you to compare different runtimes, including Mono. If you apply [MonoJob] attribute to your class we use your default mono runtime. If you want to compare different versions of Mono you need to provide use the custom paths. You can do this today by using the overloaded ctor of MonoJob attribute or by specifying the runtime in a fluent way. The mono runtime can also operate as an ahead-of-time compiler. Using mono's AOT mode requires providing the AOT compilation arguments, as well as the path to mono's corlib. (See IntroCustomMonoObjectStyleAot in the below example). Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { // *** Attribute Style *** [MonoJob(\"Mono x64\", @\"C:\\Program Files\\Mono\\bin\\mono.exe\")] [MonoJob(\"Mono x86\", @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\")] public class IntroCustomMono { [Benchmark] public void Foo() { // Benchmark body } } // *** Object Style *** [Config(typeof(Config))] public class IntroCustomMonoObjectStyle { private class Config : ManualConfig { public Config() { AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x64\", @\"C:\\Program Files\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x86\", @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\"))); } } [Benchmark] public void Foo() { // Benchmark body } } // ** Object Style, Using AOT ** [Config(typeof(Config))] public class IntroCustomMonoObjectStyleAot { private class Config : ManualConfig { public void AddMono (string name, string mono_top_dir) { var aot_compile_args = \"--aot=llvm\"; var mono_bcl = $@\"{mono_top_dir}\\lib\\mono\\4.5\"; var mono_bin = $@\"{mono_top_dir}\\bin\\mono.exe\"; AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( name, mono_bin, aot_compile_args, mono_bcl))); } public Config() { AddMono(\"Mono x64\", @\"C:\\Program Files\\Mono\"); AddMono(\"Mono x86\", @\"C:\\Program Files (x86)\\Mono\"); } } [Benchmark] public void Foo() { // Benchmark body } } // *** Fluent Config *** public class IntroCustomMonoFluentConfig { public static void Run() { BenchmarkRunner.Run<IntroCustomMonoFluentConfig>(ManualConfig .CreateMinimumViable() .AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x64\", @\"C:\\Program Files\\Mono\\bin\\mono.exe\"))) .AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x86\", @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\")))); } [Benchmark] public void Foo() { // Benchmark body } } } Links Customizing Runtime The permanent link to this sample: BenchmarkDotNet.Samples.IntroCustomMono"
  },
  "articles/samples/IntroCustomMonoArguments.html": {
    "href": "articles/samples/IntroCustomMonoArguments.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroCustomMonoArguments Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [Config(typeof(ConfigWithCustomArguments))] public class IntroCustomMonoArguments { public class ConfigWithCustomArguments : ManualConfig { public ConfigWithCustomArguments() { // --optimize=MODE , -O=mode // MODE is a comma separated list of optimizations. They also allow // optimizations to be turned off by prefixing the optimization // name with a minus sign. AddJob(Job.Default .WithRuntime(MonoRuntime.Default) .WithArguments(new[] { new MonoArgument(\"--optimize=inline\") }) .WithId(\"Inlining enabled\")); AddJob(Job.Default .WithRuntime(MonoRuntime.Default) .WithArguments(new[] { new MonoArgument(\"--optimize=-inline\") }) .WithId(\"Inlining disabled\")); } } [Benchmark] public void Sample() { ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); } private void ShouldGetInlined() { } } } Output | Method | Job | Arguments | Mean | StdDev | |------- |------------------ |------------------- |-----------:|----------:| | Sample | Inlining disabled | --optimize=-inline | 19.4252 ns | 0.4525 ns | | Sample | Inlining enabled | --optimize=inline | 0.0000 ns | 0.0000 ns | Links Customizing Runtime The permanent link to this sample: BenchmarkDotNet.Samples.IntroCustomMonoArguments"
  },
  "articles/samples/IntroDeferredExecution.html": {
    "href": "articles/samples/IntroDeferredExecution.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroDeferredExecution In LINQ, execution of a query is usually deferred until the moment when you actually request the data. If your benchmark just returns IEnumerable or IQueryable it's not measuring the execution of the query, just the creation. This is why we decided to warn you about this issue whenever it happens: Benchmark IntroDeferredExecution.Wrong returns a deferred execution result (IEnumerable<Int32>). You need to either change the method declaration to return a materialized result or consume it on your own. You can use .Consume() extension method to do that. Don't worry! We are also providing you with a Consume extension method which can execute given IEnumerable or IQueryable and consume its results. All you need to do is to create a Consumer instance, preferably store it in a field (to exclude the cost of creating Consumer from the benchmark itself) and pass it to Consume extension method. Do not call .ToArray() because it's an expensive operation and it might dominate given benchmark! Source code using System.Collections.Generic; using System.Linq; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { public class IntroDeferredExecution { private readonly int[] numbers = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; private readonly Consumer consumer = new Consumer(); /// <summary> /// this benchmark returns a deferred LINQ query which is NOT executed /// so the benchmark measures the cost of creating the query, not the actual execution /// this is WRONG /// You can read more about LINQ and Deferred Execution <see href=\"https://blogs.msdn.microsoft.com/charlie/2007/12/10/linq-and-deferred-execution/\">here</see> /// </summary> /// <returns>deferred LINQ query</returns> [Benchmark] public IEnumerable<int> Wrong() => from number in numbers orderby number descending select number; /// <summary> /// this benchmark uses .Consume extension method which executes given deferred query and consumes its result /// so the benchmark measures the cost of creating the query and executing it /// </summary> [Benchmark] public void Ok() => (from number in numbers orderby number descending select number).Consume(consumer); } } Links The permanent link to this sample: BenchmarkDotNet.Samples.IntroDeferredExecution"
  },
  "articles/samples/IntroDisassembly.html": {
    "href": "articles/samples/IntroDisassembly.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroDisassembly Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnosers; using System.Linq; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(printInstructionAddresses: true, syntax: DisassemblySyntax.Masm)] public class IntroDisassembly { private int[] field = Enumerable.Range(0, 100).ToArray(); [Benchmark] public int SumLocal() { var local = field; // we use local variable that points to the field int sum = 0; for (int i = 0; i < local.Length; i++) sum += local[i]; return sum; } [Benchmark] public int SumField() { int sum = 0; for (int i = 0; i < field.Length; i++) sum += field[i]; return sum; } } } Output ; .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.7.3110.0 05452718 BenchmarkDotNet.Samples.IntroDisassembly.Sum() IL_0000: ldc.r8 0 IL_0009: stloc.0 0545271c d9ee fldz IL_000a: ldc.i4.0 IL_000b: stloc.1 IL_000c: br.s IL_0017 0545271e 33c0 xor eax,eax IL_000e: ldloc.0 IL_000f: ldloc.1 IL_0010: conv.r8 IL_0011: add IL_0012: stloc.0 05452720 8945fc mov dword ptr [ebp-4],eax 05452723 db45fc fild dword ptr [ebp-4] 05452726 dec1 faddp st(1),st IL_0013: ldloc.1 IL_0014: ldc.i4.1 IL_0015: add IL_0016: stloc.1 05452728 40 inc eax IL_0017: ldloc.1 IL_0018: ldc.i4.s 64 IL_001a: blt.s IL_000e 05452729 83f840 cmp eax,40h 0545272c 7cf2 jl 05452720 IL_001c: ldloc.0 IL_001d: ret 0545272e 8be5 mov esp,ebp ; .NET Core 2.1.0 (CoreCLR 4.6.26515.07, CoreFX 4.6.26515.06), 64bit RyuJIT 00007ffa`6c621320 BenchmarkDotNet.Samples.IntroDisassembly.Sum() IL_0000: ldc.r8 0 IL_0009: stloc.0 00007ffa`6c621323 c4e17857c0 vxorps xmm0,xmm0,xmm0 IL_000a: ldc.i4.0 IL_000b: stloc.1 IL_000c: br.s IL_0017 00007ffa`6c621328 33c0 xor eax,eax IL_000e: ldloc.0 IL_000f: ldloc.1 IL_0010: conv.r8 IL_0011: add IL_0012: stloc.0 00007ffa`6c62132a c4e17057c9 vxorps xmm1,xmm1,xmm1 00007ffa`6c62132f c4e1732ac8 vcvtsi2sd xmm1,xmm1,eax 00007ffa`6c621334 c4e17b58c1 vaddsd xmm0,xmm0,xmm1 IL_0013: ldloc.1 IL_0014: ldc.i4.1 IL_0015: add IL_0016: stloc.1 00007ffa`6c621339 ffc0 inc eax IL_0017: ldloc.1 IL_0018: ldc.i4.s 64 IL_001a: blt.s IL_000e 00007ffa`6c62133b 83f840 cmp eax,40h 00007ffa`6c62133e 7cea jl 00007ffa`6c62132a IL_001c: ldloc.0 IL_001d: ret 00007ffa`6c621340 c3 ret Mono 5.12.0 (Visual Studio), 64bit Sum sub $0x18,%rsp mov %rsi,(%rsp) xorpd %xmm0,%xmm0 movsd %xmm0,0x8(%rsp) xor %esi,%esi jmp 2e xchg %ax,%ax movsd 0x8(%rsp),%xmm0 cvtsi2sd %esi,%xmm1 addsd %xmm1,%xmm0 movsd %xmm0,0x8(%rsp) inc %esi cmp $0x40,%esi jl 18 movsd 0x8(%rsp),%xmm0 mov (%rsp),%rsi add $0x18,%rsp retq Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassembly"
  },
  "articles/samples/IntroDisassemblyAllJits.html": {
    "href": "articles/samples/IntroDisassemblyAllJits.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroDisassemblyAllJits You can use a single config to compare the generated assembly code for ALL JITs. But to allow benchmarking any target platform architecture the project which defines benchmarks has to target AnyCPU. <PropertyGroup> <PlatformTarget>AnyCPU</PlatformTarget> </PropertyGroup> Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Diagnosers; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [Config(typeof(MultipleJits))] public class IntroDisassemblyAllJits { public class MultipleJits : ManualConfig { public MultipleJits() { AddJob(Job.ShortRun.WithPlatform(Platform.X86).WithRuntime(new MonoRuntime(name: \"Mono x86\", customPath: @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithPlatform(Platform.X64).WithRuntime(new MonoRuntime(name: \"Mono x64\", customPath: @\"C:\\Program Files\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithJit(Jit.LegacyJit).WithPlatform(Platform.X86).WithRuntime(ClrRuntime.Net462)); AddJob(Job.ShortRun.WithJit(Jit.LegacyJit).WithPlatform(Platform.X64).WithRuntime(ClrRuntime.Net462)); AddJob(Job.ShortRun.WithJit(Jit.RyuJit).WithPlatform(Platform.X64).WithRuntime(ClrRuntime.Net462)); // RyuJit for .NET Core 5.0 AddJob(Job.ShortRun.WithJit(Jit.RyuJit).WithPlatform(Platform.X64).WithRuntime(CoreRuntime.Core50)); AddDiagnoser(new DisassemblyDiagnoser(new DisassemblyDiagnoserConfig(maxDepth: 3, exportDiff: true))); } } private Increment increment = new Increment(); [Benchmark] public int CallVirtualMethod() => increment.OperateTwice(10); public abstract class Operation // abstract unary integer operation { public abstract int Operate(int input); public int OperateTwice(int input) => Operate(Operate(input)); // two virtual calls to Operate } public sealed class Increment : Operation // concrete, sealed operation: increment by fixed amount { public readonly int Amount; public Increment(int amount = 1) { Amount = amount; } public override int Operate(int input) => input + Amount; } } } Output The disassembly result can be obtained here. The file was too big to embed it in this doc page. Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassemblyAllJits"
  },
  "articles/samples/IntroDisassemblyDry.html": {
    "href": "articles/samples/IntroDisassemblyDry.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroDisassemblyDry Getting only the Disassembly without running the benchmarks for a long time. Sometimes you might be interested only in the disassembly, not the results of the benchmarks. In that case you can use Job.Dry which runs the benchmark only once. Source code using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(maxDepth: 3)] [DryJob] public class IntroDisassemblyDry { [Benchmark] public void Foo() { } } } Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassemblyDry"
  },
  "articles/samples/IntroDisassemblyRyuJit.html": {
    "href": "articles/samples/IntroDisassemblyRyuJit.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroDisassemblyRyuJit Source code using System.Linq; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(printSource: true)] [RyuJitX64Job] public class IntroDisassemblyRyuJit { private int[] field = Enumerable.Range(0, 100).ToArray(); [Benchmark] public int SumLocal() { var local = field; // we use local variable that points to the field int sum = 0; for (int i = 0; i < local.Length; i++) sum += local[i]; return sum; } [Benchmark] public int SumField() { int sum = 0; for (int i = 0; i < field.Length; i++) sum += field[i]; return sum; } } } Output Links Diagnosers Disassembler The permanent link to this sample: BenchmarkDotNet.Samples.IntroDisassemblyRyuJit"
  },
  "articles/samples/IntroDotMemoryDiagnoser.html": {
    "href": "articles/samples/IntroDotMemoryDiagnoser.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroDotMemoryDiagnoser If you want to get a memory allocation profile of your benchmarks, just add the [DotMemoryDiagnoser] attribute, as shown below. As a result, BenchmarkDotNet performs bonus benchmark runs using attached dotMemory Command-Line Profiler. The obtained dotMemory workspaces are saved to the artifacts folder. These dotMemory workspaces can be opened using the standalone dotMemory, or dotMemory in Rider. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnostics.dotMemory; using System.Collections.Generic; namespace BenchmarkDotNet.Samples { // Profile benchmarks via dotMemory SelfApi profiling for all jobs [DotMemoryDiagnoser] [SimpleJob] // external-process execution [InProcess] // in-process execution public class IntroDotMemoryDiagnoser { [Params(1024)] public int Size; private byte[] dataArray; private IEnumerable<byte> dataEnumerable; [GlobalSetup] public void Setup() { dataArray = new byte[Size]; dataEnumerable = dataArray; } [Benchmark] public int IterateArray() { var count = 0; foreach (var _ in dataArray) count++; return count; } [Benchmark] public int IterateEnumerable() { var count = 0; foreach (var _ in dataEnumerable) count++; return count; } } } Links The permanent link to this sample: BenchmarkDotNet.Samples.IntroDotMemoryDiagnoser"
  },
  "articles/samples/IntroDotTraceDiagnoser.html": {
    "href": "articles/samples/IntroDotTraceDiagnoser.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroDotTraceDiagnoser If you want to get a performance profile of your benchmarks, just add the [DotTraceDiagnoser] attribute, as shown below. As a result, BenchmarkDotNet performs bonus benchmark runs using attached dotTrace Command-Line Profiler. The obtained snapshots are saved to the artifacts folder. These snapshots can be opened using the standalone dotTrace, or dotTrace in Rider. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnostics.dotTrace; namespace BenchmarkDotNet.Samples { // Profile benchmarks via dotTrace SelfApi profiling for all jobs // See: https://www.nuget.org/packages/JetBrains.Profiler.SelfApi [DotTraceDiagnoser] [SimpleJob] // external-process execution [InProcess] // in-process execution public class IntroDotTraceDiagnoser { [Benchmark] public void Fibonacci() => Fibonacci(30); private static int Fibonacci(int n) { return n <= 1 ? n : Fibonacci(n - 1) + Fibonacci(n - 2); } } } Links The permanent link to this sample: BenchmarkDotNet.Samples.IntroDotTraceDiagnoser"
  },
  "articles/samples/IntroEnvVars.html": {
    "href": "articles/samples/IntroEnvVars.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroEnvVars You can configure custom environment variables for the process that is running your benchmarks. One reason for doing this might be checking out how different compilation, threading, garbage collector settings affect the performance of .NET Core. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [Config(typeof(ConfigWithCustomEnvVars))] public class IntroEnvVars { private class ConfigWithCustomEnvVars : ManualConfig { public ConfigWithCustomEnvVars() { AddJob(Job.Default.WithRuntime(CoreRuntime.Core80).WithId(\"Inlining enabled\")); AddJob(Job.Default.WithRuntime(CoreRuntime.Core80) .WithEnvironmentVariables([ new EnvironmentVariable(\"DOTNET_JitNoInline\", \"1\"), new EnvironmentVariable(\"COMPlus_JitNoInline\", \"1\") ]) .WithId(\"Inlining disabled\")); } } [Benchmark] public void Foo() { // Benchmark body } } } Links Customizing Runtime Configs Jobs The permanent link to this sample: BenchmarkDotNet.Samples.IntroEnvVars"
  },
  "articles/samples/IntroEventPipeProfiler.html": {
    "href": "articles/samples/IntroEventPipeProfiler.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: EventPipeProfiler The EventPipeProfiler can be enabled using the [EventPipeProfiler(...)] attribute. This attribute takes the following profiles: CpuSampling - Useful for tracking CPU usage and general .NET runtime information. This is the default option. GcVerbose - Tracks GC collections and samples object allocations. GcCollect - Tracks GC collections only at very low overhead. Jit - Logging when Just in time (JIT) compilation occurs. Logging of the internal workings of the Just In Time compiler. This is fairly verbose. It details decisions about interesting optimization (like inlining and tail call) Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnosers; namespace BenchmarkDotNet.Samples { [ShortRunJob] [EventPipeProfiler(EventPipeProfile.CpuSampling)] public class IntroEventPipeProfiler { [Benchmark] public void Sleep() => Thread.Sleep(2000); } } Output The output should contain information about the exported trace file which can be analyzed using SpeedScope. // * Diagnostic Output - EventPipeProfiler * Exported 1 trace file(s). Example: C:\\Work\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\BenchmarkDotNet.Artifacts\\BenchmarkDotNet.Samples.IntroEventPipeProfiler.Sleep-20200406-090113.speedscope.json"
  },
  "articles/samples/IntroEventPipeProfilerAdvanced.html": {
    "href": "articles/samples/IntroEventPipeProfilerAdvanced.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: EventPipeProfilerAdvanced The most advanced and powerful way to use EventPipeProfiler is a custom configuration. As you can see the below configuration adds EventPipeProfiler that constructor can take the profile and/or a list of providers. Both EventPipeProfiler and dotnet trace use the Microsoft.Diagnostics.NETCore.Client package internally. So before you start using the custom configuration of this profiler, it is worth reading the documentation here and here where you can find more information about how to configure provider list. Source code using System.Buffers; using System.Diagnostics.Tracing; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Diagnosers; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using Microsoft.Diagnostics.NETCore.Client; using Microsoft.Diagnostics.Tracing.Parsers; namespace BenchmarkDotNet.Samples { [Config(typeof(CustomConfig))] public class IntroEventPipeProfilerAdvanced { private class CustomConfig : ManualConfig { public CustomConfig() { AddJob(Job.ShortRun.WithRuntime(CoreRuntime.Core50)); var providers = new[] { new EventPipeProvider(ClrTraceEventParser.ProviderName, EventLevel.Verbose, (long) (ClrTraceEventParser.Keywords.Exception | ClrTraceEventParser.Keywords.GC | ClrTraceEventParser.Keywords.Jit | ClrTraceEventParser.Keywords.JitTracing // for the inlining events | ClrTraceEventParser.Keywords.Loader | ClrTraceEventParser.Keywords.NGen)), new EventPipeProvider(\"System.Buffers.ArrayPoolEventSource\", EventLevel.Informational, long.MaxValue), }; AddDiagnoser(new EventPipeProfiler(providers: providers)); } } [Benchmark] public void RentAndReturn_Shared() { var pool = ArrayPool<byte>.Shared; byte[] array = pool.Rent(10000); pool.Return(array); } } } Output The output should contain information about the exported trace file which can be analyzed using SpeedScope. // * Diagnostic Output - EventPipeProfiler * Exported 1 trace file(s). Example: C:\\Work\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\BenchmarkDotNet.Artifacts\\BenchmarkDotNet.Samples.IntroEventPipeProfilerAdvanced.RentAndReturn_Shared-20200406-090136.speedscope.json"
  },
  "articles/samples/IntroExceptionDiagnoser.html": {
    "href": "articles/samples/IntroExceptionDiagnoser.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroExceptionDiagnoser The ExceptionDiagnoser uses AppDomain.FirstChanceException API to report: Exception frequency: The number of exceptions thrown during the operations divided by the number of operations. Source code using BenchmarkDotNet.Attributes; using System; namespace BenchmarkDotNet.Samples { [ExceptionDiagnoser] public class IntroExceptionDiagnoser { [Benchmark] public void ThrowExceptionRandomly() { try { if (new Random().Next(0, 5) > 1) { throw new Exception(); } } catch { // ignored } } } } Output Method Mean Error StdDev Exception frequency ThrowExceptionRandomly 4.936 us 0.1542 us 0.4499 us 0.1381 Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroExceptionDiagnoser"
  },
  "articles/samples/IntroExport.html": {
    "href": "articles/samples/IntroExport.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroExport BenchmarkDotNet has a lot of predefined exporters. Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [ShortRunJob] [MediumRunJob] [KeepBenchmarkFiles] [AsciiDocExporter] [CsvExporter] [CsvMeasurementsExporter] [HtmlExporter] [PlainExporter] [RPlotExporter] [JsonExporterAttribute.Brief] [JsonExporterAttribute.BriefCompressed] [JsonExporterAttribute.Full] [JsonExporterAttribute.FullCompressed] [MarkdownExporterAttribute.Default] [MarkdownExporterAttribute.GitHub] [MarkdownExporterAttribute.StackOverflow] [MarkdownExporterAttribute.Atlassian] [XmlExporterAttribute.Brief] [XmlExporterAttribute.BriefCompressed] [XmlExporterAttribute.Full] [XmlExporterAttribute.FullCompressed] public class IntroExport { private Random random = new Random(42); [Benchmark(Baseline = true)] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep50Noisy() => Thread.Sleep(random.Next(100)); } } Links Exporters The permanent link to this sample: BenchmarkDotNet.Samples.IntroExport"
  },
  "articles/samples/IntroExportJson.html": {
    "href": "articles/samples/IntroExportJson.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroExportJson BenchmarkDotNet has a set of json exporters. You can customize the following properties of these exporters: fileNameSuffix: a string which be placed in the end of target file name. indentJson=false/true: should we format json or not. excludeMeasurements=false/true: should we exclude detailed information about measurements or not (the final summary with statistics will be in the json file anyway). Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Exporters.Json; namespace BenchmarkDotNet.Samples { // *** Attribute style *** [DryJob] [JsonExporterAttribute.Brief] [JsonExporterAttribute.Full] [JsonExporterAttribute.BriefCompressed] [JsonExporterAttribute.FullCompressed] [JsonExporter(\"-custom\", indentJson: true, excludeMeasurements: true)] public class IntroExportJson { [Benchmark] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep20() => Thread.Sleep(20); } // *** Object style *** [Config(typeof(Config))] public class IntroJsonExportObjectStyle { private class Config : ManualConfig { public Config() { AddExporter(JsonExporter.Brief); AddExporter(JsonExporter.Brief); AddExporter(JsonExporter.Full); AddExporter(JsonExporter.BriefCompressed); AddExporter(JsonExporter.FullCompressed); AddExporter(JsonExporter.Custom(\"-custom\", indentJson: true, excludeMeasurements: true)); } } [Benchmark] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep20() => Thread.Sleep(20); } } Output Example of IntroJsonExport-report-brief.json: { \"Title\":\"IntroJsonExport\", \"HostEnvironmentInfo\":{ \"BenchmarkDotNetCaption\":\"BenchmarkDotNet-Dev.Core\", \"BenchmarkDotNetVersion\":\"0.9.9.0\", \"OsVersion\":\"Microsoft Windows NT 6.2.9200.0\", \"ProcessorName\":{ \"IsValueCreated\":true, \"Value\":\"Intel(R) Core(TM) i7-4702MQ CPU 2.20GHz\" }, \"ProcessorCount\":8, \"ClrVersion\":\"MS.NET 4.0.30319.42000\", \"Architecture\":\"64-bit\", \"HasAttachedDebugger\":false, \"HasRyuJit\":true, \"Configuration\":\"RELEASE\", \"JitModules\":\"clrjit-v4.6.1586.0\", \"DotNetCliVersion\":\"1.0.0-preview2-003121\", \"ChronometerFrequency\":2143474, \"HardwareTimerKind\":\"Tsc\" }, \"Benchmarks\":[ { \"ShortInfo\":\"IntroJsonExport_Sleep10\", \"Namespace\":\"BenchmarkDotNet.Samples.Intro\", \"Type\":\"IntroJsonExport\", \"Method\":\"Sleep10\", \"MethodTitle\":\"Sleep10\", \"Parameters\":\"\", \"Properties\":{ \"Mode\":\"Throughput\", \"Platform\":\"Host\", \"Jit\":\"Host\", \"Runtime\":\"Host\", \"GcMode\":\"Host\", \"WarmupCount\":\"Auto\", \"IterationCount\":\"Auto\", \"LaunchCount\":\"Auto\", \"IterationTime\":\"Auto\", \"Affinity\":\"Auto\" }, \"Statistics\":{ \"N\":20, \"Min\":10265993.7209375, \"LowerFence\":10255329.082734371, \"Q1\":10337369.528437499, \"Median\":10360382.6953125, \"Mean\":10362283.085796878, \"Q3\":10392063.158906251, \"UpperFence\":10474103.60460938, \"Max\":10436008.3209375, \"InterquartileRange\":54693.630468752235, \"Outliers\":[ ], \"StandardError\":10219.304338928456, \"Variance\":2088683623.4328396, \"StandardDeviation\":45702.118369205156, \"Skewness\":-0.1242777170069375, \"Kurtosis\":2.31980277935226, \"ConfidenceInterval\":{ \"Mean\":10362283.085796878, \"Error\":10219.304338928456, \"Level\":6, \"Margin\":20029.836504299772, \"Lower\":10342253.249292579, \"Upper\":10382312.922301177 }, \"Percentiles\":{ \"P0\":10265993.7209375, \"P25\":10338555.905625, \"P50\":10360382.6953125, \"P67\":10373496.555659376, \"P80\":10400703.4841875, \"P85\":10417280.326718749, \"P90\":10424125.595812501, \"P95\":10435620.51609375, \"P100\":10436008.3209375 } } },{ \"ShortInfo\":\"IntroJsonExport_Sleep20\", \"Namespace\":\"BenchmarkDotNet.Samples.Intro\", \"Type\":\"IntroJsonExport\", \"Method\":\"Sleep20\", \"MethodTitle\":\"Sleep20\", \"Parameters\":\"\", \"Properties\":{ \"Mode\":\"Throughput\", \"Platform\":\"Host\", \"Jit\":\"Host\", \"Runtime\":\"Host\", \"GcMode\":\"Host\", \"WarmupCount\":\"Auto\", \"IterationCount\":\"Auto\", \"LaunchCount\":\"Auto\", \"IterationTime\":\"Auto\", \"Affinity\":\"Auto\" }, \"Statistics\":{ \"N\":20, \"Min\":20258672.37, \"LowerFence\":20206333.269843742, \"Q1\":20325342.761249997, \"Median\":20362636.192500003, \"Mean\":20360791.931687497, \"Q3\":20404682.4221875, \"UpperFence\":20523691.913593754, \"Max\":20422396.073125, \"InterquartileRange\":79339.66093750298, \"Outliers\":[ ], \"StandardError\":10728.817907277158, \"Variance\":2302150673.7502208, \"StandardDeviation\":47980.732317777525, \"Skewness\":-0.50826238372439869, \"Kurtosis\":2.11050327966268, \"ConfidenceInterval\":{ \"Mean\":20360791.931687497, \"Error\":10728.817907277158, \"Level\":6, \"Margin\":21028.48309826323, \"Lower\":20339763.448589232, \"Upper\":20381820.414785761 }, \"Percentiles\":{ \"P0\":20258672.37, \"P25\":20327638.975312497, \"P50\":20362636.192500003, \"P67\":20391669.3762875, \"P80\":20406370.68625, \"P85\":20412542.034406248, \"P90\":20414412.5376875, \"P95\":20416606.697718751, \"P100\":20422396.073125 } } } ] } Links Exporters The permanent link to this sample: BenchmarkDotNet.Samples.IntroExportJson"
  },
  "articles/samples/IntroExportXml.html": {
    "href": "articles/samples/IntroExportXml.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroExportXml BenchmarkDotNet has a set of XML exporters. You can customize the following properties of these exporters: fileNameSuffix: a string which be placed in the end of target file name. indentXml=false/true: should we format xml or not. excludeMeasurements=false/true: should we exclude detailed information about measurements or not (the final summary with statistics will be in the XML file anyway). Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DryJob] [XmlExporterAttribute.Brief] [XmlExporterAttribute.Full] [XmlExporterAttribute.BriefCompressed] [XmlExporterAttribute.FullCompressed] [XmlExporter(\"-custom\", indentXml: true, excludeMeasurements: true)] public class IntroExportXml { [Benchmark] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep20() => Thread.Sleep(20); } } Output Example of IntroXmlExport-report-brief.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <Summary> <Title>IntroXmlExport</Title> <HostEnvironmentInfo> <BenchmarkDotNetCaption>BenchmarkDotNet</BenchmarkDotNetCaption> <BenchmarkDotNetVersion>0.10.9.20170805-develop</BenchmarkDotNetVersion> <OsVersion>Windows 10 Redstone 2 (10.0.15063)</OsVersion> <ProcessorName>Intel Core i7-3770K CPU 3.50GHz (Ivy Bridge)</ProcessorName> <ProcessorCount>8</ProcessorCount> <RuntimeVersion>.NET Framework 4.7 (CLR 4.0.30319.42000)</RuntimeVersion> <Architecture>64bit</Architecture> <HasAttachedDebugger>False</HasAttachedDebugger> <HasRyuJit>True</HasRyuJit> <Configuration>RELEASE</Configuration> <JitModules>clrjit-v4.7.2101.1</JitModules> <DotNetSdkVersion>1.0.4</DotNetSdkVersion> <ChronometerFrequency> <Hertz>3410220</Hertz> </ChronometerFrequency> <HardwareTimerKind>Tsc</HardwareTimerKind> </HostEnvironmentInfo> <Benchmarks> <Benchmark> <DisplayInfo>IntroXmlExport.Sleep10: DefaultJob</DisplayInfo> <Namespace>BenchmarkDotNet.Samples.Intro</Namespace> <Type>IntroXmlExport</Type> <Method>Sleep10</Method> <MethodTitle>Sleep10</MethodTitle> <Statistics> <N>15</N> <Min>10989865.8785938</Min> <LowerFence>10989836.0967969</LowerFence> <Q1>10990942.6053125</Q1> <Median>10991249.5870313</Median> <Mean>10991270.0524583</Mean> <Q3>10991680.2776563</Q3> <UpperFence>10992786.7861719</UpperFence> <Max>10992115.5501563</Max> <InterquartileRange>737.672343749553</InterquartileRange> <StandardError>148.484545262958</StandardError> <Variance>330714.902729213</Variance> <StandardDeviation>575.07817097262</StandardDeviation> <Skewness>-0.67759778074187</Skewness> <Kurtosis>3.14296703520386</Kurtosis> <ConfidenceInterval> <N>15</N> <Mean>10991270.0524583</Mean> <StandardError>148.484545262958</StandardError> <Level>L999</Level> <Margin>614.793505974065</Margin> <Lower>10990655.2589524</Lower> <Upper>10991884.8459643</Upper> </ConfidenceInterval> <Percentiles> <P0>10989865.8785938</P0> <P25>10991027.3689063</P25> <P50>10991249.5870313</P50> <P67>10991489.490875</P67> <P80>10991696.7722187</P80> <P85>10991754.5031875</P85> <P90>10991933.1939688</P90> <P95>10992067.441125</P95> <P100>10992115.5501563</P100> </Percentiles> </Statistics> </Benchmark> </Benchmarks> </Summary> Links Exporters The permanent link to this sample: BenchmarkDotNet.Samples.IntroExportXml"
  },
  "articles/samples/IntroFilters.html": {
    "href": "articles/samples/IntroFilters.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroFilters You can either use one of the predefined Filter types or create a custom type which implements IFilter interface. Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Filters; namespace BenchmarkDotNet.Samples { [DryJob] [Config(typeof(Config))] public class IntroFilters { private class Config : ManualConfig { // We will benchmark ONLY method with // names (which contains \"A\" OR \"1\") AND (have length < 3) public Config() { // benchmark with names which contains \"A\" OR \"1\" AddFilter(new DisjunctionFilter( new NameFilter(name => name.Contains(\"A\")), new NameFilter(name => name.Contains(\"1\")) )); // benchmark with names with length < 3 AddFilter(new NameFilter(name => name.Length < 3)); } } [Benchmark] public void A1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void A2() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void A3() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void B1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void B2() => Thread.Sleep(10); [Benchmark] public void B3() => Thread.Sleep(10); [Benchmark] public void C1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void C2() => Thread.Sleep(10); [Benchmark] public void C3() => Thread.Sleep(10); [Benchmark] public void Aaa() => Thread.Sleep(10); } } Links Filters The permanent link to this sample: BenchmarkDotNet.Samples.IntroFilters"
  },
  "articles/samples/IntroFluentConfigBuilder.html": {
    "href": "articles/samples/IntroFluentConfigBuilder.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroFluentConfigBuilder There is no need to create new Config type, you can simply use fluent interface. Source code using System; using System.Security.Cryptography; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; using BenchmarkDotNet.Validators; namespace BenchmarkDotNet.Samples { public class Algo_Md5VsSha256 { private const int N = 10000; private readonly byte[] data; private readonly MD5 md5 = MD5.Create(); private readonly SHA256 sha256 = SHA256.Create(); public Algo_Md5VsSha256() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark(Baseline = true)] public byte[] Md5() => md5.ComputeHash(data); [Benchmark] public byte[] Sha256() => sha256.ComputeHash(data); } public class IntroFluentConfigBuilder { public static void Run() { BenchmarkRunner .Run<Algo_Md5VsSha256>( DefaultConfig.Instance .AddJob(Job.Default.WithRuntime(ClrRuntime.Net462)) .AddJob(Job.Default.WithRuntime(CoreRuntime.Core80)) .AddValidator(ExecutionValidator.FailOnError)); } } } Links Configs The permanent link to this sample: BenchmarkDotNet.Samples.IntroFluentConfigBuilder"
  },
  "articles/samples/IntroGcMode.html": {
    "href": "articles/samples/IntroGcMode.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroGcMode Source code using System.Runtime.CompilerServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Order; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [MemoryDiagnoser] public class IntroGcMode { private class Config : ManualConfig { public Config() { AddJob(Job.MediumRun.WithGcServer(true).WithGcForce(true).WithId(\"ServerForce\")); AddJob(Job.MediumRun.WithGcServer(true).WithGcForce(false).WithId(\"Server\")); AddJob(Job.MediumRun.WithGcServer(false).WithGcForce(true).WithId(\"Workstation\")); AddJob(Job.MediumRun.WithGcServer(false).WithGcForce(false).WithId(\"WorkstationForce\")); } } [Benchmark(Description = \"new byte[10kB]\")] public byte[] Allocate() { return new byte[10000]; } [Benchmark(Description = \"stackalloc byte[10kB]\")] public unsafe void AllocateWithStackalloc() { var array = stackalloc byte[10000]; Consume(array); } [MethodImpl(MethodImplOptions.NoInlining)] private static unsafe void Consume(byte* input) { } } } Output Links Jobs The permanent link to this sample: BenchmarkDotNet.Samples.IntroGcMode"
  },
  "articles/samples/IntroGenericTypeArguments.html": {
    "href": "articles/samples/IntroGenericTypeArguments.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroGenericTypeArguments Source code using System; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [GenericTypeArguments(typeof(int))] [GenericTypeArguments(typeof(char))] public class IntroGenericTypeArguments<T> { [Benchmark] public T Create() => Activator.CreateInstance<T>(); } } Links The permanent link to this sample: BenchmarkDotNet.Samples.IntroGenericTypeArguments"
  },
  "articles/samples/IntroHardwareCounters.html": {
    "href": "articles/samples/IntroHardwareCounters.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroHardwareCounters This diagnoser is not enabled in explicit way as the other diagnosers. You need to specify [HardwareCounters] and we choose the right diagnoser in the runtime. Source code using System; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnosers; namespace BenchmarkDotNet.Samples { [HardwareCounters( HardwareCounter.BranchMispredictions, HardwareCounter.BranchInstructions)] public class IntroHardwareCounters { private const int N = 32767; private readonly int[] sorted, unsorted; public IntroHardwareCounters() { var random = new Random(0); unsorted = new int[N]; sorted = new int[N]; for (int i = 0; i < N; i++) sorted[i] = unsorted[i] = random.Next(256); Array.Sort(sorted); } private static int Branch(int[] data) { int sum = 0; for (int i = 0; i < N; i++) if (data[i] >= 128) sum += data[i]; return sum; } private static int Branchless(int[] data) { int sum = 0; for (int i = 0; i < N; i++) { int t = (data[i] - 128) >> 31; sum += ~t & data[i]; } return sum; } [Benchmark] public int SortedBranch() => Branch(sorted); [Benchmark] public int UnsortedBranch() => Branch(unsorted); [Benchmark] public int SortedBranchless() => Branchless(sorted); [Benchmark] public int UnsortedBranchless() => Branchless(unsorted); } } Output Method Mean Mispredict rate BranchInstructions/Op BranchMispredictions/Op SortedBranch 21.4539 us 0,04% 70121 24 UnsortedBranch 136.1139 us 23,70% 68788 16301 SortedBranchless 28.6705 us 0,06% 35711 22 UnsortedBranchless 28.9336 us 0,05% 35578 17 Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroHardwareCounters"
  },
  "articles/samples/IntroInliningDiagnoser.html": {
    "href": "articles/samples/IntroInliningDiagnoser.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroInliningDiagnoser This sample shows how to add InliningDiagnoser with events from only one namespace (BenchmarkDotNet.Samples). Source code using BenchmarkDotNet.Attributes; using System.Runtime.CompilerServices; namespace BenchmarkDotNet.Samples { [Diagnostics.Windows.Configs.InliningDiagnoser(logFailuresOnly: false, allowedNamespaces: new[] { \"BenchmarkDotNet.Samples\" })] public class IntroInliningDiagnoser { [Benchmark] public int IterationTest() { int j = 0; for (int i = 0; i < short.MaxValue; ++i) { j = i + AddThree(i); } return j + ReturnFive() + AddThree(ReturnFive()); } [Benchmark] public int SplitJoin() => string.Join(\",\", new string[1000]).Split(',').Length; private int ReturnFive() { return 5; } [MethodImpl(MethodImplOptions.AggressiveInlining)] private int AddThree(int a) { return a + 3; } } }"
  },
  "articles/samples/IntroInProcess.html": {
    "href": "articles/samples/IntroInProcess.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroInProcess InProcessEmitToolchain is our toolchain which does not generate any new executable. It emits IL on the fly and runs it from within the process itself. It can be useful if want to run the benchmarks very fast or if you want to run them for framework which we don't support. An example could be a local build of CoreCLR. Usage [InProcessAttribute] public class TypeWithBenchmarks { } Source code using System.Runtime.CompilerServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Order; using BenchmarkDotNet.Toolchains.InProcess.Emit; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [MemoryDiagnoser] public class IntroInProcess { private class Config : ManualConfig { public Config() { AddJob(Job.MediumRun .WithLaunchCount(1) .WithId(\"OutOfProc\")); AddJob(Job.MediumRun .WithLaunchCount(1) .WithToolchain(InProcessEmitToolchain.Instance) .WithId(\"InProcess\")); } } [Benchmark(Description = \"new byte[10kB]\")] public byte[] Allocate() { return new byte[10000]; } [Benchmark(Description = \"stackalloc byte[10kB]\")] public unsafe void AllocateWithStackalloc() { var array = stackalloc byte[10000]; Consume(array); } [MethodImpl(MethodImplOptions.NoInlining)] private static unsafe void Consume(byte* input) { } } } Output Links Toolchains The permanent link to this sample: BenchmarkDotNet.Samples.IntroInProcess"
  },
  "articles/samples/IntroInProcessWrongEnv.html": {
    "href": "articles/samples/IntroInProcessWrongEnv.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroInProcessWrongEnv Source code using System; using System.Runtime.CompilerServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Order; using BenchmarkDotNet.Toolchains.InProcess; using BenchmarkDotNet.Toolchains.InProcess.Emit; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [MemoryDiagnoser] public class IntroInProcessWrongEnv { private class Config : ManualConfig { public Config() { var wrongPlatform = Environment.Is64BitProcess ? Platform.X64 : Platform.X86; AddJob(Job.MediumRun .WithLaunchCount(1) .WithPlatform(wrongPlatform) .WithToolchain(InProcessEmitToolchain.Instance) .WithId(\"InProcess\")); AddValidator(InProcessValidator.DontFailOnError); } } [Benchmark(Description = \"new byte[10kB]\")] public byte[] Allocate() { return new byte[10000]; } [Benchmark(Description = \"stackalloc byte[10kB]\")] public unsafe void AllocateWithStackalloc() { var array = stackalloc byte[10000]; Consume(array); } [MethodImpl(MethodImplOptions.NoInlining)] private static unsafe void Consume(byte* input) { } } } Output Links Toolchains The permanent link to this sample: BenchmarkDotNet.Samples.IntroInProcessWrongEnv"
  },
  "articles/samples/IntroJitStatsDiagnoser.html": {
    "href": "articles/samples/IntroJitStatsDiagnoser.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroJitStatsDiagnoser This diagnoser shows various stats from the JIT compiler that were collected during entire benchmark run (warmup phase and BenchmarkDotNet-generated boilerplate code are included): Amount of JITted methods. Amount of tiered methods. How much memory JIT allocated during the benchmark. Restrictions Windows only Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [Diagnostics.Windows.Configs.JitStatsDiagnoser] public class IntroJitStatsDiagnoser { [Benchmark] public void Sleep() => Thread.Sleep(10); } } Output Method Mean Error StdDev Methods JITted Methods Tiered JIT allocated memory Sleep 15.50 ms 0.052 ms 0.048 ms 1,102 214 221,736 B Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroJitStatsDiagnoser"
  },
  "articles/samples/IntroJobBaseline.html": {
    "href": "articles/samples/IntroJobBaseline.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroJobBaseline If you want to compare several runtime configuration, you can mark one of your jobs with baseline = true. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [SimpleJob(runtimeMoniker: RuntimeMoniker.Net462, baseline: true)] [SimpleJob(runtimeMoniker: RuntimeMoniker.Mono)] [SimpleJob(runtimeMoniker: RuntimeMoniker.Net50)] public class IntroJobBaseline { [Benchmark] public int SplitJoin() => string.Join(\",\", new string[1000]).Split(',').Length; } } Output BenchmarkDotNet=v0.10.12, OS=Windows 10 Redstone 3 [1709, Fall Creators Update] (10.0.16299.192) Processor=Intel Core i7-6700HQ CPU 2.60GHz (Skylake), ProcessorCount=8 Frequency=2531249 Hz, Resolution=395.0619 ns, Timer=TSC .NET Core SDK=2.0.3 [Host] : .NET Core 2.0.3 (Framework 4.6.25815.02), 64bit RyuJIT Job-MXFYPZ : .NET Framework 4.7 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.2600.0 Core : .NET Core 2.0.3 (Framework 4.6.25815.02), 64bit RyuJIT Mono : Mono 5.4.0 (Visual Studio), 64bit Method | Runtime | Mean | Error | StdDev | Ratio | RatioSD | ---------- |-------- |---------:|----------:|----------:|------:|--------:| SplitJoin | Clr | 19.42 us | 0.2447 us | 0.1910 us | 1.00 | 0.00 | SplitJoin | Core | 13.00 us | 0.2183 us | 0.1935 us | 0.67 | 0.01 | SplitJoin | Mono | 39.14 us | 0.7763 us | 1.3596 us | 2.02 | 0.07 | Links Benchmark and Job Baselines The permanent link to this sample: BenchmarkDotNet.Samples.IntroJobBaseline"
  },
  "articles/samples/IntroJoin.html": {
    "href": "articles/samples/IntroJoin.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroJoin If you are using BenchmarkSwitcher and want to run all the benchmarks with a category from all types and join them into one summary table, use the --join option (or BenchmarkSwitcher.RunAllJoined): Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { // Run BenchmarkSwitcher with arguments: \"--join --category=IntroJoinA\" [DryJob] public class IntroJoin1 { [Benchmark] [BenchmarkCategory(\"IntroJoinA\")] public void A() => Thread.Sleep(10); [Benchmark] [BenchmarkCategory(\"IntroJoinB\")] public void B() => Thread.Sleep(10); } [DryJob] public class IntroJoin2 { [Benchmark] [BenchmarkCategory(\"IntroJoinA\")] public void A() => Thread.Sleep(10); [Benchmark] [BenchmarkCategory(\"IntroJoinB\")] public void B() => Thread.Sleep(10); } } Command line --join --allCategories=IntroJoinA Output | Type | Method | Mean | Error | |----------- |------- |---------:|------:| | IntroJoin1 | A | 10.99 ms | NA | | IntroJoin2 | A | 12.50 ms | NA | Links Filters The permanent link to this sample: BenchmarkDotNet.Samples.IntroJoin"
  },
  "articles/samples/IntroLargeAddressAware.html": {
    "href": "articles/samples/IntroLargeAddressAware.html",
    "title": "Sample: IntroLargeAddressAware | BenchmarkDotNet",
    "summary": "Sample: IntroLargeAddressAware Source code using System; using System.Runtime.InteropServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [MemoryDiagnoser] [Config(typeof(Config))] public class IntroLargeAddressAware { private class Config : ManualConfig { public Config() { AddJob(Job.Default .WithRuntime(ClrRuntime.Net462) .WithPlatform(Platform.X86) .WithLargeAddressAware(value: RuntimeInformation.IsOSPlatform(OSPlatform.Windows)) .WithId(\"Framework\")); } } [Benchmark] public void AllocateMoreThan2GB() { const int oneGB = 1024 * 1024 * 1024; const int halfGB = oneGB / 2; byte[] bytes1 = new byte[oneGB]; byte[] bytes2 = new byte[oneGB]; byte[] bytes3 = new byte[halfGB]; GC.KeepAlive(bytes1); GC.KeepAlive(bytes2); GC.KeepAlive(bytes3); } } } Links The permanent link to this sample: Sample: IntroLargeAddressAware"
  },
  "articles/samples/IntroMonitoring.html": {
    "href": "articles/samples/IntroMonitoring.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroMonitoring If a benchmark method takes at least 100ms, you can also use the Monitoring strategy. In this case, the pilot stage will be omitted, by default you get 1 iteration = 1 operation (or you can manually set amount of operation in an iteration). Also you can use [IterationSetup] and [IterationCleanup] in this case: it shouldn't affect time measurements (but it can affect results of MemoryDiagnoser). It's a perfect mode for benchmarks which doesn't have a steady state and the performance distribution is tricky: Monitoring will help you to collect a set of measurements and get statistics. Usage [SimpleJob(RunStrategy.Monitoring, launchCount: 10, warmupCount: 0, iterationCount: 100)] public class MyBenchmarkClass Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.Monitoring, iterationCount: 10, id: \"MonitoringJob\")] [MinColumn, Q1Column, Q3Column, MaxColumn] public class IntroMonitoring { private Random random = new Random(42); [Benchmark] public void Foo() { Thread.Sleep(random.Next(10) * 10); } } } Output Result 1: 1 op, 61552600.00 ns, 61.5526 ms/op Result 2: 1 op, 10141700.00 ns, 10.1417 ms/op Result 3: 1 op, 10482900.00 ns, 10.4829 ms/op Result 4: 1 op, 50410900.00 ns, 50.4109 ms/op Result 5: 1 op, 10421400.00 ns, 10.4214 ms/op Result 6: 1 op, 20556100.00 ns, 20.5561 ms/op Result 7: 1 op, 70473200.00 ns, 70.4732 ms/op Result 8: 1 op, 50581700.00 ns, 50.5817 ms/op Result 9: 1 op, 10559000.00 ns, 10.5590 ms/op Result 10: 1 op, 70496300.00 ns, 70.4963 ms/op Method Mean Error StdDev Min Q1 Q3 Max Foo 36.57 ms 40.03 ms 26.47 ms 10.14 ms 10.48 ms 61.55 ms 70.50 ms Links Choosing RunStrategy The permanent link to this sample: BenchmarkDotNet.Samples.IntroMonitoring"
  },
  "articles/samples/IntroMultimodal.html": {
    "href": "articles/samples/IntroMultimodal.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroMultimodal Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [MValueColumn] [SimpleJob(RunStrategy.Throughput, 1, 0, -1, 1, \"MyJob\")] public class IntroMultimodal { private readonly Random rnd = new Random(42); private void Multimodal(int n) => Thread.Sleep((rnd.Next(n) + 1) * 100); [Benchmark] public void Unimodal() => Multimodal(1); [Benchmark] public void Bimodal() => Multimodal(2); [Benchmark] public void Trimodal() => Multimodal(3); [Benchmark] public void Quadrimodal() => Multimodal(4); } } Output Method | Mean | Error | StdDev | Median | MValue | ------------ |---------:|-----------:|------------:|---------:|-------:| Unimodal | 100.5 ms | 0.0713 ms | 0.0667 ms | 100.5 ms | 2.000 | Bimodal | 144.5 ms | 16.9165 ms | 49.8787 ms | 100.6 ms | 3.571 | Trimodal | 182.5 ms | 27.4285 ms | 80.8734 ms | 200.5 ms | 4.651 | Quadrimodal | 226.6 ms | 37.2269 ms | 109.7644 ms | 200.7 ms | 5.882 | // * Warnings * MultimodalDistribution IntroMultimodal.Bimodal: MainJob -> It seems that the distribution is bimodal (mValue = 3.57) IntroMultimodal.Trimodal: MainJob -> It seems that the distribution is multimodal (mValue = 4.65) IntroMultimodal.Quadrimodal: MainJob -> It seems that the distribution is multimodal (mValue = 5.88) Links Statistics The permanent link to this sample: BenchmarkDotNet.Samples.IntroMultimodal"
  },
  "articles/samples/IntroNativeMemory.html": {
    "href": "articles/samples/IntroNativeMemory.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroNativeMemory The NativeMemoryProfiler uses EtwProfiler to profile the code using ETW and adds the extra columns Allocated native memory and Native memory leak to the benchmark results table. Source code using System; using System.Drawing; using System.Runtime.InteropServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnostics.Windows.Configs; namespace BenchmarkDotNet.Samples { [ShortRunJob] [NativeMemoryProfiler] [MemoryDiagnoser] public class IntroNativeMemory { [Benchmark] public void BitmapWithLeaks() { var flag = new Bitmap(200, 100); var graphics = Graphics.FromImage(flag); var blackPen = new Pen(Color.Black, 3); graphics.DrawLine(blackPen, 100, 100, 500, 100); } [Benchmark] public void Bitmap() { using (var flag = new Bitmap(200, 100)) { using (var graphics = Graphics.FromImage(flag)) { using (var blackPen = new Pen(Color.Black, 3)) { graphics.DrawLine(blackPen, 100, 100, 500, 100); } } } } private const int Size = 20; // Greater value could cause System.OutOfMemoryException for test with memory leaks. private int ArraySize = Size * Marshal.SizeOf(typeof(int)); [Benchmark] public unsafe void AllocHGlobal() { IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize); Span<byte> unmanaged = new Span<byte>(unmanagedHandle.ToPointer(), ArraySize); Marshal.FreeHGlobal(unmanagedHandle); } [Benchmark] public unsafe void AllocHGlobalWithLeaks() { IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize); Span<byte> unmanaged = new Span<byte>(unmanagedHandle.ToPointer(), ArraySize); } } } Output Method Mean Error StdDev Gen 0 Gen 1 Gen 2 Allocated Allocated native memory Native memory leak BitmapWithLeaks 73,456.43 ns 22,498.10 ns 1,233.197 ns - - - 177 B 13183 B 11615 B Bitmap 91,590.08 ns 101,468.12 ns 5,561.810 ns - - - 180 B 12624 B - AllocHGlobal 79.91 ns 43.93 ns 2.408 ns - - - - 80 B - AllocHGlobalWithLeaks 103.50 ns 153.21 ns 8.398 ns - - - - 80 B 80 B Profiling memory leaks The BenchmarkDotNet repeats benchmarking function many times. Sometimes it can cause a memory overflow. In this case, the BenchmarkDotNet shows the message: OutOfMemoryException! BenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects. If your benchmark allocates memory and keeps it alive, you are creating a memory leak. You should redesign your benchmark and remove the side-effects. You can use `OperationsPerInvoke`, `IterationSetup` and `IterationCleanup` to do that. In this case, you should try to reduce the number of invocation, by adding [ShortRunJob] attribute or using Job.Short for custom configuration. Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroNativeMemory"
  },
  "articles/samples/IntroNuGet.html": {
    "href": "articles/samples/IntroNuGet.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroNuGet You can set specific versions of NuGet dependencies for each job. It allows comparing different versions of the same package (if there are no breaking changes in API). Source code using System; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; using Newtonsoft.Json; namespace BenchmarkDotNet.Samples { /// <summary> /// Benchmarks between various versions of a NuGet package /// </summary> /// <remarks> /// Only supported with the CsProjCoreToolchain toolchain /// </remarks> [Config(typeof(Config))] public class IntroNuGet { // Specify jobs with different versions of the same NuGet package to benchmark. // The NuGet versions referenced on these jobs must be greater or equal to the // same NuGet version referenced in this benchmark project. // Example: This benchmark project references Newtonsoft.Json 9.0.1 private class Config : ManualConfig { public Config() { var baseJob = Job.MediumRun; AddJob(baseJob.WithNuGet(\"Newtonsoft.Json\", \"11.0.2\").WithId(\"11.0.2\")); AddJob(baseJob.WithNuGet(\"Newtonsoft.Json\", \"11.0.1\").WithId(\"11.0.1\")); AddJob(baseJob.WithNuGet(\"Newtonsoft.Json\", \"10.0.3\").WithId(\"10.0.3\")); AddJob(baseJob.WithNuGet(\"Newtonsoft.Json\", \"10.0.2\").WithId(\"10.0.2\")); AddJob(baseJob.WithNuGet(\"Newtonsoft.Json\", \"10.0.1\").WithId(\"10.0.1\")); AddJob(baseJob.WithNuGet(\"Newtonsoft.Json\", \"9.0.1\").WithId(\"9.0.1\")); } } [Benchmark] public void SerializeAnonymousObject() => JsonConvert.SerializeObject( new { hello = \"world\", price = 1.99, now = DateTime.UtcNow }); } } Output Method Job NuGetReferences Mean Error StdDev SerializeAnonymousObject 10.0.1 Newtonsoft.Json 10.0.1 2.926 us 0.0795 us 0.0283 us SerializeAnonymousObject 10.0.2 Newtonsoft.Json 10.0.2 2.877 us 0.5928 us 0.2114 us SerializeAnonymousObject 10.0.3 Newtonsoft.Json 10.0.3 2.706 us 0.1251 us 0.0446 us SerializeAnonymousObject 11.0.1 Newtonsoft.Json 11.0.1 2.778 us 0.5037 us 0.1796 us SerializeAnonymousObject 11.0.2 Newtonsoft.Json 11.0.2 2.644 us 0.0609 us 0.0217 us SerializeAnonymousObject 9.0.1 Newtonsoft.Json 9.0.1 2.722 us 0.3552 us 0.1267 us Links The permanent link to this sample: BenchmarkDotNet.Samples.IntroNuGet"
  },
  "articles/samples/IntroOrderAttr.html": {
    "href": "articles/samples/IntroOrderAttr.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroOrderAttr Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Order; namespace BenchmarkDotNet.Samples { [Orderer(SummaryOrderPolicy.FastestToSlowest, MethodOrderPolicy.Declared)] [DryJob] public class IntroOrderAttr { [Params(1, 2, 3)] public int X { get; set; } [Benchmark] public void Slow() => Thread.Sleep(X * 100); [Benchmark] public void Fast() => Thread.Sleep(X * 50); } } Links Orderers The permanent link to this sample: BenchmarkDotNet.Samples.IntroOrderAttr"
  },
  "articles/samples/IntroOrderManual.html": {
    "href": "articles/samples/IntroOrderManual.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroOrderManual Source code using System.Collections.Generic; using System.Collections.Immutable; using System.Linq; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Order; using BenchmarkDotNet.Reports; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [DryJob] [RankColumn] public class IntroOrderManual { private class Config : ManualConfig { public Config() => Orderer = new FastestToSlowestOrderer(); private class FastestToSlowestOrderer : IOrderer { public IEnumerable<BenchmarkCase> GetExecutionOrder(ImmutableArray<BenchmarkCase> benchmarksCase, IEnumerable<BenchmarkLogicalGroupRule>? order = null) => from benchmark in benchmarksCase orderby benchmark.Parameters[\"X\"] descending, benchmark.Descriptor.WorkloadMethodDisplayInfo select benchmark; public IEnumerable<BenchmarkCase> GetSummaryOrder(ImmutableArray<BenchmarkCase> benchmarksCase, Summary summary) => from benchmark in benchmarksCase orderby summary[benchmark].ResultStatistics.Mean select benchmark; public string GetHighlightGroupKey(BenchmarkCase benchmarkCase) => null; public string GetLogicalGroupKey(ImmutableArray<BenchmarkCase> allBenchmarksCases, BenchmarkCase benchmarkCase) => benchmarkCase.Job.DisplayInfo + \"_\" + benchmarkCase.Parameters.DisplayInfo; public IEnumerable<IGrouping<string, BenchmarkCase>> GetLogicalGroupOrder(IEnumerable<IGrouping<string, BenchmarkCase>> logicalGroups, IEnumerable<BenchmarkLogicalGroupRule>? order = null) => logicalGroups.OrderBy(it => it.Key); public bool SeparateLogicalGroups => true; } } [Params(1, 2, 3)] public int X { get; set; } [Benchmark] public void Fast() => Thread.Sleep(X * 50); [Benchmark] public void Slow() => Thread.Sleep(X * 100); } } Links Orderers The permanent link to this sample: BenchmarkDotNet.Samples.IntroOrderManual"
  },
  "articles/samples/IntroOutliers.html": {
    "href": "articles/samples/IntroOutliers.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroOutliers Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; using Perfolizer.Mathematics.OutlierDetection; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] public class IntroOutliers { private class Config : ManualConfig { public Config() { var jobBase = Job.Default.WithWarmupCount(0).WithIterationCount(10).WithInvocationCount(1).WithUnrollFactor(1); AddJob(jobBase.WithOutlierMode(OutlierMode.DontRemove).WithId(\"DontRemoveOutliers\")); AddJob(jobBase.WithOutlierMode(OutlierMode.RemoveUpper).WithId(\"RemoveUpperOutliers\")); } } private int counter; [Benchmark] public void Foo() { counter++; int noise = counter % 10 == 0 ? 500 : 0; Thread.Sleep(100 + noise); } } } Output Method | Job | OutlierMode | Mean | Error | StdDev | ------- |-------------------- |------------ |---------:|------------:|------------:| Foo | DontRemoveOutliers | DontRemove | 150.5 ms | 239.1911 ms | 158.2101 ms | Foo | RemoveUpperOutliers | RemoveUpper | 100.5 ms | 0.1931 ms | 0.1149 ms | // * Hints * Outliers IntroOutliers.Foo: DontRemoveOutliers -> 1 outlier was detected IntroOutliers.Foo: RemoveUpperOutliers -> 1 outlier was removed Links Statistics The permanent link to this sample: BenchmarkDotNet.Samples.IntroOutliers"
  },
  "articles/samples/IntroParams.html": {
    "href": "articles/samples/IntroParams.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroParams You can mark one or several fields or properties in your class by the [Params] attribute. In this attribute, you can specify set of values. Every value must be a compile-time constant. As a result, you will get results for each combination of params values. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroParams { [Params(100, 200)] public int A { get; set; } [Params(10, 20)] public int B { get; set; } [Benchmark] public void Benchmark() => Thread.Sleep(A + B + 5); } } Output | Method | A | B | Mean | Error | StdDev | |---------- |---- |--- |---------:|--------:|--------:| | Benchmark | 100 | 10 | 115.3 ms | 0.13 ms | 0.12 ms | | Benchmark | 100 | 20 | 125.4 ms | 0.14 ms | 0.12 ms | | Benchmark | 200 | 10 | 215.5 ms | 0.19 ms | 0.18 ms | | Benchmark | 200 | 20 | 225.4 ms | 0.17 ms | 0.16 ms | Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroParams"
  },
  "articles/samples/IntroParamsAllValues.html": {
    "href": "articles/samples/IntroParamsAllValues.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroParamsAllValues If you want to use all possible values of an enum or another type with a small number of values, you can use the [ParamsAllValues] attribute, instead of listing all the values by hand. The types supported by the attribute are: bool any enum that is not marked with [Flags] Nullable<T>, where T is an enum or boolean Source code using BenchmarkDotNet.Attributes; using System.Threading; namespace BenchmarkDotNet.Samples { [DryJob] public class IntroParamsAllValues { public enum CustomEnum { One = 1, Two, Three } [ParamsAllValues] public CustomEnum E { get; set; } [ParamsAllValues] public bool? B { get; set; } [Benchmark] public void Benchmark() { Thread.Sleep( (int)E * 100 + (B == true ? 20 : B == false ? 10 : 0)); } } } Output Method | E | B | Mean | Error | ---------- |------ |------ |---------:|------:| Benchmark | One | ? | 101.4 ms | NA | Benchmark | One | False | 111.1 ms | NA | Benchmark | One | True | 122.0 ms | NA | Benchmark | Two | ? | 201.3 ms | NA | Benchmark | Two | False | 212.1 ms | NA | Benchmark | Two | True | 221.3 ms | NA | Benchmark | Three | ? | 301.4 ms | NA | Benchmark | Three | False | 311.5 ms | NA | Benchmark | Three | True | 320.8 ms | NA | Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroParamsAllValues"
  },
  "articles/samples/IntroParamsPriority.html": {
    "href": "articles/samples/IntroParamsPriority.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroParamsPriority In order to sort columns of parameters in the results table you can use the Property Priority inside the params attribute. The priority range is [Int32.MinValue;Int32.MaxValue], lower priorities will appear earlier in the column order. The default priority is set to 0. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroParamsPriority { [Params(100)] public int A { get; set; } [Params(10, Priority = -100)] public int B { get; set; } [Benchmark] public void Benchmark() => Thread.Sleep(A + B + 5); } } Output | Method | B | A | Mean | Error | StdDev | |---------- |--- |---- |---------:|--------:|--------:| | Benchmark | 10 | 100 | 115.4 ms | 0.12 ms | 0.11 ms | Links Priority BaseClass PriorityAttribute.cs Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroParamsPriority"
  },
  "articles/samples/IntroParamsSource.html": {
    "href": "articles/samples/IntroParamsSource.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroParamsSource In case you want to use a lot of values, you should use [ParamsSource] You can mark one or several fields or properties in your class by the [Params] attribute. In this attribute, you have to specify the name of public method/property which is going to provide the values (something that implements IEnumerable). The source must be within benchmarked type! Source code using System.Collections.Generic; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroParamsSource { // property with public setter [ParamsSource(nameof(ValuesForA))] public int A { get; set; } // public field [ParamsSource(nameof(ValuesForB))] public int B; // public property public IEnumerable<int> ValuesForA => new[] { 100, 200 }; // public static method public static IEnumerable<int> ValuesForB() => new[] { 10, 20 }; [Benchmark] public void Benchmark() => Thread.Sleep(A + B + 5); } } Output | Method | B | A | Mean | Error | StdDev | |---------- |--- |---- |---------:|--------:|--------:| | Benchmark | 10 | 100 | 115.5 ms | 0.17 ms | 0.16 ms | | Benchmark | 10 | 200 | 215.6 ms | 0.15 ms | 0.14 ms | | Benchmark | 20 | 100 | 125.5 ms | 0.19 ms | 0.18 ms | | Benchmark | 20 | 200 | 225.5 ms | 0.23 ms | 0.22 ms | Remarks A remark about IParam. You don't need to use IParam anymore since 0.11.0. Just use complex types as you wish and override ToString method to change the display names used in the results. Links Parameterization The permanent link to this sample: BenchmarkDotNet.Samples.IntroParamsSource"
  },
  "articles/samples/IntroPercentiles.html": {
    "href": "articles/samples/IntroPercentiles.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroPercentiles The percentile represents a higher boundary for specified percentage of the measurements. For example, 95th percentile = 500ms means that 95% of all samples are not slower than 500ms. This metric is not very useful in microbenchmarks, as the values from consequent runs have a very narrow distribution. However, real-world scenarios often have so-called long tail distribution (due to IO delays, locks, memory access latency and so on), so the average execution time cannot be trusted. The percentiles allow to include the tail of distribution into the comparison. However, it requires some preparations steps. At first, you should have enough runs to count percentiles from. The IterationCount in the config should be set to 10-20 runs at least. Second, the count of iterations for each run should not be very high, or the peak timings will be averaged. The IterationTime = 25 works fine for most cases; for long-running benchmarks the Mode = Mode.SingleRun will be the best choice. However, feel free to experiment with the config values. Third, if you want to be sure that measurements are repeatable, set the LaunchCount to 3 or higher. And last, don't forget to include the columns into the config. They are not included by default (as said above, these are not too useful for most of the benchmarks). There're predefined StatisticColumn.P0..StatisticColumn.P100 for absolute timing percentiles. Example Run the IntroPercentiles sample. It contains three benchmark methods. First delays for 20 ms constantly. The second has random delays for 10..30 ms. And the third delays for 10ms 85 times of 100 and delays for 40ms 15 times of 100. Here's the output from the benchmark (some columns removed for brevity): Method Median StdDev Ratio P0 P50 P80 P85 P95 P100 ConstantDelays 20.3813 ms 0.2051 ms 1.00 20.0272 ms 20.3813 ms 20.4895 ms 20.4954 ms 20.5869 ms 21.1471 ms RandomDelays 19.8055 ms 5.7556 ms 0.97 10.0793 ms 19.8055 ms 25.4173 ms 26.5187 ms 29.0313 ms 29.4550 ms RareDelays 10.3385 ms 11.4828 ms 0.51 10.0157 ms 10.3385 ms 10.5211 ms 40.0560 ms 40.3992 ms 40.4674 ms Also, it's very easy to screw the results with incorrect setup. For example, the same code being run with new Job { IterationCount = 5, IterationTime = 500 } completely hides the peak values: Method Median StdDev Ratio P0 P50 P80 P85 P95 P100 ConstantDelays 20.2692 ms 0.0308 ms 1.00 20.1986 ms 20.2692 ms 20.2843 ms 20.2968 ms 20.3097 ms 20.3122 ms RandomDelays 18.9965 ms 0.8601 ms 0.94 18.1339 ms 18.9965 ms 19.8126 ms 19.8278 ms 20.4485 ms 20.9466 ms RareDelays 14.0912 ms 2.8619 ms 0.70 10.2606 ms 14.0912 ms 15.7653 ms 17.3862 ms 18.6728 ms 18.6940 ms Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Columns; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { // Using percentiles for adequate timings representation [Config(typeof(Config))] [SimpleJob(RunStrategy.ColdStart, launchCount: 4, warmupCount: 3, iterationCount: 20, id: \"MyJob\")] public class IntroPercentiles { // To share between runs. // DO NOT do this in production code. The System.Random IS NOT thread safe. private static readonly Random Rnd = new Random(); private class Config : ManualConfig { public Config() { AddColumn( StatisticColumn.P0, StatisticColumn.P25, StatisticColumn.P50, StatisticColumn.P67, StatisticColumn.P80, StatisticColumn.P85, StatisticColumn.P90, StatisticColumn.P95, StatisticColumn.P100); } } [Benchmark(Baseline = true)] public void ConstantDelays() => Thread.Sleep(20); [Benchmark] public void RandomDelays() => Thread.Sleep(10 + (int) (20 * Rnd.NextDouble())); [Benchmark] public void RareDelays() { int rndTime = 10; // Bigger delays for 15% of the runs if (Rnd.NextDouble() > 0.85) { rndTime += 30; } Thread.Sleep(rndTime); } } } Links Statistics The permanent link to this sample: BenchmarkDotNet.Samples.IntroPercentiles"
  },
  "articles/samples/IntroPowerPlan.html": {
    "href": "articles/samples/IntroPowerPlan.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroPowerPlan This sample shows how we can manipulate with power plans. In BenchmarkDotNet we could change power plan in two ways. The first one is to set one from the list: PowerSaver, guid: a1841308-3541-4fab-bc81-f71556f20b4a Balanced, guid: 381b4222-f694-41f0-9685-ff5bb260df2e High-Performance, guid: 8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c (the default one) Ultimate Performance, guid: e9a42b02-d5df-448d-aa00-03f14749eb61 UserPowerPlan (a current power plan set in computer) The second one rely on guid string. We could easily found currently set GUIDs with cmd command powercfg /list If we set power plans in two ways at the same time, the second one will be used. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using System; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] public class IntroPowerPlan { private class Config : ManualConfig { public Config() { AddJob(Job.MediumRun.WithPowerPlan(new Guid(\"e9a42b02-d5df-448d-aa00-03f14749eb61\"))); AddJob(Job.MediumRun.WithPowerPlan(PowerPlan.UltimatePerformance)); AddJob(Job.MediumRun.WithPowerPlan(PowerPlan.UserPowerPlan)); AddJob(Job.MediumRun.WithPowerPlan(PowerPlan.HighPerformance)); AddJob(Job.MediumRun.WithPowerPlan(PowerPlan.Balanced)); AddJob(Job.MediumRun.WithPowerPlan(PowerPlan.PowerSaver)); } } [Benchmark] public int IterationTest() { int j = 0; for (int i = 0; i < short.MaxValue; ++i) { j = i; } return j; } [Benchmark] public int SplitJoin() => string.Join(\",\", new string[1000]).Split(',').Length; } } Links Power Plans The permanent link to this sample: BenchmarkDotNet.Samples.IntroPowerPlan"
  },
  "articles/samples/IntroRankColumn.html": {
    "href": "articles/samples/IntroRankColumn.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroRankColumn Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Mathematics; using BenchmarkDotNet.Order; namespace BenchmarkDotNet.Samples { [ShortRunJob] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [RankColumn(NumeralSystem.Arabic)] [RankColumn(NumeralSystem.Roman)] [RankColumn(NumeralSystem.Stars)] public class IntroRankColumn { [Params(1, 2)] public int Factor; [Benchmark] public void Foo() => Thread.Sleep(Factor * 100); [Benchmark] public void Bar() => Thread.Sleep(Factor * 200); } } Output Method | Factor | Mean | Error | StdDev | Rank | Rank | Rank | ------- |------- |---------:|---------:|----------:|-----:|-----:|-----:| Foo | 1 | 100.8 ms | 2.250 ms | 0.1272 ms | 1 | I | * | Foo | 2 | 200.8 ms | 4.674 ms | 0.2641 ms | 2 | II | ** | Bar | 1 | 200.9 ms | 2.012 ms | 0.1137 ms | 2 | II | ** | Bar | 2 | 400.7 ms | 4.509 ms | 0.2548 ms | 3 | III | *** | Links Statistics The permanent link to this sample: BenchmarkDotNet.Samples.IntroRankColumn"
  },
  "articles/samples/IntroRatioSD.html": {
    "href": "articles/samples/IntroRatioSD.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroRatioSD The ratio of two benchmarks is not a single number, it's a distribution. In most simple cases, the range of the ratio distribution is narrow, and BenchmarkDotNet displays a single column Ratio with the mean value. However, it also adds the RatioSD column (the standard deviation of the ratio distribution) in complex situations. In the below example, the baseline benchmark is spoiled by a single outlier Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; using Perfolizer.Mathematics.OutlierDetection; namespace BenchmarkDotNet.Samples { // Don't remove outliers [Outliers(OutlierMode.DontRemove)] // Skip jitting, pilot, warmup; measure 10 iterations [SimpleJob(RunStrategy.Monitoring, iterationCount: 10, invocationCount: 1)] public class IntroRatioSD { private int counter; [GlobalSetup] public void Setup() => counter = 0; [Benchmark(Baseline = true)] public void Base() { Thread.Sleep(100); if (++counter % 7 == 0) Thread.Sleep(5000); // Emulate outlier } [Benchmark] public void Slow() => Thread.Sleep(200); [Benchmark] public void Fast() => Thread.Sleep(50); } } Output Here are statistics details for the baseline benchmark: Mean = 600.6054 ms, StdErr = 500.0012 ms (83.25%); N = 10, StdDev = 1,581.1428 ms Min = 100.2728 ms, Q1 = 100.3127 ms, Median = 100.4478 ms, Q3 = 100.5011 ms, Max = 5,100.6163 ms IQR = 0.1884 ms, LowerFence = 100.0301 ms, UpperFence = 100.7837 ms ConfidenceInterval = [-1,789.8568 ms; 2,991.0677 ms] (CI 99.9%), Margin = 2,390.4622 ms (398.01% of Mean) Skewness = 2.28, Kurtosis = 6.57, MValue = 2 -------------------- Histogram -------------------- [-541.891 ms ; 743.427 ms) | @@@@@@@@@ [ 743.427 ms ; 2027.754 ms) | [2027.754 ms ; 3312.082 ms) | [3312.082 ms ; 4458.453 ms) | [4458.453 ms ; 5742.780 ms) | @ --------------------------------------------------- As you can see, a single outlier significantly affected the metrics. Because of this, BenchmarkDotNet adds the Median and the RatioSD columns in the summary table: Method | Mean | Error | StdDev | Median | Ratio | RatioSD | ------- |----------:|--------------:|--------------:|----------:|------:|--------:| Base | 600.61 ms | 2,390.4622 ms | 1,581.1428 ms | 100.45 ms | 1.00 | 0.00 | Slow | 200.50 ms | 0.4473 ms | 0.2959 ms | 200.42 ms | 1.80 | 0.62 | Fast | 50.54 ms | 0.3435 ms | 0.2272 ms | 50.48 ms | 0.45 | 0.16 | Let's look at the Base and Slow benchmarks. The Mean values are 600 and 200 milliseconds; the \"Scaled Mean\" value is 0.3. The Median values are 100 and 200 milliseconds; the \"Scaled Median\" value is 2. Both values are misleading. BenchmarkDotNet evaluates the ratio distribution and displays the mean (1.80) and the standard deviation (0.62). Links Benchmark and Job Baselines The permanent link to this sample: BenchmarkDotNet.Samples.IntroRatioSD"
  },
  "articles/samples/IntroRatioStyle.html": {
    "href": "articles/samples/IntroRatioStyle.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroRatioStyle Using RatioStyle, we can override the style of the \"Ratio\" column in SummaryStyle. Here are the possible values: Value: default value that shows the ration value between the current benchmark and the baseline benchmark (e.g., 0.15 or 1.15) Percentage: express the ration in percentage (e.g., -85% or +15%) Trend: shows how much the current benchmark is faster or slower than the base benchmark (e.g., 6.63x faster or 1.15x slower) Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Columns; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Reports; namespace BenchmarkDotNet.Samples { [ShortRunJob, Config(typeof(Config))] public class IntroRatioStyle { [Benchmark(Baseline = true)] public void Baseline() => Thread.Sleep(1000); [Benchmark] public void Bar() => Thread.Sleep(150); [Benchmark] public void Foo() => Thread.Sleep(1150); private class Config : ManualConfig { public Config() { SummaryStyle = SummaryStyle.Default.WithRatioStyle(RatioStyle.Trend); } } } } Output With the given RatioStyle.Trend, we have the following table: | Method | Mean | Error | StdDev | Ratio | RatioSD | |--------- |-----------:|--------:|--------:|-------------:|--------:| | Baseline | 1,000.6 ms | 2.48 ms | 0.14 ms | baseline | | | Bar | 150.9 ms | 1.30 ms | 0.07 ms | 6.63x faster | 0.00x | | Foo | 1,150.4 ms | 5.17 ms | 0.28 ms | 1.15x slower | 0.00x | With the default RatioStyle.Value, we get the following table: | Method | Mean | Error | StdDev | Ratio | |--------- |-----------:|--------:|--------:|------:| | Baseline | 1,000.3 ms | 2.71 ms | 0.15 ms | 1.00 | | Bar | 150.6 ms | 1.67 ms | 0.09 ms | 0.15 | | Foo | 1,150.6 ms | 7.41 ms | 0.41 ms | 1.15 | If we use RatioStyle.Percentage, we get the following table: | Method | Mean | Error | StdDev | Ratio | RatioSD | |--------- |-----------:|--------:|--------:|---------:|--------:| | Baseline | 1,000.3 ms | 4.69 ms | 0.26 ms | baseline | | | Bar | 150.7 ms | 1.42 ms | 0.08 ms | -85% | 0.1% | | Foo | 1,150.3 ms | 6.13 ms | 0.34 ms | +15% | 0.0% | Links Benchmark and Job Baselines The permanent link to this sample: BenchmarkDotNet.Samples.IntroRatioStyle"
  },
  "articles/samples/IntroSetupCleanupGlobal.html": {
    "href": "articles/samples/IntroSetupCleanupGlobal.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroSetupCleanupGlobal A method which is marked by the [GlobalSetup] attribute will be executed only once per a benchmarked method after initialization of benchmark parameters and before all the benchmark method invocations. A method which is marked by the [GlobalCleanup] attribute will be executed only once per a benchmarked method after all the benchmark method invocations. If you are using some unmanaged resources (e.g., which were created in the GlobalSetup method), they can be disposed in the GlobalCleanup method. Source code using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroSetupCleanupGlobal { [Params(10, 100, 1000)] public int N; private int[] data; [GlobalSetup] public void GlobalSetup() { data = new int[N]; // executed once per each N value } [Benchmark] public int Logic() { int res = 0; for (int i = 0; i < N; i++) res += data[i]; return res; } [GlobalCleanup] public void GlobalCleanup() { // Disposing logic } } } Links Setup And Cleanup The permanent link to this sample: BenchmarkDotNet.Samples.IntroSetupCleanupGlobal"
  },
  "articles/samples/IntroSetupCleanupIteration.html": {
    "href": "articles/samples/IntroSetupCleanupIteration.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroSetupCleanupIteration A method which is marked by the [IterationSetup] attribute will be executed exactly once before each benchmark invocation, forcing UnrollFactor=1 and InvocationCount=1 (we have changed that in 0.11.0). It's not recommended to use this attribute in microbenchmarks because it can spoil the results. However, if you are writing a macrobenchmark (e.g. a benchmark which takes at least 100ms) and you want to prepare some data before each invocation, [IterationSetup] can be useful. A method which is marked by the [IterationCleanup] attribute will be executed exactly once after each invocation. This attribute has the same set of constraint with [IterationSetup]: it's not recommended to use [IterationCleanup] in microbenchmarks. Source code using System; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.Monitoring, launchCount: 1, warmupCount: 2, iterationCount: 3)] public class IntroSetupCleanupIteration { private int setupCounter; private int cleanupCounter; [IterationSetup] public void IterationSetup() => Console.WriteLine($\"// IterationSetup ({++setupCounter})\"); [IterationCleanup] public void IterationCleanup() => Console.WriteLine($\"// IterationCleanup ({++cleanupCounter})\"); [GlobalSetup] public void GlobalSetup() => Console.WriteLine(\"// \" + \"GlobalSetup\"); [GlobalCleanup] public void GlobalCleanup() => Console.WriteLine(\"// \" + \"GlobalCleanup\"); [Benchmark] public void Benchmark() => Console.WriteLine(\"// \" + \"Benchmark\"); } } The order of method calls // GlobalSetup // IterationSetup (1) // IterationSetup Jitting // IterationCleanup (1) // IterationCleanup Jitting // IterationSetup (2) // MainWarmup1 // Benchmark // MainWarmup1 // IterationCleanup (2) // MainWarmup1 // IterationSetup (3) // MainWarmup2 // Benchmark // MainWarmup2 // IterationCleanup (3) // MainWarmup2 // IterationSetup (4) // MainTarget1 // Benchmark // MainTarget1 // IterationCleanup (4) // MainTarget1 // IterationSetup (5) // MainTarget2 // Benchmark // MainTarget2 // IterationCleanup (5) // MainTarget2 // IterationSetup (6) // MainTarget3 // Benchmark // MainTarget3 // IterationCleanup (6) // MainTarget3 // GlobalCleanup Links Setup And Cleanup The permanent link to this sample: BenchmarkDotNet.Samples.IntroSetupCleanupIteration"
  },
  "articles/samples/IntroSetupCleanupTarget.html": {
    "href": "articles/samples/IntroSetupCleanupTarget.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroSetupCleanupTarget Sometimes it's useful to run setup or cleanups for specific benchmarks. All four setup and cleanup attributes have a Target property that allow the setup/cleanup method to be run for one or more specific benchmark methods. Source code using System; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.Monitoring, launchCount: 0, warmupCount: 0, iterationCount: 1)] public class IntroSetupCleanupTarget { [GlobalSetup(Target = nameof(BenchmarkA))] public void GlobalSetupA() => Console.WriteLine(\"// \" + \"GlobalSetup A\"); [Benchmark] public void BenchmarkA() => Console.WriteLine(\"// \" + \"Benchmark A\"); [GlobalSetup(Targets = new[] { nameof(BenchmarkB), nameof(BenchmarkC) })] public void GlobalSetupB() => Console.WriteLine(\"// \" + \"GlobalSetup B\"); [Benchmark] public void BenchmarkB() => Console.WriteLine(\"// \" + \"Benchmark B\"); [Benchmark] public void BenchmarkC() => Console.WriteLine(\"// \" + \"Benchmark C\"); [Benchmark] public void BenchmarkD() => Console.WriteLine(\"// \" + \"Benchmark D\"); } } The order of method calls // GlobalSetup A // Benchmark A // GlobalSetup B // Benchmark B // GlobalSetup B // Benchmark C // Benchmark D Links Setup And Cleanup The permanent link to this sample: BenchmarkDotNet.Samples.IntroSetupCleanupTarget"
  },
  "articles/samples/IntroStaThread.html": {
    "href": "articles/samples/IntroStaThread.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroStaThread If the code you want to benchmark requires [System.STAThread] then you need to apply this attribute to the benchmarked method. BenchmarkDotNet will generate an executable with [STAThread] applied to its Main method. Using this feature on .NET Core requires .NET Core 2.1 or newer. Older versions will not work due to this bug. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroStaThread { [Benchmark, System.STAThread] public void CheckForSTA() { if (Thread.CurrentThread.GetApartmentState() != ApartmentState.STA) { throw new ThreadStateException( \"The current threads apartment state is not STA\"); } } } } Links Customizing Runtime The permanent link to this sample: BenchmarkDotNet.Samples.IntroStaThread"
  },
  "articles/samples/IntroStatisticalTesting.html": {
    "href": "articles/samples/IntroStatisticalTesting.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroStatisticalTesting Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [StatisticalTestColumn(\"500us\")] [StatisticalTestColumn(\"3%\")] [SimpleJob(warmupCount: 0, iterationCount: 5)] public class IntroStatisticalTesting { [Benchmark] public void Sleep50() => Thread.Sleep(50); [Benchmark] public void Sleep97() => Thread.Sleep(97); [Benchmark] public void Sleep99() => Thread.Sleep(99); [Benchmark(Baseline = true)] public void Sleep100() => Thread.Sleep(100); [Benchmark] public void Sleep101() => Thread.Sleep(101); [Benchmark] public void Sleep103() => Thread.Sleep(103); [Benchmark] public void Sleep150() => Thread.Sleep(150); } } Output | Method | Mean | Error | StdDev | Ratio | Welch(1us)/p-values | Welch(3%)/p-values | MannWhitney(1us)/p-values | MannWhitney(3%)/p-values | |--------- |----------:|----------:|----------:|------:|---------------------- |---------------------- |-------------------------- |------------------------- | | Sleep50 | 53.13 ms | 0.5901 ms | 0.1532 ms | 0.51 | Faster: 1.0000/0.0000 | Faster: 1.0000/0.0000 | Faster: 1.0000/0.0040 | Faster: 1.0000/0.0040 | | Sleep97 | 100.07 ms | 0.9093 ms | 0.2361 ms | 0.97 | Faster: 1.0000/0.0000 | Same: 1.0000/0.1290 | Faster: 1.0000/0.0040 | Same: 1.0000/0.1111 | | Sleep99 | 102.23 ms | 2.4462 ms | 0.6353 ms | 0.99 | Faster: 0.9928/0.0072 | Same: 1.0000/0.9994 | Faster: 0.9960/0.0079 | Same: 1.0000/1.0000 | | Sleep100 | 103.34 ms | 0.8180 ms | 0.2124 ms | 1.00 | Base: 0.5029/0.5029 | Base: 1.0000/1.0000 | Base: 0.7262/0.7262 | Base: 1.0000/1.0000 | | Sleep101 | 103.73 ms | 2.1591 ms | 0.5607 ms | 1.00 | Same: 0.1041/0.8969 | Same: 0.9999/1.0000 | Same: 0.1111/0.9246 | Same: 1.0000/1.0000 | | Sleep103 | 106.21 ms | 1.2511 ms | 0.3249 ms | 1.03 | Slower: 0.0000/1.0000 | Same: 0.9447/1.0000 | Slower: 0.0040/1.0000 | Same: 0.9246/1.0000 | | Sleep150 | 153.16 ms | 3.4929 ms | 0.9071 ms | 1.48 | Slower: 0.0000/1.0000 | Slower: 0.0000/1.0000 | Slower: 0.0040/1.0000 | Slower: 0.0040/1.0000 | // * Legends * Mean : Arithmetic mean of all measurements Error : Half of 99.9% confidence interval StdDev : Standard deviation of all measurements Ratio : Mean of the ratio distribution ([Current]/[Baseline]) Welch(1us)/p-values : Welch-based TOST equivalence test with 1 us threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' Welch(3%)/p-values : Welch-based TOST equivalence test with 3% threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' MannWhitney(1us)/p-values : MannWhitney-based TOST equivalence test with 1 us threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' MannWhitney(3%)/p-values : MannWhitney-based TOST equivalence test with 3% threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' 1 ms : 1 Millisecond (0.001 sec) Links The permanent link to this sample: BenchmarkDotNet.Samples.IntroStatisticalTesting"
  },
  "articles/samples/IntroStatisticsColumns.html": {
    "href": "articles/samples/IntroStatisticsColumns.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroStatisticsColumns Source code using System; using System.Security.Cryptography; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [MediumRunJob, SkewnessColumn, KurtosisColumn] public class IntroStatisticsColumns { private const int N = 10000; private readonly byte[] data; private readonly MD5 md5 = MD5.Create(); private readonly SHA256 sha256 = SHA256.Create(); public IntroStatisticsColumns() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark(Baseline = true)] public byte[] Md5A() => md5.ComputeHash(data); [Benchmark] public byte[] Md5B() => md5.ComputeHash(data); [Benchmark] public byte[] Sha256() => sha256.ComputeHash(data); } } Output Method Mean Error StdDev Skewness Kurtosis Ratio RatioSD Md5A 15.91 us 0.0807 us 0.1209 us 0.4067 1.646 1.00 0.00 Md5B 15.89 us 0.0709 us 0.1062 us 0.5893 2.141 1.00 0.01 Sha256 36.62 us 0.6390 us 0.9564 us 1.1363 4.014 2.30 0.06 Links Statistics The permanent link to this sample: BenchmarkDotNet.Samples.IntroStatisticsColumns"
  },
  "articles/samples/IntroStopOnFirstError.html": {
    "href": "articles/samples/IntroStopOnFirstError.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroStopOnFirstError BenchmarkDotNet can be configured to stop on first error. You just have to add StopOnFirstError attribute to your class or use --stopOnFirstError command line argument. Source code using System; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [StopOnFirstError] public class IntroStopOnFirstError { [Benchmark(Baseline = true)] public int FirstMethod() => throw new Exception(\"Example exception.\"); [Benchmark] public int SecondMethod() => 1; } } Links Configs How to use console arguments The permanent link to this sample: BenchmarkDotNet.Samples.IntroStopOnFirstError"
  },
  "articles/samples/IntroSummaryStyle.html": {
    "href": "articles/samples/IntroSummaryStyle.html",
    "title": "| BenchmarkDotNet",
    "summary": "SummaryStyle in BenchmarkDotNet SummaryStyle is a class in BenchmarkDotNet that allows customization of the summary reports of benchmark results. It offers several properties to fine-tune how the results are displayed. Usage You can customize the summary report by specifying various properties of SummaryStyle. These properties include formatting options like whether to print units in the header or content, setting the maximum width for parameter columns, and choosing units for size and time measurements. Source Code using System.Globalization; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Reports; using Perfolizer.Horology; using Perfolizer.Metrology; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] public class IntroSummaryStyle { private class Config : ManualConfig { public Config() { // Configure the summary style here var summaryStyle = new SummaryStyle ( cultureInfo: CultureInfo.InvariantCulture, printUnitsInHeader: true, printUnitsInContent: false, sizeUnit: SizeUnit.KB, timeUnit: TimeUnit.Nanosecond, maxParameterColumnWidth: 20 ); WithSummaryStyle(summaryStyle); } } [Params(10, 100)] public int N; [Benchmark] public void Sleep() => System.Threading.Thread.Sleep(N); } } Properties PrintUnitsInHeader: Boolean to indicate if units should be printed in the header. PrintUnitsInContent: Boolean to control unit printing in the content. PrintZeroValuesInContent: Determines if zero values should be printed. MaxParameterColumnWidth: Integer defining the max width for parameter columns. SizeUnit: Optional SizeUnit to specify the unit for size measurements. TimeUnit: Optional TimeUnit for time measurement units. CultureInfo: CultureInfo to define culture-specific formatting. Example Output Using SummaryStyle options: | Method | N | Mean [ns] | Error [ns] | StdDev [ns] | |------- |---- |--------------:|-----------:|------------:| | Sleep | 10 | 15,644,973.1 | 32,808.7 | 30,689.3 | | Sleep | 100 | 109,440,686.7 | 236,673.8 | 221,384.8 | Default: | Method | N | Mean | Error | StdDev | |------- |---- |----------:|---------:|---------:| | Sleep | 10 | 15.65 ms | 0.039 ms | 0.034 ms | | Sleep | 100 | 109.20 ms | 0.442 ms | 0.392 ms | Links @docs.SummaryStyle The permanent link to this sample: @BenchmarkDotNet.Samples.IntroSummaryStyle"
  },
  "articles/samples/IntroTagColumn.html": {
    "href": "articles/samples/IntroTagColumn.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroTagColumn In the following example, we introduce two new columns which contains a tag based on a benchmark method name. Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Columns; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { // You can add custom tags per each method using Columns [Config(typeof(Config))] public class IntroTagColumn { private class Config : ManualConfig { public Config() { AddJob(Job.Dry); AddColumn(new TagColumn(\"Kind\", name => name.Substring(0, 3))); AddColumn(new TagColumn(\"Number\", name => name.Substring(3))); } } [Benchmark] public void Foo1() => Thread.Sleep(10); [Benchmark] public void Foo12() => Thread.Sleep(10); [Benchmark] public void Bar3() => Thread.Sleep(10); [Benchmark] public void Bar34() => Thread.Sleep(10); } } Output | Method | Mean | Kind | Number | | ------ | ---------- | ---- | ------ | | Bar34 | 10.3636 ms | Bar | 34 | | Bar3 | 10.4662 ms | Bar | 3 | | Foo12 | 10.1377 ms | Foo | 12 | | Foo1 | 10.2814 ms | Foo | 1 | Links Columns The permanent link to this sample: BenchmarkDotNet.Samples.IntroTagColumn"
  },
  "articles/samples/IntroTailcall.html": {
    "href": "articles/samples/IntroTailcall.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroTailcall You need to use the TailcallDiagnoser attribute to configure it. The available options are: logFailuresOnly: Track only the methods that failed to get tail called. True by default. filterByNamespace : Track only the methods from declaring type's namespace. Set to false if you want to see all Jit tail events. True by default. Restrictions Windows only x64 Source code using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [Diagnostics.Windows.Configs.TailCallDiagnoser] [LegacyJitX86Job, LegacyJitX64Job, RyuJitX64Job] public class IntroTailcall { [Benchmark] public long Calc() => FactorialWithoutTailing(7) - FactorialWithTailing(7); private static long FactorialWithoutTailing(int depth) => depth == 0 ? 1 : depth * FactorialWithoutTailing(depth - 1); private static long FactorialWithTailing(int pos, int depth) => pos == 0 ? depth : FactorialWithTailing(pos - 1, depth * pos); private static long FactorialWithTailing(int depth) => FactorialWithTailing(depth - 1, depth); } } Output // * Diagnostic Output - TailCallDiagnoser * -------------------- -------------------- Jit_TailCalling.Calc: LegacyJitX64(Jit=LegacyJit, Platform=X64, Runtime=Clr) -------------------- -------------------- Jit_TailCalling.Calc: LegacyJitX86(Jit=LegacyJit, Platform=X86, Runtime=Clr) -------------------- -------------------- Jit_TailCalling.Calc: RyuJitX64(Jit=RyuJit, Platform=X64) -------------------- Caller: <null>.<null> - <null> Callee: BenchmarkDotNet.Samples.JIT.Jit_TailCalling.FactorialWithTailing - int64 (int32,int32) Tail prefix: False Tail call type: RecursiveLoop ------------------- Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroTailcall"
  },
  "articles/samples/IntroThreadingDiagnoser.html": {
    "href": "articles/samples/IntroThreadingDiagnoser.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroThreadingDiagnoser The ThreadingDiagnoser uses new APIs exposed in .NET Core 3.0 to report: Completed Work Items: The number of work items that have been processed in ThreadPool (per single operation) Lock Contentions: The number of times there was contention upon trying to take a Monitor's lock (per single operation) Source code using BenchmarkDotNet.Attributes; using System.Threading; namespace BenchmarkDotNet.Samples { [ThreadingDiagnoser] // ENABLE the diagnoser public class IntroThreadingDiagnoser { [Benchmark] public void CompleteOneWorkItem() { ManualResetEvent done = new ManualResetEvent(initialState: false); ThreadPool.QueueUserWorkItem(m => (m as ManualResetEvent).Set(), done); done.WaitOne(); } } } Output Method Mean StdDev Median Completed Work Items Lock Contentions CompleteOneWorkItem 8,073.5519 ns 69.7261 ns 8,111.6074 ns 1.0000 - Links Diagnosers The permanent link to this sample: BenchmarkDotNet.Samples.IntroThreadingDiagnoser"
  },
  "articles/samples/IntroUnicode.html": {
    "href": "articles/samples/IntroUnicode.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroUnicode Some of the BenchmarkDotNet exporters use Unicode symbols that are not ASCII-compatible (e.g., μ or ±). Unfortunately, some terminals are not supported such symbols. That's why BenchmarkDotNet prints only ASCII characters by default (μ will be replaced by u). If you want to display Unicode symbols in your terminal, you should use [UnicodeConsoleLoggerAttribute] (see usage examples below). Warning This feature works only with terminal(s)|text editor(s) that support Unicode. On Windows, you may have some troubles with Unicode symbols if system default code page configured as non-English (in Control Panel + Regional and Language Options, Language for Non-Unicode Programs). Source code using System.Diagnostics; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Loggers; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { // *** Attribute Style *** [UnicodeConsoleLogger] public class IntroUnicode { [Benchmark] public long Foo() { long waitUntil = Stopwatch.GetTimestamp() + 1000; while (Stopwatch.GetTimestamp() < waitUntil) { } return waitUntil; } } // *** Object Style *** [Config(typeof(Config))] public class IntroUnicodeObjectStyle { private class Config : ManualConfig { public Config() => AddLogger(ConsoleLogger.Unicode); } [Benchmark] public long Foo() { long waitUntil = Stopwatch.GetTimestamp() + 1000; while (Stopwatch.GetTimestamp() < waitUntil) { } return waitUntil; } } // *** Fluent Config *** public class IntroUnicodeFluentConfig { public static void Run() { BenchmarkRunner.Run<IntroUnicodeFluentConfig>( DefaultConfig.Instance .AddLogger(ConsoleLogger.Unicode)); } [Benchmark] public long Foo() { long waitUntil = Stopwatch.GetTimestamp() + 1000; while (Stopwatch.GetTimestamp() < waitUntil) { } return waitUntil; } } } Output Mean = 1.0265 μs, StdErr = 0.0005 μs (0.05%); N = 15, StdDev = 0.0018 μs Min = 1.0239 μs, Q1 = 1.0248 μs, Median = 1.0264 μs, Q3 = 1.0280 μs, Max = 1.0296 μs IQR = 0.0033 μs, LowerFence = 1.0199 μs, UpperFence = 1.0329 μs ConfidenceInterval = [1.0245 μs; 1.0285 μs] (CI 99.9%), Margin = 0.0020 μs (0.19% of Mean) Skewness = 0.12, Kurtosis = 1.56, MValue = 2 -------------------- Histogram -------------------- [1.023 μs ; 1.030 μs) | @@@@@@@@@@@@@@@ --------------------------------------------------- Method | Mean | Error | StdDev | ------- |---------:|----------:|----------:| Foo | 1.027 μs | 0.0020 μs | 0.0018 μs | Links UnicodeConsoleLoggerAttribute The permanent link to this sample: BenchmarkDotNet.Samples.IntroUnicode"
  },
  "articles/samples/IntroVisualStudioProfiler.html": {
    "href": "articles/samples/IntroVisualStudioProfiler.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: Visual Studio Profiler Using the Microsoft.VisualStudio.BenchmarkDotNetDiagnosers NuGet package you can capture performance profiles of your benchmarks that can be opened in Visual Studio. Source code using System; using BenchmarkDotNet.Attributes; using Microsoft.VSDiagnostics; namespace BenchmarkDotNet.Samples { // Enables profiling with the CPU Usage tool // See: https://learn.microsoft.com/visualstudio/profiling/profiling-with-benchmark-dotnet [CPUUsageDiagnoser] public class IntroVisualStudioProfiler { private readonly Random rand = new Random(42); [Benchmark] public void BurnCPU() { for (int i = 0; i < 100000; ++i) { rand.Next(1, 100); } } } } Output The output will contain a path to the collected diagsession and automatically open in Visual Studio when launched from it. // * Diagnostic Output - VSDiagnosticsDiagnoser * Collection result moved to 'C:\\Work\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\bin\\Release\\net8.0\\BenchmarkDotNet.Artifacts\\BenchmarkDotNet_IntroVisualStudioProfiler_20241205_192056.diagsession'. Session : {d54ebddb-2d6d-404f-b1da-10acbc89635f} Stopped Exported diagsession file: C:\\Work\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\bin\\Release\\net8.0\\BenchmarkDotNet.Artifacts\\BenchmarkDotNet_IntroVisualStudioProfiler_20241205_192056.diagsession. Opening diagsession in VisualStudio: 15296"
  },
  "articles/samples/IntroWakeLock.html": {
    "href": "articles/samples/IntroWakeLock.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroWakeLock Running benchmarks may sometimes take enough time such that the system enters sleep or turns off the display. Using a WakeLock prevents the Windows system doing so. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using System; using System.Threading; // *** Attribute Style applied to Assembly *** [assembly: WakeLock(WakeLockType.System)] namespace BenchmarkDotNet.Samples; // *** Attribute Style *** [WakeLock(WakeLockType.Display)] public class IntroWakeLock { [Benchmark] public void LongRunning() => Thread.Sleep(TimeSpan.FromSeconds(10)); } // *** Object Style *** [Config(typeof(Config))] public class IntroWakeLockObjectStyle { private class Config : ManualConfig { public Config() => WakeLock = WakeLockType.System; } [Benchmark] public void LongRunning() => Thread.Sleep(TimeSpan.FromSeconds(10)); } Command line --wakeLock None --wakeLock System --wakeLock Display Links WakeLockAttribute The permanent link to this sample: BenchmarkDotNet.Samples.IntroWakeLock"
  },
  "articles/samples/IntroWasm.html": {
    "href": "articles/samples/IntroWasm.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroWasm WasmToolchain uses a local Mono Runtime build to run the benchmarks compiled as WebAssembly using V8 JavaScript Engine. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; using BenchmarkDotNet.Toolchains; using BenchmarkDotNet.Toolchains.DotNetCli; using BenchmarkDotNet.Toolchains.MonoWasm; namespace BenchmarkDotNet.Samples { // *** Command Line Arguments *** public class IntroWasmCmdConfig { // the args must contain: // an information that we want to run benchmark as Wasm: // --runtimes Wasm // path to dotnet cli // --cli /home/adam/projects/runtime/dotnet.sh public static void Run(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(IntroWasmCmdConfig).Assembly).Run(args); [Benchmark] public void Foo() { // Benchmark body } } // *** Fluent Config *** public class IntroWasmFluentConfig { public static void Run() { // the Wasm Toolchain requires two mandatory arguments: const string cliPath = @\"/home/adam/projects/runtime/dotnet.sh\"; WasmRuntime runtime = new WasmRuntime(msBuildMoniker: \"net5.0\"); NetCoreAppSettings netCoreAppSettings = new NetCoreAppSettings( targetFrameworkMoniker: \"net5.0\", runtimeFrameworkVersion: null, name: \"Wasm\", customDotNetCliPath: cliPath); IToolchain toolChain = WasmToolchain.From(netCoreAppSettings); BenchmarkRunner.Run<IntroCustomMonoFluentConfig>(DefaultConfig.Instance .AddJob(Job.ShortRun.WithRuntime(runtime).WithToolchain(toolChain))); } [Benchmark] public void Foo() { // Benchmark body } } } Links Toolchains The permanent link to this sample: BenchmarkDotNet.Samples.IntroWasm"
  },
  "articles/samples/IntroXamarin.html": {
    "href": "articles/samples/IntroXamarin.html",
    "title": "| BenchmarkDotNet",
    "summary": "Sample: IntroXamarin To use BenchmarkDotNet with Xamarin, you will need to build a small UI for running Benchmarks and displaying the results so you can actually read them. Using Xamarin.Forms is a simple way to be able to run your benchmarks on iOS or Android. Other notes: Use Release builds when running actual benchmarks. Disable the linker via the Don't Link or None. Source code using BenchmarkDotNet.Analysers; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Exporters; using BenchmarkDotNet.Loggers; using BenchmarkDotNet.Running; using System; using System.Linq; using System.Threading.Tasks; using Xamarin.Forms; namespace BenchmarkDotNet.Samples.Forms { public partial class MainPage : ContentPage { public MainPage() { InitializeComponent(); } async void Button_Clicked(object sender, EventArgs e) { SetIsRunning(true); try { var logger = new AccumulationLogger(); await Task.Run(() => { var config = default(IConfig); #if DEBUG config = new DebugInProcessConfig(); #endif var summary = BenchmarkRunner.Run<IntroBasic>(config); MarkdownExporter.Console.ExportToLog(summary, logger); ConclusionHelper.Print(logger, summary.BenchmarksCases .SelectMany(benchmark => benchmark.Config.GetCompositeAnalyser().Analyse(summary)) .Distinct() .ToList()); }); SetSummary(logger.GetLog()); } catch (Exception exc) { await DisplayAlert(\"Error\", exc.Message, \"Ok\"); } finally { SetIsRunning(false); } } void SetIsRunning(bool isRunning) { Indicator.IsRunning = isRunning; Run.IsVisible = Summary.IsVisible = !isRunning; } void SetSummary(string text) { Summary.Text = text; var size = Summary.Measure(double.MaxValue, double.MaxValue).Request; Summary.WidthRequest = size.Width; Summary.HeightRequest = size.Height; } } } Output Links Xamarin.Android linker settings Xamarin.iOS linker settings The permanent link to this sample: BenchmarkDotNet.Samples.Xamarin"
  },
  "articles/team.html": {
    "href": "articles/team.html",
    "title": "Team | BenchmarkDotNet",
    "summary": "Team Maintainers: Andrey Akinshin (Project Lead), Adam Sitnik, Yegor Stepanov, Tim Cassell. All contributors on GitHub (200+) BenchmarkDotNet is a part of the .NET Foundation."
  },
  "changelog/full.html": {
    "href": "changelog/full.html",
    "title": "Full ChangeLog | BenchmarkDotNet",
    "summary": "Full ChangeLog BenchmarkDotNet v0.15.0 Milestone details In the v0.15.0 scope, 25 issues were resolved and 43 pull requests were merged. This release includes 62 commits by 25 contributors. Resolved issues (25) #1067 Conditions in Directory.Build.props fail (assignee: @timcassell) #1120 Large Spike from WorkloadWarmup to WorkloadActual (assignee: @timcassell) #1738 Async GlobalSetup does not work with InProcess toolchain (assignee: @timcassell) #2236 Benchmarks sporadically failing on Executable Emitted.dll not found (assignee: @timcassell) #2383 DisassemblyDiagnoser does not work in InProcessEmitToolchain (assignee: @timcassell) #2411 Jobs can mess up builds with --keepFiles (assignee: @timcassell) #2425 WithCustomBuildConfiguration breaks build (assignee: @timcassell) #2483 Pressing Ctrl-C does not reset power plan back #2516 Add validation warning for sealed classes containing benchmarks (assignee: @ketanpkolte) #2520 If a test run fails, the report shows it passed. (assignee: @ketanpkolte) #2533 MonoAOTLLVM run failed to build properly but still ran (assignee: @timcassell) #2577 Processor model is not detected on Azure arm64 (assignee: @AndreyAkinshin) #2591 Not possible to compute the (Ratio, RatioSD) #2599 Generic benchmarks in one report #2611 ScottPlotExporter is incorrectly calculating mean on measurements from all iteration stages (assignee: @FlatlinerDOA) #2629 Feature Request: Add ability to automatically hide metric columns if value is not set #2638 Missing disassembly on .NET 9 (assignee: @timcassell) #2652 Build problems with BenchmarkDotNet 0.14.0 and Grpc.Tools 2.67.0 (assignee: @timcassell) #2654 [Documentation] console-args.md is out of date (assignee: @5AIPAVAN) #2664 Starting CLI Commands no longer works via the dotnet-runtime-host \".exe\" (assignee: @timcassell) #2677 Release changes for #2651 (assignee: @AndreyAkinshin) #2678 Getting assembly conflict warnings on net471 after updating to 0.14.0 from 0.13.12 (assignee: @adamsitnik) #2701 InProcessNoEmitToolchain + NativeAOT Support? #2712 BenchmarkDotNet should warn if there are no benchmarks (assignee: @AvishaiDotan) #2721 Feature Request: Add options to disable build in parallel. Merged pull requests (43) #2109 Fix async GlobalSetup/Cleanup with InProcessEmit toolchain (by @timcassell) #2423 Fix builds when --keepFiles is specified (by @timcassell) #2488 Update clrmd to 3.1 (by @timcassell) #2505 Remove support for old core runtimes (by @timcassell) #2535 Always fail if dotnet command failed (by @timcassell) #2579 Support required properties (by @aelij) #2612 Fix #2611 - Add Iteration mode and stage filtering to ScottPlotExporter (by @FlatlinerDOA) #2613 Fix known high severity vulnerabilities (by @adamsitnik) #2614 Feature: Box Plot support for ScottPlotExporter (by @FlatlinerDOA) #2616 Clean up unsupported native AOT flags (by @MichalStrehovsky) #2618 Update good-practices.md (by @SteveDunn) #2622 Fix deadlock in GetDotNetSdkVersion (by @Korexio) #2626 Bump Perfolizer + Initial Phd adoption (by @AndreyAkinshin) #2627 Refactor dotTrace and dotMemory diagnosers (by @AndreyAkinshin) #2642 Add .NET 10 support (by @am11) #2643 Add DOTNET_ environment vars (by @am11) #2645 Change .NET SDK Validator to account for backwards compatibility (by @caaavik-msft) #2646 Get full parsable version part in .NET SDK Validator (by @caaavik-msft) #2647 add RiscV64 support (by @adamsitnik) #2650 improve BaselineCustomAnalyzer warning message, fixes #2591 (by @znxftw) #2653 Fixed GitHub workflow report for failed tests (by @ketanpkolte) #2657 Update console-args.md (by @5AIPAVAN) #2660 Fixed: Add validation warning for sealed classes containing benchmarks (by @ketanpkolte) #2661 Prevent premature end of the Benchmark process at Ctrl-C, fixes #2483 (by @leonvandermeer) #2665 Native AOT projects should also copy SettingsWeWantToCopy (by @keegan-caruso) #2667 Remove obsolete API usage in articles (by @keegan-caruso) #2670 Implement WakeLock so that the system does not enter sleep (by @leonvandermeer) #2672 Add documentation for VS Profiler (by @karpinsn) #2673 Feature Request: Add ability to automatically hide metric columns if value is not set (by @AvishaiDotan) #2674 add HostSignal.AfterProcessStart to allow the users to obtain ID of a process that was started suspended (by @adamsitnik) #2676 Use ArtifactsPath (by @timcassell) #2680 Cleanup templates (by @timcassell) #2681 Fix Windows path too long (by @timcassell) #2686 Some minor fixes before new version release (by @adamsitnik) #2688 Constant stack size (by @timcassell) #2692 Revert remove old runtimes (by @timcassell) #2702 Basic support of InProcessNoEmitRunner for NativeAOT. (by @eliphatfs) #2703 Missing dotnet 9.0 support. (by @VAllens) #2709 Exporters.Plotting: Move to ScottPlot 5.0.54 (by @bclehmann) #2716 Allow to set ParamsAttribute's values from derived class (by @filzrev) #2718 Log a warning when an empty benchmark is run (by @AvishaiDotan) #2725 feat: Add option to disable parallel build (by @filzrev) #2731 Added Measurements to DiagnoserResults (by @persn) Commits (62) a739e2 Set next BenchmarkDotNet version: 0.14.1 (by @AndreyAkinshin) c8105a Fix deadlock in GetDotNetSdkVersion (#2622) (by @Korexio) 29a0eb Update good-practices.md (#2618) (by @SteveDunn) 3927ce Fix #2611 - Add Iteration mode and stage filtering to ScottPlotExporter (#2612) (by @FlatlinerDOA) cd9e4e Feature - Added Box plots (by @FlatlinerDOA) d2f73e Bump .NET SDK: 8.0.101->8.0.401 (by @AndreyAkinshin) 64b3d8 Refactor CpuInfo detection, fix #2577 (by @AndreyAkinshin) 5e9b35 Fix lscpu cpu frequency parsing (by @AndreyAkinshin) a58872 Make lscpu call language-invariant, fix #2577 (by @AndreyAkinshin) ae4bb9 Bump Perfolizer + Initial Phd adoption (by @AndreyAkinshin) 296c99 Remove ConfigCompatibilityValidator, fix #2599 (by @AndreyAkinshin) 92f33f Refactor dotTrace and dotMemory diagnosers (by @AndreyAkinshin) 475ab4 Move Smoke benchmarks to BenchmarkDotNet.Samples (by @AndreyAkinshin) ca5dfd Clean up unsupported native AOT flags (#2616) (by @MichalStrehovsky) bc3abf \uFEFFUpdate clrmd to 3.1 (#2488) (by @timcassell) 3a2d11 \uFEFFRemoved support for netcoreapp3.0 and older runtimes. (#2505) (by @timcassell) adf8e6 Add DOTNET_ environment vars (#2643) (by @am11) 5fe0c7 Change .NET SDK Validator to account for backwards compatibility (#2645) (by @caaavik-msft) 52485e Get full parsable version part (#2646) (by @caaavik-msft) 9040e4 add RiscV64 support, fixes #2644 (#2647) (by @adamsitnik) 9ff49c Fixed GitHub workflow report for failed tests (#2653) (by @ketanpkolte) 1f7cab Update console-args.md (#2657) (by @5AIPAVAN) 6248e8 improve baseline warning message (#2650) (by @znxftw) af8bde Fix known high severity vulnerabilities (#2613) (by @adamsitnik) 346bba Fixed: Add validation warning for sealed classes containing benchmarks (#2660) (by @ketanpkolte) b9d69a Prevent premature end of the Benchmark process at Ctrl-C, fixes #2483 (#2661) (by @leonvandermeer) 25308b Native AOT projects should also copy SettingsWeWantToCopy (#2665) (by @keegan-caruso) c7ed71 Remove obsolete API usage in articles (#2667) (by @keegan-caruso) 5f0c47 \uFEFFFix async GlobalSetup/GlobalCleanup not being awaited with InProcessEmit too... (by @timcassell) 6367ad Add documentation for VS Profiler (#2672) (by @karpinsn) fe5b2f Fix builds when --keepFiles is specified (#2423) (by @timcassell) cd50f7 add HostSignal.AfterProcessStart to allow the users to obtain ID of a process... (by @adamsitnik) cac4f6 Feature Request: Add ability to automatically hide metric columns if value is... (by @AvishaiDotan) 3337a0 Add .NET 10 support (#2642) (by @am11) 1aab1c Add support for user-supplied project file detection (#2684) (by @Genbox) 390463 Some minor fixes before new version release (#2686) (by @adamsitnik) 804482 Revert \"Add support for user-supplied project file detection (#2684)\" (#2687) (by @adamsitnik) de8fb9 Implement WakeLock so that the system does not enter sleep (#2670) (by @leonvandermeer) e7e758 Revert remove old runtimes (#2692) (by @timcassell) 021fc6 Missing dotnet 9.0 support. (#2703) (by @VAllens) 6ce979 Basic support of InProcessNoEmitRunner for NativeAOT. (#2702) (by @eliphatfs) 1c62b2 Fix URLs in documentation (#2705) (by @WojciechNagorski) ce6eb7 Exporters.Plotting: Move to ScottPlot 5.0.54 (#2709) (by @bclehmann) c4bc75 Support required properties (#2579) (by @aelij) 30c730 Add test for required properties in InProcess (#2713) (by @aelij) 21da33 chore: allow to set ParamsAttribute values from derived class (#2716) (by @filzrev) f4bfcd Fix publish-nightly failures (#2695) (by @timcassell) 8af544 Bump Perfolizer: 0.4.0->0.4.1 (needed for #2688) (by @AndreyAkinshin) 49514c [build] Bump BenchmarkDotNet.Build dependencies (by @AndreyAkinshin) 250f9b Bump dawidd6/action-download-artifact from 2 to 6 in /.github/workflows (by @dependabot[bot]) 42c32f Removed unnecessary output path properties from csproj templates. (#2680) (by @timcassell) 602c5f [build] Update InTestsCoreTask description (by @AndreyAkinshin) 43c7b5 Log a warning when an empty benchmark is run (#2718) (by @AvishaiDotan) 924ca6 Always fail if dotnet command failed. (#2535) (by @timcassell) ee248c feat: Add option to disable parallel build (#2725) (by @filzrev) 0a5c82 [docs] Prepare v0.15.0 changelog (by @AndreyAkinshin) 3afc4e Use ArtifactsPath (#2676) (by @timcassell) 8b14cb Constant stack size (#2688) (by @timcassell) 5045ea Added Measurements to DiagnoserResults (#2731) (by @persn) c7cbbf Bump Perfolizer: 0.4.1->0.5.2 (and update API usage) (by @AndreyAkinshin) 56610b Fix Windows path too long (#2681) (by @timcassell) 4c839d Update README and template.json files (by @AndreyAkinshin) Contributors (25) Adam Sitnik (@adamsitnik) Adeel Mujahid (@am11) Allen Cai (@VAllens) Andrew Chisholm (@FlatlinerDOA) Andrey Akinshin (@AndreyAkinshin) Avishai Dotan (@AvishaiDotan) Benjamin Lehmann (@bclehmann) Cameron Aavik (@caaavik-msft) dependabot[bot] (@dependabot[bot]) Eli Arbel (@aelij) filzrev (@filzrev) Ian Qvist (@Genbox) Keegan (@keegan-caruso) Ketan Pramod Kolte (@ketanpkolte) Korexio (@Korexio) leonvandermeer (@leonvandermeer) Michal Strehovský (@MichalStrehovsky) Nik Karpinsky (@karpinsn) Per Olav Flaten (@persn) Ruoxi (@eliphatfs) Saipavan Lingamallu (@5AIPAVAN) Steve Dunn (@SteveDunn) Tim Cassell (@timcassell) Vishnu Bhagyanath (@znxftw) Wojciech Nagórski (@WojciechNagorski) Thank you very much! Additional details Date: May 22, 2025 Milestone: v0.15.0 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.15.0 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.15.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotMemory/0.15.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.15.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.15.0 https://www.nuget.org/packages/BenchmarkDotNet.Exporters.Plotting/0.15.0 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.15.0 https://www.nuget.org/packages/BenchmarkDotNet.TestAdapter/0.15.0 BenchmarkDotNet v0.14.0 Highlights Introduce BenchmarkDotNet.Diagnostics.dotMemory #2549: memory allocation profile of your benchmarks using dotMemory, see BenchmarkDotNet.Samples.IntroDotMemoryDiagnoser Introduce BenchmarkDotNet.Exporters.Plotting #2560: plotting via ScottPlot (initial version) Multiple bugfixes The default build toolchains have been updated to pass IntermediateOutputPath, OutputPath, and OutDir properties to the dotnet build command. This change forces all build outputs to be placed in a new directory generated by BenchmarkDotNet, and fixes many issues that have been reported with builds. You can also access these paths in your own .csproj and .props from those properties if you need to copy custom files to the output. Bug fixes Fixed multiple build-related bugs including passing MsBuildArguments and .Net 8's UseArtifactsOutput. Breaking Changes DotNetCliBuilder removed retryFailedBuildWithNoDeps constructor option. DotNetCliCommand removed RetryFailedBuildWithNoDeps property and BuildNoRestoreNoDependencies() and PublishNoBuildAndNoRestore() methods (replaced with PublishNoRestore()). Milestone details In the v0.14.0 scope, 18 issues were resolved and 28 pull requests were merged. This release includes 55 commits by 16 contributors. Resolved issues (18) #946 Copy to $(OutDir) does not copy to benchmarkdotnet output folder (assignee: @timcassell) #1270 Docs for SummaryStyle #1377 Forward msbuild properties to project reference (assignee: @timcassell) #1457 Directory.Build.props hijacking generated csproj output path (assignee: @timcassell) #1595 ValueTask-returning benchmarks are not being called correctly (assignee: @timcassell) #1795 'BenchmarkDotNet.Autogenerated\\project.assets.json' not found. (assignee: @timcassell) #2203 Consider adding tests for WASM support #2253 TaskbarProgressCom is not supported when benchmarking Native AOT #2310 Bug: Getting an error loading BenchmarkDotNet.Diagnostics.Windows.dll for a benchmark that is not windows specific #2366 default(object) takes more time than expected in net7.0 #2466 Add support for true (assignee: @timcassell) #2477 MSBuild Params Not Applied to Benchamrk (assignee: @timcassell) #2524 Reference assemblies are searched in the wrong location #2540 Unable to use wasm or monoaotllvm as runtime (assignee: @LoopedBard3) #2542 InvalidMeasurementUnitException when using --statisticalTest argument when comparing private builds (assignee: @AndreyAkinshin) #2545 HideColumns + custom corerun = incorrect table markdown #2554 Question about visibility of DotTraceDiagnoser's second constructor (assignee: @AndreyAkinshin) #2570 BenchmarkDotNet test adapter not running tests with dotnet test Merged pull requests (28) #2108 Fix consume ValueTask backed by IValueTaskSource (by @timcassell) #2255 Fix TaskbarProgress (by @timcassell) #2374 stackalloc in separate method (by @timcassell) #2393 Fix MsBuildArguments (by @timcassell) #2498 Enhance Diagnoser Loading Behavior for Non-Critical Assemblies (by @MattFromRVA) #2500 Mark test adapter entry points as autogenerated (by @molesmoke) #2503 Update MsBuildErrorMapper (by @timcassell) #2504 Fix some tests (by @timcassell) #2510 Docs for SummaryStyle (by @MattFromRVA) #2517 fix: Spelling mistake (by @BenjaminMichaelis) #2522 Fix benchmarks with same class but different namespace having same ID (by @caaavik-msft) #2523 .Net SDK Validation (by @MattFromRVA) #2525 Update toolchain docs (by @MattFromRVA) #2526 Bump Octokit version (by @adamsitnik) #2531 Fix wasm toolchain (by @timcassell) #2532 Add Integration Test for WASM (by @caaavik-msft) #2534 Update Microsoft.Diagnostics.Tracing.TraceEvent (by @sbomer) #2538 Add support for wasm and Mono AOT LLVM monikers to SDK Validator (by @caaavik-msft) #2539 Fix Mono AOT LLVM (by @caaavik-msft) #2541 Add Wasm and MonoAOTLLVM to DotNetSdkVersionValidator (by @LoopedBard3) #2549 DotMemoryDiagnoser implementation (by @martinothamar) #2560 Initial ScottPlotExporter with just Bar Plot and Unit Tests (by @FlatlinerDOA) #2565 Fix - incorrect table markdown #2545 (by @AumkarGorde) #2566 Fix names of instructions sets for PublishAot scenarios (by @MichalStrehovsky) #2571 Fix BenchmarkDotNet test adapter not running tests with dotnet test (by @sheffer21) #2572 Add Support for Warning Logging and Integrate with Visual Studio Test Logging (by @sheffer21) #2583 Updated readme to make it clear that experienced performance engineers are also welcome (by @iCodeSometime) #2605 fix(CI): Deprecation issues (by @workgroupengineering) Commits (55) f8ac9c Set next BenchmarkDotNet version: 0.13.13 (by @AndreyAkinshin) 5dd1a9 [docs] Update cSpell.json (by @AndreyAkinshin) 7dacb1 [docs] Update cSpell.json (by @AndreyAkinshin) aa85d8 Added new Exception (by @MattFromRVA) e8cf48 Update copyright year (by @AndreyAkinshin) 688913 [build] Bump .NET SDK: 8.0.100 -> 8.0.101 (by @AndreyAkinshin) 3cf7b8 [build] Reduce verbosity of RestoreTask (by @AndreyAkinshin) 96d8f5 [docs] Update vstest.md (by @AndreyAkinshin) cf14d5 Mark test adapter entry points as autogenerated (by @jeremy-visionaid) 570eee [build] Bump Docfx.App: 2.74.1->2.75.0 (by @AndreyAkinshin) c4c204 Fixed some tests. (by @timcassell) f32166 Update MsBuildErrorMapper. (by @timcassell) d2f690 Update tests. (by @timcassell) 1d95e5 [build] Bump Docfx.App: 2.75.0->2.75.1 (by @AndreyAkinshin) e6fdc6 Pass OutputPath, IntermediateOutputPath, OutDir properties to dotnet ... (by @timcassell) 33e9e9 fix: Spelling mistake (by @BenjaminMichaelis) 109528 Fix benchmarks with same class but different namespace having same ID (#2522) (by @caaavik-msft) c20fd5 Update toolchain docs (#2525) (by @MattFromRVA) 0a41e1 Bump Octokit version (by @adamsitnik) 863165 Fix wasm toolchain (#2531) (by @timcassell) f4c39e Update Microsoft.Diagnostics.Tracing.TraceEvent (#2534) (by @sbomer) 59647c .Net SDK Validation (#2523) (by @MattFromRVA) f17d40 Add support for wasm and Mono AOT LLVM monikers to SDK Validator (#2538) (by @caaavik-msft) 443579 Add Integration Test for WASM (#2532) (by @caaavik-msft) b5fc05 [build] Make build.sh more portable (by @AndreyAkinshin) 63626b [tests] Add docs for WasmTests (by @AndreyAkinshin) 9a9d7e Fix Mono AOT LLVM (#2539) (by @caaavik-msft) 3305b3 Add System.Runtime.CompilerServices.Unsafe to BenchmarkDotNet.Tests (by @AndreyAkinshin) 306210 Bump Perfolizer: 0.2.1->0.3.16 (by @AndreyAkinshin) 036f46 Add Wasm and MonoAOTLLVM to DotNetSdkVersionValidator (#2541) (by @LoopedBard3) ad0240 Bump Perfolizer: 0.3.16->0.3.17 (by @AndreyAkinshin) 7a1c10 Fix bugs in statistical tests, fix #2542 (by @AndreyAkinshin) 0d3099 Fix StatisticalTestColumnTests.NoDifferenceIfValuesAreTheSame (by @AndreyAkinshin) 7306ee Fix consume ValueTask backed by IValueTaskSource (#2108) (by @timcassell) 4ab69b Moved stackalloc to separate method. (#2374) (by @timcassell) c7b7ab DotMemoryDiagnoser implementation (#2549) (by @martinothamar) 55ce92 Bump JetBrains.Profiler.SelfApi: 2.5.0->2.5.2 (by @AndreyAkinshin) a24d68 Fix DotTrace/DotMemory attribute ctors, fix #2554 (by @AndreyAkinshin) d98a1d Fix names of instructions sets for PublishAot scenarios (#2566) (by @MichalStrehovsky) 205ce6 Fix - incorrect table markdown #2545 (#2565) (by @AumkarGorde) 063d2f Fix BenchmarkDotNet test adapter not running tests with dotnet test (#2571) (by @sheffer21) 6a7244 Add warning support (#2572) (by @sheffer21) 01d9b7 Update README.md (#2583) (by @iCodeSometime) 20e2ee Docs for SummaryStyle (#2510) (by @MattFromRVA) e933bb Initial ScottPlotExporter with just Bar Plot and Unit Tests (#2560) (by @FlatlinerDOA) f8082a Fix IntroSummaryStyle compilation (by @AndreyAkinshin) 834417 Improve logging in ScottPlotExporterTests (by @AndreyAkinshin) 15200d [build] Add BenchmarkDotNet.Exporters.Plotting.Tests to unit-tests (by @AndreyAkinshin) 027564 \uFEFFFixed crash from TaskbarProgress when BuiltInComInteropSupport is disabled. ... (by @timcassell) bf0a49 fix(CI): Deprecation issues (#2605) (by @workgroupengineering) 3d34ed Bump JetBrains.Profiler.SelfApi: 2.5.2->2.5.9 (by @AndreyAkinshin) 23e6c5 Fix InvalidOperationException in DotMemoryDiagnoser (by @AndreyAkinshin) b3fbe7 Set next BenchmarkDotNet version: 0.14.0 (by @AndreyAkinshin) 17cf3b [docs] Prepare v0.14.0 changelog (by @AndreyAkinshin) cf882d Add macOS Sequoia in OsBrandStringHelper (by @AndreyAkinshin) Contributors (16) Adam Sitnik (@adamsitnik) Alon Sheffer (@sheffer21) Andrew Chisholm (@FlatlinerDOA) Andrey Akinshin (@AndreyAkinshin) Benjamin Michaelis (@BenjaminMichaelis) Cameron Aavik (@caaavik-msft) Jeremy Powell (@jeremy-visionaid) Kenneth Cochran (@iCodeSometime) Martin Othamar (@martinothamar) Matt Chaulklin (@MattFromRVA) Michal Strehovský (@MichalStrehovsky) Omkar Gorde (@AumkarGorde) Parker Bibus (@LoopedBard3) Sven Boemer (@sbomer) Tim Cassell (@timcassell) workgroupengineering (@workgroupengineering) Thank you very much! Additional details Date: August 06, 2024 Milestone: v0.14.0 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.14.0 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.14.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotMemory/0.14.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.14.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.14.0 https://www.nuget.org/packages/BenchmarkDotNet.Exporters.Plotting/0.14.0 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.14.0 https://www.nuget.org/packages/BenchmarkDotNet.TestAdapter/0.14.0 BenchmarkDotNet v0.13.12 Highlights The biggest highlight of this release if our new VSTest Adapter, which allows to run benchmarks as unit tests in your favorite IDE! The detailed guide can be found here. This release also includes to a minor bug fix that caused incorrect job id generation: fixed job id generation (#2491). Also, the target framework in the BenchmarkDotNet templates was bumped to .NET 8.0. Milestone details In the v0.13.12 scope, 3 issues were resolved and 4 pull requests were merged. This release includes 12 commits by 4 contributors. Resolved issues (3) #2473 Custom SimpleJob Id ignored when the MinIterationTime attribute is used. #2492 Packing of BenchmarkDotNet.TestAdapter is broken (assignee: @AndreyAkinshin) #2494 Rider and R# do not distinguish parametrized TestAdapter cases (assignee: @AndreyAkinshin) Merged pull requests (4) #2438 Add a VSTest Adapter (by @caaavik-msft) #2490 Update the default framework on the templates to net8.0 (by @julesrx) #2491 [Bug Fix] Custom SimpleJob Id ignored (by @MattFromRVA) #2493 Fix BenchmarkDotNet.TestAdapter packability (by @AndreyAkinshin) Commits (12) d49417 Set next BenchmarkDotNet version: 0.13.12 (by @AndreyAkinshin) b3b2d9 Add Sponsors to README (by @AndreyAkinshin) 91f3f7 Add a VSTest Adapter (#2438) (by @caaavik-msft) 41b23b Update default framework version to net8.0 (LTS) (by @julesrx) 5c4653 [build] Bump Octokit: 9.0.0->9.1.0 (by @AndreyAkinshin) 8b6bad [build] In the release workflow, automatically generate an announcement discu... (by @AndreyAkinshin) 9f7492 [build] Add test-pack job in run-tests workflow, see #2492 (by @AndreyAkinshin) b67b6b Update pack files layout for BenchmarkDotNet.TestAdapter, fix #2492 (by @AndreyAkinshin) 06fb24 Use different FQNs for parameterized cases in TestAdapter, fix #2494 (by @AndreyAkinshin) 299095 [Bug Fix] Custom SimpleJob Id ignored (#2491) (by @MattFromRVA) 0159b8 [docs] Update vstest (by @AndreyAkinshin) cdce32 Prepare v0.13.12 changelog (by @AndreyAkinshin) Contributors (4) Andrey Akinshin (@AndreyAkinshin) Cameron Aavik (@caaavik-msft) Jules Raffoux (@julesrx) Matt Chaulklin (@MattFromRVA) Thank you very much! Additional details Date: January 05, 2024 Milestone: v0.13.12 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.12 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.12 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.12 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.12 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.12 https://www.nuget.org/packages/BenchmarkDotNet.TestAdapter/0.13.12 BenchmarkDotNet v0.13.11 Highlights Small improvements. Milestone details In the v0.13.11 scope, 4 issues were resolved and 8 pull requests were merged. This release includes 28 commits by 7 contributors. Resolved issues (4) #2060 NativeAOT benchmark started from .Net Framework host doesn't have all intrinsics enabled (assignee: @adamsitnik) #2233 Q: Include hardware counters in XML output (assignee: @nazulg) #2388 Include AVX512 in listed HardwareIntrinsics #2463 Bug. Native AOT .NET 7.0 doesn't work. System.NotSupportedException: X86Serialize (assignee: @adamsitnik) Merged pull requests (8) #2412 Add HardwareIntrinsics AVX-512 info (by @nietras) #2458 Adds Metrics Columns to Benchmark Report Output (by @nazulg) #2459 Enable MemoryDiagnoser on Legacy Mono (by @MichalPetryka) #2462 update SDK to .NET 8 (by @adamsitnik) #2464 Use \"native\" for .NET 8, don't use \"serialize\" for .NET 7 (by @adamsitnik) #2465 fix NativeAOT toolchain and tests (by @adamsitnik) #2468 Add OperationsPerSecondAttribute (by @DarkWanderer) #2475 Fix some tests (by @timcassell) Commits (28) bb55e6 Set next BenchmarkDotNet version: 0.13.11 (by @AndreyAkinshin) db4d8b Adds Metrics Columns to Benchmark Report Output (#2458) (by @nazulg) e93b2b Use \"native\" for .NET 8, don't use \"serialize\" for .NET 7 (#2464) (by @adamsitnik) 127157 [build] Fix spellcheck-docs workflow (by @AndreyAkinshin) 8a02ec [build] Use our .NET SDK on Windows (by @AndreyAkinshin) 1b39e8 Suppress NU1903 in IntegrationTests.ManualRunning.MultipleFrameworks (by @AndreyAkinshin) e90311 update SDK to .NET 8 (#2462) (by @adamsitnik) fc7afe Enable MemoryDiagnoser on Legacy Mono (#2459) (by @MichalPetryka) 630622 fix NativeAOT toolchain and tests (#2465) (by @adamsitnik) 536a28 Add HardwareIntrinsics AVX-512 info (#2412) (by @nietras) 3fa045 Add OperationsPerSecondAttribute (#2468) (by @DarkWanderer) 0583cb Bump Microsoft.NETCore.Platforms: 5.0.0->6.0.0 (by @AndreyAkinshin) 2e62b9 Remove netcoreapp2.0;net461 from TFMs for IntegrationTests.ManualRunning.Mult... (by @AndreyAkinshin) 92fa3f Bump xunit: 2.5.0->2.6.2 (by @AndreyAkinshin) 01e220 Bump xunit.runner.visualstudio: 2.5.0->2.5.4 (by @AndreyAkinshin) 29a94c Bump Verify.Xunit: 20.3.2->20.8.2 (by @AndreyAkinshin) 538e0e Bump Microsoft.NET.Test.SDK: 17.6.2->17.8.0 (by @AndreyAkinshin) 136e4b Remove explicit Microsoft.NETFramework.ReferenceAssemblies reference in Bench... (by @AndreyAkinshin) 423b84 [build] Bump Docfx.App: 2.71.1->2.74.0 (by @AndreyAkinshin) 718953 [build] Bump Octokit: 7.0.0->9.0.0 (by @AndreyAkinshin) 0cce91 [build] Bump Cake.Frosting: 3.2.0->4.0.0 (by @AndreyAkinshin) 4d5dc9 Fix Newtonsoft.Json v13.0.1 in BenchmarkDotNet.IntegrationTests (by @AndreyAkinshin) c7ec60 Enable UserCanSpecifyCustomNuGetPackageDependency test on Linux (by @AndreyAkinshin) a572db Bump C# LangVersion: 11.0->12.0 (by @AndreyAkinshin) b4ac9d Nullability cleanup (2023-11-26) (by @AndreyAkinshin) 5557ae [build] Bump Docfx.App: 2.74.0->2.74.1 (by @AndreyAkinshin) b987b9 Fixed some tests. (#2475) (by @timcassell) 05eb00 Prepare v0.13.11 changelog (by @AndreyAkinshin) Contributors (7) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Michał Petryka (@MichalPetryka) Nazul Grimaldo (@nazulg) nietras (@nietras) Oleg V. Kozlyuk (@DarkWanderer) Tim Cassell (@timcassell) Thank you very much! Additional details Date: December 06, 2023 Milestone: v0.13.11 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.11 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.11 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.11 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.11 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.11 BenchmarkDotNet v0.13.10 Highlights Initial support of .NET 9 and minor bug fixes. Milestone details In the v0.13.10 scope, 2 issues were resolved and 3 pull requests were merged. This release includes 10 commits by 4 contributors. Resolved issues (2) #2436 BenchmarkDotNet Access Denied Error on WSL2 when Writing to '/mnt/c/DumpStack.log.tmp' (assignee: @AndreyAkinshin) #2455 .NET 9 support (assignee: @adamsitnik) Merged pull requests (3) #2447 Add support for wasm/net9.0 (by @radical) #2453 feat: set RuntimeHostConfigurationOption on generated project (by @workgroupengineering) #2456 implement full .NET 9 support (by @adamsitnik) Commits (10) c27152 Set next BenchmarkDotNet version: 0.13.10 (by @AndreyAkinshin) 2e96d2 Don't show AssemblyInformationalVersion metadata in BDN BrandVersion (by @AndreyAkinshin) d17c6a Support Windows 11 23H2 (10.0.22631) in OsBrandStringHelper (by @AndreyAkinshin) af9c5c Exception handling in DotNetCliGenerator.GetRootDirectory, fix #2436 (by @AndreyAkinshin) e11136 [build] Bump Docfx.App: 2.71.0->2.71.1 (by @AndreyAkinshin) 7b342f Add support for wasm/net9.0 (#2447) (by @radical) e17068 Adjust 'Failed to set up high priority' message (by @AndreyAkinshin) 0a734a feat: set RuntimeHostConfigurationOption on generated project (#2453) (by @workgroupengineering) ae4914 implement full .NET 9 support (#2456) (by @adamsitnik) 40c414 Prepare v0.13.10 changelog (by @AndreyAkinshin) Contributors (4) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Ankit Jain (@radical) workgroupengineering (@workgroupengineering) Thank you very much! Additional details Date: November 01, 2023 Milestone: v0.13.10 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.10 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.10 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.10 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.10 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.10 BenchmarkDotNet v0.13.9 Highlights This release contains bug fixes. Milestone details In the v0.13.9 scope, 3 issues were resolved and 7 pull requests were merged. This release includes 26 commits by 5 contributors. Resolved issues (3) #2054 Custom logging/visualization during the benchmark run (assignee: @caaavik-msft) #2404 Using DisassemblyDiagnoser in GitHub Actions (assignee: @timcassell) #2432 Something went wrong with outliers when using --launchCount (assignee: @AndreyAkinshin) Merged pull requests (7) #1882 use coalesce instead of join (by @askazakov) #2413 Fix linux crash from disassembler (by @timcassell) #2420 Add event processor functionality (by @caaavik-msft) #2421 More nullability warnings fixes (by @alinasmirnova) #2433 Fix build errors with latest sdk (by @timcassell) #2434 Fix Event Processors not being copied in ManualConfig.Add (by @caaavik-msft) #2435 Treat warnings not as errors in manual test project (by @timcassell) Commits (26) ece5cc Set next BenchmarkDotNet version: 0.13.9 (by @AndreyAkinshin) ad9376 Add event processor functionality (#2420) (by @caaavik-msft) 8227bb Address PR feedback (#2434) (by @caaavik-msft) 46b3c0 Fix linux crash from disassembler (#2413) (by @timcassell) 967a97 Fix build errors with latest sdk. (#2433) (by @timcassell) dd7a9b Treat warnings not as errors in manual test project (#2435) (by @timcassell) 583874 Print full stacktrace for GenerateException, see #2436 (by @AndreyAkinshin) 6e3a15 Support WSL detection in RuntimeInformation (by @AndreyAkinshin) 8986e0 Update myget url in README (by @AndreyAkinshin) 516bd6 Enabled nullability for BenchmarkDotNet.Diagnostics.dotTrace.csproj (by @alinasmirnova) 5428eb Fixed nullability warnings in methods signatures (by @alinasmirnova) 7fbbc9 Removed CanBeNull attribute (by @alinasmirnova) 9d7350 Fixed warnings on null assignments (by @alinasmirnova) b43d28 Fixed warnings in EngineEventLogParser (by @alinasmirnova) 148165 Removed an unnecessary check (by @alinasmirnova) 465aaf Fixed empty catch warning (by @alinasmirnova) 9a7bb7 [build] Bump: Microsoft.DocAsCode.App 2.67.5 -> Docfx.App 2.71.0 (by @AndreyAkinshin) 9dd7b6 Fix license badge link in README (by @AndreyAkinshin) 134b8e [build] Automatic NextVersion evaluation (by @AndreyAkinshin) 8090d9 Suppress NETSDK1138 (TFM out of support warning) (by @AndreyAkinshin) af610e Bump .NET SDK: 7.0.305->7.0.401 (by @AndreyAkinshin) 8838ed [build] Fix docfx build warnings (by @AndreyAkinshin) 2d379b Remove outlier consistency check, fix #2432 (by @AndreyAkinshin) 00628a use coalesce instead of join (by @askazakov) 411a6e Prepare v0.13.9 changelog (by @AndreyAkinshin) 228a46 Rollback docfx.json (by @AndreyAkinshin) Contributors (5) Alina Smirnova (@alinasmirnova) Andrey Akinshin (@AndreyAkinshin) askazakov (@askazakov) Cameron Aavik (@caaavik-msft) Tim Cassell (@timcassell) Thank you very much! Additional details Date: October 05, 2023 Milestone: v0.13.9 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.9 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.9 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.9 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.9 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.9 BenchmarkDotNet v0.13.8 Highlights This release contains important bug fixes. Milestone details In the v0.13.8 scope, 5 issues were resolved and 9 pull requests were merged. This release includes 15 commits by 8 contributors. Resolved issues (5) #1995 Left Justification option for summary table columns #2394 Multiple MarkdownExporters not possible (assignee: @bstordrup) #2399 Custom MarkdownExporter (assignee: @nietras) #2400 Should StreamLogger be TextWriterLogger? (assignee: @nietras) #2405 0.13.7 BenchmarkDotNet.Autogenerated project fails build (assignee: @timcassell) Merged pull requests (9) #2395 Issue2394 multiple markdown exporters not possible even with different names (by @bstordrup) #2406 Refactor out base TextLogger from StreamLogger (by @nietras) #2407 Make MarkdownExporter ctor and Dialect protected (by @nietras) #2409 Default to RoslynToolchain (by @timcassell) #2410 feat: add text justification style (by @Vahdanian) #2415 - update the templates install command to reflect dotnet cli updates (by @baywet) #2416 Update stub decoding for .NET 8 for disassemblers (by @janvorli) #2418 Enable nullability for BenchmarkDotNet.Annotations (by @alinasmirnova) #2419 Nullability In BenchmarkDotNet project (by @alinasmirnova) Commits (15) e1122c Set next BenchmarkDotNet version: 0.13.8 (by @AndreyAkinshin) b2235a [build] Remove explicit snupkg pushing (by @AndreyAkinshin) 2c999b [build] Fix ReleaseTask console help info (by @AndreyAkinshin) d058c7 Issue2394 multiple markdown exporters not possible even with different names ... (by @bstordrup) 9da449 Make MarkdownExporter ctor and Dialect protected (#2407) (by @nietras) c35dcb Refactor out base TextLogger from StreamLogger (#2406) (by @nietras) e0c667 - update the templates install command to reflect dotnet cli updates (#2415) (by @baywet) d39108 Update stub decoding for .NET 8 for disassemblers (#2416) (by @janvorli) 2d763c Enable nullability for BenchmarkDotNet.Annotations (by @alinasmirnova) 83fc5e Updated CodeAnnotations to the actual version (by @alinasmirnova) 3860e4 Removed redundant check (by @alinasmirnova) 2a8bab Fixed nullability warnings for some files from BenchmarkDotNet project (by @alinasmirnova) b035d9 feat: add text justification style (#2410) (by @Vahdanian) e2e888 Use Roslyn Toolchain by default if no build settings are changed. (by @timcassell) f8de1e Prepare v0.13.8 changelog (by @AndreyAkinshin) Contributors (8) Alina Smirnova (@alinasmirnova) AmirHossein Vahdanian (@Vahdanian) Andrey Akinshin (@AndreyAkinshin) Benny Tordrup (@bstordrup) Jan Vorlicek (@janvorli) nietras (@nietras) Tim Cassell (@timcassell) Vincent Biret (@baywet) Thank you very much! Additional details Date: September 08, 2023 Milestone: v0.13.8 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.8 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.8 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.8 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.8 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.8 BenchmarkDotNet v0.13.7 Highlights This release contains important bug fixes listed below. Milestone details In the v0.13.7 scope, 12 issues were resolved and 13 pull requests were merged. This release includes 38 commits by 9 contributors. Resolved issues (12) #1773 Ability to recompile for each target runtime #2311 Detect when MonoAOT compilation fails and abort the benchmark run #2346 Can't use latest version of BenchmarkDotNet #2356 Add tests for expected results (assignee: @timcassell) #2364 Benchmark project using paket dependency manager fails to build auto-generated projects (assignee: @timcassell) #2369 Unable to use variables for PackageReferences after #2347 #2373 Regression in parsing arguments with spaces (assignee: @kant2002) #2377 Multiple nuget warnings/errors after moving to 0.13.6 breaking the build #2378 BenchmarkDotNet requires dotnet cli to be installed #2382 -p perf doesn't seem to work right with locally built runtime (assignee: @adamsitnik) #2389 PlatformNotSupportedException thrown on Android in ConsoleTitler #2391 Benchmark fails build with imported project Merged pull requests (13) #2335 AggressiveOptimization in InProcess toolchains (by @timcassell) #2361 Add expected results tests (by @timcassell) #2365 Don't copy PackageReference in csproj (by @timcassell) #2367 Improve build for mono aot (by @radical) #2368 IComparable fallback for Tuple/ValueTuple (by @mrahhal) #2370 Rebuild .Net Framework projects (by @timcassell) #2375 Fix regression in parsing arguments with spaces Closes #2373 (by @kant2002) #2379 [chore]: fix error message (by @ErtanTaner) #2380 Cancel old jobs on push (by @timcassell) #2381 Support --cli argument for CsProjClassicNetToolchain (by @timcassell) #2384 perfcollect: don't restore symbols for local builds (by @adamsitnik) #2385 Fix missing import on Debug build (by @caaavik-msft) #2390 Fix PlatformNotSupportedException thrown on Android in ConsoleTitler (by @Adam--) Commits (38) c9347c Set next BenchmarkDotNet version: 0.13.7 (by @AndreyAkinshin) df4ced Fix generate-gh-pages.yaml (by @AndreyAkinshin) 142a89 DotNetCliCommand.cs: Fail the build if no-dependencies retry build fails (by @radical) c0311b MonoAOTLLVMCsProj.txt: Add auto-imports for extension props/targets (by @radical) f42b97 MonoAOTLLVMCsProj.txt: Imports the props file early enough to allow (by @radical) f6bc29 MonoAOTLLVMCsProj.txt: Add SelfContained=true (by @radical) e4c4f6 [build] Specify NuGet source to PushNupkg (by @AndreyAkinshin) 7de12a [build] rework command line argument parsing (by @AndreyAkinshin) 3f890f [build] Rename tasks (by @AndreyAkinshin) c780b3 [build] Rework examples (by @AndreyAkinshin) 398ae6 [build] Rework ReleaseTask (by @AndreyAkinshin) 8a7caa [build] Rework ReadmeUpdater (by @AndreyAkinshin) 7a8135 IComparable fallback for Tuple/ValueTuple (#2368) (by @mrahhal) fd2639 Removed PackageReference from copied settings. (#2365) (by @timcassell) 6f471c Fix package version in BenchmarkDotNet.Templates (by @AndreyAkinshin) dc9b80 Fix regression in parsing arguments with spaces Closes #2373 (#2375) (by @kant2002) bc59d4 AggressiveOptimization in InProcess toolchains (#2335) (by @timcassell) 70ebf6 Update file layout (by @AndreyAkinshin) ab1794 Recover cSpell location (by @AndreyAkinshin) 28809a Rework environment-specific custom xUnit attributes (by @AndreyAkinshin) c682d5 Skip UserCanSpecifyCustomBuildConfiguration on .NET Framework, see #2376 (by @AndreyAkinshin) 55a337 Move cSpell.json to build (by @AndreyAkinshin) 293627 Add expected results tests (#2361) (by @timcassell) 60c302 Fix attribute usage in IntegrationTests.ManualRunning (by @AndreyAkinshin) 6fa7a9 change dotnet \"cli\" to \"SDK\" in error message (#2379) (by @ErtanTaner) 4d6f16 Update run-tests.yaml (#2380) (by @timcassell) 64d05c Support --cli argument for CsProjClassicNetToolchain (#2381) (by @timcassell) d93490 Rebuild .Net Framework projects (#2370) (by @timcassell) f8ab51 Enable nullable annotations for the whole solution (by @AndreyAkinshin) b912a8 Code cleanup (by @AndreyAkinshin) dc365e Add snupkg to nightly workflow artifacts (by @AndreyAkinshin) a89ad2 Fix path in dotnet nuget push command (by @AndreyAkinshin) da02fd Upgrade setup-node in spellcheck-docs workflow (by @AndreyAkinshin) 657342 Bump xUnit: 2.4.2->2.5.0 (by @AndreyAkinshin) 90ef2a Fix debug build (#2385) (by @caaavik-msft) 914ee7 perfcollect: don't restore symbols for local builds (#2384) (by @adamsitnik) fd5b76 Fix PlatformNotSupportedException thrown on Android in ConsoleTitler (#2390) (by @Adam--) c02aea Prepare v0.13.7 changelog (by @AndreyAkinshin) Contributors (9) Adam Anderson (@Adam--) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Andrii Kurdiumov (@kant2002) Ankit Jain (@radical) Cameron Aavik (@caaavik-msft) Ertan Taner (@ErtanTaner) Mohammad Rahhal (@mrahhal) Tim Cassell (@timcassell) Thank you very much! Additional details Date: August 04, 2023 Milestone: v0.13.7 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.7 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.7 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.7 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.7 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.7 BenchmarkDotNet v0.13.6 Highlights New BenchmarkDotNet.Diagnostics.dotTrace NuGet package. Once this package is installed, you can annotate your benchmarks with the [DotTraceDiagnoser] and get a dotTrace performance snapshot at the end of the benchmark run. #2328 Updated documentation website. We migrated to docfx 2.67 and got the refreshed modern template based on bootstrap 5 with dark/light theme switcher. Updated BenchmarkDotNet.Templates. Multiple issues were resolved, now you can create new benchmark projects from terminal or your favorite IDE. #1658 #1881 #2149 #2338 Response file support. Now it's possible to pass additional arguments to BenchmarkDotNet using @filename syntax. #2320 #2348 Custom runtime support. #2285 Introduce CategoryDiscoverer, see IntroCategoryDiscoverer. #2306 #2307 Multiple bug fixes. Milestone details In the v0.13.6 scope, 19 issues were resolved and 33 pull requests were merged. This release includes 127 commits by 14 contributors. Resolved issues (19) #1658 Pass arguments to runner in dotnet new templates #1694 Length cannot be less than zero #1783 MemoryDiagnoser table output invalid symbol #1856 Not Set Hardware Counter throws Argument Null Exception #1877 Any combination of Params/ParamsSource/ParamsAllValues is broken #1881 broken template for Rider #2036 Publish changelog for each BenchmarkDotNet versions using GitHub releases (assignee: @AndreyAkinshin) #2149 BenchmarkDotNet.Templates not showing in VS2022(17.3.6) new project dialog #2249 BenchmarkSwitcher.Run nullability check warnings in .NET 7 (assignee: @AndreyAkinshin) #2259 CSproj code generator produces invalid syntax after incorrectly parsing .targets file #2264 Benchmarkdotnet crashes when flushing the logger #2266 Incompatible Microsoft.CodeAnalysis.CSharp versioning with Razor #2271 'Unknown processor' yet again (assignee: @br3aker) #2279 Endless compile errors (assignee: @AndreyAkinshin) #2282 TimeUnit Setting Not Being Used in Excel Report #2306 Allow for benchmark categories composition using inheritance (assignee: @AndreyAkinshin) #2312 CodeAnalysisTreatWarningsAsErrors=true in Directory.Build.props breaks auto-generated benchmark assembly build (assignee: @viktorz) #2333 Cannot benchmark netcoreapp3.0 #2358 System.MissingMethodException: Method not found: 'System.String Perfolizer.Horology.TimeInterval.ToString(System.Globalization.CultureInfo, System.String, Perfolizer.Common.UnitPresentation)' Merged pull requests (33) #1879 adjust defaultBenchmarkDotNetVersion on build (by @askazakov) #2086 Tell the user about the asterisk (by @YegorStepanov) #2106 If a metric value could not be calculated, display ? instead of -. (by @timcassell) #2124 Fix crash when using HardwareCounter.NotSet (by @YegorStepanov) #2141 Add support for nested generic types (by @YegorStepanov) #2272 Try to shorten the log file name to avoid TooLongPath on Windows (by @AndreyAkinshin) #2274 Add Android specific GetNetCoreVersion Runtime Information capabilities. (by @LoopedBard3) #2276 Fix nullability issues in runner method signatures, fix #2249 (by @AndreyAkinshin) #2277 Bump xunit 2.4.1->2.4.2 (by @AndreyAkinshin) #2278 lock all access to CompositeLogger (by @adamsitnik) #2280 Add ParamsValidator (by @AndreyAkinshin) #2283 Improve ParamsValidator (by @AndreyAkinshin) #2285 Allow custom runtimes to use Executor (by @tgjones) #2286 Use config summary style in CsvExporter by default, fix #2282 (by @AndreyAkinshin) #2288 update Microsoft.CodeAnalysis.CSharp, fixes #2266 (by @dennishermann) #2300 Fix typos in good-practices.md (by @mrahhal) #2302 Fix net8.0 tfm detection (by @adamsitnik) #2304 IComparable for complex params (by @mrahhal) #2307 Introduce CategoryDiscoverer, fix #2306 (by @AndreyAkinshin) #2316 Updated CsProj.txt, set CodeAnalysisTreatWarningsAsErrors=false (by @viktorz) #2320 Add support for response files (by @kant2002) #2328 Add BenchmarkDotNet.Diagnostics.dotTrace (by @AndreyAkinshin) #2329 Bump Microsoft.NET.Test.Sdk: 16.11.0->17.6.2 (by @AndreyAkinshin) #2330 Use Verify library for approval tests (by @alinasmirnova) #2338 Improve templates (by @YegorStepanov) #2339 Add the args parameter to RunAll and RunAllJoined (by @YegorStepanov) #2343 Fix JitOptimizationsValidator when ran in NativeAOT (by @timcassell) #2347 Copy PackageReferences to generated csproj (by @timcassell) #2348 Add docs for RSP file support (by @kant2002) #2352 Fix netcoreapp3.0 and older builds (by @timcassell) #2359 Fix netcoreapp3.0 builds (by @timcassell) #2360 Fix MosCpuInfoProvider (by @timcassell) #2362 Cancel old CI jobs (by @timcassell) Commits (127) 401030 Postrelease v0.13.5 update (by @AndreyAkinshin) e2de0e Try to shorten the log file name to avoid TooLongPath on Windows (#2272) (by @AndreyAkinshin) fb7f1b Add Android specific NetCoreVersion. (#2274) (by @LoopedBard3) 6c128c Fix nullability issues in runner method signatures, fix #2249 (by @AndreyAkinshin) d9ecba Bump xunit 2.4.1->2.4.2 (by @AndreyAkinshin) cb571d Move ChangeLogBuilder.cs to the build project (by @AndreyAkinshin) c0b592 Remove scripts in docs (by @AndreyAkinshin) b26471 Bump docfx: 2.59.4 -> 2.62.1 (by @AndreyAkinshin) 0772ce log all access to CompositeLogger (#2278) (by @adamsitnik) 5148fe ReflectionExtensions cleanup (by @AndreyAkinshin) e07363 Add ParamsValidator for readonly/const fields (see #2279) (by @AndreyAkinshin) 4b6e83 Add validation for multiple Params* attributes, fix #1877 (by @AndreyAkinshin) b846d5 Add validation for Params* attributes on init-only properties, fix #1877 (by @AndreyAkinshin) 975a0e Fix crash when using HardwareCounter.NotSet (#2124) (by @YegorStepanov) 6162e9 Improve HardwareCounters validation, see #1856 (by @AndreyAkinshin) 565870 Allow custom runtimes to use Executor (#2285) (by @tgjones) 2d04a2 Use config summary style in CsvExporter by default, fix #2282 (#2286) (by @AndreyAkinshin) 809fed Add user help about asterisk (#2086) (by @YegorStepanov) ec429a update Microsoft.CodeAnalysis.CSharp, fixes #2266 (#2288) (by @dennishermann) 9b3186 Add twitter badge in README (by @AndreyAkinshin) 56c66d Create FUNDING.yml (by @AndreyAkinshin) bfb192 Fix net8.0 tfm detection (#2302) (by @adamsitnik) 492e58 Improve ParamsValidator (#2283) (by @AndreyAkinshin) f32a2e IComparable for complex params (#2304) (by @mrahhal) 960289 Enabled category inheritance, fix #2306 (by @AndreyAkinshin) 521b7f Introduce CategoryDiscoverer, fix #2306 (by @AndreyAkinshin) 40305b Add support for nested generic types (#2141) (by @YegorStepanov) 572dd1 Updated CsProj.txt, set CodeAnalysisTreatWarningsAsErrors=false (#2316) (by @viktorz) 43815d Improve timeouts for InProcessEmitExecutor under profiling (by @AndreyAkinshin) 7c4241 Fix nullability issues in AssemblyExtensions (by @AndreyAkinshin) fc7490 Enable verbose xunit logs for CI tests (by @AndreyAkinshin) e1f1d4 Ignore \"Platform linker not found\" in local runs (by @AndreyAkinshin) 40dca9 Fix compilation (by @AndreyAkinshin) c3a0f8 Workaround for xunit+ApprovalTests integration issues (by @AndreyAkinshin) adf72c Fix MemoryDiagnoserSupportsNativeAOT (by @AndreyAkinshin) b1baa7 Better assert message for AllSetupAndCleanupMethodRunsTest (by @AndreyAkinshin) 775ad4 Increase FinishEventTimeout in AsyncProcessOutputReader (by @AndreyAkinshin) 567562 Fix local DisassemblyDiagnoserTests run on macOS (by @AndreyAkinshin) a260bd Improve 'command took' log line format (by @AndreyAkinshin) ff6e8d Add BenchmarkDotNet.Diagnostics.dotTrace (by @AndreyAkinshin) 1c5597 Fix links in docs (by @AndreyAkinshin) 4b265c Fix generation of the docs/api (by @AndreyAkinshin) bb46d8 Bump .NET SDK: 7.0.200->7.0.302 (by @AndreyAkinshin) 6553e0 Bump docfx: 2.62.1->2.67.3 (by @AndreyAkinshin) e2c321 Simplify api generation via cake+docfx (by @AndreyAkinshin) 88beb2 Fix building doc specifying .net 4.6.2 as requirement (by @JobaDiniz) 43ae33 Bump .NET SDK: 7.0.302->7.0.304 (security fix) (by @AndreyAkinshin) 862617 Make formatting DotSettings consistent with Roslyn analyzer (by @AndreyAkinshin) bfbcec Fix ConfigCompatibilityValidatorTests on Linux (by @AndreyAkinshin) bed071 Bump Microsoft.NET.Test.Sdk: 16.11.0->17.6.2 (by @AndreyAkinshin) 73f8fd Use Verify library for approval tests (#2330) (by @alinasmirnova) b725ac Fix PackTask.ShouldRun (by @AndreyAkinshin) 2e1774 Catch the NotSupportedException thrown in NativeAOT for `GetReferencedAssem... (by @timcassell) 58ee5c Add the args parameter to RunAll and RunAllJoined (#2339) (by @YegorStepanov) 977c05 Add support for response files (#2320) (by @kant2002) 17df12 Add docs for RSP file support (#2348) (by @kant2002) dc3cef Improve templates (#2338) (by @YegorStepanov) d6e080 Move RedirectGenerator to the build project (by @AndreyAkinshin) b797cf Update versioning in build scripts (by @AndreyAkinshin) ebe925 Revert \"Update versioning in build scripts\" (by @AndreyAkinshin) b91501 Update versioning in build scripts (by @AndreyAkinshin) 68bedd Update changelog builder (by @AndreyAkinshin) d46c32 Update contributors names and count in changelogs (by @AndreyAkinshin) 319f0e Remove hardcoded markdown from code, generate dynamically (by @AndreyAkinshin) 6d005a Update UID in changelog generation (by @AndreyAkinshin) fb6f43 Fix full.md generation (by @AndreyAkinshin) 124476 Bump Cake.FileHelpers: 6.0.0->6.1.3 (by @AndreyAkinshin) 0286c4 Split MsBuildSettings to separate tasks in the Build project (by @AndreyAkinshin) a519b6 Copy PackageReferences to generated csproj (#2347) (by @timcassell) 74c1e1 Added platform property to MsBuildSettingsBuild (by @AndreyAkinshin) 4e9edb Update Pack workflow (by @AndreyAkinshin) 9b8227 Move generated changelog details to a separate branch (by @AndreyAkinshin) 562a80 Add workflows/docs-changelog-generate.yaml (by @AndreyAkinshin) f519a5 Exclude 'docs-changelog-details' from builds (by @AndreyAkinshin) 152ad7 Update changelog download strategy in workflows (by @AndreyAkinshin) fbc0d7 Fix changelog downloading workflow (by @AndreyAkinshin) 748448 Add UpdateStats task (by @AndreyAkinshin) 609e48 Generate index.md from README.md (by @AndreyAkinshin) c4debe adjust defaultBenchmarkDotNetVersion on build (#1879) (by @askazakov) 88cb48 If a metric value could not be calculated, display ? instead of -. (#2106) (by @timcassell) 3af22c Prepare v0.13.6 changelog (by @AndreyAkinshin) 2d5156 Remove Ben.Demystifier from Build project (by @AndreyAkinshin) ee1ae7 Bump Octokit: 6.2.1->7.0.0 (by @AndreyAkinshin) dc54ac Bump docfx: 2.67.3->2.67.5 (by @AndreyAkinshin) 7986ce Remove excessive logs in cleanup (by @AndreyAkinshin) c352b3 Improve RScript discover strategy in RPlotExporter (by @AndreyAkinshin) 7dc098 Handle exceptions in GetDebuggableAttribute (by @AndreyAkinshin) 5065bc Bump C#: 9.0->11.0 (by @AndreyAkinshin) 48a7b6 Support Linux brand versions (by @AndreyAkinshin) 03ebe4 Simplify the environment info presentation (by @AndreyAkinshin) 0978d0 Support macOS 14 Sonoma in OsBrandStringHelper (by @AndreyAkinshin) a6edfe Fix CPU frequency detection on Linux (by @AndreyAkinshin) 144f5c Fix CPU detection on Windows when wmic is not available via PATH, fix #2271 (by @AndreyAkinshin) 6291a7 Huge build project refactoring (by @AndreyAkinshin) 47bd6d Bump JetBrains.Profiler.SelfApi: 2.4.2->2.5.0 (by @AndreyAkinshin) f5777b Disable net462 integration tests on non-windows os (by @AndreyAkinshin) c78b7d Fix race in Broker, workaround for #2317 (#2318) (by @AndreyAkinshin) 389908 Suppress dependency rebuilding in integration tests on windows+net7.0 (by @AndreyAkinshin) 469b43 Update test-reporter (by @AndreyAkinshin) 2b8bc8 Fix netcoreapp3.0 and older builds (#2352) (by @timcassell) c0cbd2 Add version history to BuildContext (by @AndreyAkinshin) 41f86e Rework documentation generation (by @AndreyAkinshin) 4243a6 Improve build script option parsing (by @AndreyAkinshin) 210020 Rework GitHub workflows (by @AndreyAkinshin) c5fd22 Fix DocsUpdate (by @AndreyAkinshin) b6cbad Fix report-test-results.yaml (by @AndreyAkinshin) 519537 report-test-results.yaml: fix artifact download (by @AndreyAkinshin) 81cf9f report-test-results.yaml: fix permissions (by @AndreyAkinshin) e42dae GitHub workflow rename (by @AndreyAkinshin) 554b00 Update report-test-results.yaml (by @AndreyAkinshin) f3a799 Update Github Actions workflow files (by @AndreyAkinshin) cca009 Update report-test-results.yaml (by @AndreyAkinshin) 28a196 Disable AppVeyor integration (by @AndreyAkinshin) bd89a0 Disable Azure Pipelines integration (by @AndreyAkinshin) 1e9c99 Update version handling in build properties (by @AndreyAkinshin) d4c70e Update version prefix to 0.13.6 (by @AndreyAkinshin) bf020e Automatically update changelog footer (by @AndreyAkinshin) 3b361e Add Release build task (by @AndreyAkinshin) f43495 Fix documentation generation (by @AndreyAkinshin) 30887e Update team.md (by @AndreyAkinshin) 28e003 Update license.md (by @AndreyAkinshin) d883fd Suppress running publish-nightly on forked repositories (by Andrey Akinshin) ca9d8b Fix MosCpuInfoProvider (#2360) (by @timcassell) 3e7334 Cancel old CI jobs when a new push is done. (#2362) (by @timcassell) 9171cf Lock perfolizer reference, fix #2358 (by @AndreyAkinshin) 278549 Add MyGet badge in README (by @AndreyAkinshin) e85fe2 Fix netcoreapp3.0 builds (#2359) (by @timcassell) Contributors (14) Adam Sitnik (@adamsitnik) Alina Smirnova (@alinasmirnova) Andrey Akinshin Andrey Akinshin (@AndreyAkinshin) Andrii Kurdiumov (@kant2002) askazakov (@askazakov) dennishermann (@dennishermann) Joberto Diniz (@JobaDiniz) Mohammad Rahhal (@mrahhal) Parker Bibus (@LoopedBard3) Tim Cassell (@timcassell) Tim Jones (@tgjones) ViktorZ (@viktorz) Yegor Stepanov (@YegorStepanov) Thank you very much! Additional details Date: July 11, 2023 Milestone: v0.13.6 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.6 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.6 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.6 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.6 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.6 BenchmarkDotNet v0.13.5 Highlights Improved JitStatsDiagnoser. This diagnoser was added in v0.13.4, it shows various stats from the JIT compiler that were collected during entire benchmark run (amount of JITted methods, amount of tiered methods, how much memory JIT allocated during the benchmark). In this release, we improved metric collection (#2246, e715d5) and added the [JitStatsDiagnoser] attribute (#2250 512413). Enable strong-named assemblies in the released NuGet packages #2258 #2263 5cd288 Avoid keeping referenced values returned from a benchmark in memory #1942 #2191 ff5dbe Keep generated files when MSBuild bin log is requested #2252 #2254 d3fbc0 Add Id for UnresolvedDiagnoser (an exception fix) #2251 a992b5 Add brand names for Windows 22H2 and macOS 13 86f212 0c2699 Remove deprecated InProcessToolchain #2248 615384 Milestone details In the v0.13.5 scope, 3 issues were resolved and 11 pull requests were merged. This release includes 16 commits by 4 contributors. Resolved issues (3) #1942 Consider changing Consume to not hold onto references for very long (assignee: @timcassell) #2252 msbuild binlog for the benchmark projects gets cleaned up too, making diagnosis of build impossible (assignee: @adamsitnik) #2258 Strong name validation failed Merged pull requests (11) #2178 Introduce MockToolchain (by @AndreyAkinshin) #2191 Don't hold onto references in Consumer (by @timcassell) #2246 improve the numbers reported for Tiered JIT (by @adamsitnik) #2248 Remove deprecated InProcessToolchain (by @timcassell) #2250 Add JitStatsDiagnoserAttribute (by @KeterSCP) #2251 UnresolvedDiagnoser needs to have an Id as well (by @adamsitnik) #2254 Keep generated files when MSBuild bin log is requested (by @adamsitnik) #2263 Enabled strong-named assemblies on all OS, fix #2258 (by @AndreyAkinshin) #2267 Bump Cake to 3.0.0 (by @AndreyAkinshin) #2268 simplify the MockRunner design (by @adamsitnik) #2269 bump SDK version to pick up .NET Runtime fix that should fix disassembler test issues (by @adamsitnik) Commits (16) 9193d4 Postrelease v0.13.4 update (by @AndreyAkinshin) 7b1f29 Set net7.0 as primary TFM for BenchmarkDotNet.Samples (by @AndreyAkinshin) 86f212 Support macOS 13 (Ventura) in OsBrandStringHelper (by @AndreyAkinshin) 0c2699 Support Windows 22H2 in OsBrandStringHelper (by @AndreyAkinshin) e715d5 improve JitStatsDiagnoser based on feedback from @kouvel (#2246) (by @adamsitnik) a992b5 UnresolvedDiagnoser needs to have an Id as well, otherwise CompositeDiagnoser... (by @adamsitnik) 512413 Add JitStatsDiagnoserAttribute (#2250) (by @KeterSCP) 5cd288 Enabled strong-named assemblies on all OS, fix #2258 (by @AndreyAkinshin) 615384 Removed deprecated InProcessToolchain. (#2248) (by @timcassell) d3fbc0 Keep generated files when MSBuild bin log is requested (#2254) (by @adamsitnik) ff5dbe Don't hold onto references in Consumer (#2191) (by @timcassell) 59e17f Bump Cake: 2.0.0->3.0.0 (#2267) (by @AndreyAkinshin) f76c68 Introduce MockToolchain (#2178) (by @AndreyAkinshin) 9e88e4 bump SDK version to pick up .NET Runtime fix that should fix disassembler tes... (by @adamsitnik) e2593c Prepare v0.13.5 changelog (by @AndreyAkinshin) ec962b Set library version: 0.13.5 (by @AndreyAkinshin) Contributors (4) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Sergiusz Zalewski (@KeterSCP) Tim Cassell (@timcassell) Thank you very much! Additional details Date: February 17, 2023 Milestone: v0.13.5 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.5 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.5 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.5 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.5 BenchmarkDotNet v0.13.4 Highlights Fixed LINQPad support #2237 #2238 New JitStatsDiagnoser #2243 Minor documentation improvements #2206 #2218 JitStatsDiagnoser This new diagnoser introduced in (#2243) allows getting advanced JIT statistics. Sample usage: dotnet run -c Release -f net7.0 --filter *IntroBasic.Sleep --profiler jit Result: Method Mean Error StdDev Methods JITted Methods Tiered JIT allocated memory Sleep 15.53 ms 0.034 ms 0.032 ms 1,102 15 221,736 B Milestone details In the v0.13.4 scope, 1 issues were resolved and 4 pull requests were merged. This release includes 9 commits by 5 contributors. Resolved issues (1) #2237 Version 0.13.3 breaks LINQPad (and any non-Console application) Merged pull requests (4) #2206 Add single quote when use pattern with filters (by @erlangxk) #2218 Improve getting started guide (by @reflectronic) #2238 Fix IOException when Console window unavailable (#2237) (by @albahari) #2243 JitStatsDiagnoser (by @adamsitnik) Commits (9) dc7734 Postrelease v0.13.3 update (by @AndreyAkinshin) e04e2d Fix IOException when Console window unavailable (#2237) (#2238) (by @albahari) 7694d0 Update copyright year (by @AndreyAkinshin) 5e8a31 Revert comments in DocFxChangelogDownloadTask (by @AndreyAkinshin) ea0eb2 Add single quote when use pattern with filters (#2206) (by @erlangxk) 0cf185 Improve getting started guide (#2218) (by @reflectronic) 12bf22 JitStatsDiagnoser (#2243) (by @adamsitnik) 858a86 Prepare v0.13.4 changelog (by @AndreyAkinshin) 0dbc1f Set library version: 0.13.4 (by @AndreyAkinshin) Contributors (5) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) erlangxk (@erlangxk) Joe Albahari (@albahari) John Tur (@reflectronic) Thank you very much! Additional details Date: January 13, 2023 Milestone: v0.13.4 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.4 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.4 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.4 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.4 BenchmarkDotNet v0.13.3 Highlights New supported technologies Add arm64 disassembler #1422 #2127 #2107 #2123 #2070 #2118 #2119 #2234 #2222 #2212 9ee1/Capstone.NET#37 Initial .NET 8 support #2192 .NET 6/7 MonoVM support #2064 #2142 #2227 #2230 Armv6 and Ppc64le architectures support #2216 #2219 Improved support Improved WASM support #2201 #2099 #2154 #2112 Improved NativeAOT support #2095 #2221 Improved Android support #2231 32-bit benchmarks can now handle addresses larger than 2GB with the help of LargeAddressAware #1469 #2145 Support 64bit affinity masks #2211 #2228 New features Add ExceptionDiagnoser #1736 #2169 #2182 Add PerfCollectProfiler #2117 Incremental benchmark execution with the help of --resume #1799 #2164 Taskbar progress #2102 #2158 #2140 Support --noForcedGCs to avoid forced GC between benchmark runs #2101 Added apples to apples comparison mode #2116 #2193 Communication between the host process and the benchmark process is now using pipes instead of output parsing #2092 #1933 #2189 #2207 #2200 Dozens of bugfixes Special Thanks We would like to highlight some important contributors who helped us with this release: OpenHack'22 (devexperts.com) hackathon sponsored by the DevExperts company. As part of this hackathon we have received following PRs: #2132 fix: include argument and param names in --filter (by @blouflashdb) #2140 Update console title with benchmark information (by @franciscomoloureiro) #2142 Issue 2064: Mono70 moniker (by @Serg046) #2148 adding validation errors when the benchmarks are unsupported (by @emanuel-v-r) #2160 Corrected logic to restore foreground color in ConsoleLogger.cs (by @farQtech) #2164 1799 adding resume arg (by @melias) #2169 Issue #1736: Add ExceptionDiagnoser (by @Serg046) #2161 add quiet logger (by @franciscomoloureiro) (not merged yet) #2171 Issue #1024: Calculate baseline by the fastest benchmark (by @Serg046) (not merged yet) Jan Vorlicek helped to implement arm64 disassembler during an internal Microsoft Hackathon: #2107 Implement TryGetReferencedAddress for relative branches (by @janvorli) #2123 Added other arm64 constant form extraction plus other changes (by @janvorli) Ahmed Garhy (maintainer of Capstone.NET) helped to improve Capstone.NET, which was need to implement arm64 disassembler: 9ee1/Capstone.NET#37 Sign Assembly with a Strong Name (by @9ee1) Milestone details In the v0.13.3 scope, 29 issues were resolved and 71 pull requests were merged. This release includes 87 commits by 22 contributors. Resolved issues (29) #989 [Suggestion] add API for detecting benchmark run failures. (assignee: @emanuel-v-r) #1422 --disasm switch on ARM64 throws Exception (assignee: @adamsitnik) #1469 Host exe marked /largeaddressaware #1521 Iteration setup and cleanup causes job baseline error with multiple runtimes passed to BenchmarkSwitcher #1684 Getting System.FormatException when passing certain string as params. (assignee: @YegorStepanov) #1709 BenchmarkSwitcher executes all benchmarks that share a base class (assignee: @YegorStepanov) #1736 Consider adding an ExceptionDiagnoser (assignee: @Serg046) #1737 runtime knobs broken link (assignee: @YegorStepanov) #1799 Enable interactive, incremental runs through the terminal (assignee: @melias) #1839 Markdown output should escape the output #1867 Trailing newline characters in input value break summary table #1933 how to debug reflection error #2064 Running with .Net 6/7 Mono JIT (assignee: @Serg046) #2070 BenchmarkDotNet crashing on Linux with DisassemblyDiagnoser (assignee: @adamsitnik) #2088 Running on Linux leaves terminal colors changed (assignee: @farQtech) #2099 WASM is recognized as NativeAOT #2102 Add benchmarking progress to console title (assignee: @franciscomoloureiro) #2125 Tests Just Stop Running During Run (assignee: @adamsitnik) #2126 DotNet 6 - VB - Error: The type or namespace name 'DeserializingBenchmarks' could not be found in the global namespace (are you missing an assembly reference?) #2131 --filter should include argument/params names (assignee: @blouflashdb) #2146 Build warning MSB3245: Could not locate the assembly Mono.Posix #2167 Site: No vertical bar should be displayed for the Main page #2185 WarmupCount=0 doesn't work (assignee: @AndreyAkinshin) #2187 Reports for InProcess jobs don't include non-Result measurements (assignee: @AndreyAkinshin) #2189 broker.ProcessData() hangs if something wrong is the spawned process (assignee: @adamsitnik) #2210 Broken integration tests on Ubuntu 22.04 (assignee: @adamsitnik) #2211 Setting affinity does not work for Environment.ProcessorCount >= 32 (assignee: @Donis-) #2216 ppc64le architecture support required for running benchmarks on Power Systems (assignee: @adamsitnik) #2223 Disassembler fails to disassemble some methods on Linux when using recursive mode (assignee: @adamsitnik) Merged pull requests (71) #2018 Port JetBrains' nullability annotations and clean-up code. (by @teo-tsirpanis) #2085 Use latest AzDO macOS pool (by @adamsitnik) #2087 Nit: fix broken link (by @YegorStepanov) #2092 Use Pipes for host and benchmark process communication (by @adamsitnik) #2095 [NativeAOT] use PublishAot and don't reference ILCompiler in explicit way (by @adamsitnik) #2096 ExecuteResult: Surface a Data property so the full output can be acce… (by @radical) #2101 Added a command line arg for not inducing any GCs while running Benchmarks (by @mrsharm) #2104 Fix invalid pre-requisites NativeAOT link in the 0.13.2 changelog (by @KeterSCP) #2107 Implement TryGetReferencedAddress for relative branches (by @janvorli) #2112 Disambiguate NativeAOT, and Wasm identification in BenchmarkDotNet.Po… (by @radical) #2116 Implement apples to apples comparison mode (by @adamsitnik) #2117 PerfCollect diagnoser (by @adamsitnik) #2118 Resolve indirect addresses in disassembly (by @adamsitnik) #2119 Initial version of the Arm64 instruction formatter (by @adamsitnik) #2120 Roslyn Toolchain does not support .NET Core (by @YegorStepanov) #2123 Added other arm64 constant form extraction plus other changes (by @janvorli) #2127 arm64 disassembler (by @adamsitnik) #2132 fix: include argument and param names in --filter (by @blouflashdb) #2133 ensure CompositeLogger is synchronized (by @adamsitnik) #2134 [Mono] Disable LLVM JIT (by @fanyang-mono) #2135 Escape Param data for the exporters (by @YegorStepanov) #2136 Pass non escaped strings to generated project (by @YegorStepanov) #2137 Update doc links and reduce redirects (by @YegorStepanov) #2140 Update console title with benchmark information (by @franciscomoloureiro) #2142 Issue 2064: Mono70 moniker (by @Serg046) #2143 throw an exception when multiple benchmark projects with the same name are found (by @adamsitnik) #2144 Automated spellcheck for docs via GitHub Actions (and address all raised issues) (by @SeanKilleen) #2145 Handle addresses larger than 2GB for 32-bit benchmarks #1469 (by @leonvandermeer) #2148 adding validation errors when the benchmarks are unsupported (by @emanuel-v-r) #2150 Update StaThread intro documentation (by @norepro) #2151 Fix user input matching (by @YegorStepanov) #2152 Make ParamsAllValues validator mandatory (by @YegorStepanov) #2154 remove dependency to Mono.Posix.NETStandard to unblock WASM benchmarks runs (by @adamsitnik) #2158 Add taskbar progress (by @timcassell) #2160 Corrected logic to restore foreground color in ConsoleLogger.cs (by @farQtech) #2164 1799 adding resume arg (by @melias) #2168 Fix bugs and typos (by @YegorStepanov) #2169 Issue #1736: Add ExceptionDiagnoser (by @Serg046) #2172 Cleanup NuGet.config (by @Youssef1313) #2174 Added the ability to not run with Evaluation Overhead (by @mrsharm) #2175 Rename TargetCount to IterationCount in SimpleJob attribute (by @johanvts) #2176 Fix #1521 (by @YegorStepanov) #2177 Simplify GetHashCode() (by @YegorStepanov) #2180 Fix race in AsyncProcessOutputReader (by @AndreyAkinshin) #2181 Fix #2167 - Give main page a title. Then the tab displays 'Home | Be…' (by @leonvandermeer) #2182 Fix a threading issue in ExceptionDiagnoser #1736 (by @leonvandermeer) #2183 Remove allowMultiple=true from column attributes (by @YegorStepanov) #2186 Fix EngineStage.Run for warmupCount=0 (fixes #2185) (by @AndreyAkinshin) #2188 Engine.Run() should return the full list of performed measurements (fixes #2187) (by @AndreyAkinshin) #2192 Add net8.0 support to all existing runtimes and toolchains (by @adamsitnik) #2193 use ImmutableConfig when doing apples-to-apples comparison (by @adamsitnik) #2196 Docs: Add note for ETW Profiling regarding Intel TDT (by @rbanks54) #2200 Fix resources leak (by @adamsitnik) #2201 fix WASM support (by @adamsitnik) #2202 Fix job filtering (by @YegorStepanov) #2204 Deprecate RunSource/RunUrl methods (by @YegorStepanov) #2207 Avoid hangs when starting benchmark process fails (by @adamsitnik) #2208 Fix Full Framework tests (by @adamsitnik) #2209 Update SDK to .NET 7, re-enable tests (by @adamsitnik) #2212 use the new, strong-name signed Capstone.NET (by @adamsitnik) #2217 Bump Newtonsoft.Json (by @YegorStepanov) #2219 add Armv6 and Ppc64le architectures support (by @adamsitnik) #2220 Remove duplicate reference (by @YegorStepanov) #2221 NuGet.org should be the default feed for NativeAOT 7.0 ILCompiler (by @adamsitnik) #2222 arm64 disassembler tests (by @adamsitnik) #2227 Add support for MonoVM to MemoryDiagnoser (by @adamsitnik) #2228 Increase max supported affinity from 31 to 64 (#2211) (by @Donis-) #2230 Add support for .NET SDK that uses Mono instead CLR as a default VM (by @adamsitnik) #2231 improve Android support (by @adamsitnik) #2234 Disassembler realiability fixes (by @adamsitnik) #2235 tests can't assume x64 hardware (by @adamsitnik) Commits (87) 33b288 Use latest AzDO macOS pool (#2085) (by @adamsitnik) 83750b Postrelease v0.13.2 update (by @AndreyAkinshin) 188c11 Nit: fix broken link (#2087) (by @YegorStepanov) 3a18b1 use PublishAot and don't reference ILCompiler in explicit way (#2095) (by @adamsitnik) 8ed521 Added a command line arg for not inducing any GCs while running Benchmarks (#... (by @mrsharm) 8514b2 ExecuteResult: Surface a Data property so the full output can be accessed (#2... (by @radical) 58f2d1 Use Pipes for host and benchmark process communication (#2092) (by @adamsitnik) b525ba Fix invalid pre-requisites NativeAOT links in the docs (#2104) (by @KeterSCP) 0cee16 Disambiguate NativeAOT, and Wasm identification in BenchmarkDotNet.Portabilit... (by @radical) 21a294 Implement apples to apples comparison mode (#2116) (by @adamsitnik) 37d0cf Roslyn Toolchain does not support .NET Core (#2120) (by @YegorStepanov) dbccef Add workflows/docs-stable.yaml (by @AndreyAkinshin) d03287 PerfCollect diagnoser (#2117) (by @adamsitnik) de5cf4 Bump docfx 2.59.3->2.59.4 (by @AndreyAkinshin) 7e87e8 Update workflows/docs-stable.yaml (by @AndreyAkinshin) ff443a Update workflows/docs-stable.yaml (by @AndreyAkinshin) a78c2e Add write-all permissions to workflows/docs-stable.yaml (by @AndreyAkinshin) f4d99a arm64 disassembler (#2127) (by @adamsitnik) 97c2d1 ensure access to logger is synchronized for async output reader (#2133) (by @adamsitnik) 9938c3 include argument and param names in --filter (#2132) (by @blouflashdb) 7f9590 Update doc links and reduce redirects (#2137) (by @YegorStepanov) 95bb2a Escape Param data for the exporters (#2135) (by @YegorStepanov) ecb25b Pass non escaped strings to generated project (#2136) (by @YegorStepanov) 5ed46d [Mono] Disable LLVM JIT (#2134) (by @fanyang-mono) 1f5637 throw an exception when multiple benchmark projects with the same name are fo... (by @adamsitnik) 095975 Handle addresses larger than 2GB for 32-bit benchmarks #1469 (#2145) (by @leonvandermeer) 8d2379 Update console title with benchmark information (#2140) (by @franciscomoloureiro) f8e0a5 Automated spellcheck for docs via GitHub Actions (and address all raised issu... (by @SeanKilleen) db8f8d Fix spelling warning in docs/articles/configs.jobs.md (by @AndreyAkinshin) adf9d6 Fix BenchmarkSwitcher user input matching (#2151) (by @YegorStepanov) b758d2 Update StaThread intro documentation (#2150) (by @norepro) eda1a4 remove dependency to Mono.Posix.NETStandard to unblock WASM benchmarks runs (... (by @adamsitnik) 58d4ba Make ParamsAllValues validator mandatory (#2152) (by @YegorStepanov) 28bf21 adding validation errors when the benchmarks are unsupported (#2148) (by @emanuel-v-r) 1fb101 Corrected logic to restore foreground color in ConsoleLogger.cs (#2160) (by @farQtech) c02c3d Fix bugs and typos (#2168) (by @YegorStepanov) 0f7eb2 Implement --resume support (#2164), fixes #1799 (by @melias) 7d8375 Issue #1736: Add ExceptionDiagnoser (#2169) (by @Serg046) 64c3a3 Implement MonoVM toolchain for net6.0 and net7.0 monikers (#2142) fixes #2064 (by @Serg046) c69895 Add taskbar progress (#2158) (by @timcassell) 163899 Cleanup NuGet.config (#2172) (by @Youssef1313) f4c0a7 Added the ability to not run with Evaluation Overhead from command line (#2174) (by @mrsharm) ce1b74 Rename TargetCount to IterationCount in SimpleJob attribute (#2175) (by @johanvts) 18c6ff Fix #1521 (#2176) (by @YegorStepanov) 4eb6d3 Bump Build.csproj TFM to net6.0 (by @AndreyAkinshin) 279c96 Bump actions/checkout v2->v3 (by @AndreyAkinshin) a1c62c Bump actions/checkout v2->v3 for spellcheck.yml (by @AndreyAkinshin) 7ba989 Automatically generate redirects in documentation (by @AndreyAkinshin) d55c47 Remove old redirect files in documentation (by @AndreyAkinshin) b6d329 Bump System.Drawing.Common in BenchmarkDotNet.Samples.csproj: 4.5.1->4.7.2 (by @AndreyAkinshin) ee8125 Remove allowMultiple=true from column attributes (#2183) (by @YegorStepanov) ddd2f3 Fix a threading issue in ExceptionDiagnoser #1736 (#2182) (by @leonvandermeer) 276f1a Fix EngineStage.Run for warmupCount=0 (fixes #2185) (#2186) (by @AndreyAkinshin) 681a63 Fix #2167 - Give main page a title. Then the tab displays 'Home | BenchmarkDo... (by @leonvandermeer) 00f693 Fix race in AsyncProcessOutputReader (#2180) (by @AndreyAkinshin) 36e998 Disable MemoryDiagnoserSupportsNativeAOT on osx-arm64 (by @AndreyAkinshin) 9e759f Disable ThreadingDiagnoserTests with ILCompiler 6.0.0-rc.1.21420.1 on osx-arm64 (by @AndreyAkinshin) e75bdd Engine.Run() should return the full list of performed measurements (fixes #21... (by @AndreyAkinshin) 28a8e7 Simplify GetHashCode() (#2177) (by @YegorStepanov) 36f9e7 Set net6.0 as the first TFM for BenchmarkDotNet.Tests (by @AndreyAkinshin) 761590 Add net8.0 support to all existing runtimes and toolchains (#2192) (by @adamsitnik) 8b6159 use ImmutableConfig when doing apples-to-apples comparison (#2193) (by @adamsitnik) a4ab68 Docs: Add note for ETW Profiling regarding Intel TDT and Windows Defender (#2... (by @rbanks54) 9c32a8 fix resources leak (#2200) (by @adamsitnik) ad8e9b fix WASM support (#2201) (by @adamsitnik) ccbaf0 Remove duplicated jobs when creating immutable config (#2202) (by @YegorStepanov) 90c82b Deprecate methods (#2204) (by @YegorStepanov) 47b8b7 Avoid hangs when starting benchmark process fails (#2207) (by @adamsitnik) 7982b8 Fix Full Framework tests (#2208) (by @adamsitnik) 61b3c5 Update SDK to .NET 7, re-enable NativeAOT tests, fix some other tests (#2209) (by @adamsitnik) d38313 use the new, strong-name signed Capstone.NET (#2212) (by @adamsitnik) b40150 add Armv6 and Ppc64le architectures support (#2219) (by @adamsitnik) 5ce28b Bump Newtonsoft.Json (#2217) (by @YegorStepanov) 3531c1 Port JetBrains' nullability annotations and clean-up code. (#2018) (by @teo-tsirpanis) 5ef855 Remove duplicate reference (#2220) (by @YegorStepanov) ee24d7 NuGet.org should be the default feed for NativeAOT 7.0 ILCompiler package (#2... (by @adamsitnik) 530d00 arm64 disassembler tests (#2222) (by @adamsitnik) 699285 Add support for MonoVM to MemoryDiagnoser (#2227) (by @adamsitnik) 0c90af change something small just to triegger the CI (by @adamsitnik) 2cce42 improve Android support (#2231) (by @adamsitnik) a6ef73 don't run Long Running Test on AppVeyor, try to avoid 1h timeouts (by @adamsitnik) bf8b53 Increase max supported affinity from 31 to 64 (#2211) (#2228) (by @Donis-) 82f03f Add support for .NET SDK that uses Mono instead CLR as a default VM (#2230) (by @adamsitnik) 968448 Disassembler realiability fixes (#2234) (by @adamsitnik) a098bc tests can't assume x64 hardware (#2235) (by @adamsitnik) 2665ac Prepare v0.13.3 changelog (by @AndreyAkinshin) 0714f5 Set library version: 0.13.3 (by @AndreyAkinshin) Contributors (22) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Ankit Jain (@radical) blouflashdb (@blouflashdb) Donis- (@Donis-) Emanuel Ramos (@emanuel-v-r) Fan Yang (@fanyang-mono) farQtech (@farQtech) franciscomoloureiro (@franciscomoloureiro) Johan von Tangen Sivertsen (@johanvts) leonvandermeer (@leonvandermeer) Maykon Elias (@melias) Mukund Raghav Sharma (Moko) (@mrsharm) norepro (@norepro) Richard Banks (@rbanks54) Sean Killeen (@SeanKilleen) Sergey Aseev (@Serg046) Sergiusz Zalewski (@KeterSCP) Theodore Tsirpanis (@teo-tsirpanis) Tim Cassell (@timcassell) Yegor Stepanov (@YegorStepanov) Youssef Victor (@Youssef1313) Thank you very much! Additional details Date: December 26, 2022 Milestone: v0.13.3 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.3 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.3 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.3 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.3 BenchmarkDotNet v0.13.2 Highlights In BenchmarkDotNet v0.13.2, we have implemented support for: .NET 7 NativeAOT .NET Framework 4.8.1 We have also introduced new features and improvements including: Possibility to hide selected columns, Allocation Ratio column, Logging progress and estimated finish time, ARM64 support for BenchmarkDotNet.Diagnostics.Windows package, Printing Hardware Intrinsics information, Glob filters support for DisassemblyDiagnoser. Of course, this release includes dozens of other improvements and bug fixes! Our special thanks go to @mawosoft, @YegorStepanov and @radical who fixed a LOT of really nasty bugs. Supported technologies .NET 7 and .NET Framework 4.8.1 .NET 4.8.1 has been released earlier this month, while .NET 7 should land in autumn this year. Now you can use BenchmarkDotNet to compare both! BenchmarkDotNet=v0.13.1.1845-nightly, OS=Windows 11 (10.0.22622.575) Microsoft SQ1 3.0 GHz, 1 CPU, 8 logical and 8 physical cores .NET SDK=7.0.100-preview.6.22352.1 [Host] : .NET 7.0.0 (7.0.22.32404), Arm64 RyuJIT AdvSIMD Job-QJVIDT : .NET 7.0.0 (7.0.22.32404), Arm64 RyuJIT AdvSIMD Job-FNNXOY : .NET Framework 4.8.1 (4.8.9032.0), Arm64 RyuJIT Method Runtime Mean Allocated BinaryTrees_2 .NET 7.0 193.6 ms 227.33 MB BinaryTrees_2 .NET Framework 4.8.1 192.8 ms 228.01 MB Credit for adding .NET 7 support in #1816 goes to @am11. @adamsitnik implemented .NET 4.8.1 support in #2044 and #2067. Big thanks to @MichalPetryka who was using preview versions of BenchmarkDotNet and reported a bug related to .NET 4.8.1 support: #2059 that got fixed before we released a new version. NativeAOT We are really excited to see the experimental CoreRT project grow and become officially supported by Microsoft (under new name: NativeAOT)! You can read more about it here. Implementing and improving the support was a combined effort of multiple contributors that spawned across multiple repositories: @MichalStrehovsky: #66290 in dotnet/runtime, #2020 in dotnet/BenchmarkDotNet, #2046 in dotnet/BenchmarkDotNet @hez2010: #66650 in dotnet/runtime @Beau-Gosse-dev: #1955 in dotnet/BenchmarkDotNet @adamsitnik: #1960 in dotnet/BenchmarkDotNet, #1965 in dotnet/BenchmarkDotNet, #1972 in dotnet/BenchmarkDotNet, #1973 in dotnet/BenchmarkDotNet, #1994 in dotnet/BenchmarkDotNet, #1997 in dotnet/BenchmarkDotNet, #2045 in dotnet/BenchmarkDotNet, #2068 in dotnet/BenchmarkDotNet @kant2002: #1976 in dotnet/BenchmarkDotNet, #1979 in dotnet/BenchmarkDotNet @jkotas: #68038 in dotnet/runtime, #68142 in dotnet/runtime, #68249 in dotnet/runtime, #68308 in dotnet/runtime, #68375 in dotnet/runtime @MichalPetryka: #2065 in dotnet/BenchmarkDotNet As every AOT solution, NativeAOT has some limitations like limited reflection support or lack of dynamic assembly loading. Because of that, the host process (what you run from command line) is never an AOT process, but just a regular .NET process. This process (called Host process) uses reflection to read benchmarks metadata (find all [Benchmark] methods etc.), generates a new project that references the benchmarks and compiles it using ILCompiler. The boilerplate code is not using reflection, so the project is built with TrimmerDefaultAction=link (we have greatly reduced build time thanks to that). Such compilation produces a native executable, which is later started by the Host process. This process (called Benchmark or Child process) performs the actual benchmarking and reports the results back to the Host process. By default BenchmarkDotNet uses the latest version of Microsoft.DotNet.ILCompiler to build the NativeAOT benchmark according to this instructions. Moreover, BenchmarkDotNet by default uses current machines CPU features (change: #1994, discussion: #2061) and if you don't like this behavior, you can disable it. This is why you need to: install pre-requisites required by NativeAOT compiler target .NET to be able to run NativeAOT benchmarks (example: <TargetFramework>net7.0</TargetFramework> in the .csproj file) run the app as a .NET process (example: dotnet run -c Release -f net7.0). specify the NativeAOT runtime in an explicit way, either by using console line arguments --runtimes nativeaot7.0 (the recommended approach), or by using[SimpleJob] attribute or by using the fluent Job config API Job.ShortRun.With(NativeAotRuntime.Net70): dotnet run -c Release -f net7.0 --runtimes nativeaot7.0 For more examples please go to docs. BenchmarkDotNet=v0.13.1.1845-nightly, OS=Windows 11 (10.0.22000.856/21H2) AMD Ryzen Threadripper PRO 3945WX 12-Cores, 1 CPU, 24 logical and 12 physical cores .NET SDK=7.0.100-rc.1.22423.16 [Host] : .NET 7.0.0 (7.0.22.42223), X64 RyuJIT AVX2 Job-KDVXET : .NET 7.0.0 (7.0.22.42223), X64 RyuJIT AVX2 Job-HFRAGK : .NET 7.0.0-rc.1.22424.9, X64 NativeAOT AVX2 Method Runtime Mean Ratio Allocated BinaryTrees_2 .NET 7.0 95.06 ms 1.00 227.33 MB BinaryTrees_2 NativeAOT 7.0 90.32 ms 0.96 227.33 MB Some of .NET features are not supported by Native AOT, that is why you may want to filter them out using new [AotFilter] attribute: [AotFilter(\"Currently not supported due to missing metadata.\")] public class Xml_FromStream<T> New features and improvements Hiding Columns In #1621 @marcnet80 has reduced the number of columns displayed when multiple runtimes are being compared. In #1890 @YegorStepanov has implemented a set of new APIs that allow for hiding columns. It's also exposed via -h and --hide command line arguments. [MemoryDiagnoser] // adds Gen0, Gen1, Gen2 and Allocated Bytes columns [HideColumns(Column.Gen0, Column.Gen1, Column.Gen2)] // dont display GenX columns public class IntroHidingColumns { [Benchmark] public byte[] AllocateArray() => new byte[100_000]; } Sample results without [HideColumns]: Method Mean Error StdDev Gen0 Gen1 Gen2 Allocated AllocateArray 3.303 us 0.0465 us 0.0435 us 31.2462 31.2462 31.2462 97.69 KB With: Method Mean Error StdDev Allocated AllocateArray 3.489 us 0.0662 us 0.0763 us 97.69 KB Imagine how much time @YegorStepanov has saved to all the people who so far were removing the columns manually from the results before publishing them on GitHub! Allocation Ratio Column In #1859 @YegorStepanov has added Allocation Ratio Column. It's enabled by default when MemoryDiagnoser is used and one of the benchmarks is marked as [Benchmark(Baseline = true)] or when there are multuple jobs defined and one of them is marked as baseline. [MemoryDiagnoser] public class AllocationColumnSample { [Benchmark(Baseline = true)] [Arguments(\"test\")] public string Builder(string value) { StringBuilder sb = new (value); for (int i = 0; i < 10; i++) sb.Append(value); return sb.ToString(); } [Benchmark] [Arguments(\"test\")] public string Concatenation(string value) { string result = value; for (int i = 0; i < 10; i++) result += value; return result; } } Method value Mean Error StdDev Ratio Gen 0 Allocated Alloc Ratio Builder test 127.9 ns 0.49 ns 0.43 ns 1.00 0.0544 456 B 1.00 Concatenation test 120.2 ns 0.94 ns 0.88 ns 0.94 0.0908 760 B 1.67 Progress and estimated finish time In #1909 @adamsitnik has added logging of progress and estimated finish time. // ** Remained 5211 (99.9%) benchmark(s) to run. Estimated finish 2022-08-25 22:26 (9h 7m from now) ** arm64 support for BenchmarkDotNet.Diagnostics.Windows package Due to the update to TraceEvent 3.0 BenchmarkDotNet.Diagnostics.Windows package has now arm64 support. Which means that you can use EtwProfiler and other ETW-based diagnosers on Windows arm64. It would not be possible without @brianrob who implemented arm64 support for TraceEvent in #1533! Hardware Intrinsics information In #2051 @adamsitnik has extended the hardware information printed in the Summary table with Hardware Intrinsics information. Sine the space in Summary table is quite limited, we full information is printed only in the log: Special thanks to @tannergooding who provided a lot of very valuable feedback and @MichalPetryka who contributed an improvement #2066 for older runtimes. Other improvements WASM toolchain has received a lot of improvements from various .NET Team members: #1769, #1936, #1938, #1982. Dependencies and TFMs updates: #1805, #1978, #2012, #2019, #2035. Ensure proper SummaryStyle handling implemented by @mawosoft in #1828. Preserving EnablePreviewFeatures project setting which gives the possibility to benchmark preview .NET features. Implemented by @kkokosa in #1842. CI: Using non-deprecated macOS pool on Azure Pipelines, implemented by @akoeplinger in #1847 CI: Updating Cake to 2.0.0, adopting frosting project style. Implemented by @AndreyAkinshin in #1865. Detecting ReSharper's Dynamic Program Analysis. Implemented by @adamsitnik in #1874. Preventing benchmark failure when some of the exporters fail. Implemented by @epeshk in #1902. Don't use the diagnosers when benchmarking has failed. Implemented by @adamsitnik in #1903. Ensuring the default order of benchmarks is the same as declared in source code. Implemented by @adamsitnik in #1907. Making BuildTimeout configurable. Implemented by @adamsitnik in #1906. Notify users about private methods with Setup/Cleanup attributes. Implemented by @epeshk in #1912. Don't run Roslyn Analyzers for the generated code. Implemented by @adamsitnik in #1917. Ensure WorkloadActionUnroll and similar are optimized if possible. Implemented by @AndyAyersMS in #1935. Don't use blocking acknowledgments when there is no need to. Implemented by @adamsitnik in #1940. Executor: Don't use Process.ExitCode, unless the process has exited. Implemented by @radical in #1947. Revise heuristic for initial jitting. Implemented by @AndyAyersMS in #1949. Allow logging build commands output. Implemented by @radical in #1950. Change Mono AOT mode to Normal AOT with LLVM JIT fall back. Implemented by @fanyang-mono in #1990. Glob filters support for DisassemblyDiagnoser So far, the disassembler was always loading the type that was generated by BDN, searching for the benchmark method, disassembling it and when encountered direct method calls, disassembling the called methods as well (if their depth was lesser or equal to max configured depth). This was working fine, but only for direct method calls. For indirect, the disassembly was incomplete. In #2072 @adamsitnik has added the possibility to filter methods disassembled by the DisassemblyDiagnoser. The users can now pass --disasmFilter $globPattern and it's going to be applied to full signatures of all methods available for disassembling. Examples: --disasmFilter *System.Text* - disassemble all System.Text methods. --disasmFilter * - disassemble all possible methods. Moreover, ClrMD was updated to v2 (#2040) and few disassembler bugs have been fixed (#2075, #2078). We are expecting that the disassembler will be more reliable now. Docs and Samples improvements Big thanks to @SnakyBeaky, @Distinctlyminty, @asaf92, @adamsitnik and @eiriktsarpalis who have improved our docs, samples and error messages! #1776, #1797, #1850, #1861, #1939, #1974, #1997, #2042, #2050, #2068. Bug fixes WASM: #1811, #1846, #1916, #1926, #1932. Diagnoser-provided Analysers weren't automatically added to Config. Fixed by @mawosoft in #1790. Exportes could been duplicated. Fixed by @workgroupengineering in #1796. Small bug in SummaryStyle. Fixed by @mawosoft in #1801. InvalidOperationException/NullReferenceException in SmartParaemter. Fixed by @mawosoft in #1810. Failures caused by colons in benchmark name. Fixed by @ronbrogan in #1823. Some benchmark arugments were not properly escaped and were causing process launcher to crush. Fixed by @adamsitnik in #1841 Invalid size specifiers for Memory and Disassembly diagnosers. Fixed by @YegorStepanov in #1854 and #1855. Respect LogicalGroup order in DefaultOrderer. Fixed by @AndreyAkinshin in #1866. Endless loop in user interaction with redirected input. Fixed by @tmds in #. Broken power plan support. Fixed by @YegorStepanov in #1885. BytesAllocatedPerOperation was not being output by the JSON and XML exporters. Fixed by #martincostello in #1919. Incorrect default InvocationCount in the summary table. Fixed by @AndreyAkinshin in #1929. Failed build output was printed in reverse order. Fixed by @radical in #1945. Build failures due to NETSDK1150. Fixed by @OlegOLK in #1981. MetricCoumn was not respecting provided units when formatting values. Fixed by @mawosoft in #2033. Generating invalid code that was causing benchmark failures. Fixed by @mawosoft in #2041. CI: non-master build branches were publishing artifacts to the CI feed. Fixed by @mawosoft in #2047. Comments in the project files were causing build failures. Fixed by @mawosoft in #2056. Milestone details In the v0.13.2 scope, 50 issues were resolved and 124 pull requests were merged. This release includes 147 commits by 34 contributors. Resolved issues (50) #299 Add API to remove columns for baseline comparison (assignee: @AndreyAkinshin) #384 Print Vector .Count as part of machine info (assignee: @adamsitnik) #722 Add scaled column for Allocated Memory #837 Problems with default UnrollFactor in V0.11.0 (assignee: @adamsitnik) #1177 Public types missing from reference assemblies don't work with ParamsSource #1506 BenchmarkDotNet does not force to High Performance Mode during running (assignee: @YegorStepanov) #1603 Don't display Job and Toolchain column when running benchmarks for multiple runtimes #1669 --buildTimeout does not seem to work (assignee: @adamsitnik) #1680 Cannot override RD.xml for NativeAOT #1711 Add support for IBM Z architecture (assignee: @adamsitnik) #1727 Unhelpful rounding in MemoryDiagnoser #1753 \"call: command not found\" in .sh build script (assignee: @AndreyAkinshin) #1755 EventPipeProfiler: File names are very verbose #1756 EventPipeProfile: speedscope.app cannot parse result file (assignee: @adamsitnik) #1774 Ability to compare --corerun with --runtimes (assignee: @adamsitnik) #1775 Please add an easy way to remove columns #1789 Small bug in ImmutableConfigbuilder (assignee: @mawosoft) #1794 typo in error message #1800 Small bug in SummaryStyle (assignee: @mawosoft) #1803 Benchmark exception stops entire suite run (assignee: @adamsitnik) #1809 Exception when using ParamsSource with (null) objects #1812 Invalid codegen for Enumerable.Empty returned from ParamsSource #1819 How to change exporter output path? #1836 [Bug] System.InvalidOperationException: There is an error in XML document (0, 0). #1857 Github actions ubuntu-latest \"Unable to load shared library 'advapi32.dll' or one of its dependencies\" when profiling dotnet 5 #1864 Is there a way to join summaries as if the benchmarks were run separately? (assignee: @AndreyAkinshin) #1871 Detect ReSharper's Dynamic Program Analysis (assignee: @adamsitnik) #1872 BenchmarkDontNet should make allowance for projects where Preview Features are enabled #1887 MonoAotLLVM runtime is not actually AOTing things (assignee: @naricc) #1900 Failed to benchmark .NET 7 in release mode #1908 BenchmarkRunner.RunSource and BenchmarkRunner.RunUrl doesn't work #1929 Incorrect default InvocationCount in the summary table (assignee: @AndreyAkinshin) #1934 Ensure WorkloadActionUnroll and similar are optimized if possible #1937 PR builds should not be published to BDN nightly feed (assignee: @mawosoft) #1943 GitHub Actions Windows CI leg failing due to lack of native tools (assignee: @adamsitnik) #1948 questions to help with future PRs #1957 Broken pipe (assignee: @adamsitnik) #1977 More Data for JSON and XML Export #1989 Way to summarize all the params results (assignee: @YegorStepanov) #1992 API Docs on website empty (assignee: @AndreyAkinshin) #2000 DisassemblyDiagnoser broken on Linux (assignee: @adamsitnik) #2009 Cleanup the dependencies (assignee: @martincostello) #2011 Release-only build error when using ParamsSource with a LINQ method: Cannot implicitly convert type 'object' (assignee: @mawosoft) #2016 Support for .NET 7? #2028 Trying to build BDN on a windows arm64 host (assignee: @adamsitnik) #2039 Support .NET Framework 4.8.1 (assignee: @adamsitnik) #2055 Comment after breaks generated project #2059 BenchmarkDotNet misreports .Net Framework as 4.8.1 (assignee: @adamsitnik) #2063 BenchmarkDotNet nightly fails to disassemble .Net 7.0 properly #2074 DisassemblyDiagnoser producing invalid disassembly (assignee: @adamsitnik) Merged pull requests (124) #1621 Hide columns for multiple runtime (by @marcnet80) #1769 Make wasm-interpreter work like wasm-aot (by @naricc) #1776 Clarify effects of IterationSetup on UnrollFactor and InvocationCount (by @SnakyBeaky) #1790 Bugfix in ImmutableConfigBuilder. Fixes #1789 (by @mawosoft) #1796 fixes(configuration): Not unique exporter for exporter type (by @workgroupengineering) #1797 Update DotNetCliCommandExecutor.cs (by @Distinctlyminty) #1801 Include RatioStyle in SummaryStyle.Equals()/GetHashCode(). Fixes #1800. (by @mawosoft) #1805 Update PackageReference for System.Management to latest (5.0.0). (by @mawosoft) #1810 Fix null reference exceptions in SmartParameter. Fixes #1809 (by @mawosoft) #1811 [WASM][AOT] Do not include KernelTraceControl in WasmAssembliesToBundle (by @naricc) #1816 Add net70 runtime support (by @am11) #1823 Replace colon if present in folder name (by @ronbrogan) #1828 Ensure proper SummaryStyle handling (by @mawosoft) #1835 Enable mono llvmaot tool chain to work with net7 (by @naricc) #1841 Fix argument escaping (by @adamsitnik) #1842 Preserve EnablePreviewFeatures csproj setting (by @kkokosa) #1846 [wasm] fix perf after test renames (by @pavelsavara) #1847 Use non-deprecated macOS pool on Azure Pipelines (by @akoeplinger) #1848 align both Executors to use the same timeout (2s) (by @adamsitnik) #1850 Added exporter custom path to docs #1819 (by @asaf92) #1854 Fix size specifier (by @YegorStepanov) #1855 Change DisassemblyDiagnoser to use byte unit always (by @YegorStepanov) #1858 Bugfix for merged PR #1855 (by @mawosoft) #1859 Add Allocation Ratio column (by @YegorStepanov) #1861 JitDiagnosers should print an error when run on non-Windows OS (by @adamsitnik) #1865 Bump Cake to 2.0.0, adopt frosting project style (by @AndreyAkinshin) #1866 Respect LogicalGroup order in DefaultOrderer (see #1864) (by @AndreyAkinshin) #1870 UserInteraction: don't loop when reaching the input end. (by @tmds) #1873 add EnablePreviewFeatures to the list of settings copied by BDN to the auto-generated project (by @adamsitnik) #1874 disable ReSharper's Dynamic Program Analysis by default (by @adamsitnik) #1885 Comeback of power management (by @YegorStepanov) #1888 Added IntermediateOutputPath option to MonoAotCompiler task parameters (by @naricc) #1890 Hiding columns (by @YegorStepanov) #1896 Fix warnings (by @adamsitnik) #1897 set TreatWarningsAsErrors to true (by @adamsitnik) #1902 Handled exceptions from exporters in CompositeExporter (by @epeshk) #1903 don't use diagnosers when running the benchmark has failed (by @adamsitnik) #1906 Improve BuildTimeout (by @adamsitnik) #1907 ensure the default order of benchmarks is the same as declared in source code (by @adamsitnik) #1909 Log progress and estimated finish time (by @adamsitnik) #1910 Make FromUrl and FromSource more friendly (by @YegorStepanov) #1912 Notified users about private methods with Setup/Cleanup attributes (by @epeshk) #1915 JsonExporter: make Json export more extensible. (by @ptr1120) #1916 [WASM] Fix rename of main.js to test-main.js (by @naricc) #1917 Don't run Analyzers for the generated project + Roslyn workaround (by @adamsitnik) #1919 Restore BytesAllocatedPerOperation for JSON and XML (by @martincostello) #1921 Improve failure handling and finish time estimation (by @adamsitnik) #1926 Fix typo in WasmCsProj.txt (by @lewing) #1930 Display correct default InvocationCount in SummaryTable, fixes #1929 (by @AndreyAkinshin) #1932 [wasm] Set the right runtime moniker (by @radekdoulik) #1935 Fix optimization of action methods for coreclr (by @AndyAyersMS) #1936 [wasm] Improve the autogenerated project (by @radical) #1938 [wasm] Add a --wasmDataDir parameter (by @radical) #1939 Update contributing docs (by @adamsitnik) #1940 Don't use blocking acknowledgments when there is no need to (by @adamsitnik) #1945 AsyncProcessOutputReader: Use ConcurrentQueue instead of ConcurrentStack (by @radical) #1946 improve error message for users who pass path to Core_Root instead of CoreRun (by @adamsitnik) #1947 Executor: Don't use Process.ExitCode, unless the process has exited (by @radical) #1949 Revise heuristic for initial jitting. (by @AndyAyersMS) #1950 DotNetCli*: Allow logging command output (by @radical) #1953 add possibility to enable build output logging via command line args (by @adamsitnik) #1955 Cleaning up argument spacing in CLI calls. Add output path for publish. CoreRT (by @Beau-Gosse-dev) #1958 fix broken pipe issue (by @adamsitnik) #1959 add --justBuild for users who want to reuse code produced by BDN without running the benchmarks (by @adamsitnik) #1960 Improve support for NativeAOT (by @adamsitnik) #1961 disable AwaitingTasksShouldNotInterfereAllocationResults test (by @adamsitnik) #1965 Rename CoreRT to NativeAOT (by @adamsitnik) #1966 Actually AOT things in AOT mode; prevent JIT fall back (by @naricc) #1969 Fixed FreeBSD shared library extension in MonoAOTLLVM tool chain. (by @naricc) #1970 Add new --generateBinLog to generate msbuild binlogs, with names (by @radical) #1972 [NativeAOT] Set TrimmerDefaultAction to link (by @adamsitnik) #1973 don't place DynamicallyAccessedMembers on an array (by @adamsitnik) #1974 Update ArtifactFileNameHelper error message (by @eiriktsarpalis) #1975 Addressing code review suggestions (by @adamsitnik) #1976 Add support for Rd.xml file around project file (by @kant2002) #1978 Migrate from .NET 5 to .NET 6.0 (by @kant2002) #1979 Remove CPP codegen for NativeAOT (by @kant2002) #1981 Fix for issue NETSDK1150 (by @OlegOLK) #1982 DotNetCliCommand: Add new RetryFailedBuildWithNoDeps property (by @radical) #1984 Reduce generated code size (by @adamsitnik) #1985 don't emit debug symbols on platforms where it does not work well (by @adamsitnik) #1986 the CI must run net6.0, not net5.0 tests (by @adamsitnik) #1987 Fix AppVeyor build (by @adamsitnik) #1988 re-enable NativeAOT tests on GitHub Actions Windows (by @adamsitnik) #1990 [Mono] Change AOT mode to Normal AOT with LLVM JIT fall back (by @fanyang-mono) #1994 NativeAOT: IlcOptimizationPreference & IlcInstructionSet (by @adamsitnik) #1996 use AnyCPU for S390x (by @adamsitnik) #1997 Update NativeAOT docs, fix the support for local NativeAOT builds (by @adamsitnik) #2002 when user specifies both --runtimes and --corerun, multiple independent jobs should be created (by @adamsitnik) #2006 when Host process is not .NET Core, CoreRunToolchain should use latest available TFM (by @adamsitnik) #2008 Use PackageIcon property (by @martincostello) #2012 Cleanup dependencies and add net6.0 TFM (by @martincostello) #2019 Update Iced to its latest version. (by @teo-tsirpanis) #2020 Opt out of metadata trimming (by @MichalStrehovsky) #2023 don't run NativeAOT tests on AppVeyor Windows (by @adamsitnik) #2029 don't emit debug symbols for samples and test projects (by @adamsitnik) #2030 update TraceEvent to 3.0.1 to have a proper ARM64 support for Diagnostics package (by @adamsitnik) #2033 Bugfix MetricColumn: Respect unit when formatting values. (by @mawosoft) #2035 net461->net462 in Samples, Diagnosers, Tests (by @AndreyAkinshin) #2040 Port the .NET (Core) disassembler to ClrMd v2 (by @adamsitnik) #2041 Bugfix SmartParameter source code generation (by @mawosoft) #2042 Fix WmicCpuInfoProvider documentation (by @msitt) #2043 restore Microsoft.DotNet.PlatformAbstraction dependency (by @adamsitnik) #2044 add .NET 4.8.1 support (by @adamsitnik) #2045 adopt to recent NativeAOT changes (by @adamsitnik) #2046 Make a bit of BenchmarkDotNet trimmable (by @MichalStrehovsky) #2047 Restrict what's published to AppVeyor NuGet feed (BDN nightly) (by @mawosoft) #2050 Fix DocFx configuration and build (by @mawosoft) #2051 extend printed Runtime Info with simple Hardware Intrinsics information (by @adamsitnik) #2052 Address code review feedback (by @adamsitnik) #2056 Bugfix copied project settings (by @mawosoft) #2065 Add serialize to NativeAOT (by @MichalPetryka) #2066 Print Vector width in summary on older runtimes (by @MichalPetryka) #2067 fix .NET 4.8.1 detection (by @adamsitnik) #2068 print error when users try DisassemblyDiagnoser with NativeAOT (by @adamsitnik) #2071 use ClrMd v2 disassembler on Windows whenever possible (by @adamsitnik) #2072 Add glob filters support to disassembler to allow disassembling specific methods (by @adamsitnik) #2073 add two fallbacks to CoreRun copying (by @adamsitnik) #2075 Fix disassembler (by @adamsitnik) #2078 More disassembler improvements (by @adamsitnik) #2079 fix the CI (by @adamsitnik) #2081 JsonExporter: make Json export more extensible. (by @ptr1120) #2082 remove last warning (by @adamsitnik) #2084 Release notes for 0.13.2 (by @adamsitnik) Commits (147) 4de165 Postrelease v0.13.1 update (by @AndreyAkinshin) 74e3c4 Make wasm-interpreter work like wasm-aot (#1769) (by @naricc) 1a8296 Better snap support, fix #1753 (by @AndreyAkinshin) aa9167 Clarify effects of IterationSetup on UnrollFactor and InvocationCount (#1776) (by @SnakyBeaky) 937865 Set allow unsafe blocks to true. (#1779) (by @naricc) e08b79 Bugfix in ImmutableConfigBuilder. Fixes #1789 (#1790) (by @mawosoft) 156fd6 Fix an logger message typo in the DotNetCliCommandExecutor Execute method, fi... (by @Distinctlyminty) d312ed Include RatioStyle in SummaryStyle.Equals()/GetHashCode(). Fixes #1800. (#1801) (by @mawosoft) 38b99b Update PackageReference for System.Management to latest (5.0.0). (#1805) (by @mawosoft) e9a569 [WASM][AOT] Do not include KernelTraceControl in WasmAssembliesToBundle (#1811) (by @naricc) 80044a Fix null reference exceptions in SmartParameter. Fixes #1809 (#1810) (by @mawosoft) 273113 Add tests for the case when ParamsSource contains null (by @AndreyAkinshin) a5176a Add net7.0 runtime support (#1816) (by @am11) 7e757d Replace colon if present in folder name (#1823) (by @ronbrogan) 24e041 Use non-deprecated Azure Pipelines Ubuntu pool (#1829) (by @akoeplinger) beb543 Enable mono llvmaot tool chain to work with net7 (#1835) (by @naricc) 8a88b4 Ensure proper SummaryStyle handling (#1828) (by @mawosoft) 559d18 Fix argument escaping (#1841) (by @adamsitnik) 5927a6 Preserve EnablePreviewFeatures csproj setting (#1842) (by @kkokosa) db0a88 [wasm] fix perf after test renames (#1846) (by @pavelsavara) dddc1e Use non-deprecated macOS pool on Azure Pipelines (#1847) (by @akoeplinger) e62dc2 align both Executors to use the same timeout (2s) (#1848) (by @adamsitnik) 7d5a8f Added exporter custom path to docs #1819 (#1850) (by @asaf92) 7b0211 Fix size specifier (#1854), fixes #1727 (by @YegorStepanov) 34817b Change DisassemblyDiagnoser to use byte unit always (#1855) (by @YegorStepanov) 0c03e8 Bugfix for merged PR #1855 (#1858) (by @mawosoft) f00f7c JitDiagnosers should print an error when run on non-Windows OS (#1861) (by @adamsitnik) 956051 Add Allocation Ratio column (#1859) (by @YegorStepanov) 42c718 Categories should have the highest priority in logical group order, fixes #1864 (by @AndreyAkinshin) 6f6de0 Introduce BenchmarkRunner.Run(Type[] types) (by @AndreyAkinshin) 408786 Use Cake.FileHelpers 4.0.1 (by @AndreyAkinshin) 130f0f Additional diagnostics in WindowsDisassembler (see #1836) (by @AndreyAkinshin) 189e68 Fix GroupExporterTest (by @AndreyAkinshin) 61c447 Remove travis badges (by @AndreyAkinshin) e17992 Bump Cake to 2.0.0, adopt frosting project style (#1865) (by @AndreyAkinshin) bb180a Remove .travis.yml (by @AndreyAkinshin) f188f7 Respect LogicalGroup order in DefaultOrderer (see #1864) (#1866) (by @AndreyAkinshin) 7e19f3 Enable GitHub actions (by @AndreyAkinshin) ed53a3 Add GitHub Actions build status badge (by @AndreyAkinshin) 195cfd Support Windows 11 in OsBrandStringHelper (by @AndreyAkinshin) 5145d1 Fix documentation build tasks (by @AndreyAkinshin) 988dbf Update docs/articles/contributing/documentation.md (by @AndreyAkinshin) f17453 UserInteraction: don't loop when reaching the input end. (#1870) (by @tmds) 23d115 force High Performance Mode by default, fixes #1506 (#1885) (by @YegorStepanov) 328573 Added IntermediateOutputPath option to MonoAotCompiler task parameters (#1888) (by @naricc) 26ed31 set JETBRAINS_DPA_AGENT_ENABLE by default to 0 to disable ReSharper's Dynamic... (by @adamsitnik) 625b2c Fix warnings (#1896) (by @adamsitnik) 4b8821 Handled exceptions from exporters in CompositeExporter. Preventing benchmark ... (by @epeshk) 6ca6c6 don't use diagnosers when running the benchmark has failed (#1903) (by @adamsitnik) 6d2739 Improve BuildTimeout (#1906) (by @adamsitnik) 3ea212 ensure the default order of benchmarks is the same as declared in source code... (by @adamsitnik) 05bb3d Log progress and estimated finish time (#1909) (by @adamsitnik) 11751a Don't run Analyzers for the generated project + Roslyn workaround (#1917) (by @adamsitnik) 80f45c [WASM] Fix rename of main.js to test-main.js (#1916) (by @naricc) 32bb2d Improve failure handling and finish time estimation (#1921) (by @adamsitnik) 9ff0f9 Restore BytesAllocatedPerOperation for JSON and XML (#1919) (by @martincostello) 569f4f Add macOS Monterey test case in OsBrandStringTests (by @AndreyAkinshin) 63c0ce Notified users about private methods with Setup/Cleanup attributes (#1912) (by @epeshk) c1f210 fixes(configuration): Not unique exporter for exporter type (#1796) (by @workgroupengineering) bd0872 Rollback logicalGroupRules to List (by @AndreyAkinshin) c303ad Fix typo in WasmCsProj (#1926) (by @lewing) f1aefb Display correct default InvocationCount in SummaryTable, fixes #1929 (#1930) (by @AndreyAkinshin) ca5103 [wasm] Set the right runtime moniker (#1932) (by @radekdoulik) fa5984 [wasm] Improve the autogenerated project (#1936) (by @radical) b78ec9 Fix optimization of action methods for coreclr (#1935) (by @AndyAyersMS) 13f4ea Don't use blocking acknowledgments when there is no need to (#1940) (by @adamsitnik) 8ce19e [wasm] Add a --wasmDataDir parameter (#1938) (by @radical) 9b990d AsyncProcessOutputReader: Use ConcurrentQueue instead of ConcurrentStack (#1945) (by @radical) 937311 Revise heuristic for initial jitting. (#1949) (by @AndyAyersMS) 228a6a improve error message for users who pass path to Core_Root instead of CoreRun... (by @adamsitnik) 1d34f8 DotNetCli*: Allow logging command output (#1950) (by @radical) 01ead5 Executor: Don't use Process.ExitCode, unless the process has exited (#1947) (by @radical) 8e3d13 add possibility to enable build output logging via command line args (#1953) (by @adamsitnik) 6fa333 Cleaning up argument spacing in CLI calls. Add output path for publish. CoreR... (by @Beau-Gosse-dev) 010ac2 don't redirect standard input and don't write Acknowledgment to it if acknowl... (by @adamsitnik) d66289 Improve support for NativeAOT (#1960) (by @adamsitnik) 0868da disable AwaitingTasksShouldNotInterfereAllocationResults for InProcess toolch... (by @adamsitnik) 41a151 Rename CoreRT to NativeAOT (#1965) (by @adamsitnik) 9c1c27 [Mono] Actually AOT things in AOT mode; prevent JIT fall back (#1966) (by @naricc) ed6529 Fixed FreeBSD shared library extension in MonoAOTLLVM tool chain. (#1969) (by @naricc) 19679d Set TrimmerDefaultAction to link to ensure that trimmer only analyzes the par... (by @adamsitnik) e2d41b don't place DynamicallyAccessedMembers on an array (#1973) (by @adamsitnik) 09d939 Update ArtifaceFileNameHelper error message (#1974) (by @eiriktsarpalis) cac918 Add new --generateBinLog to generate msbuild binlogs, with names (#1970) (by @radical) 5f0db4 Add support for LoongArch64. (#1971) (by @LuckyXu-HF) 56556a Add support for Rd.xml file around project file (#1976) (by @kant2002) 804ed9 Remove CPP codegen for NativeAOT (#1979) (by @kant2002) 190d07 Fix for issue NETSDK1150 (#1981) (by @OlegOLK) a57819 Migrate from .NET 5 to .NET 6.0 (#1978) (by @kant2002) 74086a Addressing code review suggestions (#1975) (by @adamsitnik) 5fdafb Update contributing docs (#1939) (by @adamsitnik) ca43aa DotNetCliCommand: Add new RetryFailedBuildWithNoDeps property (#1982) (by @radical) bbe6ab Reduce generated code size (#1984) (by @adamsitnik) 31de77 the CI must run net6.0, not net5.0 tests (#1986) (by @adamsitnik) 554127 Fix AppVeyor build (#1987) (by @adamsitnik) a0035f re-enable NativeAOT tests on GitHub Actions Windows (#1988) (by @adamsitnik) 163f40 don't emit debug symbols (#1985) (by @adamsitnik) 35ba9d Change aot mode to normal aot with LLVM JIT fall back (#1990) (by @fanyang-mono) 1c935d NativeAOT: IlcOptimizationPreference & IlcInstructionSet (#1994) (by @adamsitnik) c165ba use AnyCPU for S390x, fixes #1711 (#1996) (by @adamsitnik) f4e8de Update NativeAOT docs, fix the support for local NativeAOT builds (#1997) (by @adamsitnik) 9e173d Fix typo in README (by @AndreyAkinshin) a79881 when user specifies both --runtimes and --corerun, multiple independent jobs ... (by @adamsitnik) 5e6275 when Host process is not .NET Core, CoreRunToolchain should use latests avail... (by @adamsitnik) b09431 Opt out of metadata trimming (#2020) (by @MichalStrehovsky) 5448d4 Update Iced to its latest version. (#2019) (by @teo-tsirpanis) fcda33 Use PackageIcon property (#2008) (by @martincostello) 72fce9 don't run NativeAOT tests on AppVeyor, as one of them takes 3 minutes and we ... (by @adamsitnik) 14f9cf don't emit debug symbols for samples and test projects as it breaks arm64 win... (by @adamsitnik) fd4a9c update TraceEvent to 3.0.1 to have a proper ARM64 support for Diagnostics pac... (by @adamsitnik) 8deec6 Bugfix MetricColumn: Respect unit when formatting values. (by @mawosoft) 9216a7 Add MetricColumnTests (by @AndreyAkinshin) 23f995 net461->net462 in Samples, Diagnosers, Tests (#2035) (by @AndreyAkinshin) 762b76 Cleanup dependencies and add net6.0 TFM (#2012) (by @martincostello) d24ea3 Port the .NET (Core) disassembler to ClrMd v2 (#2040) (by @adamsitnik) 6eb280 Fix WmicCpuInfoProvider comment (#2042) (by @msitt) f72e61 restore Microsoft.DotNet.PlatformAbstraction dependency (#2043) (by @adamsitnik) 99ef3f add .NET 4.8.1 support (#2044) (by @adamsitnik) 118135 adopt to recent NativeAOT changes (#2045) (by @adamsitnik) 96b376 Make a bit of BenchmarkDotNet trimmable (#2046) (by @MichalStrehovsky) e4ff20 Bugfix SmartParameter source code generation (#2041) (by @mawosoft) 461b70 Added the kernel keyword as a parameter to the ETWConfig (#2049) (by @mrsharm) d6020e Restrict what's published to AppVeyor NuGet feed (BDN nightly) (#2047) (by @mawosoft) 32ddeb provide Hardware Intrinsics information (#2051) (by @adamsitnik) 2e943e Fix DocFx configuration and build (by @mawosoft) 8c963b Reverting DocFX_Build dependency on Build (by @mawosoft) 48ecbc add missing hardware intrinsic info (#2052) (by @adamsitnik) b4c44c Bugfix copied project settings (#2056) (by @mawosoft) 2dc6c9 Add serialize to NativeAOT (#2065) (by @MichalPetryka) 7fb872 Print Vector width in summary on older runtimes (#2066) (by @MichalPetryka) 8e355b fix .NET 4.8.1 detection (#2067) (by @adamsitnik) 0f457d print error when users try DisassemblyDiagnoser with NativeAOT (#2068) (by @adamsitnik) b79282 use ClrMd2Disassembler on Windows whenever possible (#2071) (by @adamsitnik) a5b0e9 Add glob filters support to disassembler to allow disassembling specific meth... (by @adamsitnik) cab43e add two fallbacks to CoreRun copying (#2073) (by @adamsitnik) 4924f0 Fix few new disassembler bugs caused by update to ClrMd v2 (#2075) (by @adamsitnik) c99ba3 More disassembler improvements (#2078) (by @adamsitnik) 6bb61c Make FromUrl and FromSource more friendly (#1910) (by @YegorStepanov) 387ca0 fix the CI (#2079) (by @adamsitnik) 52d770 set TreatWarningsAsErrors to true (#1897) (by @adamsitnik) a11b49 JsonExporter: make Json export more extensible. (#2081) (by @ptr1120) 1424cf remove last warning that happens during pack command for master branch build ... (by @adamsitnik) 838000 Hide columns for multiple runtime (#1621) (by @marcnet80) 8ec00d Hiding columns (#1890) (by @YegorStepanov) e0dbce Release notes for 0.13.2 (#2084) (by @adamsitnik) f6f335 Prepare v0.13.2 changelog (by @AndreyAkinshin) 186998 Set library version: 0.13.2 (by @AndreyAkinshin) Contributors (34) Adam Sitnik (@adamsitnik) Adeel Mujahid (@am11) Alexander Köplinger (@akoeplinger) Andrey Akinshin (@AndreyAkinshin) Andrii Kurdiumov (@kant2002) Andy Ayers (@AndyAyersMS) Ankit Jain (@radical) Asaf Agami (@asaf92) Beau Gosse (@Beau-Gosse-dev) Eirik Tsarpalis (@eiriktsarpalis) Evgeny Peshkov (@epeshk) Fan Yang (@fanyang-mono) James MIllar (@Distinctlyminty) Konrad Kokosa (@kkokosa) Larry Ewing (@lewing) marcnet80 (@marcnet80) Marland Sitt (@msitt) Martin Costello (@martincostello) Matthias Wolf (@mawosoft) Michał Petryka (@MichalPetryka) Michal Strehovský (@MichalStrehovsky) Mukund Raghav Sharma (Moko) (@mrsharm) Nathan Ricci (@naricc) OlegOLK (@OlegOLK) Oriol Mesa (@SnakyBeaky) Pavel Savara (@pavelsavara) Peter Bruch (@ptr1120) Radek Doulik (@radekdoulik) Ron Brogan (@ronbrogan) Theodore Tsirpanis (@teo-tsirpanis) Tom Deseyn (@tmds) workgroupengineering (@workgroupengineering) Xu Liangyu (@LuckyXu-HF) Yegor Stepanov (@YegorStepanov) Thank you very much! Additional details Date: August 26, 2022 Milestone: v0.13.2 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.2 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.2 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.2 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.2 BenchmarkDotNet v0.13.1 BenchmarkDotNet v0.13.1 is a service update with various bug fixes and improvements. Highlights S390x architecture support (#1712) Various WASM toolchain improvements (#1719, #1722, #1729, #1742, #1743, #1744, #1746, #1757, #1763) Support of CoreRT on 5.0.3XX SDK (#1725) Using Utf8 for reading from standard input (fixes a nasty encoding-related bug) (#1735) Adjusting WaitForExit timeouts (#1745) Support for returning unmanaged types from benchmarks with InProcessToolchain (#1750) Disabled Tiered JIT (#1751) A MemoryDiagnoser bug fix (#1762) Allow users to hide Gen X columns (#1764) Copy GC settings from host process to the benchmark process (#1765) Do not split surrogates in shortified parameter values (#1705) Milestone details In the v0.13.1 scope, 3 issues were resolved and 23 pull requests were merged. This release includes 36 commits by 10 contributors. Resolved issues (3) #1703 Unable to run benchmark when ParamsSource refers to string with surrogate pairs #1713 System.NotSupportedException: Unknown Acknowledgment: \uFEFFAcknowledgment when running in a github action (assignee: @adamsitnik) #1714 AwaitingTasksShouldNotInterfereAllocationResults is flaky (assignee: @adamsitnik) Merged pull requests (23) #1705 do not split surrogates in ParameterInstance.ToDisplayText() (by @novak-as) #1710 Fix typo (by @martincostello) #1712 add S390x architecture support (by @adamsitnik) #1719 Added UsingBrowserRuntimeWorkload (by @naricc) #1722 Add AOT options to wasm runtime (by @naricc) #1725 Add ValidateExecutableReferencesMatchSelfContained (by @kant2002) #1729 Naricc/validate executable references match self contained (by @naricc) #1735 Use Utf8 not just for writing to standard output, but also for reading from standard input (by @adamsitnik) #1739 Add support for returning unmanaged types from benchmarks (by @kant2002) #1742 Fix WasmAssembliesToBundle item is empty error (by @radekdoulik) #1743 Add linker description for wasm AOT (by @radekdoulik) #1744 Make mono/wasm run on Windows (by @radekdoulik) #1745 Fix #1731. (by @cgranade) #1746 Make PrepareForWasmBuild work with wasm workload (by @radekdoulik) #1748 Fix typo in docs (by @Jlobblet) #1750 Fix pointer-returning benchmarks support for InProcessToolchain (by @adamsitnik) #1751 disable TieredJit so it's background allocations don't show up in allocated memory reported by MemoryDiagnoser tests (by @adamsitnik) #1757 [wasm] Add WasmMainJSPath in interpreter projects (by @radekdoulik) #1762 MemoryDiagnoser fix (by @adamsitnik) #1763 Pr wasm set runtimesrcdir for interpreter (by @naricc) #1764 Allow users to hide Gen X columns (by @adamsitnik) #1765 Copy GC settings from host process (by @adamsitnik) #1768 Fix typo in README (by @eugene-g) Commits (36) fe1124 Postrelease update of v0.13.0 changelog (by @AndreyAkinshin) 0388db Update build-and-pack.cmd (by @AndreyAkinshin) 5c8469 Set release date for v0.13.0 (by @AndreyAkinshin) 601a1a Fix typo (#1710) (by @martincostello) 5bc925 do not split surrogates in ParameterInstance.ToDisplayText() (#1705) (by @novak-as) 891e57 Add unicode testcases in ParameterInstanceTests.MaxParameterColumnWidthCanBeC... (by @AndreyAkinshin) 5d2160 Update changelog files (by @AndreyAkinshin) bbc4b4 add S390x architecture support (#1712) (by @adamsitnik) bf54f0 Fix flakiness in ThreadingDiagnoserTests (by @AndreyAkinshin) 6ffdb2 [WASM] Added UsingBrowserRuntimeWorkload (#1719) (by @naricc) 5196e6 Add AOT options to wasm runtime (#1722) (by @naricc) d97285 Add ValidateExecutableReferencesMatchSelfContained (#1725) (by @kant2002) cb23e1 Delete .BenchmarkDotNet.Samples.csproj.swp (#1726) (by @naricc) 75f632 Set ValidateExecutableReferencesMatchSelfContained for Wasm (#1729) (by @naricc) 9e7e50 Added false to Wasm cs proj. (#1734) (by @naricc) e7ff4c Use Utf8 not just for witing to standard output, but also for reading from st... (by @adamsitnik) 081563 Added UsingBrowserRuntimeWorkload false. (#1741) (by @naricc) 2fefdb Fix WasmAssembliesToBundle item is empty error (#1742) (by @radekdoulik) 6b475f Add linker description for wasm AOT (#1743) (by @radekdoulik) acb6f2 Make mono/wasm run on Windows (#1744) (by @radekdoulik) 4b3d19 Make PrepareForWasmBuild work with wasm workload (#1746) (by @radekdoulik) 141ef7 handle processes that don't exit on time more gracefully, fixes #1731. (#1745) (by @cgranade) c3fb7b Add support for returning unmanaged types from benchmarks (#1739) (by @kant2002) 6f453b [wasm] Allow unsafe code (#1752) (by @radekdoulik) c2cee2 Fix the CI (by @radekdoulik) 19cbef Fix typo in docs (#1748) (by John Blundell) 1a94d4 [wasm] Add WasmMainJSPath in interpreter projects (#1757) (by @radekdoulik) 37ec19 Get rid of warning (#1760) (by @radekdoulik) 4bd433 use benchmark process runtime, not host process runtime when deciding whether... (by @adamsitnik) 8cb701 Update OsBrandStringHelper (by @AndreyAkinshin) 8f81b5 Copy GC settings from host process (#1765) (by @adamsitnik) f37266 Allow users to hide Gen X columns (#1764) (by @adamsitnik) f9a4c1 [WASM] set runtimesrcdir for interpreter (#1763) (by @naricc) 9e674d Fix typo in README (by @eugene-g) 708be4 Prepare v0.13.1 changelog (by @AndreyAkinshin) a93681 Set library version: 0.13.1 (by @AndreyAkinshin) Contributors (10) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Andrii Kurdiumov (@kant2002) Cassandra Granade (@cgranade) Evgenii Grebeniuk (@eugene-g) John Blundell Martin Costello (@martincostello) Nathan Ricci (@naricc) Oleksandr Novak (@novak-as) Radek Doulik (@radekdoulik) Thank you very much! Additional details Date: August 11, 2021 Milestone: v0.13.1 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.1 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.1 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.1 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.1 BenchmarkDotNet v0.13.0 It's been a year since our last release. BenchmarkDotNet has been downloaded more than seven million times from nuget.org. It's more than we could have ever possibly imagined! Some could say, that it's also more than we can handle ;) That is why we wanted to once again thank all the contributors who helped us with 0.13.0 release! Highlights In BenchmarkDotNet v0.13.0, we have supported various technologies: .NET 5 and .NET 6 target framework monikers .NET SDK installed via snap SingleFile deployment Xamarin applications WASM applications Mono AOT We have also introduced new features and improvements including: Memory randomization Method-specific job attributes Sortable parameter columns Customizable ratio column Improved CoreRun and CoreRT support Improved Hardware Counters support Of course, this release includes dozens of other improvements and bug fixes! Supported technologies .NET 5, .NET 6, SingleFile and snap At some point in time, netcoreapp5.0 moniker was changed to net5.0, which required a fix on our side (#1479, btw we love this kind of changes). Moreover, .NET 5 introduced platform-specific TMFs (example: net5.0-windows10.0.19041.0) which also required some extra work: #1560, #1691. In #1523 support for .NET 6 was added. <TargetFrameworks>net5.0;net5.0-windows10.0.19041.0;net6.0<TargetFrameworks> In #1686 @am11 has implemented support for single file deployment (supported in .NET 5 onwards). Last, but not least in #1652 snap support has been implemented. adam@adsitnik-ubuntu:~/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples$ dotnet50 run -c Release -f net5.0 --filter BenchmarkDotNet.Samples.IntroColdStart.Foo // Validating benchmarks: // ***** BenchmarkRunner: Start ***** // ***** Found 1 benchmark(s) in total ***** // ***** Building 1 exe(s) in Parallel: Start ***** // start /snap/dotnet-sdk/112/dotnet restore /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in /home/adam/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples/bin/Release/net5.0/9a018ee4-0f33-46dd-9093-01d3bf31233b // command took 1.49s and exited with 0 // start /snap/dotnet-sdk/112/dotnet build -c Release --no-restore /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in /home/adam/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples/bin/Release/net5.0/9a018ee4-0f33-46dd-9093-01d3bf31233b // command took 2.78s and exited with 0 // ***** Done, took 00:00:04 (4.37 sec) ***** // Found 1 benchmarks: // IntroColdStart.Foo: Job-NECTOD(IterationCount=5, RunStrategy=ColdStart) // ************************** // Benchmark: IntroColdStart.Foo: Job-NECTOD(IterationCount=5, RunStrategy=ColdStart) // *** Execute *** // Launch: 1 / 1 // Execute: /snap/dotnet-sdk/112/dotnet \"9a018ee4-0f33-46dd-9093-01d3bf31233b.dll\" --benchmarkName \"BenchmarkDotNet.Samples.IntroColdStart.Foo\" --job \"IterationCount=5, RunStrategy=ColdStart\" --benchmarkId 0 in /home/adam/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples/bin/Release/net5.0/9a018ee4-0f33-46dd-9093-01d3bf31233b/bin/Release/net5.0 Xamarin support Thanks to the contributions of the amazing @jonathanpeppers BenchmarkDotNet supports Xamarin! The examples can be found in our repo: iOS, Android. #1360, #1429, #1434, #1509 WASM support Thanks to the work of @naricc you can now benchmark WASM using Mono Runtime! For more details, please refer to our docs. #1483, #1498, #1500, #1501, #1507, #1592, #1689. Mono AOT support In another awesome contribution (#1662) @naricc has implemented Mono AOT support. The new toolchain supports doing Mono AOT runs with both the Mono-Mini compiler and the Mono-LLVM compiler (which uses LLVM on the back end). For more details, please go to our docs. New features and improvements Memory randomization In #1587 @adamsitnik has introduced a new, experimental feature called \"Memory Randomization\". This feature allows you to ask BenchmarkDotNet to randomize the memory alignment by allocating random-sized byte arrays between iterations and call [GlobalSetup] before every benchmark iteration and [GlobalCleanup] after every benchmark iteration. Sample benchmark: public class IntroMemoryRandomization { [Params(512 * 4)] public int Size; private int[] _array; private int[] _destination; [GlobalSetup] public void Setup() { _array = new int[Size]; _destination = new int[Size]; } [Benchmark] public void Array() => System.Array.Copy(_array, _destination, Size); } Without asking for the randomization, the objects are allocated in [GlobalSetup] and their unmodified addresses (and alignment) are used for all iterations (as long as they are not promoted to an older generation by the GC). This is typically the desired behavior, as it gives you very nice and flat distributions: dotnet run -c Release --filter IntroMemoryRandomization -------------------- Histogram -------------------- [502.859 ns ; 508.045 ns) | @@@@@@@@@@@@@@@ --------------------------------------------------- But if for some reason you are interested in getting a distribution that is better reflecting the \"real-life\" performance you can enable the randomization: dotnet run -c Release --filter IntroMemoryRandomization --memoryRandomization true -------------------- Histogram -------------------- [108.803 ns ; 213.537 ns) | @@@@@@@@@@@@@@@ [213.537 ns ; 315.458 ns) | [315.458 ns ; 446.853 ns) | @@@@@@@@@@@@@@@@@@@@ [446.853 ns ; 559.259 ns) | @@@@@@@@@@@@@@@ --------------------------------------------------- Method-specific job attributes From now, all attributes that derive from JobMutatorConfigBaseAttribute (full list) can be applied to methods. You no longer have to move a method to a separate type to customize config for it. [Benchmark] [WarmupCount(1)] public void SingleWarmupIteration() [Benchmark] [WarmupCount(9)] public void NineWarmupIterations() Sortable parameter columns In order to sort columns of parameters in the results table, you can use the Property Priority inside the params attribute. The priority range is [Int32.MinValue;Int32.MaxValue], lower priorities will appear earlier in the column order. The default priority is set to 0. public class IntroParamsPriority { [Params(100)] public int A { get; set; } [Params(10, Priority = -100)] public int B { get; set; } [Benchmark] public void Benchmark() => Thread.Sleep(A + B + 5); } Method B A Mean Error StdDev Benchmark 10 100 115.4 ms 0.12 ms 0.11 ms This feature got implemented by @JohannesDeml in #1612. Customizable ratio column Now it's possible to customize the format of the ratio column. [Config(typeof(Config))] public class IntroRatioStyle { [Benchmark(Baseline = true)] public void Baseline() => Thread.Sleep(1000); [Benchmark] public void Bar() => Thread.Sleep(150); [Benchmark] public void Foo() => Thread.Sleep(1150); private class Config : ManualConfig { public Config() { SummaryStyle = SummaryStyle.Default.WithRatioStyle(RatioStyle.Trend); } } } | Method | Mean | Error | StdDev | Ratio | RatioSD | |--------- |-----------:|--------:|--------:|-------------:|--------:| | Baseline | 1,000.6 ms | 2.48 ms | 0.14 ms | baseline | | | Bar | 150.9 ms | 1.30 ms | 0.07 ms | 6.63x faster | 0.00x | | Foo | 1,150.4 ms | 5.17 ms | 0.28 ms | 1.15x slower | 0.00x | This feature was implemented in #731. Improved CoreRun support BenchmarkDotNet was reporting invalid .NET Core version number when comparing performance using CoreRuns built from dotnet/corefx and dotnet/runtime. Fixed by @adamsitnik in #1580 In #1552 @stanciuadrian has implemented support for all GcMode characteristics for CoreRunToolchain. Previously the settings were just ignored, now they are being translated to corresponding COMPlus_* env vars. Improved CoreRT support CoreRT has moved from https://github.com/dotnet/corert/ to https://github.com/dotnet/runtimelab/tree/feature/NativeAOT and we had to update the default compiler version and nuget feed address. Moreover, there was a bug in CoreRtToolchain which was causing any additional native dependencies to not work. Big thanks to @MichalStrehovsky, @jkotas and @kant2002 for their help and support! #1606, #1643, #1679 Command-line argument support in BenchmarkRunner So far only BenchmarkSwitcher was capable of handling console line arguments. Thanks to @chan18 BenchmarkRunner supports them as well (#1292): public class Program { public static void Main(string[] args) => BenchmarkRunner.Run(typeof(Program).Assembly, args: args); } New API: ManualConfig.CreateMinimumViable ManualConfig.CreateEmpty creates a completely empty config. Without adding a column provider and a logger to the config the users won't see any results being printed. In #1582 @adamsitnik has introduced a new method that creates minimum viable config: IConfig before = ManualConfig.CreateEmpty() .AddColumnProvider(DefaultColumnProviders.Instance) .AddLogger(ConsoleLogger.Default); IConfig after = ManualConfig.CreateMinimumViable(); Benchmarking NuGet packages from custom feeds In #1659 @workgroupengineering added the possibility to indicate the source of the tested nuget package and whether it is a pre-release version. Deterministic benchmark builds BenchmarkDotNet is now always enforcing Deterministic builds (#1489) and Optimizations enabled (#1494) which is a must-have if you are using custom build configurations. MSBuild enforces optimizations only for configurations that are named Release (the comparison is case-insensitive). <ItemGroup Condition=\" '$(Configuration)' == 'X' \"> <PackageReference Include=\"SomeLibThatYouWantToBenchmark\" Version=\"1.0.0\" /> </ItemGroup> <ItemGroup Condition=\" '$(Configuration)' == 'Y' \"> <PackageReference Include=\"SomeLibThatYouWantToBenchmark\" Version=\"2.0.0\" /> </ItemGroup> var config = DefaultConfig.Instance .AddJob(Job.Default.WithCustomBuildConfiguration(\"X\").WithId(\"X\").AsBaseline()) .AddJob(Job.Default.WithCustomBuildConfiguration(\"Y\").WithId(\"Y\")); #1489, #1494 Improved Hardware Counters support BenchmarkDotNet is being used by the .NET Team to ensure that .NET is not regressing. More than three thousand benchmarks (they can be found here) are being executed multiple times a day on multiple hardware configs. Recently, .NET Team started to use InstructionsRetired to help to filter unstable benchmarks that report regressions despite not changing the number of instructions retired. This has exposed few bugs in Hardware Counters support in BenchmarkDotNet, which all got fixed by @adamsitnik in #1547 and #1550. Moreover, we have removed the old PmcDiagnoser and extended EtwProfiler with the hardware counters support. It's just much more accurate and futureproof. For details, please go to #1548. How stable was PmcDiagnoser (same benchmarks run twice in a row on the same machine): Method Runtime InstructionRetired/Op Burgers_0 .NET 5.0 845,746 Burgers_0 .NET Core 2.1 30,154,151 Burgers_0 .NET Framework 4.6.1 4,230,848 Method Runtime InstructionRetired/Op Burgers_0 .NET 5.0 34,154,524 Burgers_0 .NET Core 2.1 246,534,203 Burgers_0 .NET Framework 4.6.1 2,607,686 How stable is EtwProfiler: Method Runtime InstructionRetired/Op Burgers_0 .NET 5.0 3,069,978,261 Burgers_0 .NET Core 2.1 3,676,000,000 Burgers_0 .NET Framework 4.6.1 3,468,866,667 Method Runtime InstructionRetired/Op Burgers_0 .NET 5.0 3,066,810,000 Burgers_0 .NET Core 2.1 3,674,666,667 Burgers_0 .NET Framework 4.6.1 3,468,600,000 Moreover, in #1540 @WojciechNagorski has added the removal of temporary files created by EtwProfiler. Improved Troubleshooting We have the possibility to ask BDN to stop on the first error: --stopOnFirstError true. The problem was when the users had not asked for that, tried to run n benchmarks, all of them failed to build, and BDN was printing the same build error n times. In #1672 @adamsitnik has changed that, so when all the build fails, BDN stops after printing the first error. Moreover, we have also changed the default behavior for the failed builds of the boilerplate code. If the build fails, we don't remove the files. Previously we have required the users to pass --keepFiles to keep them. See #1567 for more details and don't forget about the Troubleshooting docs! Docs and Samples improvements Big thanks to @lukasz-pyrzyk, @fleckert, @MarecekF, @joostas, @michalgalecki, @WojciechNagorski, @MendelMonteiro, @kevinsalimi, @cedric-cf, @YohDeadfall, @jeffhandley and @JohannesDeml who have improved our docs and samples! #1463, #1465, #1508, #1518, #1554, #1568, #1601, #1633, #1645, #1647, #1657, #1675, #1676, #1690. Template improvements Projects created out of our official templates might have been unexpectedly packed when running dotnet pack on the entire solution. In #1584 @kendaleiv has explicitly disabled packing for the template. The template had netcoreapp3.0 TFM hardcoded. This got fixed by @https://github.com/ExceptionCaught in #1630 and #1632. In #1667 @YohDeadfall has changed the default debug type from portable to pdbonly (required by DisassemblyDiagnoser). Bug fixes Very long string [Arguments] and [Params] were causing BenchmarkDotNet to crash. Fixed by @adamsitnik in #1248 and #1545. So far trace file names were containing full benchmark names and arguments. Now if the name is too long, the trace file name is a hash (consistent for multiple runs of the same benchmark). The same goes for passing benchmark name by the host process to the benchmark process via command-line arguments. LangVersion set to a non-numeric value like latest was crashing the build. Fixed by @martincostello in #1420. Windows 10 November 2019 was being recognized as 2018. Fixed by @kapsiR in #1437. Assemblies loaded via streams were not supported. Fixed by @jeremyosterhoudt in #1443. NativeMemoryProfiler was detecting small leaks that were false positives. Fixed by @WojciechNagorski in #1451 and #1600. DisassemblyDiagnoser was crashing on Linux. Fixed by @damageboy in #1459. Target framework moniker was being printed as toolchain name for Full .NET Framework benchmarks. Fixed by @svick in #1471. [ParamsSource] returning IEnumerable<object[]> was not working properly when combined with [Arguments]. Fixed by @adamsitnik in #1478. NullReferenceException in MultimodalDistributionAnalyzer. Fixed by @suslovk in #1488. NotSupportedException was being thrown if there was an encoding mismatch between host and benchmark process. Diagnosed by @ChristophLindemann in #1487, fixed by @lovettchris in #1491. MissingMethodException was being thrown in projects that referenced a newer version of Iced. Fixed by @Symbai in #1497 and in #1502. AppendTargetFrameworkToOutputPath set to false was not supported. Fixed by @adamsitnik in #1563 A locking finalizer could have hanged benchmark process which would just print // AfterAll and never quit. Fixed by @adamsitnik in #1571. To prevent other hangs from happening, a timeout of 250ms was added. If the process does not quit after running the benchmarks and waiting 250ms, it's being force killed. In some cases, JsonExporter was reporting NaN for some of the Statistics. This was breaking non-.NET JSON deserializers. Fixed by @marcnet80 in #1581. UnitType.Size metrics were not using the provided number format. Fixed by @jodydonetti in #1569 and #1618. MaxColumnWidth setting was not used for type names. Fixed by @JohannesDeml in #1609. Current culture was not respected when formatting Ratio column values. Fixed by @JohannesDeml in #1610. BenchmarkDotNet was redirecting Standard Error of the benchmark process, which was causing deadlocks for benchmarks that were writing to it. Fixed by @adamstinik in #1631 DisassemblyDiagnoser was failing to disassemble multiline source code. @YohDeadfall fixed that in #1674. In #1644 @adamstinik has fixed the inconsistency between benchmark filter and hint. Removal of the dotnet global tool In #1006 (0.11.4) we have introduced a new dotnet global tool. By looking at the number of reported bugs we got to the conclusion that the tool has not passed the test of time. Why? Because it was based entirely on dynamic assembly loading which is very hard to get right in .NET and the fact that we support all existing .NET Runtimes (.NET, .NET Core, Mono, CoreRT) made it even harder (if not impossible). We have removed it and the old versions are no longer supported. For more details, please refer to #1572. Milestone details In the v0.13.0 scope, 53 issues were resolved and 94 pull requests were merged. This release includes 111 commits by 37 contributors. Resolved issues (53) #721 Add possibility to customize BaselinedScaledColumn with provided func (assignee: @AndreyAkinshin) #1136 benchmark / beforeEverything fails when running in docker-win #1242 bug JSON Exporter exports NaN for some properties. This fails most JSON parsers (assignee: @marcnet80) #1247 Support benchmarks with very long string arguments (assignee: @adamsitnik) #1288 Fix Hardware Counters diagnoser (assignee: @adamsitnik) #1290 BenchmarkRunner should support parsing console line arguments (assignee: @chan18) #1333 Getting \"Unknown Processor\" Again #1427 NativeMemoryProfiler reports false positive leak (assignee: @WojciechNagorski) #1431 System.IO.FileNotFoundException with EtwProfiler #1433 Benchmarks work in .NET 4.7.2 but not .NET Core 3.1 #1436 Wrong OsBrandString for Windows 10 1909 #1448 NRE in MultimodalDistributionAnalyzer #1452 Setting LangVersion to Latest Causes an Error #1464 DisassemblyDiagnoserConfig.ExportDiff needs better description #1472 Add support of Wasm to Benchmark Dotnet (assignee: @naricc) #1474 docs: Getting started guide #1480 BenchmarkRunner not working from VSTS agent (assignee: @lovettchris) #1487 Benchmarks do not execute (as service process / VSTS agent) on non US systems #1493 Using WithCustomBuildConfiguration leads to always running with RyuJIT Debug (assignee: @adamsitnik) #1495 [GcServer(true)] is ignored with --corerun #1496 System.MissingMethodException: Method not found: 'Iced.Intel.MasmFormatter.get_MasmOptions()'. #1512 Template has hardcoded netcoreapp3.0 TFM (assignee: @ExceptionCaught) #1532 Auto-generated project has invalid XML #1535 Can't benchmark library that targets 'net5.0-windows' framework (assignee: @adamsitnik) #1537 Failed to run benchmarks on .net 5 RC1 and Preview LangVersion #1539 Inconsistency between benchmark filter and hint (assignee: @adamsitnik) #1544 [EtwProfiler] Merge operation failed return code 0x3 (assignee: @adamsitnik) #1546 Sometimes Hardware Counters per Op are reported as NaNs (assignee: @adamsitnik) #1549 InstructionPointerExporter has been broken for a while (assignee: @adamsitnik) #1559 [Docs] Update Console Args doc (assignee: @kevinsalimi) #1561 NativeMemoryProfiler doesn't report allocations in v0.12.1.1432 Nightly (assignee: @WojciechNagorski) #1564 error MSB4086: A numeric comparison was attempted on \"$(LangVersion)\" (assignee: @adamsitnik) #1565 More consistent formatting of results #1566 BDN should not delete temporary build directories for failed builds (assignee: @adamsitnik) #1570 Benchmark runs failing when using .NET 5 RC2 SDK installed via snap (assignee: @adamsitnik) #1576 Missing/misleading version number with corerun #1585 Non-optimized dependency #1591 Wasm Benchmark Runs Failing with Target Framework Error (assignee: @naricc) #1598 VB Net Framework project throws exception from command line tool #1605 CoreRT / NativeAOT version (assignee: @adamsitnik) #1607 Exporter approval tests has recently become unstable (assignee: @marcnet80) #1613 EventPipeProfiler generating invalid SpeedScope files. #1616 BenchmarkDotNet fail in WPF project with .NET 5.0-windows target #1620 NullReferenceException in v0.12.1 #1623 Can I run Full Framework benchmarks without having a Console App? (assignee: @adamsitnik) #1628 Installation uses legacy/archaic dotnetcore 2.1.503 (assignee: @adamsitnik) #1629 Writing to Console.Error in benchmarked code causes a deadlock (assignee: @adamsitnik) #1654 Update for 0.12.2 #1670 dotnet benchmark cli tool errors with .net5.0 assemblies (assignee: @adamsitnik) #1673 Source code provider incorrectly handles multiline source code #1685 Support for SingleFile && SelfContained apps #1692 Bug running wasm benchmarks - Broken Pipe in writeline #1693 Estimate Date for Supporting .NET 6 (assignee: @adamsitnik) Merged pull requests (94) #1097 Allow for Config per method, introduce OS and OSArchitecture filters (by @adamsitnik) #1248 Support very long string as benchmark arguments (by @adamsitnik) #1292 passed args to benchmark runner (by @chan18) #1360 Basic BenchmarkDotNet support for Xamarin (by @jonathanpeppers) #1420 Fix MSB4086 if LangVersion is a keyword (by @martincostello) #1426 Fix typo in log message (by @martincostello) #1429 [xamarin] fix Mono runtime version detection (by @jonathanpeppers) #1434 [samples] UI tweaks to Xamarin samples (by @jonathanpeppers) #1437 Fix wrongly reported os brand string for Windows 10 1909 (by @kapsiR) #1443 Handle assemblies loaded via a stream (by @jeremyosterhoudt) #1451 Fix native memory profiler (by @WojciechNagorski) #1454 always print full information about non-optimized dependencies (by @adamsitnik) #1458 Don't try to parse blank lines (by @TysonMN) #1459 Upgrades ClrMD to a version that will not crash on Linux :( (by @damageboy) #1463 Updated Disassembler docs (by @lukasz-pyrzyk) #1465 Improved doc description of the ExportDiff property (by @lukasz-pyrzyk) #1471 Clearly display names for .Net Framework (by @svick) #1478 ParamsSource returning IEnumerable<object[]> fixes (by @adamsitnik) #1479 net5.0 does not contain \"core\" word but it's a .NET Core moniker (by @adamsitnik) #1483 Add Wasm Tool Chain (by @naricc) #1488 Safe access to CultureInfo (by @suslovk) #1489 enforce Deterministic builds for auto-generated .NET Core projects (by @adamsitnik) #1490 be less strict about verifying the Acknowledgment (by @adamsitnik) #1491 set process output encoding to utf8 so BenchmarkRunnerDotNet works in self hosted VSTS agent. (by @lovettchris) #1492 allow the users to specify Platform via console args (by @adamsitnik) #1494 enforce Optimizations when using Custom Build Configurations (by @adamsitnik) #1497 Update to latest Iced 1.7.0 (by @Symbai) #1498 Pedantic WASM improvements (by @adamsitnik) #1500 Wasm: samples, docs and a bug fix (by @adamsitnik) #1501 Add Custom Runtime Pack option (by @naricc) #1502 Update to latest Iced (by @Symbai) #1503 Update MeasurementsStatistics.cs (by @skynode) #1507 Change mono-config.js format in the Wasm Tool Chain for ICU support (by @naricc) #1508 fixed typo (by @fleckert) #1509 [xamarin] fix for DebugConfig and read-only file system (by @jonathanpeppers) #1518 FactorialWithTailing - incorrect implementation (by @MarecekF) #1523 add .NET 6.0 support, rename .NET Core 5.0 to .NET 5.0 (by @adamsitnik) #1540 Remove unneeded files after etw profiler (by @WojciechNagorski) #1545 Fix Merge operation failed for EtwProfiler (by @adamsitnik) #1547 hardware counters: don't try to exclude non-existing overhead for long running benchmarks (by @adamsitnik) #1548 Remove the old PmcDiagnoser, EtwProfiler is much more accurate (by @adamsitnik) #1550 Bring instruction pointer exporter back to live (by @adamsitnik) #1552 Enable supported GcMode characteristics with corerun (by @stanciuadrian) #1554 Documentation: add --maxWidth description (by @joostas) #1556 Simplify code: remove sort before adding to HashSet (by @stanciuadrian) #1560 Add support for Platform-specific TFMs introduced in .NET 5 (by @adamsitnik) #1563 ensure that the auto-generated project alwas has tfm in the output path (by @adamsitnik) #1567 Dont remove artifacts when build fails (by @adamsitnik) #1568 Update getting-started.md (by @michalgalecki) #1569 Respect size number format in MetricColumn (by @jodydonetti) #1571 Dispose parameters, kill benchmarking process when it hangs after printing the results (by @adamsitnik) #1572 Remove the dotnet global tool (by @adamsitnik) #1573 Don't run the benchmark once per iteration if only the first ivocation lasts longer than IterationTime (by @adamsitnik) #1580 use Environment.Version to determine .NET 5+ versions (by @adamsitnik) #1581 Json exporter fix (by @marcnet80) #1582 introduce ManualConfig.CreateMinimumViable() method (by @adamsitnik) #1584 Prevent dotnet pack from packaging benchmark projects (by @kendaleiv) #1587 Memory Randomization (by @adamsitnik) #1590 Update message to not suggest an obsolete API (by @martincostello) #1592 Add wasmnet50 wasmnet60 monikers (by @naricc) #1600 fix issue #1561 (by @WojciechNagorski) #1601 Update README.md (by @WojciechNagorski) #1606 CoreRT feed and version update (by @adamsitnik) #1609 Fix #1604 - pass SummaryStyle to ParameterInstance.ToDisplayText() (by @JohannesDeml) #1610 Fix add missing culuture info to ToString in RatioStyle (by @JohannesDeml) #1612 Sorting parameter columns with parameter priority (by @JohannesDeml) #1618 Json indentation level fix (by @marcnet80) #1630 Update framework symbol on dotnet new template #1512 (by @ExceptionCaught) #1631 don't redirect Standard Error, as we don't read it and writing to it by benchmark can cause deadlocks (by @adamsitnik) #1632 update console app templating (by @ExceptionCaught) #1633 Update etwprofiler.md (by @MendelMonteiro) #1635 Install local SDK without sudo on Unix (by @am11) #1637 .NET Core 2.1 -> .NET 5.0 (by @adamsitnik) #1643 Remove CoreRT workaround (by @MichalStrehovsky) #1644 Filter hint improvements (by @adamsitnik) #1645 Update Console Args doc #1559 (by @kevinsalimi) #1647 Update API in documentation #1602 (by @kevinsalimi) #1652 Basic snap support (by @adamsitnik) #1657 1655 doc with options obsolete usage of with (by @cedric-cf) #1659 feat: Allowed to indicate the source of nuget package and whether it is a pre-release version. (by @workgroupengineering) #1662 Add tool chain for Netcore Mono AOT. (by @naricc) #1667 Changed default debug type to pdbonly (by @YohDeadfall) #1672 when all builds fail, BDN should stop after printing first error (by @adamsitnik) #1674 Fixed smart pointer for multiline source code (by @YohDeadfall) #1675 Updated disassembler contribution docs (by @YohDeadfall) #1676 Fix a docs typo (by @jeffhandley) #1679 Fix location for NativeAOT publish files (by @kant2002) #1686 Resolve assembly location for SingleFile (by @am11) #1689 Dont redirect standard input for WASM (by @naricc) #1690 Fix change runtime target to Core50 (by @JohannesDeml) #1691 don't remove OS version number from the platform-specifc TFM (by @adamsitnik) #1697 0.13.0 release notes (by @adamsitnik) #1698 Update \"View results\" from \"Getting started\" (by @rstm-sf) #1707 Set ValidateExecutableReferencesMatchSelfContained to false in aotllvm template (by @naricc) Commits (111) 117c37 Postrelease update of v0.12.1 changelog (by @AndreyAkinshin) 742f44 Fix typo (by @AndreyAkinshin) 82b15e Fix MSB4086 if LangVersion is a keyword (#1420) (by @martincostello) 9c0f52 Xamarin Support (#1360) (by @jonathanpeppers) e37c02 Fix typo in log message (#1426) (by @martincostello) ccdf22 [xamarin] fix Mono runtime version detection (#1429) (by @jonathanpeppers) d95493 [samples] UI tweaks to Xamarin samples (#1434) (by @jonathanpeppers) d07604 Fix wrongly reported os brand string for Windows 10 1909 (#1437) (by @kapsiR) 1efd5e Handle assemblies loaded via a stream (#1443) (by @jeremyosterhoudt) 502ad7 Update OsBrandStringHelper.cs (by @AndreyAkinshin) 67971e Update OsBrandStringTests.cs (by @AndreyAkinshin) ceef31 don't try to parse blank lines #1456 (#1458) (by @TysonMN) 9a3469 Upgrades ClrMD to a version that will not crash on Linux :( (#1459) (by @damageboy) bd1c93 Updated Disassembler settings (#1463) (by @lukasz-pyrzyk) 35f50f Improved doc description of the ExportDiff property (#1465) (by @lukasz-pyrzyk) dbbab9 Clearly display names for .Net Framework (#1471) (by @svick) 044591 ParamsSource returning IEnumerable<object[]> fixes (#1478) (by @adamsitnik) 703d54 Safe access to CultureInfo (by @suslovk) a4dd37 Update to latest Iced (#1497) (by @Symbai) 092889 Add Wasm Tool Chain (#1483) (by @naricc) 01455d set process output encoding to utf8 (#1491) (by @lovettchris) fa7da4 net5.0 does not contain \"core\" word but it's a .NET Core moniker (#1479) (by @adamsitnik) 254da4 enforce Optimizations when using Custom Build Configurations (#1494) (by @adamsitnik) 765d52 allow the users to specify Platform via console args (#1492) (by @adamsitnik) 908b09 always print full information about non-optimized dependencies (#1454) (by @adamsitnik) 1ff50a Pedantic WASM improvements (#1498) (by @adamsitnik) d57c4c enforce Deterministic builds for auto-generated .NET Core projects (#1489) (by @adamsitnik) 59080c Support very long string as benchmark arguments (#1248) (by @adamsitnik) 9c5663 Wasm: samples, docs and a bug fix (#1500) (by @adamsitnik) 13ee8b Add Custom Runtime Pack option to WasmToolchain (#1501) (by @naricc) b356ac Update to latest Iced (#1502) (by @Symbai) 797ced fixed typo (#1508) (by @fleckert) ef0ac7 Change mono-config.js format in the Wasm Tool Chain for ICU support (#1507) (by @naricc) eb20d3 Update README (by @AndreyAkinshin) 92474e make MeasurementsStatistics a readonly ref struct (#1503) (by @skynode) 64cc94 [xamarin] fix for DebugConfig and read-only file system (#1509) (by @jonathanpeppers) c8af03 FactorialWithTailing - fix incorrect sample implementation (#1518) (by @MarecekF) c9f158 add .NET 6.0 support, rename .NET Core 5.0 to .NET 5.0 (#1523) (by @adamsitnik) e4d37d Fix native memory profiler (#1451) (by @WojciechNagorski) 10abc4 Remove unneeded files after etw profiler (#1540) (by @WojciechNagorski) e8d085 Documentation: add --maxWidth description (#1554) (by @joostas) c6cd54 Update CorrectionsSuggester.cs (#1556) (by @stanciuadrian) be769f Enable supported GcMode characteristics with corerun (#1552) (by @stanciuadrian) 0a004a Update getting-started.md (#1568) (by @michalgalecki) cd0bda Respect size number format in MetricColumn (#1569), fixes #1565 (by @jodydonetti) 349e90 Introduce RatioStyle, fix #721 (by @AndreyAkinshin) 718031 hardware counters: don't try to exclude non-existing overhead for long runnin... (by @adamsitnik) fbd52c remove the old PmcDiagnoser, EtwProfiler is much more accurate (#1548) (by @adamsitnik) 152414 Bring instruction pointer exporter back to live (#1550) (by @adamsitnik) c6d6fb Fix Merge operation failed for EtwProfiler (#1545) (by @adamsitnik) 769090 Add support for Platform-specific TFMs introduced in .NET 5 (#1560) (by @adamsitnik) 8de321 ensure that the auto-generated project alwas has target framework moniker in ... (by @adamsitnik) 0f9bb3 Dont remove artifacts when build fails (#1567) (by @adamsitnik) b4bda1 Dispose parameters, kill benchmarking process when it hangs after printing th... (by @adamsitnik) c209b1 Remove the dotnet global tool (#1572) (by @adamsitnik) 178b6a Don't run the benchmark once per iteration if only the first ivocation lasts ... (by @adamsitnik) 8b2214 use Environment.Version to determine .NET 5+ versions (#1580) (by @adamsitnik) d5c158 Prevent dotnet pack from packaging benchmark projects (#1584) (by @kendaleiv) 8149c3 Json exporter fix for double.NaN (#1581), fixes #1242 (by @marcnet80) c63fe8 Update message to not suggest an obsolete API (#1590) (by @martincostello) 0de41c Added wasmnet50 wasmnet60 monikers. (#1592) (by @naricc) 992719 fix issue #1561 (#1600) (by @WojciechNagorski) 81c234 Update README.md (#1601) (by @WojciechNagorski) 641ffd Fix #1604 - pass SummaryStyle to ParameterInstance.ToDisplayText() (#1609) (by @JohannesDeml) e72ddf Fix add missing culuture info to ToString in RatioStyle (#1610) (by @JohannesDeml) d17926 Json indentation level fix (#1618) (by @marcnet80) 40f6e5 Update framework symbol on dotnet new template #1512 (#1630) (by @ExceptionCaught) ffc8dd use .AddDiagnoser instead of the obsolete .With in the EtwProfiler doc sample... (by @MendelMonteiro) 5d421c Install local SDK without sudo on Unix (#1635) (by @am11) d71a7e update console app templating (#1632) (by @ExceptionCaught) aef9cb Sorting parameter columns with parameter priority (#1612) (by @JohannesDeml) d5f7b9 Memory Randomization (#1587) (by @adamsitnik) 5b2167 don't redirect Standard Error, as we don't read it and writing to it by bench... (by @adamsitnik) a7af81 introduce ManualConfig.CreateMinimumViable() method (#1582) (by @adamsitnik) 852bb8 .NET Core 2.1 -> .NET 5.0 (#1637) (by @adamsitnik) e01312 Support latest Windows and macOS versions in OsBrandStringHelper (by @AndreyAkinshin) 502dc9 CoreRT feed and version update (#1606) (by @adamsitnik) 9f5d70 Remove CoreRT workaround (#1643) (by @MichalStrehovsky) 6a151f passed args to benchmark runner (#1292) (by @chan18) bf63b3 Update Console Args doc, fixes #1559 (#1645) (by @kevinsalimi) 970d28 Update API in documentation, fixes #1602 (#1647) (by @kevinsalimi) d758f6 Allow for Config per method, introduce OS and OSArchitecture filters (#1097) (by @adamsitnik) b4e2b6 1655 doc with options obsolete usage of with (#1657) (by @cedric-cf) 8c28c8 add basic snap support (#1652) (by @adamsitnik) e1c8cb Filter hint improvements (#1644) (by @adamsitnik) 349f9d feat: Allowed to indicate the source of nuget package and whether it is a pre... (by @workgroupengineering) 4a917d Add tool chain for Netcore Mono AOT. (#1662) (by @naricc) 314a27 [Templates] Changed default debug type to pdbonly (#1667) (by @YohDeadfall) 2616cd Updated disassembler contribution docs (#1675) (by @YohDeadfall) 02b907 Fix a typo (#1676) (by @jeffhandley) b67cfb Fix location for NativeAOT publish files (#1679) (by @kant2002) 63e28c when all builds fail, BDN should stop after printing first error (#1672) (by @adamsitnik) becc13 Dont redirect standard input for WASM (#1689) (by @naricc) b97bf6 Fix change runtime target to Core50 (#1690) (by @JohannesDeml) 0321a3 Fixed smart pointer for multiline source code (#1674) (by @YohDeadfall) 7265c1 Resolve assembly location for SingleFile (#1686) (by @am11) 626dcb don't remove OS version number from the platform-specifc TFM (#1691) (by @adamsitnik) 95608d 0.13.0 release notes (#1697) (by @adamsitnik) 4b5a65 Remove Allocated column from the \"View results\" doc page (#1698) (by @rstm-sf) b0683f Set ValidateExecutableReferencesMatchSelfContained to false in aotllvm templa... (by @naricc) 09afe7 Windows 21H1 support in OsBrandStringHelper (by @AndreyAkinshin) 77b58d Update old changelogs (by @AndreyAkinshin) 2f4b79 Improve AsyncBenchmarksTests.TaskReturningMethodsAreAwaited (by @AndreyAkinshin) a79339 Disable CoreRtToolchain.Core50 in ThreadingDiagnoserTests.GetToolchains on Unix (by @AndreyAkinshin) 18e292 Update README (by @AndreyAkinshin) 09a204 Update BenchmarkDotNet.sln.DotSettings (by @AndreyAkinshin) 85db95 Bump Cake version: 0.37.0->1.1.0 (by @AndreyAkinshin) 5c74d5 Bump docfx version: 2.51->2.57.2 (by @AndreyAkinshin) 2a2c0c Update copyright year (2021) (by @AndreyAkinshin) 396060 Prepare v0.13.0 changelog (by @AndreyAkinshin) 6dcf43 Set library version: 0.13.0 (by @AndreyAkinshin) Contributors (37) Adam Sitnik (@adamsitnik) Adeel Mujahid (@am11) Adrian Stanciu (@stanciuadrian) Andrey Akinshin (@AndreyAkinshin) Andrii Kurdiumov (@kant2002) Cédric Charière Fiedler (@cedric-cf) chan18 (@chan18) Chris Lovett (@lovettchris) damageboy (@damageboy) Dexter (@skynode) Florian Eckert (@fleckert) Jeff Handley (@jeffhandley) jeremyosterhoudt (@jeremyosterhoudt) Jody Donetti (@jodydonetti) Johannes Deml (@JohannesDeml) Jonathan Peppers (@jonathanpeppers) Jonathon Wei (@ExceptionCaught) Justas (@joostas) kapsiR (@kapsiR) Kaywan Salimi (@kevinsalimi) Ken Dale (@kendaleiv) Konstantin (@suslovk) Łukasz Pyrzyk (@lukasz-pyrzyk) marcnet80 (@marcnet80) MarecekF (@MarecekF) Martin Costello (@martincostello) Mendel Monteiro-Beckerman (@MendelMonteiro) Michał Gałecki (@michalgalecki) Michal Strehovský (@MichalStrehovsky) Nathan Ricci (@naricc) Petr Onderka (@svick) Rustam (@rstm-sf) Symbai (@Symbai) Tyson Williams (@TysonMN) Wojciech Nagórski (@WojciechNagorski) workgroupengineering (@workgroupengineering) Yoh Deadfall (@YohDeadfall) Thank you very much! Additional details Date: May 19, 2021 Milestone: v0.13.0 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.0 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.0 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.0 BenchmarkDotNet v0.12.1 Highlights .NET 5 support As you probably know, .NET Core 5 was officially rebranded to .NET 5. The new version of BenchmarkDotNet supports the new runtime after rebranding. #1399 465ebf Perfolizer adoption The internal statistical engine of BenchmarkDotNet became mature enough to be transformed into an independent project. Meet perfolizer — a toolkit for performance analysis! While BenchmarkDotNet focuses on obtaining reliable measurements, perfolizer focuses on the decent analysis of measured data. You still can use all the statistical algorithms from BenchmarkDotNet, but you can also install perfolizer as a standalone NuGet package. You can find more details in the official announcement. #1386 54a061 Cross-platform disassembler Now the DisassemblyDiagnoser is cross-platform! The disassembling logic was also improved, now it handles runtime helper methods and references to method tables properly. Internally, it uses the Iced library for formatting assembly code. Special thanks to @adamsitnik for the implementation and @0xd4d for Iced! #1332 #899 #1316 #1364 294320 EventPipe-based cross-platform profiler Now you can easily profiler your benchmarks on Windows, Linux, and macOS! Just mark your class with the [EventPipeProfiler(...)] attribute and get a .speedscope.json file that you can browse in SpeedScope. Special thanks to @WojciechNagorski for the implementation! #1321 #1315 c648ff New fluent API We continue to improve our API and make it easier for reading and writing. Special thanks to @WojciechNagorski for the implementation! #1273 #1234 640d88 Ref readonly support Now you can use ref readonly in benchmark signatures. Special thanks to @adamsitnik for the implementation! #1389 #1388 9ac777 Cross-platform disassembler Just mark your benchmark class with the [DisassemblyDiagnoser] attribute and you will get the disassembly listings for all the benchmarks. The formatting looks pretty nice thanks to Iced. It works like a charm on Windows, Linux, and macOS. [DisassemblyDiagnoser] public class IntroDisassembly { private int[] field = Enumerable.Range(0, 100).ToArray(); [Benchmark] public int SumLocal() { var local = field; // we use local variable that points to the field int sum = 0; for (int i = 0; i < local.Length; i++) sum += local[i]; return sum; } [Benchmark] public int SumField() { int sum = 0; for (int i = 0; i < field.Length; i++) sum += field[i]; return sum; } } .NET Core 2.1.16 (CoreCLR 4.6.28516.03, CoreFX 4.6.28516.10), X64 RyuJIT ; BenchmarkDotNet.Samples.IntroDisassembly.SumLocal() mov rax,[rcx+8] xor edx,edx xor ecx,ecx mov r8d,[rax+8] test r8d,r8d jle short M00_L01 M00_L00: movsxd r9,ecx add edx,[rax+r9*4+10] inc ecx cmp r8d,ecx jg short M00_L00 M00_L01: mov eax,edx ret ; Total bytes of code 35 .NET Core 2.1.16 (CoreCLR 4.6.28516.03, CoreFX 4.6.28516.10), X64 RyuJIT ; BenchmarkDotNet.Samples.IntroDisassembly.SumField() sub rsp,28 xor eax,eax xor edx,edx mov rcx,[rcx+8] cmp dword ptr [rcx+8],0 jle short M00_L01 M00_L00: mov r8,rcx cmp edx,[r8+8] jae short M00_L02 movsxd r9,edx add eax,[r8+r9*4+10] inc edx cmp [rcx+8],edx jg short M00_L00 M00_L01: add rsp,28 ret M00_L02: call CORINFO_HELP_RNGCHKFAIL int 3 ; Total bytes of code 53 Now we handle runtime helper methods and references to method tables properly. Example: Before: ; MicroBenchmarks.WithCallsAfter.Benchmark(Int32) push rsi sub rsp,20h mov rsi,rcx cmp edx,7FFFFFFFh jne M00_L00 call MicroBenchmarks.WithCallsAfter.Static() mov rcx,rsi call MicroBenchmarks.WithCallsAfter.Instance() mov rcx,rsi call MicroBenchmarks.WithCallsAfter.Recursive() mov rcx,rsi mov rax,qword ptr [rsi] mov rax,qword ptr [rax+40h] call qword ptr [rax+20h] mov rcx,rsi mov edx,1 mov rax,7FF8F4217050h add rsp,20h pop rsi jmp rax M00_L00: mov rcx,offset System_Private_CoreLib+0xa31d48 call coreclr!MetaDataGetDispenser+0x322a0 mov rsi,rax mov ecx,0ACFAh mov rdx,7FF8F42F4680h call coreclr!MetaDataGetDispenser+0x17140 mov rdx,rax mov rcx,rsi call System.InvalidOperationException..ctor(System.String) mov rcx,rsi call coreclr!coreclr_shutdown_2+0x39f0 int 3 add byte ptr [rax],al sbb dword ptr [00007ff9`26284e30],eax add dword ptr [rax+40h],esp add byte ptr [rax],al add byte ptr [rax],al add byte ptr [rax],al add byte ptr [rax-70BC4CCh],ah ; Total bytes of code 157 After: ; BenchmarkDotNet.Samples.WithCallsAfter.Benchmark(Int32) push rsi sub rsp,20 mov rsi,rcx cmp edx,7FFFFFFF jne M00_L00 call BenchmarkDotNet.Samples.WithCallsAfter.Static() mov rcx,rsi call BenchmarkDotNet.Samples.WithCallsAfter.Instance() mov rcx,rsi call BenchmarkDotNet.Samples.WithCallsAfter.Recursive() mov rcx,rsi mov rax,[rsi] mov rax,[rax+40] call qword ptr [rax+20] mov rcx,rsi mov edx,1 mov rax BenchmarkDotNet.Samples.WithCallsAfter.Benchmark(Boolean) add rsp,20 pop rsi jmp rax M00_L00: mov rcx MT_System.InvalidOperationException call CORINFO_HELP_NEWSFAST mov rsi,rax mov ecx,12D mov rdx,7FF954FF83F0 call CORINFO_HELP_STRCNS mov rdx,rax mov rcx,rsi call System.InvalidOperationException..ctor(System.String) mov rcx,rsi call CORINFO_HELP_THROW int 3 ; Total bytes of code 134 See also: Cross-runtime .NET disassembly with BenchmarkDotNet. Special thanks to @adamsitnik for the implementation and @0xd4d for Iced! EventPipe-based cross-platform profiler Now you can easily profiler your benchmarks on Windows, Linux, and macOS! If you want to use the new profiler, you should just mark your benchmark class with the [EventPipeProfiler(...)] attribute: [EventPipeProfiler(EventPipeProfile.CpuSampling)] // <-- Enables new profiler public class IntroEventPipeProfiler { [Benchmark] public void Sleep() => Thread.Sleep(2000); } Once the benchmark run is finished, you get a .speedscope.json file that can be opened in SpeedScope: The new profiler supports several modes: CpuSampling - Useful for tracking CPU usage and general .NET runtime information. This is the default option. GcVerbose - Tracks GC collections and samples object allocations. GcCollect - Tracks GC collections only at very low overhead. Jit - Logging when Just in time (JIT) compilation occurs. Logging of the internal workings of the Just In Time compiler. This is fairly verbose. It details decisions about interesting optimization (like inlining and tail call) Please see Wojciech Nagórski's blog post for all the details. Special thanks to @WojciechNagorski for the implementation! New fluent API We continue to improve our API and make it easier for reading and writing. The old API is still existing, but it is marked as obsolete and will be removed in the further library versions. The most significant changes: Changes in Job configuration Changes in IConfig/ManualConfig Full fluent API Special thanks to @WojciechNagorski for the implementation! Ref readonly support Now you can use ref readonly in benchmark signatures. Here is an example: public class RefReadonlyBenchmark { static readonly int[] array = { 1 }; [Benchmark] public ref readonly int RefReadonly() => ref RefReadonlyMethod(); static ref readonly int RefReadonlyMethod() => ref array[0]; } Special thanks to @adamsitnik for the implementation! Milestone details In the v0.12.1 scope, 31 issues were resolved and 42 pull requests were merged. This release includes 85 commits by 19 contributors. Resolved issues (31) #641 RPlotExporter hanging (assignee: @m-mccormick) #899 Tiered compilation and disassembler (assignee: @adamsitnik) #1023 Out of process benchmarks fail with ASP.NET Core SDK reference #1211 Binding Redirect Issues When Using Xml Serializers #1234 Strong type fluent API proposal (assignee: @WojciechNagorski) #1238 RunAllJoined Causing Exception (assignee: @gsomix) #1262 Params attribute doesn`t work in F# if you specify more than one enum value in constructor (assignee: @gsomix) #1295 Custom format/culture for report output values (for CSV, and maybe HTML, MD) #1305 Copy UserSecrets from benchmark project #1311 Spelling nit (assignee: @AndreyAkinshin) #1312 Add an option to pass environment variables to the default job #1315 Implement cross platform EventPipeProfiler diagnoser (assignee: @WojciechNagorski) #1316 Implement Unix Disassembler for .NET Core (assignee: @adamsitnik) #1318 use of NugetReference[] causes System.MissingMethodException: No parameterless constructor defined for this object. (assignee: @adamsitnik) #1323 DisassemblyDiagnoser index outside array bounds (assignee: @AndreyAkinshin) #1325 Surface native code size benchmarked code (assignee: @adamsitnik) #1326 BDN does not build using dotnet sdk from the command line in Linux #1339 Generated code and StyleCop.Analyzers (assignee: @adamsitnik) #1348 Different display text for arrays depending on a value source (assignee: @YohDeadfall) #1350 Warn the user if command line arguments were not passed to the BenchmarkSwitcher #1353 Show Length when param type is an array #1361 SimpleJobAttribute with RunStrategy and RuntimeMoniker #1363 Wrong assembly binding redirects for Microsoft.Data.SqlClient.resources ; using in Netcore3.0 project (assignee: @adamsitnik) #1364 Bug: Benchmark class with Console.WriteLine(1) fails for DisassemblyDiagnoser with 'Sequence contains no matching element' (assignee: @adamsitnik) #1369 Parameter column doesn't seem to respect culture info (assignee: @Tyrrrz) #1379 Unix CI builds are red (assignee: @AndreyAkinshin) #1385 Make BaselineCustomColumn.GetValue public #1388 'ref readonly' return is not supported (assignee: @adamsitnik) #1396 MacOS Azure Pipeline build is broken (assignee: @AndreyAkinshin) #1413 Plot with only one \"default\" Job (assignee: @AndreyAkinshin) #1416 EventPipeProfiler Documentation (assignee: @WojciechNagorski) Merged pull requests (42) #1258 Task add style cope and fxcop analyzers (by @WojciechNagorski) #1263 Configuration compatibility validation (by @gsomix) #1266 Add EnumParam preserving type information (by @gsomix) #1273 New fluent API (by @WojciechNagorski) #1287 EdPeltChangePointDetector improvements (by @jeanbern) #1300 Update link of \" official benchmarking guide\" to use the new recommended link (by @eriawan) #1301 Improve BenchmarkDotNet.Templates (by @AndreyAkinshin) #1302 CultureInfo Refactoring (by @AndreyAkinshin) #1307 Fix project file order (by @vilinski) #1309 Copy UserSecrets from benchmark project (by @kant2002) #1313 add possibility to specify env vars via console line arguments (by @adamsitnik) #1321 The EventPipeProfiler cross-platform profiler (by @WojciechNagorski) #1327 Add package-refs to reference assemblies for linux build (by @damageboy) #1329 Show information about docker (by @WojciechNagorski) #1331 Use 24-hour time in joined summary file name (by @jroessel) #1332 Improved and Cross platform disassembler (by @adamsitnik) #1335 Attribute improvements (by @WojciechNagorski) #1340 Improvement of csproj finding (by @WojciechNagorski) #1349 Fixed display text for array parameters and arguments (by @YohDeadfall) #1357 add the header at the top of the generated file to avoid static analysis tools from analyzing it, (by @adamsitnik) #1359 Warn if command line arguments were not passed to the BenchmarkSwitcher (by @suslovk) #1365 Use DirtyAssemblyResolveHelper only for Full .NET Framework (by @adamsitnik) #1366 add missing SimpleJobAttribute ctor (by @adamsitnik) #1367 Await non-generic ValueTask returning method (by @mayuki) #1372 Use CultureInfo when formatting parameter values (by @Tyrrrz) #1373 fixes #641 (by @m-mccormick) #1375 don't require the JitDiagnosers (TailCall & Inlining) to run benchmarks once again just to gather JIT info, the overhead is very small (by @adamsitnik) #1376 update TraceEvent to 2.0.49 to get TailCalls working again (by @adamsitnik) #1380 Bump Cake version from 0.30.0 to 0.37.0, fix #1379 (by @AndreyAkinshin) #1381 Minor event pipe profiler improvements (by @adamsitnik) #1384 Fix build after styleCop (by @WojciechNagorski) #1386 Switch to perfolizer (by @AndreyAkinshin) #1387 Make BaselineCustomColumn expose \"GetValue\" as a public API (by @damageboy) #1389 Ref readonly support (by @adamsitnik) #1394 Align homepage example with README (by @dahlbyk) #1397 Bump macOS Azure Pipeline vmImage to 10.14, fix #1396 (by @AndreyAkinshin) #1399 React to .NET 5 branding changes (by @jkotas) #1407 Improve warnings for small operations number (by @CodeFuller) #1410 Updating Document - Fixing a small grammar mistake (by @abhinavgalodha) #1417 Fix --profiler option description. (by @WojciechNagorski) #1418 EventPipeProfiler documentation (by @WojciechNagorski) #1419 Small fix in EventPipeProfiler documentation (by @WojciechNagorski) Commits (85) 396d4b #1262: Add EnumParam preserving type information (by @gsomix) 718b77 #1262: Add tests (by @gsomix) 33ec90 EdPeltChangePointDetector improvements (by @jeanbern) 7e3efc Postrelease update of v0.12.0 changelog (by @AndreyAkinshin) 8677b0 Update css in documentation (by @AndreyAkinshin) 919b7f Fix link to IntroThreadingDiagnoser in diagnoser.md (by @AndreyAkinshin) 4d15ea Update README.md (by @AndreyAkinshin) f2d081 Update link of \" official benchmarking guide\" to use the new recommended link... (by @eriawan) 05df0e Documentation: update article about command-line tool (by @AndreyAkinshin) d69505 Improve BenchmarkDotNet.Templates (#1301) (by @AndreyAkinshin) e23755 Speed up some integration tests (by @AndreyAkinshin) 3d96bf Update NuGet package descriptions (by @AndreyAkinshin) 351dae Update README.md (by @AndreyAkinshin) 5f07f4 Add Windows 10 brand string for 19H1 (by @AndreyAkinshin) fd92ff Update README.md (by @AndreyAkinshin) 5af5c5 Update README.md (by @AndreyAkinshin) 1b923f Fix project file order (#1307) (by @vilinski) 57b01f Copy UserSecrets from benchmark project (#1309) (by @kant2002) 2415fd Fix some typos, fix #1311 (by @AndreyAkinshin) e92d6d add possibility to specify env vars via console line arguments (#1313) (by @adamsitnik) b7054c WithNuGet should accept NuGetReferenceList, not IReadOnlyCollection<NuGetRefe... (by @adamsitnik) bb437b Remove curly braces for single statements (by @AndreyAkinshin) 76c675 Improve code readability (by @AndreyAkinshin) 8486e1 Merge pull request #1287 from jeanbern/patch-1 (by @AndreyAkinshin) d6bf40 Update README.md (by @AndreyAkinshin) 728c40 Support empty lines in disassembler/GetSmartPrefix, fix #1323 (by @AndreyAkinshin) 0c48c2 CultureInfo Refactoring (#1302) (by @AndreyAkinshin) 099550 Switch to using ms ref aseemblies for build (#1327) (by @damageboy) 55842b Merge pull request #1266 from gsomix/feature/1262-fsharp-enums (by @AndreyAkinshin) 35d358 Show information about docker (#1329) (by @WojciechNagorski) b6283c Use 24-hour time in joined summary file name (#1331) (by @jroessel) 640d88 New fluent API (#1273), fixes #1234 (by @WojciechNagorski) a3f76b Update README (by @AndreyAkinshin) 4a9697 Update copyright year (by @AndreyAkinshin) 5e7f01 add the header at the top of the generated file to avoid s... (by @adamsitnik) 07b512 Await non-generic ValueTask returning method (#1367) (by @mayuki) 479177 Display array length for array parameters and arguments (#1349), fixes #1348 ... (by @YohDeadfall) 3b8d2c Warn if command line arguments were not passed to the BenchmarkSwitcher (#135... (by @suslovk) 87d85a Use CultureInfo when formatting parameter values (#1372) (by @Tyrrrz) 310b5a add missing SimpleJobAttribute ctor, fixes #1361 (#1366) (by @adamsitnik) 6a1458 change the way RPlotExporter reads the R script output, fixes #641 (#1373) (by @m-mccormick) ff4c3d Attribute improvements (#1335) (by @WojciechNagorski) 29eafb Improvement of csproj finding (#1340) (by @WojciechNagorski) be2168 Use DirtyAssemblyResolveHelper only for Full .NET Framework (#1365) (by @adamsitnik) 664ab6 update TraceEvent to 2.0.49 to get TailCalls working again (#1376) (by @adamsitnik) b788bc don't require the JitDiagnosers (TailCall & Inlining) to run benchmarks once ... (by @adamsitnik) 8ad2a9 Bump Cake version from 0.30.0 to 0.37.0, fix #1379 (#1380) (by @AndreyAkinshin) 474047 Task add style cope and fxcop analyzers (#1258) (by @WojciechNagorski) c648ff The EventPipeProfiler cross-platform profiler (#1321) (by @WojciechNagorski) 19169a Add brand strings for latest Windows versions (by @AndreyAkinshin) 532f84 Update README (by @AndreyAkinshin) 3defd7 Minor event pipe profiler improvements (#1381) (by @adamsitnik) 294320 Improved and Cross platform disassembler (#1332) (by @adamsitnik) 1d63d6 Fix build after styleCop (#1384) (by @WojciechNagorski) b3ba08 Make BaselineCustomColumn expose \"GetValue\" as a public API (#1387) (by @damageboy) 54a061 Switch to perfolizer (by @AndreyAkinshin) 9ac777 Ref readonly support (#1389) (by @adamsitnik) c3286f Update CodeAnnotations.cs (by @AndreyAkinshin) 3223c9 Code cleanup (by @AndreyAkinshin) c19e54 Implement configurations compatibility validation (#1263), Closes #1238 (by @gsomix) df434e Align homepage example with README (#1394) (by @dahlbyk) 9a251a Bump macOS Azure Pipeline vmImage to 10.14, fix #1396 (#1397) (by @AndreyAkinshin) 465ebf React to .NET 5 branding changes (#1399) (by @jkotas) 6cca72 Updating a small grammar mistake (#1410) (by @abhinavgalodha) 27b32e Improve warnings for small operations number (#1407) (by @CodeFuller) 2d365b Fix --profiler option description. (#1417) (by @WojciechNagorski) 7902cd Add macOS Catalina support in OsBrandStringHelper (by @AndreyAkinshin) fd4c32 Update README (by @AndreyAkinshin) 6e13ba Resolving JobId in DefaultCharacteristicPresenter, fix #1413 (by @AndreyAkinshin) 35ebd2 Better job id generation in SimpleJobAttribute (by @AndreyAkinshin) bf4778 Use ASCII mode for Measurement presentation in terminal (by @AndreyAkinshin) f6b81f Display result path in RPlotExporter (by @AndreyAkinshin) 30b269 Disable plot printing in BuildPlots.R (by @AndreyAkinshin) 27887d Disable Rplots.pdf generation in BuildPlots.R (by @AndreyAkinshin) 338e40 Specify uid for how-to-run.md (by @AndreyAkinshin) f6dcd3 Add BenchmarkDotNet.Annotations in API documentation (by @AndreyAkinshin) b503fd Bump DocFX version from 2.46 to 2.51 (by @AndreyAkinshin) f457e7 Prepare v0.12.1 changelog (by @AndreyAkinshin) 53d090 Fix documentation.md (by @AndreyAkinshin) e72897 Add v0.12.1 highlights (by @AndreyAkinshin) 2de040 Bump perfolizer version from 0.2.0 to 0.2.1 (by @AndreyAkinshin) 76a070 EventPipeProfiler documentation (#1418) (by @WojciechNagorski) 928fb1 EventPipeProfiler doc improvements (#1419) (by @WojciechNagorski) 12798e Update documentation (by @AndreyAkinshin) 384d47 Set library version: 0.12.1 (by @AndreyAkinshin) Contributors (19) Abhinav Galodha (@abhinavgalodha) Adam Sitnik (@adamsitnik) Andreas Vilinski (@vilinski) Andrey Akinshin (@AndreyAkinshin) Andrii Kurdiumov (@kant2002) CodeFuller (@CodeFuller) damageboy (@damageboy) Eriawan Kusumawardhono (@eriawan) Evgeniy Andreev (@gsomix) Jan Kotas (@jkotas) Jean-Bernard Pellerin (@jeanbern) Johannes Rössel [yWorks] (@jroessel) Keith Dahlby (@dahlbyk) Konstantin (@suslovk) Matt McCormick (@m-mccormick) Mayuki Sawatari (@mayuki) Oleksii Holub (@Tyrrrz) Wojciech Nagórski (@WojciechNagorski) Yoh Deadfall (@YohDeadfall) Thank you very much! Additional details Date: April 6, 2020 Milestone: v0.12.1 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.12.1 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.12.1 https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.12.1 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.12.1 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.12.1 BenchmarkDotNet v0.12.0 It's been several months since our last release, but we have been working hard and have some new features for you! Highlights Features and major improvements Advanced multiple target frameworks support Now BenchmarkDotNet supports .NET Framework 4.8, .NET Core 3.1, and .NET Core 5.0. Also, we reworked our API that allows targeting several runtimes from the same config: the new API is more consistent, flexible, and powerful. For example, if you want to execute your benchmarking using .NET Framework 4.8 and .NET Core 3.1, you can use the SimpleJob(RuntimeMoniker.Net48), [SimpleJob(RuntimeMoniker.NetCoreApp31)] attributes or Job.Default.With(ClrRuntime.Net48), Job.Default.With(CoreRuntime.Core31) jobs in a manual config. You can find more details below. #1188, #1186, #1236 Official templates for BenchmarkDotNet-based projects With the help of the BenchmarkDotNet.Templates NuGet package, you can easily create new projects from the command line via dotnet new benchmark. This command has a lot of useful options, so you can customize your new project as you want. #1044 New NativeMemoryProfiler NativeMemoryProfiler measure the native memory traffic and adds the extra columns Allocated native memory and Native memory leak to the summary table. Internally, it uses EtwProfiler to profile the code using ETW. #457, #1131, #1208, #1214, #1218, #1219 New ThreadingDiagnoser ThreadingDiagnoser also adds two extra columns to the summary table: Completed Work Items (the number of work items that have been processed in ThreadPool per single operation) and Lock Contentions (the number of times there was contention upon trying to take a Monitor's lock per single operation). Internally, it uses new APIs exposed in .NET Core 3.0. #1154, #1227 Improved MemoryDiagnoser Now MemoryDiagnoser includes memory allocated by all threads that were live during benchmark execution: a new GC API was exposed in .NET Core 3.0 preview6+. It allows to get the number of allocated bytes for all threads. #1155, #1153, #723 LINQPad 6 support Now both LINQPad 5 and LINQPad 6 are supported! #1241, #1245 Fast documentation search We continue to improve the usability of our documentation. In this release, we improved the search experience in the documentation: now it works almost instantly with the help of Algolia engine! #1148, #1158 Minor summary and exporter improvements Improved presentation of the current architecture in the environment information In the previous version of BenchmarkDotNet, the reports always contained \"64bit\" or \"32bit\" which did not tell if it was ARM or not. Now it prints the full architecture name (x64, x86, ARM, or ARM64). For example, instead of .NET Framework 4.8 (4.8.3815.0), 64bit RyuJIT you will get .NET Framework 4.8 (4.8.3815.0), X64 RyuJIT or .NET Framework 4.8 (4.8.3815.0), ARM64 RyuJIT. #1213 Simplified reports for Full .NET Framework version Previous version: .NET Framework 4.7.2 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.3324.0. Current version: .NET Framework 4.7.2 (4.7.3362.0), 64bit RyuJIT. #1114, #1111 More reliable CPU info on Windows We added a workaround to for a bug in wmic that uses \\r\\r\\n as a line separator. #1144, #1145 Better naming for generated plots When [RPlotExporter] is used, BenchmarkDotNet generates a lot of useful plots in the BenchmarkDotNet.Artifacts folder. The naming of the plot files was improved: benchmarks without Params doesn't include a double dash (--) in their names anymore. 1183, 1212 Better density plot precision The previous version of BenchmarkDotNet used the rule-of-thumb bandwidth selector in RPlotExporter density plots. It was fine for unimodal distributions, but sometimes it produced misleading plots for multimodal distributions. Now, RPlotExporter uses the Sheather&Jones bandwidth selector that significantly improves the presentation of the density plots for complex distributions. 58fde64 Better alignment in HtmlExporter Now BenchmarkDotNet aligns the content exported by HtmlExporter to the right. #1189 dfa074 Better precision calculation in SummaryTable 4e9eb43 Better summary analysis BenchmarkDotNet warns the user when benchmark baseline value is too close to zero and the columns derived from BaselineCustomColumn cannot be computed. #1161, #600 Make log file datetime format 24-hour #1149 Improve AskUser prompt message The error messages will surround * by quotes on Linux and macOS. #1147 Minor API improvements ED-PELT algorithm for changepoint detection is now available You can find details in this blog post. f89091 Improved OutlierMode API BenchmarkDotNet performs measurement postprocessing that may remove some of the outlier values (it can be useful to remove upper outliers that we get because of the natural CPU noise). In the previous version, naming for the OutlierMode values was pretty confusing: None/OnlyUpper/OnlyLower/All. Now, these values were renamed to DontRemove/RemoveUpper/RemoveLower/RemoveAll. For example, if you want to remove all the outliers, you can annotate your benchmark with the [Outliers(OutlierMode.RemoveAll)] attribute. The old names still exist (to make sure that the changes are backward compatible), but they are marked as obsolete, and they will be removed in the future versions of the library. #1199, 0e4b8e Add the possibility to pass Config to BenchmarkSwitcher.RunAll and RunAllJoined #1194, ae23bd Improved command line experience When user uses --packages $path, the $path will be sent to the dotnet build command as well. 1187 Extend the list of supported power plans. Now it supports \"ultimate\", \"balanced\", and \"power saver\" plans. #1132, #1139 Make it possible to not enforce power plan on Windows. 1578c5c Guid support in benchmark arguments Now you can use Guid instances as benchmark arguments. 04ec20b Make ArgumentsSource support IEnumerable<object[]> for benchmarks accepting a single argument to mimic MemberData behaviour. ec296dc Make FullNameProvider public So it can be reused by the dotnet/performance repository. 6d71308 Extend Summary with LogFilePath #1135, 6e6559 Allow namespace filtering for InliningDiagnoser #1106, #1130 Option to configure MaxParameterColumnWidth #1269, 4ec888 Other improvements Misc improvements in the documentation #1175, #1173, #1180, #1203, #1204, #1206, #1209, #1219, #1225, #1279 Copy PreserveCompilationContext MSBuild setting from the project that defines benchmarks #1152, 063d1a Add System.Buffers.ArrayPoolEventSource to the list of default .NET Providers of EtwProfiler #1179, a106b1 Consume CoreRT from the new NuGet feed Because CoreRT no longer publishes to MyGet. #1129 Breaking changes: The [ClrJob], [CoreJob] and [CoreRtJob] attributes got obsoleted and replaced by a [SimpleJob] which requires the user to provide target framework moniker in an explicit way. (See the \"Advanced multiple target frameworks support\" section for details.) #1188, #1182, #1115, #1056, #993, The old InProcessToolchain is now obsolete. It's recommended to use InProcessEmitToolchain. If you want to use the old one on purpose, you have to use InProcessNoEmitToolchain. #1123 Bug fixes: Invalid arg passing in StreamLogger constructor. The append arg was not passed to the StreamWriter .ctor. #1185 Improve the output path of .etl files produced by EtwProfiler. EtwProfiler was throwing NRE for users who were using [ClrJob] and [CoreJob] attributes. #1156, #1072 Flush custom loggers at the end of benchmark session. #1134 Make ids for tag columns unique - when using multiple TagColumns only one TagColumn was printed in the results. #1146 Advanced multiple target frameworks support Now BenchmarkDotNet supports .NET Framework 4.8, .NET Core 3.1, and .NET Core 5.0. Also, we reworked our API that allows targeting several runtimes from the same config: the new API is more consistent, flexible, and powerful. For example, if you want to execute your benchmarking using .NET Framework 4.8 and .NET Core 3.1, you can use the SimpleJob(RuntimeMoniker.Net48), [SimpleJob(RuntimeMoniker.NetCoreApp31)] attributes or Job.Default.With(ClrRuntime.Net48), Job.Default.With(CoreRuntime.Core31) jobs in a manual config. Now let's discuss how to use it in detail. If you want to test multiple frameworks, your project file MUST target all of them and you MUST install the corresponding SDKs: <TargetFrameworks>netcoreapp3.0;netcoreapp2.1;net48</TargetFrameworks> If you run your benchmarks without specifying any custom settings, BenchmarkDotNet is going to run the benchmarks using the same framework as the host process (it corresponds to RuntimeMoniker.HostProcess): dotnet run -c Release -f netcoreapp2.1 # is going to run the benchmarks using .NET Core 2.1 dotnet run -c Release -f netcoreapp3.0 # is going to run the benchmarks using .NET Core 3.0 dotnet run -c Release -f net48 # is going to run the benchmarks using .NET 4.8 mono $pathToExe # is going to run the benchmarks using Mono from your PATH To run the benchmarks for multiple runtimes with a single command from the command line, you need to specify the runtime moniker names via --runtimes|-r console argument: dotnet run -c Release -f netcoreapp2.1 --runtimes netcoreapp2.1 netcoreapp3.0 # is going to run the benchmarks using .NET Core 2.1 and .NET Core 3.0 dotnet run -c Release -f netcoreapp2.1 --runtimes netcoreapp2.1 net48 # is going to run the benchmarks using .NET Core 2.1 and .NET 4.8 What is going to happen if you provide multiple Full .NET Framework monikers? Let's say: dotnet run -c Release -f net461 net472 net48 Full .NET Framework always runs every .NET executable using the latest .NET Framework available on a given machine. If you try to run the benchmarks for a few .NET TFMs, they are all going to be executed using the latest .NET Framework from your machine. The only difference is that they are all going to have different features enabled depending on the target version they were compiled for. You can read more about this here and here. This is .NET Framework behavior which can not be controlled by BenchmarkDotNet or any other tool. Note: Console arguments support works only if you pass the args to BenchmarkSwitcher: class Program { static void Main(string[] args) => BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args); // crucial to make it work } You can achieve the same thing using [SimpleJobAttribute]: using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [SimpleJob(RuntimeMoniker.Net48)] [SimpleJob(RuntimeMoniker.Mono)] [SimpleJob(RuntimeMoniker.NetCoreApp21)] [SimpleJob(RuntimeMoniker.NetCoreApp30)] public class TheClassWithBenchmarks Or using a custom config: using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { class Program { static void Main(string[] args) { var config = DefaultConfig.Instance .With(Job.Default.With(CoreRuntime.Core21)) .With(Job.Default.With(CoreRuntime.Core30)) .With(Job.Default.With(ClrRuntime.Net48)) .With(Job.Default.With(MonoRuntime.Default)); BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args, config); } } } The recommended way of running the benchmarks for multiple runtimes is to use the --runtimes console line argument. By using the console line argument, you don't need to edit the source code anytime you want to change the list of runtimes. Moreover, if you share the source code of the benchmark, other people can run it even if they don't have the exact same framework version installed. Official templates for BenchmarkDotNet-based projects Since v0.12.0, BenchmarkDotNet provides project templates to setup your benchmarks easily. The template exists for each major .NET language (C#, F# and VB) with equivalent features and structure. The templates require the .NET Core SDK. Once installed, run the following command to install the templates: dotnet new -i BenchmarkDotNet.Templates If you want to uninstall all BenchmarkDotNet templates: dotnet new -u BenchmarkDotNet.Templates The template is a NuGet package distributed over nuget.org: BenchmarkDotNet.Templates. To create a new C# benchmark library project from the template, run: dotnet new benchmark If you'd like to create F# or VB project, you can specify project language with -lang option: dotnet new benchmark -lang F# dotnet new benchmark -lang VB The template projects have five additional options - all of them are optional. By default, a class library project targeting netstandard2.0 is created. You can specify -f or --frameworks to change target to one or more frameworks: dotnet new benchmark -f netstandard2.0;net472 The option --console-app creates a console app project targeting netcoreapp3.0 with an entry point: dotnet new benchmark --console-app This lets you run the benchmarks from a console (dotnet run) or from your favorite IDE. The option -f or --frameworks will be ignored when --console-app is set. The option -b or --benchmarkName sets the name of the benchmark class: dotnet new benchmark -b Md5VsSha256 BenchmarkDotNet lets you create a dedicated configuration class (see Configs) to customize the execution of your benchmarks. To create a benchmark project with a configuration class, use the option -c or --config: dotnet new benchmark -c The option --no-restore if specified, skips the automatic NuGet restore after the project is created: dotnet new benchmark --no-restore Use the -h or --help option to display all possible arguments with a description and the default values: dotnet new benchmark --help The version of the template NuGet package is synced with the BenchmarkDotNet package. For instance, the template version 0.12.0 is referencing BenchmarkDotnet 0.12.0 - there is no floating version behavior. For more info about the dotnet new CLI, please read the documentation. New NativeMemoryProfiler NativeMemoryProfiler measure the native memory traffic and adds the extra columns Allocated native memory and Native memory leak to the summary table. Internally, it uses EtwProfiler to profile the code using ETW. Consider the following benchmark: [ShortRunJob] [NativeMemoryProfiler] [MemoryDiagnoser] public class IntroNativeMemory { [Benchmark] public void BitmapWithLeaks() { var flag = new Bitmap(200, 100); var graphics = Graphics.FromImage(flag); var blackPen = new Pen(Color.Black, 3); graphics.DrawLine(blackPen, 100, 100, 500, 100); } [Benchmark] public void Bitmap() { using (var flag = new Bitmap(200, 100)) { using (var graphics = Graphics.FromImage(flag)) { using (var blackPen = new Pen(Color.Black, 3)) { graphics.DrawLine(blackPen, 100, 100, 500, 100); } } } } private const int Size = 20; // Greater value could cause System.OutOfMemoryException for test with memory leaks. private int ArraySize = Size * Marshal.SizeOf(typeof(int)); [Benchmark] public unsafe void AllocHGlobal() { IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize); Span<byte> unmanaged = new Span<byte>(unmanagedHandle.ToPointer(), ArraySize); Marshal.FreeHGlobal(unmanagedHandle); } [Benchmark] public unsafe void AllocHGlobalWithLeaks() { IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize); Span<byte> unmanaged = new Span<byte>(unmanagedHandle.ToPointer(), ArraySize); } } It will produce the summary table like this one: Method Mean Error StdDev Gen 0 Gen 1 Gen 2 Allocated Allocated native memory Native memory leak BitmapWithLeaks 73,456.43 ns 22,498.10 ns 1,233.197 ns - - - 177 B 13183 B 11615 B Bitmap 91,590.08 ns 101,468.12 ns 5,561.810 ns - - - 180 B 12624 B - AllocHGlobal 79.91 ns 43.93 ns 2.408 ns - - - - 80 B - AllocHGlobalWithLeaks 103.50 ns 153.21 ns 8.398 ns - - - - 80 B 80 B As you can see, we have two additional columns Allocated native memory and Native memory leak that contain some very useful numbers! New ThreadingDiagnoser ThreadingDiagnoser also adds two extra columns to the summary table: Completed Work Items: The number of work items that have been processed in ThreadPool (per single operation) Lock Contentions: The number of times there was contention upon trying to take a Monitor's lock (per single operation) Internally, it uses new APIs exposed in .NET Core 3.0. It can be activated with the help of the [ThreadingDiagnoser] attribute: [ThreadingDiagnoser] public class IntroThreadingDiagnoser { [Benchmark] public void CompleteOneWorkItem() { ManualResetEvent done = new ManualResetEvent(initialState: false); ThreadPool.QueueUserWorkItem(m => (m as ManualResetEvent).Set(), done); done.WaitOne(); } } The above example will print a summary table like this one: Method Mean StdDev Median Completed Work Items Lock Contentions CompleteOneWorkItem 8,073.5519 ns 69.7261 ns 8,111.6074 ns 1.0000 - LINQPad 6 support Now both LINQPad 5 and LINQPad 6 are supported: Fast documentation search We continue to improve the usability of our documentation. In this release, we improved the search experience in the documentation: now it works almost instantly with the help of Algolia engine! That's how it looks: Milestone details In the v0.12.0 scope, 44 issues were resolved and 56 pull requests were merged. This release includes 110 commits by 25 contributors. Resolved issues (44) #198 [Feature request] No logger for benchmark run? (assignee: @CodeTherapist) #311 How to debug benchmarks that fail with exception on file system access operations (assignee: @adamsitnik) #457 Track Native Memory Allocations and more informations with our ETW Memory Diagnoser #600 Scaling issue #723 MemoryDiagnoser should include memory allocated by all Threads that were live during benchmark execution (assignee: @adamsitnik) #995 Running benchmark fails when targeting netcoreapp2.2 (assignee: @adamsitnik) #1028 Add new template for \"dotnet new benchmark\" (assignee: @CodeTherapist) #1072 EtwProfiler exports trace file only for a single runtime when Runtimes are controlled via attributes (assignee: @adamsitnik) #1106 Allow user defined namespace filter for InliningDiagnoser #1111 Change the format of printed Full .NET Framework Version (assignee: @adamsitnik) #1115 Running using dotnet benchmark uses wrong core runtime #1132 The power management feature extension #1134 StreamLogger is not properly flushed on shutdown (assignee: @AndreyAkinshin) #1135 The default file logger and summary title are out of sync (assignee: @adamsitnik) #1137 [Discussion] Improve search experience in the documentation #1144 Incorrect CPU info for .NET Core applications #1146 Only the first of multiple custom columns is included in the summary table (assignee: @AndreyAkinshin) #1147 Update benchmark switcher instructions to work on Linux (assignee: @AndreyAkinshin) #1149 Ambiguous hour component in log file name timestamp (assignee: @AndreyAkinshin) #1152 Failed to test Roslyn. (assignee: @adamsitnik) #1153 Use GC.GetTotalAllocatedBytes when available in MemoryDiagnoser (assignee: @adamsitnik) #1154 Add a ConcurrencyDiagnoser? (assignee: @adamsitnik) #1156 Crash when BenchmarkDotNet.Diagnostics.Windows.Session.GetFilePath throws NRE (assignee: @adamsitnik) #1158 \uD83D\uDD0D Improving search on docs with Algolia's DocSearch #1162 Incorrect value of BenchmarkDotNet.Toolchains.DotNetCli.NetCoreAppSettings.Default #1168 Consider using default value instead of hardcoded '-' in MetricColumn.GetValue() #1179 Add System.Buffers.ArrayPoolEventSource to the list of default .NET Providers of EtwProfiler (assignee: @adamsitnik) #1181 Log shows a wrong name for plot images #1182 Benchingmarking .NET 4.8 Causes Errors #1183 Plots of benchmarks without params have a double dash (--) in the name #1186 Add support for --runtimes net48 (assignee: @adamsitnik) #1187 When user uses --packages $path, the $path should be sent to dotnet build command as well (assignee: @adamsitnik) #1194 RunAll with ToolChains (assignee: @adamsitnik) #1195 LatestCoreRtVersionIsSupported fails on Mac Os #1202 BenchmarkDotNet Not Recognizing CPU #1220 [Docs] RScript / R_HOME setup #1235 NativeMemoryProfiler exception (assignee: @WojciechNagorski) #1236 Rework new API for target runtimes (assignee: @adamsitnik) #1241 Can BenchmarkDotNet be enabled for LINQPad 6? (assignee: @adamsitnik) #1269 Unable to show full param string in the report (assignee: @adamsitnik) #1280 Improvement in memory statistics (assignee: @WojciechNagorski) #1285 Issue with .Net Core version 3.0 #1289 How to config to not save .log files? #1291 MemoryDiagnoser reports weird results for .NET Core 3.0 Merged pull requests (56) #1044 Add \"dotnet new\" benchmark project template (by @CodeTherapist) #1114 simplify the reported Full .NET Framework version, fixes 1111 (by @adamsitnik) #1123 + InProcessNoEmitToolchain (obsoletes the InProcessToolchain) (by @ig-sinicyn) #1129 Consume CoreRT from the new NuGet feed (by @MichalStrehovsky) #1130 allow namespace filtering for InliningDiagnoser (#1106) (by @MarekM25) #1131 NativeMemoryDiagnoser (by @WojciechNagorski) #1139 Power-Management extension (#1132) (by @MarekM25) #1145 Added workaround to fix incorrect CPU info when using wmic (by @YohDeadfall) #1148 Improve search experience in the documentation (by @s-pace) #1155 Use new .NET Core 3.0 API to get the total number of allocated bytes for all threads (by @adamsitnik) #1161 Warn the user when benchmark baseline value is too close to zero and the columns derived from BaselineCustomColumn cannot be computed (by @mhmd-azeez) #1163 Make netcoreapp2.1 default (by @adamsitnik) #1169 Fix: broken link in readme.md (by @Ant-hem) #1173 Updated index.md and fixed Relative performance url (by @sergey-litvinov) #1175 Added information about what a Gen X column means (by @jigargandhi) #1180 Update docstring for IterationSetup/IterationCleanup (by @billwert) #1185 Invalid arg passing in StreamLogger constructor (by @ig-sinicyn) #1188 Enforce the users to provide full target framework moniker when using attributes to define multiple runtime jobs (by @adamsitnik) #1189 Update HtmlExporter.cs (by @chuuddo) #1196 Update Mac Os for Travis CI (by @WojciechNagorski) #1199 Rename OutlierMode values (by @AndreyAkinshin) #1201 print benchmark process id to the output (better profiler user story) (by @adamsitnik) #1203 Easier introduction of new benchmarks (by @Scooletz) #1204 Fix casing typo (by @antondahlin) #1206 add *.fsproj to the list of supported project types (by @JaggerJo) #1208 Support of --profiler NativeMemory command line argument (by @WojciechNagorski) #1209 Sorting examples list and adding missing pages (by @WojciechNagorski) #1212 Plots with a double dash (--) in the names (#1183) (by @marcnet80) #1213 print full architecture name (by @adamsitnik) #1214 Add documentation to NativeMemoryDiagnoser (by @WojciechNagorski) #1217 Log shows a wrong name for plot images #1181 (by @marcnet80) #1218 NativeMemoryProfiler -add count of allocated object (by @WojciechNagorski) #1219 Add links to blogs. (by @WojciechNagorski) #1222 Enhance rscript location (by @tebeco) #1225 Documentation: Fix some typos in the documentation (by @MSeifert04) #1227 Threading Diagnoser (by @adamsitnik) #1228 Support IEnumerable as benchmark argument (by @adamsitnik) #1230 further runtime detection improvements (by @adamsitnik) #1231 Fix iteration cleanup bug (by @adamsitnik) #1232 Fixed dots at the end (not used in other places) (by @cincuranet) #1233 try to read .NET Core version from all available information (by @adamsitnik) #1237 The null ArtifactsPath value causes exception for all EtwProfiler (by @WojciechNagorski) #1239 Add using statement to sample snippet (by @b8adamson) #1240 Amend SummaryStyle to support visualization of '0' in reports (by @sleemer) #1245 LINQPad 6 support using InProcessEmitToolchain (by @adamsitnik) #1252 Add possibility to disable the log file (by @CodeTherapist) #1255 Update Build Tools to use .NET Core SDK to 3.0.100 (by @CodeTherapist) #1257 Task remove unused nuget packages (by @WojciechNagorski) #1259 Task remove trailing whitespace (by @WojciechNagorski) #1260 Fix ca1825 rule - Avoid zero-length array allocations (by @WojciechNagorski) #1261 Fix CA2000 - Add missing using (by @WojciechNagorski) #1265 make it possible to configure MaxParamterColumnWidth (by @adamsitnik) #1268 Fix compilation error with post v3.3.1 Roslyn (by @stanciuadrian) #1277 change the runtimes API (by @adamsitnik) #1279 Improve documentation for version 0.12.0 (by @WojciechNagorski) #1281 Print GC and threading stats only if needed (by @WojciechNagorski) Commits (110) 881c6d Postrelease update of v0.11.5 changelog (by @AndreyAkinshin) a2bddf Fix release date for v0.11.5 in changelog (by @AndreyAkinshin) c0c91a Consume CoreRT from the new NuGet feed (#1129) (by @MichalStrehovsky) 40dcab allow namespace filtering for InliningDiagnoser (#1106) (#1130), fixes #1106 (by @MarekM25) 12fdbe + InProcessNoEmitToolchain (#1123) (by @ig-sinicyn) 62d6af Bump docfx version to 2.42.1 (by @AndreyAkinshin) 40901c Add sitemap generation in docfx.json (see #1137) (by @AndreyAkinshin) 04ec20 add Guid support to code templates (by @adamsitnik) 4e9eb4 Better precision calculation in SummaryTable (by @AndreyAkinshin) df6f91 Added workaround to fix incorrect CPU info when using wmic (#1145) (by @YohDeadfall) 9065c7 Make ids for tag columns unique, fixes #1146 (by @AndreyAkinshin) 527c95 Improve AskUser prompt message, fixes #1147 (by @AndreyAkinshin) 45253c Flush custom loggers at the end of benchmark session, fix #1134 (by @AndreyAkinshin) 21175b Make log file datetime format 24-hour, fix #1149 (by @AndreyAkinshin) 0dfa37 Power-Management extension (#1132) (#1139) (by @MarekM25) f54055 Use new .NET Core 3.0 API to get the total number of allocated bytes for all ... (by @adamsitnik) aa17ec improve the output path of .etl files produced by EtwProfiler, fixes #1156, f... (by @adamsitnik) ec296d make ArgumentsSource support IEnumerable<object[]> for benchmarks accepting a... (by @adamsitnik) 96f162 write \"Setup power plan\" in a separate line (by @adamsitnik) 063d1a copy PreserveCompilationContext MSBuild setting from the project that defines... (by @adamsitnik) 1578c5 make it possible to not enforce power plan, move the revert to finally, simpl... (by @adamsitnik) 0513a7 remove the test that requires a manual update every time we add a new charact... (by @adamsitnik) 6e6559 extend Summary with LogFilePath, fixes #1135 (by @adamsitnik) 6d7130 make FullNameProvider public so it can be reused by the dotnet/performance re... (by @adamsitnik) 6f91ea Drop netcoreapp2.0 TFM in sample and test projects (see #1141) (by @AndreyAkinshin) bfe676 Warn the user when benchmark baseline value is too close to zero and the colu... (by @mhmd-azeez) 4282b1 Update year in LICENSE.md (by @AndreyAkinshin) 29d01b Improve search experience in the documentation (#1148) (by Sylvain Pace) ddf1b8 Fixed: broken link in readme.md (by @Ant-hem) fc35f7 simplify the reported Full .NET Framework version, fixes 1111 (#1114) (by @adamsitnik) 0a4550 Updated index.md and fixed Relative performance (#1173) (by @sergey-litvinov) a106b1 Add System.Buffers.ArrayPoolEventSource to the list of default .NET Providers... (by @adamsitnik) c022e7 Update docstring for IterationSetup/IteraitonCleanup (by @billwert) 31cb34 Invalid arg passing in StreamLogger constructor (#1185) (by @ig-sinicyn) fc8867 Make netcoreapp2.1 default (#1163) (by @adamsitnik) 0f210c Add support for --runtimes net48, fixes #1186 (by @adamsitnik) 48a9de When user uses --packages $path, the $path should be sent to dotnet build com... (by @adamsitnik) dfa074 Update HtmlExporter.cs (#1189) (by @chuuddo) 8b018d doc update: InProc toolchain supports Arguments now, we use Median instead of... (by @adamsitnik) ae23bd add the possibility to pass config to BenchmarkSwitcher.RunAll and RunAllJoin... (by @adamsitnik) 94b788 Update Mac Os for Travis CI (#1196), fixes #1195 (by @WojciechNagorski) 58fde6 Use Sheather&Jones bandwidth selector for density plots in RPlotExporter (by @AndreyAkinshin) 0e4b8e Rename OutlierMode values (#1199) (by @AndreyAkinshin) 863c65 Added information about what a Gen X column means (#1175) (by @jigargandhi) 70c5b3 print benchmark process id to the output (better profiler user story) (#1201) (by @adamsitnik) 55cba0 Easier introduction of new benchmarks (#1203) (by @Scooletz) 31bb6f Fix casing typo (#1204) (by @antondahlin) e92abf NativeMemoryDiagnoser (#1131), fixes #457 (by @WojciechNagorski) d04a01 update list of supported project types (#1206) (by @JaggerJo) 5db67b Sorting examples list and add missing pagges (#1209) (by @WojciechNagorski) 6620cd print full architecture name (#1213) (by @adamsitnik) 705bc3 Add documentation to NativeMemoryDiagnouser (#1214) (by @WojciechNagorski) 9caa05 Support of --profiler NativeMemory command line argument (#1208) (by @WojciechNagorski) 5d7c78 Plots with a double dash (--) in the names (#1183) (#1212) (by @marcnet80) d0d883 Extend NativeMemoryProfiler with the number of allocated objects (#1218) (by @WojciechNagorski) 09aba3 Add links to blogs. (#1219) (by @WojciechNagorski) a200af Enforce the users to provide full target framework moniker when using attribu... (by @adamsitnik) f8ef67 add release notes for 0.11.6 (by @adamsitnik) 88ea5a Documentation: Fix some typos in the documentation (#1225) (by @MSeifert04) ea0468 Support IEnumerable as benchmark argument (#1228) (by @adamsitnik) 4080ab Threading Diagnoser (#1227) (by @adamsitnik) b6d0e0 further runtime detection improvements (#1230), (by @adamsitnik) bc9624 Fix iteration cleanup bug (#1231) (by @adamsitnik) cfccac Fixed dots at the end (not used in other places) (#1232) (by @cincuranet) 61feb7 try to read .NET Core version from all available information (#1233) (by @adamsitnik) c06ab7 Add using statement to sample snippet (#1239) (by @b8adamson) af9608 The null ArtifactsPath value causes exception for all EtwProfiler (#1237) (by @WojciechNagorski) 5f337d chore(tests): extract helper methods to MockFactory (by @sleemer) 03e9ce feat(CsvExproter): print '0' instead of '-' in the CSV report (by @sleemer) 06f0e7 Improuve link visibility for R installation (by @tebeco) a2d9e3 adding example of R_HOME value in the doc to understand it construction (by @tebeco) ce5ac8 Enhanced RScript detection, with a Fallback to the PATH if R_HOME points to a... (by @tebeco) b86845 not necessary to set rscriptPath to null since it's re-affected right after (by @tebeco) ee97ca Change access modifier to private, was not intended to be public (by @tebeco) 609eec Log shows a wrong name for plot images #1181 (by @marcnet80) 76096e Add \"dotnet new\" benchmark project template (#1044) (by @CodeTherapist) b7cbdf Update year in license (docs) (by @AndreyAkinshin) 29919d Remove extra spaces in template *proj files (by @AndreyAkinshin) 80ccfd Add some readonly modifiers (by @AndreyAkinshin) d6a697 Improve MannWhitneyTest precision for small samples (by @AndreyAkinshin) 9ba645 Fix CurrentRuntimeIsProperlyRecognized for NETFRAMEWORK case on Linux/macOS (by @AndreyAkinshin) 24fda9 LINQPad 6 support using InProcessEmitToolchain (#1245) (by @adamsitnik) e01e0d Fix typos in attribute messages (by @AndreyAkinshin) 56a71f Add possibility to disable the log file (#1252) (by @CodeTherapist) 3c4ec9 remove unused nuget packages (#1257) (by @WojciechNagorski) 61cc56 Add missing using (#1261) (by @WojciechNagorski) cd88ed Fix ca1825 rule - Avoid zero-length array allocations (#1260) (by @WojciechNagorski) 2ba303 Task remove trailing whitespace (#1259) (by @WojciechNagorski) e1c4aa Fix compilation error with post v3.3.1 Roslyn (#1268) (by @stanciuadrian) 4ec888 make it possible to configure MaxParamterColumnWidth (#1265), fixes #1269 (by @adamsitnik) 51f53a CombinedDisassemblyExporter output should be aligned to left, not right (by @adamsitnik) f89091 Add EdPeltChangePointDetector (by @AndreyAkinshin) da63e8 change the runtimes API (#1277) (by @adamsitnik) 5333d5 Change next version number from 0.11.6 to 0.12.0 (by @AndreyAkinshin) 52cc45 NativeMemoryProfiler instead of NativeMemoryDiagnoser (#1279) (by @WojciechNagorski) f86e13 Print GC and threading stats if needed (#1281) (by @WojciechNagorski) a08062 Rename some obsolete TargetFrameworkMoniker names to RuntimeMoniker (by @AndreyAkinshin) 7fdee8 Fix JitOptimizationsValidatorIsMandatoryByDefault in DEBUG mode (by @AndreyAkinshin) f2639e Move ImmutableConfigTests from IntegrationTests to regular unit tests (by @AndreyAkinshin) 4f6a6b Fix diagnoser tests in ImmutableConfigTests (by @AndreyAkinshin) 0768b7 Fix some typos in identifiers (by @AndreyAkinshin) 28bb7c Bump DocFX version from 2.42.1 to 2.46 (by @AndreyAkinshin) af9ff5 Fix mistakes in old changelogs (by @AndreyAkinshin) c5aa4f Prepare v0.12.0 changelog (by @AndreyAkinshin) cb1575 Add BenchmarkDotNet.Templates in build-and-pack.cmd (by @AndreyAkinshin) bc7cb8 Improve v0.12.0 release notes (by @AndreyAkinshin) c5ac2f Fix bug in BaselineCustomAnalyzer (by @AndreyAkinshin) d75b1b Add .NET Core 2.2 and .NET Core 3.0 support in BenchmarkDotNet.Tool (by @AndreyAkinshin) d582b5 Revert previous commit because of the CI Error (by @AndreyAkinshin) 7bdf6e Set library version: 0.12.0 (by @AndreyAkinshin) Contributors (25) Adam Sitnik (@adamsitnik) Adrian Stanciu (@stanciuadrian) Andrey Akinshin (@AndreyAkinshin) Antoine Hémery (@Ant-hem) Anton Dahlin (@antondahlin) b8adamson (@b8adamson) Bill Wert (@billwert) Code Therapist (@CodeTherapist) ig-sinicyn (@ig-sinicyn) Ilya Chudin (@chuuddo) Jigar (@jigargandhi) Jiri Cincura ↹ (@cincuranet) Josua Jäger (@JaggerJo) marcnet80 (@marcnet80) Marek Moraczyński (@MarekM25) Michael Seifert (@MSeifert04) Michal Strehovský (@MichalStrehovsky) Muhammad Azeez (@mhmd-azeez) Sergey Litvinov (@sergey-litvinov) Sylvain Pace Szymon Kulec (@Scooletz) TeBeCo (@tebeco) Vlad Kovalev (@sleemer) Wojciech Nagórski (@WojciechNagorski) Yoh Deadfall (@YohDeadfall) Thank you very much! Additional details Date: October 24, 2019 Milestone: v0.12.0 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.12.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.12.0 https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.12.0 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.12.0 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.12.0 BenchmarkDotNet v0.11.5 Highlights Features and noticeable improvements Power plan management Now BenchmarkDotNet executes all benchmarks with enabled High-Performance power plan (configurable, Windows-only). You can find some details below. #68 #952 Better Environment Variables API Now we have some additional extension methods which allow defining environment variables in user jobs. In the previous version, users always had to set an array of environment variables like this: job.With(new[] { new EnvironmentVariable(\"a\", \"b\") }). Now it's possible to define an environment variable like job.With(new EnvironmentVariable(\"a\", \"b\")) or job.WithEnvironmentVariable(\"a\", \"b\"). Also, it's possible to clear the list of environment variables via job.WithoutEnvironmentVariables(). #1069 #1080 Better outlier messages The previous version of BenchmarkDotNet printed information about detected or removed outliers like this: \"3 outliers were detected\". It was nice, but it didn't provide additional information about these outliers (users had to read the full log to find the outliers values). Now BenchmarkDotNet prints additional information about outlier values like this: \"3 outliers were detected (2.50 us..2.70 us)\". e983cd31 Support modern CPU architecture names In the environment information section, BenchmarkDotNet prints not only the processor brand string, but also its architecture (e.g., \"Intel Core i7-4770K CPU 3.50GHz (Haswell)\"). However, it failed to recognize some recent processors. Now it's able to detect the architecture for modern Intel processors correctly (Kaby Lake, Kaby Lake R, Kaby Lake G, Amber Lake Y, Coffee Lake, Cannon Lake, Whiskey Lake). 995e053d Introduce BenchmarkDotNet.Annotations Currently, BenchmarkDotNet targets .NET Standard 2.0. It makes some users unhappy because they want to define benchmarks in projects with lower target framework. We decided to start working on the BenchmarkDotNet.Annotations NuGet package which targets .NET Standard 1.0 and contains classes that users need to define their benchmarks. However, it's not easy to refactor the full source code base and move all relevant public APIs to this package. In v0.11.5, we did the first step and moved some of these APIs to BenchmarkDotNet.Annotations. We want to continue moving classes to this package and get full-featured annotation package in the future. #1084 #1096 Use InProcessEmitToolchain by default in InProcess benchmarks In BenchmarkDotNet 0.11.4, we introduced InProcessEmitToolchain. It's a new, full-featured InProcess toolchain which allows executing benchmarks in the current process without spawning additional process per benchmark. It supports [Arguments], [ArgumentsSource], passing the arguments by out, ref and returning stack-only types like Span<T>. However, in v0.11.4, it can be activated only if InProcessEmitToolchain is declared explicitly. Now it's enabled by default when [InProcessAttribute] is used. #1093 Introduce an option which prevents overwriting results Currently, BenchmarkDotNet overwrites results each time when the benchmarks are executed. It allows avoiding tons of obsolete files in the BenchmarkDotNet.Artifacts folder. However, the behavior doesn't fit all use cases: sometimes users want to keep results for old benchmark runs. Now we have a special option for it. The option can be activated via --noOverwrite console line argument or DontOverwriteResults extension method for IConfig #1074 #1083 Other improvements and bug fixes Diagnostics and validation Better benchmark declaration error processing In the previous version, BenchmarkDotNet threw an exception when some benchmark methods had an invalid declaration (e.g., invalid signature or invalid access modifiers). Now it prints a nice error message without ugly stack traces. #1107 Better error message for users who want to debug benchmarks #1073 Don't show the same validation error multiple times Now each error will be printed only once. #1079 Restrict MemoryDiagnoserAttribute usage to class Now it's impossible to accidentally mark a method with this attribute. #1119 #1122 Export Better indentation in disassembly listings Now DissassemblyDiagnoser correctly process source code which contains tab as the indentation symbol #1110 Fix incorrect indentation for StackOverflow exporter Previously, StackOverflow exporter doesn't have a proper indent for job runtimes in the environment information. Now it's fixed. #826 #1104 Fix StackOverflowException in XmlExporter.Full #1086 #1090 Shortify MemoryDiagnoser column titles Now we use the following column titles: \"Allocated\" instead of \"Allocated Memory/Op\", \"Gen 0\" instead of \"Gen 0/1k Op\". The full description of each column can be found in the legend section below the summary table. #1081 Benchmark generation and execution Fixed broken Orderers The previous version has a nasty bug with custom orderers. Now it's fixed. #1070 #1109 Better overhead evaluation In the previous version, BenchmarkDotNet evaluated the benchmark overhead as a mean value of all overhead iteration. It was fine in most cases, but in some cases, the mean value can be spoiled by outliers. Now BenchmarkDotNet uses the median value. #1116 Respect CopyLocalLockFileAssemblies Now BenchmarkDotNet respect the CopyLocalLockFileAssemblies value and copies it to the generated benchmark project. #1068 #1108 Disable CodeAnalysisRuleSet for generated benchmarks Previously, generated benchmarks may fail if the CodeAnalysisRuleSet is defined in Directory.Build.Props. #1082 Supported undefined enum values #1020 #1071 Other minor improvements and bug fixes Power plans In #952, power plan management was implemented. It resolves a pretty old issue #68 which was created more than three years ago. Now BenchmarkDotNet forces OS to execute a benchmark on the High-Performance power plan. You can disable this feature by modifying PowerPlanMode property. Here is an example where we are playing with this value: [Config(typeof(Config))] public class IntroPowerPlan { private class Config : ManualConfig { public Config() { Add(Job.MediumRun.WithPowerPlan(PowerPlan.HighPerformance)); Add(Job.MediumRun.WithPowerPlan(PowerPlan.UserPowerPlan)); } } [Benchmark] public int IterationTest() { int j = 0; for (int i = 0; i < short.MaxValue; ++i) j = i; return j; } [Benchmark] public int SplitJoin() => string.Join(\",\", new string[1000]).Split(',').Length; } And here is an example of the summary table on plugged-off laptop: Method | PowerPlan | Mean | Error | StdDev | -------------- |---------------- |---------:|----------:|----------:| IterationTest | HighPerformance | 40.80 us | 0.4168 us | 0.6109 us | SplitJoin | HighPerformance | 13.24 us | 0.2514 us | 0.3763 us | IterationTest | UserPowerPlan | 79.72 us | 2.5623 us | 3.8352 us | SplitJoin | UserPowerPlan | 24.54 us | 2.1062 us | 3.1525 us | As you can see, the power plan produces a noticeable effect on the benchmark results. This feature is available on Windows only. Milestone details In the v0.11.5 scope, 16 issues were resolved and 16 pull requests were merged. This release includes 44 commits by 12 contributors. Resolved issues (16) #68 Power management #826 MarkdownExporter.StackOverflow fails to indent jobs' runtime descriptions (assignee: @alinasmirnova) #976 System.NotSupportedException: Line must start with GC (assignee: @adamsitnik) #1020 Errors using undefined enum values as benchmark arguments (assignee: @adamsitnik) #1068 The csproj setting CopyLocalLockFileAssemblies is ignored #1070 System.InvalidOperationException: Sequence contains more than one matching element after 0.11.4 (assignee: @AndreyAkinshin) #1071 Enum flags results into compiler errors (assignee: @adamsitnik) #1073 The error message for users who want to Debug benchmarks is not clear (assignee: @adamsitnik) #1074 Results should be exported to a file with unique name #1079 Dont display the same Validation Error many times (assignee: @adamsitnik) #1086 XmlExporter.Full fails with StackOverflowException #1107 Unhandled Exception: System.InvalidOperationException: Benchmark method '' has incorrect signature. Method shouldn't have any arguments. (assignee: @AndreyAkinshin) #1109 Issue with DefaultOrderer #1110 DisassemblyDiagnoser assumes indentation uses spaces (assignee: @AndreyAkinshin) #1116 Use Median instead of Mean whe deducing Overhead (assignee: @AndreyAkinshin) #1119 MemoryDiagnoserAttribute on methods (assignee: @Rizzen) Merged pull requests (16) #952 Implemented power-management, add docs (#68) (by @MarekM25) #1080 Improved Environment Variables API, resolves #1069 (by @AndreyAkinshin) #1081 Shortify MemoryDiagnoser column titles (by @AndreyAkinshin) #1082 Make it so that the code analysis settings are disabled. (by @glennawatson) #1083 make it possible to Don't Overwrite Results, fixes #1074 (by @adamsitnik) #1084 introduce BenchmarkDotNet.Annotations (by @adamsitnik) #1088 Typo (by @Stromberg90) #1090 XmlExporter.Full fails (by @daveMueller) #1093 make InProcessEmitToolchain the default one (by @adamsitnik) #1096 move more simple Attributes to BenchmarkDotNet.Annotations (by @adamsitnik) #1104 fix #826 (by @alinasmirnova) #1105 Just spell check (by @sungam3r) #1108 Fix #1068 - Copy value of CopyLocalLockFileAssemblies (by @WojciechNagorski) #1112 Fixed event wire-up before Session acquisition (by @jzabroski) #1122 Restrict MemoryDiagnoserAttribute usage to class (by @Rizzen) #1126 Styling in docfx fashion (by @robertmuehsig) Commits (44) 0a63e4 Postrelease update of v0.11.4 changelog (by @AndreyAkinshin) f94616 Fix namespace for JobTests (by @AndreyAkinshin) 995e05 Support modern CPUs in ProcessorBrandStringHelper (by @AndreyAkinshin) f946ba Repair custom orderers, fixes #1070 (by @AndreyAkinshin) 1d3783 allow passing Enum Flags and undefined enum values as benchmarks arguments/pa... (by @adamsitnik) dfe9ca make sure that we can pass undefined enum values and the bug never comes back... (by @adamsitnik) 76b467 improve the error message when users try to run the benchmarks in Debug, fixe... (by @adamsitnik) 98d9f8 Dont display the same Validation Error many times, fixes #1079 (by @adamsitnik) 03981c fix the unit test that I broke when I was fixing #1071 (by @adamsitnik) 877aba Throw exception about private benchmark method (by @AndreyAkinshin) e983cd Print some outlier values in OutliersAnalyser (by @AndreyAkinshin) b5d324 Shortify MemoryDiagnoser column titles (#1081) (by @AndreyAkinshin) c5c4c4 handle undefined negative enum values, #1020 (thanks @TylerBrinkley) (by @adamsitnik) 2f273c Improved Environment Variables API, resolves #1069 (#1080) (by @AndreyAkinshin) ff2847 Implement FrequencyTests.ParseTest (by @AndreyAkinshin) 5e25da Make it so that the code analysis settings are disabled for compiled builds (... (by @glennawatson) db701e make it possible to Don't Overwrite Results, fixes #1074 (#1083) (by @adamsitnik) a12d8c introduce BenchmarkDotNet.Annotations (#1084) (by @adamsitnik) dcc40a Typo (#1088) (by @Stromberg90) 2c392a XmlExporter.Full fails #1090 (by @daveMueller) 8968bb make InProcessEmitToolchain the default one (#1093) (by @adamsitnik) 4c9136 move more simple Attributes to BenchmarkDotNet.Annotations (#1096) (by @adamsitnik) 6f524f Added extra output lines for jobs in test (by @alinasmirnova) 27ed8a Logger with prefix works correctly with multiline input (by @alinasmirnova) a846b8 just spell check (#1105) (by @sungam3r) a2da9a Reverted reporter change (by @alinasmirnova) e1c9b9 Merge pull request #1104 from alinasmirnova/master (by @AndreyAkinshin) e45adc Fix #1068 - Copy value of CopyLocalLockFileAssemblies (#1108) (by @WojciechNagorski) 2f823c don't fail with exception if user has written something to output in GlobalCl... (by @adamsitnik) 8bc2cc Fixed event wire-up before Session acquisition (#1112) (by @jzabroski) db3a8f Better handling of benchmark with incorrect signature, fixes #1107 (by @AndreyAkinshin) 8a8e01 Fix GlobalSetupAttributeMethodsMustHaveNoParameters (by @AndreyAkinshin) 52eca7 Better disasm indentation, fixes #1110 (by @AndreyAkinshin) d9901b Use Median instead of Mean for overhead calculations, fixes #1116 (by @AndreyAkinshin) 1c1913 add dotnet/performance to the list of users (by @adamsitnik) e1d4d2 Restrict MemoryDiagnoserAttribute usage to class (#1122), fixes #1119 (by @Rizzen) 8aa6ad Implemented power-management, add docs (#68) (#952) (by @MarekM25) 9c6cad Improve ApplyUserPowerPlan message (by @AndreyAkinshin) d12414 Initial v0.11.5 changelog (by @AndreyAkinshin) 1babcb styling in docfx fashion (by @robertmuehsig) fb1286 Add netstandard2.0 target framework in BenchmarkDotNet.Annotations (by @AndreyAkinshin) b7118e Add BenchmarkDotNet.Annotations in build-and-pack.cmd (by @AndreyAkinshin) 8721a9 Prepare v0.11.5 changelog (by @AndreyAkinshin) 31ea3d Set library version: 0.11.5 (by @AndreyAkinshin) Contributors (12) Adam Sitnik (@adamsitnik) Alina Smirnova (@alinasmirnova) Andrey Akinshin (@AndreyAkinshin) David Müller (@daveMueller) Glenn (@glennawatson) Ivan Maximov (@sungam3r) John Zabroski (@jzabroski) Marek Moraczyński (@MarekM25) Mark Tkachenko (@Rizzen) Robert Muehsig (@robertmuehsig) Strømberg (@Stromberg90) Wojciech Nagórski (@WojciechNagorski) Thank you very much! Additional details Date: April 2, 2019 Milestone: v0.11.5 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.5 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.5 https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.11.5 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.11.5 BenchmarkDotNet v0.11.4 It's been few months since our last release, but we have been working hard and have some new features for you! Highlights Features BenchmarkDotNet as a global tool: a new global tool which allows you to run benchmarks from given library. Now you can run benchmarks from the command line via dotnet benchmark. You can find more information about it in the documentation #1006 #213 InProcessEmitToolchain: new, full-featured InProcess toolchain which allows executing benchmarks in the current process without spawning additional process per benchmark. It supports [Arguments], [ArgumentsSource], passing the arguments by out, ref and returning stack-only types like Span<T>. #919, #921 #843 ARM support: BenchmarkDotNet supports now ARM and ARM64. #780, #979 #385 Mono AOT support: a new toolchain which allows running benchmarks using AOT version of Mono #940 NuGet symbol server support: BenchmarkDotNet publishes now the symbols to NuGet.org symbol server and you can easily debug it. #967 #968 Experimental support for .NET Core 3.0 WPF benchmarks #1066 For a working example please go to https://github.com/dotMorten/WPFBenchmarkTests Improvements: CoreRT Toolchain improvements - thanks to help from CoreRT Team we were able to make the CoreRT Toolchain work with the latest version of CoreRT #1001, #1057 Display the number of benchmarks to run: we now display how many benchmarks are going to be executed before running them and how many remained after running each of them #1048 Better list of suggested benchmarks for wrong filter #834 #957 Invalid assembly binding redirects generated by VS were a pain to many of our users, we have now implemented an approach that tries to work around this issue. #895, #667, #896, #942 Handling duplicates in IConfig #912, #938, #360, #463 Disassembly diagnoser should be kept in a separate directory to avoid dependency conflicts #1059 Give a warning when the [Benchmark] method is static - we now produce an error when users fail into this common issue #983 #985 C# keywords are prohibited as benchmark names #849 File names should be consistent across all OSes - < and > are valid on Unix, but not on Windows. We have unified that and now files produced on Unix and Windows have the same names. #981 Improve restore, build and publish projects #1002, #1013 Make it possible to disable OptimizationsValidator #988 Sort enum parameters by value instead of name #977 Detect .NET Core benchmark failures from LINQPad #980 Improved error logging #1008 Improved disassembly diff #1022 Using invariant culture for Roslyn Toolchain error messages #1042 Use only full names in the auto-generated code to avoid any possible conflicts with user code #1007, #1009 #1010 Write the GitHub table format to the console by default #1062 Proper cleanup on Ctrl+C/console Window exit #1061 Introduce StoppingCriteria - the first step to writing your own heuristic that determines when benchmarking should be stopped #984 Breaking changes: .NET Standard 2.0 only - BenchmarkDotNet has a single target now, which should help with some assembly resolving issues. We had to drop .NET 4.6 support because of that and .NET 4.6.1 is now the oldest supported .NET Framework. #1032 CustomCoreClrToolchain has been removed, it's recommended to use CoreRunToolchain instead #928 Bug fixes: NRE in Summary ctor #986 #987 ArgumentNullException when running benchmarks from published .NET Core app #1018 Dry jobs can eat iteration failures #1045 NullReferenceException in BenchmarkDotNet.Reports.SummaryTable after iteration failure #1046 Running the example throws NullReference #1049 Fix race condition in process output reader #1051 #1053 Fix a rare but really annoying bug where for some reason we were sometimes setting ForegroundColor to the same color as BackgroundColor and some parts of the logged output were invisible commit StopOnFirstError must be respected commit Milestone details In the v0.11.4 scope, 42 issues were resolved and 41 pull requests were merged. This release includes 99 commits by 18 contributors. Resolved issues (42) #213 Add a \"benchmark\" cmd to dotnet #343 FileNotFoundException on mono (assignee: @AndreyAkinshin) #360 Duplicates handling for IConfig (assignee: @adamsitnik) #385 Consider using S.R.InteropServices.RuntimeInformation.ProcessArchitecture instead pointer based detection of platform (assignee: @adamsitnik) #387 Add a mode to BenchmarkSwitcher that allows to run a method inline for profiling (assignee: @adamsitnik) #463 Review interface IConfig (assignee: @adamsitnik) #660 [Params] should not change the order of provided values #667 Does BenchMarkDotnet supports 4.7.1 Dotnet framework (assignee: @adamsitnik) #687 Implement [Arguments] support for InProcessToolchain (assignee: @ig-sinicyn) #714 Test BenchmarkDotNet against unstable/multimodal benchmarks from CoreCLR/CoreFX repo (assignee: @adamsitnik) #780 ARM support (assignee: @adamsitnik) #834 Better list of suggested benchmarks for wrong filter (assignee: @morgan-kn) #843 Exception when returning a stackonly structure in a benchmark case using in-process toolchain (assignee: @ig-sinicyn) #849 C# keywords are prohibited as benchmark names (assignee: @adamsitnik) #895 Could not load file or assembly 'System.ValueTuple, Version=4.0.2.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51' or one of its dependencies (assignee: @adamsitnik) #896 .NET 4.7.1 console app tries to use BenchmarkRunner, gets \"Could not load file or assembly 'System.Runtime, Version=4.1.2.0\" (assignee: @adamsitnik) #919 Feature proposal: full-featured inprocess toolchain (assignee: @ig-sinicyn) #928 Remove CustomCoreClrToolchain (assignee: @adamsitnik) #938 Run benchmark with DisasemblyDiagnoser with --disasam option from console (assignee: @adamsitnik) #942 System.IO.FileNotFoundException: Could not load file or assembly 'System.Runtime, Version=4.1.0.0' after adding BenchmarkDotNet.Diagnostics.Windows (assignee: @adamsitnik) #967 Publish a snupkg to the NuGet.org symbol server (assignee: @WojciechNagorski) #970 False alarm bug report #981 File names should be consistent across all OSes (assignee: @adamsitnik) #982 Invalid string representaiton of CPU Affinity on a machine with more than 32 cores on ARM64 (assignee: @adamsitnik) #983 Give a warning when the [Benchmark] method is static (assignee: @Rizzen) #986 NRE in Summary ctor #988 Make it possible to disable OptimizationsValidator (assignee: @adamsitnik) #998 Missing images in docs (assignee: @AndreyAkinshin) #1002 Multiple build/publish failure with --coreRun toolchain (assignee: @WojciechNagorski) #1007 benchmark cannot have type Action (assignee: @adamsitnik) #1010 Write unit tests which check that BenchmarkProgram.txt doesn't contain usings (assignee: @adamsitnik) #1018 ArgumentNullException when running benchmarks from published .NET Core app #1039 Some tests are broken on Net 461 (culture-dependent thing) (assignee: @ig-sinicyn) #1045 Dry jobs can eat iteration failures (assignee: @adamsitnik) #1046 NullReferenceException in BenchmarkDotNet.Reports.SummaryTable after iteration failure (assignee: @adamsitnik) #1048 Display the number of benchmarks to run (assignee: @adamsitnik) #1049 Running the example throws NullReference (assignee: @adamsitnik) #1051 Fix race condition in process output reader (assignee: @adamsitnik) #1056 Fails to build when targeting .NET Core 3.0 and .NET Framework (assignee: @adamsitnik) #1059 Disassembly diagnoser should be kept in a separate directory to avoid dependency conflicts (assignee: @adamsitnik) #1062 Write the GitHub table format to the console by default (assignee: @adamsitnik) #1065 Allow benchmarking .NET Core Desktop apps (assignee: @adamsitnik) Merged pull requests (41) #912 Duplicates handling for IConfig = big refactor, fixes #360 (by @adamsitnik) #921 InProcessEmitToolchain (by @ig-sinicyn) #940 Add support for mono AOT pass (by @alexanderkyte) #957 Better list of suggested benchmarks for wrong filter #834 (by @morgan-kn) #968 Support Nuget symbol server (by @WojciechNagorski) #969 Disable batch mode and explicitly enable build trigger for master branch (by @Ky7m) #977 sort enum parameters by value instead of name (by @kayle) #979 ARM support (by @adamsitnik) #980 Detect .NET Core benchmark failures from LINQPad (by @Turnerj) #984 Introduce StoppingCriteria (by @AndreyAkinshin) #985 Give a warning when the [Benchmark] method is static (by @Rizzen) #987 Fix NRE in MetricColumn (#986) (by @qbit86) #991 Fix typos (by @0x6a62) #992 Use .NET Standard 2.0 CommandLineParser, Update to net461 for NS2.0 support (by @glennawatson) #996 Rephrase Notes section and fix markdown (by @Maximusya) #997 Remove obsolete info from the docs (by @Maximusya) #999 Synchronize benchmark output with the code in docs (by @Maximusya) #1001 CoreRT toolchain update (by @adamsitnik) #1006 BenchmarkDotNet as global tool (by @CodeTherapist) #1008 Improve error logging to diagnose unstable tests (by @adamsitnik) #1009 Use only full names in the auto-generated code to avoid any possible conflicts with user code (by @adamsitnik) #1012 Changed TargetCount to IterationCount in docs (by @Sitiritis) #1013 Improve restore, build and publish projects - Fix for #1002 (by @WojciechNagorski) #1014 Update IntroRatioSD.md (by @fredeil) #1022 Improve diff disassembly (by @WojciechNagorski) #1032 Target .NET Standard 2.0 only (by @adamsitnik) #1033 BenchmarkDotNet as global tool (#1006), fixes #213 (by @adamsitnik) #1035 Improve global tool (by @WojciechNagorski) #1036 Remove InternalsVisibleTo for Samples application (by @WojciechNagorski) #1038 Change the name of the global tool (by @WojciechNagorski) #1040 Making the new InProcessEmitToolchain work after my recent refactor and .NET Standard 2.0 port (by @adamsitnik) #1041 InProcessEmitToolchain (by @adamsitnik) #1042 Use invariant culture for csc messages (by @ig-sinicyn) #1043 minor InProcess fix: diff now checks for implementation flags (by @ig-sinicyn) #1052 dotnet cli version update + reducing the number of long running tests (by @adamsitnik) #1053 read the process output in a thread safe way, fixes #1051 (by @adamsitnik) #1054 update Travis Ubuntu image from 14.04 to 16.04 (by @adamsitnik) #1055 Allow reflecting on DebuggableAttribute on CoreRT (by @MichalStrehovsky) #1057 CoreRT toolchain improvements (by @adamsitnik) #1061 Proper cleanup on Ctrl+C/console Window exit (by @adamsitnik) #1066 Add experimental support for .NET Core 3.0 WPF benchmarks (by @adamsitnik) Commits (99) 1fac9b Postrelease update of v0.11.3 changelog (by @AndreyAkinshin) 40fae8 Support Nuget symbol server (#968) (by @WojciechNagorski) 69b01f remove batch and explicitly enable build for master (#969) (by @Ky7m) 01992c better error messages for lack of Cli and invalid CoreRun path (by @adamsitnik) 767e02 sort enum parameters by value instead of name (#977), fixes #660 (by @kayle) 128e11 Better list of suggested benchmarks for wrong filter #834 (#957) (by @morgan-kn) c0910a Fix NRE in BaselineRatioColumn.GetRatioStatistics, fixes #970 (by @AndreyAkinshin) 67b675 Fix TimeSpan calculations in DotNetCliCommand.AddPackages (by @AndreyAkinshin) 847c27 Fix a few typos (by @AndreyAkinshin) 6fb830 ARM support (#979) (by @adamsitnik) 410d14 Detect .NET Core benchmark failures from LINQPad (#980), #975 (by @Turnerj) 138325 File names should be consistent across all OSes, fixes #981 (by @adamsitnik) add308 test fix for #981 (by @adamsitnik) 77ed41 expose OriginalValues and SortedValues in the Statistics type so they get exp... (by @adamsitnik) c0aac1 More tests for FolderNameHelper (by @AndreyAkinshin) 3497ae Better message in MinIterationTimeAnalyser (by @AndreyAkinshin) 91e16a Fix duplication of IsLinqPad check (by @AndreyAkinshin) 89255c Refactoring xUnit tests to avoid non-serializable objects in MemberData (by @AndreyAkinshin) 2cd06a Give a warning when the [Benchmark] method is static (#985) (by @Rizzen) 5070af Fix NRE in MetricColumn (#986) (#987) (by @qbit86) 17378d Fix typos (#991) (by @0x6a62) 2ce35a Fix path to logo in README (by @AndreyAkinshin) a20e4b always print the path, args and working dir of the auto-generated executable,... (by @adamsitnik) 27dd87 CoreRunToolchain: when the file exists, overwrite it (by @adamsitnik) 1b01f3 Remove obsolete info from the docs (#997) (by @Maximusya) 299e1f Synchronized benchmark output with the code in docs (#999) (by @Maximusya) 0da14b Rephrase Notes section and fix markdown (#996) (by @Maximusya) 9e791f CoreRT toolchain update (#1001) (by @adamsitnik) 04747a Use only full names in the auto-generated code to avoid any possible conflict... (by @adamsitnik) f35465 add unit test that prevents from adding using statements to the code, fixes #... (by @adamsitnik) fd0b8c Improve build error logging, increase the default timeout (by @adamsitnik) 8276be Changed TargetCount to IterationCount in docs (#1012) (by @Sitiritis) 3c98da Update IntroRatioSD.md (#1014) (by @fredeil) 286996 Improve restore, build and publish projects - Fix for #1002 (#1013) (by @WojciechNagorski) 923b23 BenchmarkDotNet as global tool (#1006), fixes #213 (by @CodeTherapist) 7ef5f6 Introduce StoppingCriteria (#984) (by @AndreyAkinshin) 5e4428 make SortedValues internal property, don't export it! (by @adamsitnik) 5c519f Use .NET Standard 2.0 CommandLineParser, Update to net461 for NS2.0 support (... (by @glennawatson) 6ee21b if we fail to do the full build, we try with --no-dependencies (by @adamsitnik) 8d9714 Support machines without .NET DevPack, fix #1018 (by @AndreyAkinshin) 573566 Add support for mono AOT pass (#940) (by @alexanderkyte) 011c79 + InProcessEmitToolchain (by @ig-sinicyn) 862e6e InProcessEmitToolchain cleanup (by @ig-sinicyn) 252d7a Fix StringCanBePassedToBenchmarkAsReadOnlySpan (by @ig-sinicyn) 7ec2f3 Check if there's something wrong with RoslynToolchain on .Net Core (by @ig-sinicyn) 57acd6 No NOPs (thanks to @Warpten!) (by @ig-sinicyn) bf362a Diff now compares nops (by @ig-sinicyn) aa9ff8 + emit correct IL (by @ig-sinicyn) 351ca5 Ignore NOPs for ldarg too (by @ig-sinicyn) fc530f Fix build after rebase (by @ig-sinicyn) 1577ba MonoAotToolchain refactoring, post #940 (by @adamsitnik) 6ccf45 Improve diff disassembly (#1022) (by @WojciechNagorski) ef090d if we fail to do the full build, we try with --no-dependencies (for the publi... (by @adamsitnik) c69934 Give a warning when the [Benchmark] method is static: handle some edge-cases,... (by @adamsitnik) 935ead use .NET 4.6.1 everywhere, we don't support 4.6 anymore. Cleanup after #992 (by @adamsitnik) 20a011 C# keywords are prohibited for benchmark names, print nice error message, fix... (by @adamsitnik) 2aec75 remove CustomCoreClrToolchain, it was causing too much trouble. We can run th... (by @adamsitnik) f10752 Duplicates handling for IConfig = big refactor, fixes #360, closes #464 and f... (by @adamsitnik) f9c8cc Target .NET Standard 2.0 (#1032), apply a workaround for assembly binding red... (by @adamsitnik) aa1ded Merge branch 'master' into tools (by @adamsitnik) ccee3e Merge pull request #1033 from dotnet/tools (by @adamsitnik) 1b9f9f almost no warnings ;) (by @adamsitnik) 3bd18f introduce ConfigOptions - an enum flag which make it easier to introduce new ... (by @adamsitnik) 66c264 reverting things that should not introduce problems but did... (by @adamsitnik) 33eaeb Merge branch 'master' into feature-inprocessemit (by @adamsitnik) a1df27 Merge pull request #921 from ig-sinicyn/feature-inprocessemit (by @adamsitnik) aac7a6 Improve global tool (#1035) (by @WojciechNagorski) c01bc5 Remove InternalsVisibleTo for Samples application (#1036) (by @WojciechNagorski) f6dbe4 Change the name of the global tool (#1038) (by @WojciechNagorski) 11d8cb Making the new InProcessEmitToolchain work after my recent refactor and .NET ... (by @adamsitnik) e935b5 minor InProcess fix: diff now checks for implementation flags, (#1043) (by @ig-sinicyn) da4128 Merge pull request #1041 from dotnet/newInProcess (by @adamsitnik) 82170f if global cleanup throws, we should report the problem but don't rethrow beca... (by @adamsitnik) 904ddd tests that ensure that when a benchmark throws the runner does not throw, fix... (by @adamsitnik) cbdf7b Use invariant culture for csc messages (#1042) (by @ig-sinicyn) 5215ee Display the number of benchmarks to run, fixes #1048 (by @adamsitnik) 84cc3e dotnet cli version update + reducing the number of long running tests (#1052)... (by @adamsitnik) 1c431a read the process output in a thread safe way, fixes #1051 (#1053) (by @adamsitnik) 41a367 update Travis Ubuntu image from 14.04 to 16.04 (by @adamsitnik) 20744e allow the user to choose the strategy from console line arguments (by @adamsitnik) 190b9b Allow reflecting on DebuggableAttribute on CoreRT (#1055) (by @MichalStrehovsky) 9dd9e7 Ctlr+C: we should kill the entire process tree, not only for the benchmarks b... (by @adamsitnik) d4249f Disassembly diagnoser should be kept in a separate directory to avoid depende... (by @adamsitnik) 0b83c9 CoreRT toolchain improvements (#1057) (by @adamsitnik) 9bc8f3 0.11.4 initial release notes (by @adamsitnik) 13bb97 if the user provide a custom value, we should use it, post #1057 (by @adamsitnik) ea3036 fix a rare but really annoying bug where for some reason we were sometimes se... (by @adamsitnik) cf3f8c Proper cleanup on Ctrl+C/console Window exit (#1061) (by @adamsitnik) 61f563 Write the GitHub table format to the console by default, fixes #1062 (by @adamsitnik) 87d281 StopOnFirstError must be respected (by @adamsitnik) 413d31 Add experimental support for .NET Core 3.0 WPF benchmarks (#1066), fixes #1065 (by @adamsitnik) 69a8aa copy UseWindowsForms too (thanks @onovotny for pointing this out), post #1066 (by @adamsitnik) d3379e Bump DocFX version (by @AndreyAkinshin) 423204 Remove Version ComboBox in docs (by @AndreyAkinshin) 1a8826 Update build-and-pack.cmd (by @AndreyAkinshin) 9068d6 Update copyrights in docs (by @AndreyAkinshin) c0c2bf Update v0.11.4 changelog (by @AndreyAkinshin) e26441 Highlight the first column separator in the console summary table (by @AndreyAkinshin) a704a4 Set library version: 0.11.4 (by @AndreyAkinshin) Contributors (18) Adam Sitnik (@adamsitnik) Alexander Kyte (@alexanderkyte) Andrey Akinshin (@AndreyAkinshin) Code Therapist (@CodeTherapist) Fredrik Eilertsen (@fredeil) Glenn (@glennawatson) ig-sinicyn (@ig-sinicyn) Igor Fesenko (@Ky7m) Irina Ananeva (@morgan-kn) James Turner (@Turnerj) Jeff B. (@0x6a62) kayle (@kayle) Maksim Yakimets (@Maximusya) Mark Tkachenko (@Rizzen) Michal Strehovský (@MichalStrehovsky) Tymur Lysenko (@Sitiritis) Viktor Ptitselov (@qbit86) Wojciech Nagórski (@WojciechNagorski) Thank you very much! Additional details Date: February 15, 2019 Milestone: v0.11.4 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.4 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.4 https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.11.4 BenchmarkDotNet v0.11.3 Highlights This release is focused mainly on bug fixes that were affecting user experience. But don't worry, we have some new features too! Diagnosers ConcurrencyVisualizerProfiler (allows profiling benchmarks on Windows and exporting the data to a trace file which can be opened with Concurrency Visualizer) Command-line: --stopOnFirstError: Stops the benchmarks execution on first error. #947 --statisticalTest: Performs a Mann–Whitney Statistical Test for identifying regressions and improvements. #960 Bug fixes: Dry mode doesn't work because of the ZeroMeasurementHelper #943 MannWhitneyTest fails when comparing statistics of different sample size #948 and #950 Improve the dynamic loading of Diagnostics package #955 BenchmarkRunner.RunUrl throws NRE when Config is not provided #961 Don't require the users to do manual installation of TraceEvent when using Diagnostics package #962 Stop benchmark after closing application + Flush log after stopping benchmark #963 Diagnosers ConcurrencyVisualizerProfiler ConcurrencyVisualizerProfiler allows to profile the benchmarked .NET code on Windows and exports the data to a CVTrace file which can be opened with Concurrency Visualizer. ConcurrencyVisualizerProfiler uses EtwProfiler to get a .etl file which still can be opened with PerfView or Windows Performance Analyzer. The difference is that it also enables all Task and Thread related ETW Providers and exports a simple xml which can be opened with Visual Studio if you install Concurrency Visualizer plugin #964 Concurrency Visualizer Profiler Diagnoser (by @adamsitnik) dfb3c89 ConcurrencyVisualizerProfiler diagnoser! (by @adamsitnik) Command-line In this release, we have some new command-line arguments! --stopOnFirstError: Stops the benchmarks execution on first error When provided, BenchmarkDotNet is going to stop the benchmarks execution on first error. #947 Add option to stop running when the first benchmark fails (by @wojtpl2) --statisticalTest: Statistical Test To perform a Mann–Whitney U Test and display the results in a dedicated column you need to provide the Threshold via --statisticalTest. Examples: 5%, 10ms, 100ns, 1s. Example: run Mann–Whitney U test with relative ratio of 1% for all benchmarks for .NET 4.6 (base), .NET Core 2.0 and .NET Core 2.1. class Program { static void Main(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args); } public class MySample { [Benchmark] public void Sleep() { #if NETFRAMEWORK Thread.Sleep(50); #elif NETCOREAPP2_0 Thread.Sleep(45); #elif NETCOREAPP2_1 Thread.Sleep(55); #endif } [Benchmark] public void Same() => Thread.Sleep(50); } dotnet run -c Release -f netcoreapp2.1 --filter * --runtimes net46 netcoreapp2.0 netcoreapp2.1 --statisticalTest 1% Note: .NET 4.6 will be our baseline because it was provided as first on the runtimes list. Method Runtime Toolchain Mean Error StdDev Ratio MannWhitney(1%) Sleep Clr net46 50.51 ms 0.1833 ms 0.1714 ms 1.00 Base Sleep Core netcoreapp2.0 45.53 ms 0.1262 ms 0.1181 ms 0.90 Faster Sleep Core netcoreapp2.1 55.50 ms 0.1217 ms 0.1138 ms 1.10 Slower Same Clr net46 50.47 ms 0.1795 ms 0.1679 ms 1.00 Base Same Core netcoreapp2.0 50.55 ms 0.1873 ms 0.1752 ms 1.00 Same Same Core netcoreapp2.1 50.55 ms 0.2162 ms 0.2022 ms 1.00 Same Milestone details In the v0.11.3 scope, 10 issues were resolved and 10 pull requests were merged. This release includes 26 commits by 6 contributors. Resolved issues (10) #870 Error after adding OperationsPerInvoke (assignee: @AndreyAkinshin) #885 Closing application dot't stop benchmark (assignee: @WojciechNagorski) #933 Investigate hanging SingleBenchmarkCanBeExecutedForMultipleRuntimes test (assignee: @adamsitnik) #939 We need an option to stop running when the first benchmark fails. (assignee: @WojciechNagorski) #943 Dry mode doesn't work because of the ZeroMeasurementHelper (assignee: @AndreyAkinshin) #948 BenchmarkDotNet.Mathematics.StatisticalTesting.MannWhitneyTest.PValueForSmallN(int n, int m, double u) (assignee: @AndreyAkinshin) #950 MannWhitneyTest fails when comparing statistics of different sample size (assignee: @AndreyAkinshin) #955 Improve the dynamic loading of Diagnostics package (assignee: @WojciechNagorski) #961 BenchmarkRunner.RunUrl throws NRE when Config is not provided #964 Concurrency Visualizer Profiler (assignee: @adamsitnik) Merged pull requests (10) #941 Fix example code (isBaseline -> baseline) (by @PathogenDavid) #944 Fixed typo in IntroTagColumn sample (by @ahmedalejo) #947 Add option to stop running when the first benchmark fails (by @WojciechNagorski) #949 Add printDiff in DisassemblyDiagnoserAttribute (by @WojciechNagorski) #951 Add failing test for #948 (by @WojciechNagorski) #958 Use DependencyContext to load diagnostics assembly (by @WojciechNagorski) #960 Expose StatisticalTestColumn via command line arguments (by @adamsitnik) #962 Don't require the users to do manual installation of TraceEvent when using Diagnostics package (by @WojciechNagorski) #963 Stop benchmark after closing application + Flush log after stopping benchmark. (by @WojciechNagorski) #966 Fix typos in ConfigParser and CommandLineOptions (by @morgan-kn) Commits (26) d85a7e Postrelease update of v0.11.2 changelog (by @AndreyAkinshin) 8b2015 Fix ZeroMeasurementHelper for dry mode case, fixes #943 (by @AndreyAkinshin) ab8543 Fix example code (#941) (by @PathogenDavid) ec5fb2 Enable default analysers in BenchmarkTestExecutor (see #943) (by @AndreyAkinshin) fb251d Remove [DryJob] from IntroBasic (by @AndreyAkinshin) 1c1bdf Fix another problem in ZeroMeasurementAnalyser (see #943) (by @AndreyAkinshin) 348f87 make sure we prevent from inlining the benchmarks also in the dummy method ge... (by @adamsitnik) 80ecec when the parallel build fails, always try one more time in sequential way, ho... (by @adamsitnik) 042291 set the metrics unit to \"Count\", they should not be empty /cc @jorive (by @adamsitnik) 5b3657 Fixed typo in IntroTagColumn sample (#944) (by @ahmedalejo) 60ea17 Add printDiff in DisassemblyDiagnoserAttribute (#949) (by @WojciechNagorski) b6e8b1 Add failing test for #948 (#951) (by @WojciechNagorski) 3e9f73 Fix IndexOutOfRangeException in MannWhitneyTest, fixes #948 (by @AndreyAkinshin) 9f33f0 Add option to stop running when the first benchmark fails (#947) (by @WojciechNagorski) 376a97 Improve dynamic assembly loading fixes #955 (by @WojciechNagorski) 7dffd4 Handle another corner case in AdaptiveHistogramBuilder, fixes #870 (by @AndreyAkinshin) dfb3c8 ConcurrencyVisualizerProfiler diagnoser! (by @adamsitnik) 7e7dde Fix NRE in BenchmarkRunner.RunUrl, fixes #961 (by @AndreyAkinshin) 4e6531 Improve diagnostics dll (#962) (by @WojciechNagorski) 6c4a59 Stop benchmark after closing application + Flush log after stopping benchmark... (by @WojciechNagorski) 51a965 Expose StatisticalTestColumn via command line arguments (#960) (by @adamsitnik) ca188d 0.11.3 initial release notes (by @adamsitnik) adde64 Fix typos in ConfigParser and CommandLineOptions (#966) (by @morgan-kn) ab96ab make sure we cleanup the Logger after running the benchmark, otherwise AppDom... (by @adamsitnik) 91362d Update v0.11.3 changelog (by @AndreyAkinshin) e7e4b5 Set library version: 0.11.3 (by @AndreyAkinshin) Contributors (6) Adam Sitnik (@adamsitnik) Ahmed Alejo (@ahmedalejo) Andrey Akinshin (@AndreyAkinshin) David Maas (@PathogenDavid) Irina Ananeva (@morgan-kn) Wojciech Nagórski (@WojciechNagorski) Thank you very much! Additional details Date: November 20, 2018 Milestone: v0.11.3 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.3 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.3 BenchmarkDotNet v0.11.2 This release includes many PRs from the Hacktoberfest. We are very grateful to all the contributors who spent their time to help us make BenchmarkDotNet even better! Highlights In this release, we have many improvements in different areas: Diagnosers EtwProfiler (allows profiling benchmarks on Windows and exporting the data to a trace file) Execution: Comparing NuGet packages (now it's possible to compare different versions of the same package) .NET Core 3.0 support Deferred Execution Validator Command-line: --list: List of benchmarks --info: Print environment info --runtimes: Choosing execution runtimes (--runtimes net472 netcoreapp2.1 will executed a benchmark on .NET 4.7.2 and .NET Core 2.1) Options for number of invocations and iterations Custom default settings for console argument parser Case-insensitive filter Benchmarking with different CoreRun instances Hardware counters command-line support Exporters: Markdown output for DisassemblyDiagnoser Diff view for disassembler output Improved LINQPad support (colored monospaced logs) Better CPU brand strings Attributes: Async [GlobalSetup] and [GlobalCleanup] support Introduced [ParamsAllValues] Selecting Baseline across Methods and Jobs Statistics: Better statistical tests (Welch's t-test and Mann-Whitney U-test) ZeroMeasurementAnalyser RatioColumn Other: Azure Pipelines support for internal builds Many minor bug fixes Improved documentation New tests Diagnosers EtwProfiler EtwProfiler allows to profile the benchmarked .NET code on Windows and exports the data to a trace file which can be opened with PerfView or Windows Performance Analyzer. EtwProfiler uses TraceEvent library which internally uses Event Tracing for Windows (ETW) to capture stack traces and important .NET Runtime events. Before the process with benchmarked code is started, EtwProfiler starts User and Kernel ETW sessions. Every session writes data to it's own file and captures different data. User session listens for the .NET Runtime events (GC, JIT etc) while the Kernel session gets CPU stacks and Hardware Counter events. After this, the process with benchmarked code is started. During the benchmark execution all the data is captured and written to a trace file. Moreover, BenchmarkDotNet Engine emits it's own events to be able to differentiate jitting, warmup, pilot and actual workload when analyzing the trace file. When the benchmarking is over, both sessions are closed and the two trace files are merged into one. You can find more details in the documentation and in the blog post by Adam Sitnik. #878 EtwProfiler Diagnoser (by @adamsitnik) 04a715 EtwProfiler Diagnoser (#878) (by @adamsitnik) Execution Comparing NuGet packages Now it's possible to compare performance of several versions of the same NuGet package. An example: [Config(typeof(Config))] public class IntroNuGet { // Specify jobs with different versions of the same NuGet package to benchmark. // The NuGet versions referenced on these jobs must be greater or equal to the // same NuGet version referenced in this benchmark project. // Example: This benchmark project references Newtonsoft.Json 9.0.1 private class Config : ManualConfig { public Config() { var baseJob = Job.MediumRun.With(CsProjCoreToolchain.Current.Value); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"11.0.2\").WithId(\"11.0.2\")); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"11.0.1\").WithId(\"11.0.1\")); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"10.0.3\").WithId(\"10.0.3\")); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"10.0.2\").WithId(\"10.0.2\")); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"10.0.1\").WithId(\"10.0.1\")); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"9.0.1\").WithId(\"9.0.1\")); } } [Benchmark] public void SerializeAnonymousObject() => JsonConvert.SerializeObject( new { hello = \"world\", price = 1.99, now = DateTime.UtcNow }); } See also: BenchmarkDotNet.Samples.IntroNuGet #290 Question: Any official way to benchmark same method between different assembly versions? #931 Same NuGet version used when benchmarking different packages #922 Enables benchmarking betweeen different Nuget packages (by @Shazwazza) #932 Partition benchmark run info based on added nuget packages (by @blairconrad) 92a786 Enables benchmarking betweeen different Nuget packages (#922) fixes #290 (by @Shazwazza) 510685 Partition benchmark run info based on added nuget packages (#932) (by @blairconrad) cf84a4 NuGet casing fix (by @AndreyAkinshin) .NET Core 3.0 support Now it's possible to run benchmarks on preview versions of .NET Core 3.0. #874 .NET Core 3.0 support (assignee: @adamsitnik) 2e398c detect .NET Core 3.0 and use the appropriate target framework moniker, fixes ... (by @adamsitnik) Deferred Execution Validator In LINQ, execution of a query is usually deferred until the moment when you actually request the data. If your benchmark just returns IEnumerable or IQueryable it's not measuring the execution of the query, just the creation. This is why we decided to warn you about this issue whenever it happens: Benchmark IntroDeferredExecution.Wrong returns a deferred execution result (IEnumerable<Int32>). You need to either change the method declaration to return a materialized result or consume it on your own. You can use .Consume() extension method to do that. Don't worry! We are also providing you with a Consume extension method which can execute given IEnumerable or IQueryable and consume its results. All you need to do is to create a Consumer instance, preferably store it in a field (to exclude the cost of creating Consumer from the benchmark itself) and pass it to Consume extension method. Do not call .ToArray() because it's an expensive operation and it might dominate given benchmark! See also: BenchmarkDotNet.Samples.IntroDeferredExecution #858 Should the Engine iterate over and consume IEnumerable and IQueryable results? (assignee: @adamsitnik) cebe2a Deferred Execution Validator, fixes #858 (by @adamsitnik) Command-line In this release, we have tons of improvements for command-line experience. --list: List of benchmarks The --list allows you to print all of the available benchmark names. Available options are: flat - prints list of the available benchmarks: --list flat BenchmarkDotNet.Samples.Algo_Md5VsSha256.Md5 BenchmarkDotNet.Samples.Algo_Md5VsSha256.Sha256 BenchmarkDotNet.Samples.IntroArguments.Benchmark BenchmarkDotNet.Samples.IntroArgumentsSource.SingleArgument BenchmarkDotNet.Samples.IntroArgumentsSource.ManyArguments BenchmarkDotNet.Samples.IntroArrayParam.ArrayIndexOf BenchmarkDotNet.Samples.IntroArrayParam.ManualIndexOf BenchmarkDotNet.Samples.IntroBasic.Sleep [...] tree - prints tree of the available benchmarks: --list tree BenchmarkDotNet └─Samples ├─Algo_Md5VsSha256 │ ├─Md5 │ └─Sha256 ├─IntroArguments │ └─Benchmark ├─IntroArgumentsSource │ ├─SingleArgument │ └─ManyArguments ├─IntroArrayParam │ ├─ArrayIndexOf │ └─ManualIndexOf ├─IntroBasic │ ├─Sleep [...] The --list option works with the --filter option. Examples: --list flat --filter *IntroSetupCleanup* prints: BenchmarkDotNet.Samples.IntroSetupCleanupGlobal.Logic BenchmarkDotNet.Samples.IntroSetupCleanupIteration.Benchmark BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkA BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkB BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkC BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkD --list tree --filter *IntroSetupCleanup* prints: BenchmarkDotNet └─Samples ├─IntroSetupCleanupGlobal │ └─Logic ├─IntroSetupCleanupIteration │ └─Benchmark └─IntroSetupCleanupTarget ├─BenchmarkA ├─BenchmarkB ├─BenchmarkC └─BenchmarkD #905 Implement --list #914 Implement --list - fixes #905 (by @wojtpl2) #916 Update console-args.md - add information about --list option (by @wojtpl2) 330f66 Implement --list - fixes #905 (#914) (by @wojtpl2) 6c7521 Update console-args.md - add information about --list option (#916) (by @wojtpl2) --info: Print environment info Some of our users really like the info we print about hardware and OS. Now we have the --info console line argument which does not run the benchmarks, but simply prints the info. BenchmarkDotNet=v0.11.1.786-nightly, OS=Windows 10.0.17134.285 (1803/April2018Update/Redstone4) Intel Xeon CPU E5-1650 v4 3.60GHz, 1 CPU, 12 logical and 6 physical cores Frequency=3507500 Hz, Resolution=285.1033 ns, Timer=TSC .NET Core SDK=3.0.100-alpha1-009642 [Host] : .NET Core 3.0.0-preview1-27004-04 (CoreCLR 4.6.27003.04, CoreFX 4.6.27003.02), 64bit RyuJIT #904 Implement --info #907 fixes #904 Implement --info (by @lahma) 4be28d fixes #904 Implement --info (#907) (by @lahma) --runtimes: Choosing execution runtimes The --runtimes or just -r allows you to run the benchmarks for selected Runtimes. Available options are: Mono, CoreRT, Core, Clr net46, net461, net462, net47, net471, net472, netcoreapp2.0, netcoreapp2.1, netcoreapp2.2, netcoreapp3.0. Example: run the benchmarks for .NET 4.7.2 and .NET Core 2.1: dotnet run -c Release -- --runtimes net472 netcoreapp2.1 #913 .NET Core Toolchains improvements (by @adamsitnik) 0f721c make it possible to specify runtimes using explicit tfms like net472 or netco... (by @adamsitnik) 1c581e .NET Core Toolchains improvements (#913) (by @adamsitnik) Options for number of invocations and iterations --launchCount - how many times we should launch process with target benchmark. The default is 1. --warmupCount - how many warmup iterations should be performed. If you set it, the minWarmupCount and maxWarmupCount are ignored. By default calculated by the heuristic. --minWarmupCount - minimum count of warmup iterations that should be performed. The default is 6. --maxWarmupCount - maximum count of warmup iterations that should be performed. The default is 50. --iterationTime - desired time of execution of an iteration. Used by Pilot stage to estimate the number of invocations per iteration. 500ms by default. --iterationCount - how many target iterations should be performed. By default calculated by the heuristic. --minIterationCount - minimum number of iterations to run. The default is 15. --maxIterationCount - maximum number of iterations to run. The default is 100. --invocationCount - invocation count in a single iteration. By default calculated by the heuristic. --unrollFactor - how many times the benchmark method will be invoked per one iteration of a generated loop. 16 by default --runOncePerIteration - run the benchmark exactly once per iteration. False by default. Example: run single warmup iteration, from 9 to 12 actual workload iterations. dotnet run -c Release -- --warmupCount 1 --minIterationCount 9 --maxIterationCount 12 #902 More command line args (by @adamsitnik) ba0d22 allow to configure the number of invocations and iterations from command line (by @adamsitnik) Custom default settings for console argument parser If you want to have a possibility to specify custom default Job settings programmatically and optionally overwrite it with console line arguments, then you should create a global config with single job marked as .AsDefault and pass it to BenchmarkSwitcher together with the console line arguments. Example: run single warmup iteration by default. static void Main(string[] args) => BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args, GetGlobalConfig()); static IConfig GetGlobalConfig() => DefaultConfig.Instance .With(Job.Default .WithWarmupCount(1) .AsDefault()); // the KEY to get it working Now, the default settings are: WarmupCount=1 but you might still overwrite it from console args like in the example below: dotnet run -c Release -- --warmupCount 2 Case-insensitive filter The --filter or just -f allows you to filter the benchmarks by their full name (namespace.typeName.methodName) using glob patterns. Examples: Run all benchmarks from System.Memory namespace: -f System.Memory* Run all benchmarks: -f * Run all benchmarks from ClassA and ClassB -f *ClassA* *ClassB* Now this filter expression is case-insensitive. #864 Make the filter case insensitive (assignee: @adamsitnik) 106777 make the filter case insensitive invariant culture, fixes #864 (by @adamsitnik) Benchmarking with different CoreRun instances CoreRun is a simpler version of dotnet run, used for developing CoreCLR and CoreFX. Typically when working on the performance of .NET Core a developer has more than 1 copy of CoreRun. Example: CoreRun before my changes, and after my changes. This change allows to simply run same benchmark for few different CoreRuns to compare the perf in easy way. Sample usage: dotnet run -c Release -f netcoreapp2.1 -- -f *Empty.method --job dry --coreRun C:\\Projects\\coreclr_upstream\\bin\\tests\\Windows_NT.x64.Release\\Tests\\Core_Root\\CoreRun.exe C:\\Projects\\coreclr_upstream\\bin\\tests\\Windows_NT.x64.Release\\Tests\\Core_Root_beforeMyChanges\\CoreRun.exe Sample output: #925 Make it possible to run the benchmark with multiple CoreRun.exe (assignee: @adamsitnik) 901616 when user provides CoreRun path and runtime in explicit way, we should use th... (by @adamsitnik) 46bebf allow the users to run the same benchmarks using few different CoreRun.exe, f... (by @adamsitnik) Hardware counters command-line support --counters CacheMisses+InstructionRetired 1e3df7 make it possible to specify hardware counters from command line (by @adamsitnik) a4f91a better handling of edge cases for parsing hardware counters from the console ... (by @adamsitnik) Exporters Markdown output for DisassemblyDiagnoser Now DisassemblyDiagnoser generates markdown version of the assembly listing. #560 Suggestion: markdown output for DisassemblyDiagnoser (assignee: @adamsitnik) 1e6235 github markdown exporter for Disassembler, fixes #560 (by @adamsitnik) Diff view for disassembler output Now we have PrettyGithubMarkdownDiffDisassemblyExporter which can generates nice diffs between assembly listings. This mode can be activated via the --disasmDiff command line argument or the printDiff: true argument of DisassemblyDiagnoserConfig. An output example (Diff between SumLocal and SumField on .NET Core 2.1.4 (CoreCLR 4.6.26814.03, CoreFX 4.6.26814.02), 64bit RyuJIT) -; BenchmarkDotNet.Samples.IntroDisassemblyRyuJit.SumLocal() - var local = field; // we use local variable that points to the field - ^^^^^^^^^^^^^^^^^^ - mov rax,qword ptr [rcx+8] +; BenchmarkDotNet.Samples.IntroDisassemblyRyuJit.SumField() int sum = 0; ^^^^^^^^^^^^ - xor edx,edx - for (int i = 0; i < local.Length; i++) + xor eax,eax + for (int i = 0; i < field.Length; i++) ^^^^^^^^^ - xor ecx,ecx - for (int i = 0; i < local.Length; i++) + xor edx,edx + for (int i = 0; i < field.Length; i++) ^^^^^^^^^^^^^^^^ - mov r8d,dword ptr [rax+8] - test r8d,r8d + mov rcx,qword ptr [rcx+8] + cmp dword ptr [rcx+8],0 jle M00_L01 - sum += local[i]; + sum += field[i]; ^^^^^^^^^^^^^^^^ M00_L00: - movsxd r9,ecx - add edx,dword ptr [rax+r9*4+10h] - for (int i = 0; i < local.Length; i++) + mov r8,rcx + cmp edx,dword ptr [r8+8] + jae 00007ff9`0c412c1f + movsxd r9,edx + add eax,dword ptr [r8+r9*4+10h] + for (int i = 0; i < field.Length; i++) ^^^ - inc ecx - cmp r8d,ecx + inc edx + cmp dword ptr [rcx+8],edx jg M00_L00 return sum; ^^^^^^^^^^^ M00_L01: - mov eax,edx -; Total bytes of code 34 + add rsp,28h +; Total bytes of code 42 #544 Diff view for disassembler output (assignee: @wojtpl2) #927 Improve Disassembly exporters and add PrettyGithubMarkdownDiffDisassemblyExporter (by @wojtpl2) #936 Producing the asm diff reports on demand #937 Producing the asm diff reports on demand - fix for #936 (by @wojtpl2) 1903a1 Improve Disassembly exporters and add PrettyGithubMarkdownDiffDisassemblyExpo... (by @wojtpl2) dd103b Producing the asm diff reports on demand - fixes #936 (#937) (by @wojtpl2) Improved LINQPad support If you run BenchmarkDotNet v0.11.2+ in LINQPad, your logs will be colored and monospaced: #447 Implement ColoredLogger for LinqPad #903 Add LINQPad logging (by @bgrainger) #915 Use a monospaced font for LINQPad logging output (by @bgrainger) c3b609 Add LINQPad logging (#903) (by @bgrainger) 10fdd0 Use a monospaced font for LINQPad logging output. (#915) (by @bgrainger) Better CPU brand strings We did a lot of changes which improve the presentation form of the CPU brand string. Here is an example of such string in the previous version of BenchmarkDotNet: AMD Ryzen 7 2700X Eight-Core Processor (Max: 4.10GHz), 1 CPU, 16 logical and 8 physical cores Now it becomes: AMD Ryzen 7 2700X 4.10GHz, 1 CPU, 16 logical and 8 physical cores As you can see, \"Eight-Core Processor\" was removed (because we already have \"8 physical cores\"); \"(Max: 4.10GHz)\" was replaced by 4.10GHz (because the original CPU brand string doesn't contain the nominal frequency). #859 Strange max frequency values on Windows (assignee: @Rizzen) #909 Improve CPU Brand Strings without frequency #860 Fix strange CPU Frequency values (by @Rizzen) #910 Simplify AMD Ryzen CPU brand info (by @lahma) a78b38 Fix strange CPU Frequency values (#860) (by @Rizzen) 5df1e6 Simplify AMD Ryzen CPU brand info (#910) (by @lahma) Attributes Async GlobalSetup and GlobalCleanup Now GlobalSetup and GlobalCleanup methods can be async. See also: docs.setup-and-cleanup #521 Support async Setup/Cleanup #892 Added support for async GlobalSetup. (by @dlemstra) #923 async GlobalCleanup support (by @dlemstra) #926 Added support for async GlobalCleanup. (by @dlemstra) e0f7a6 Added support for async GlobalSetup. (#892) (by @dlemstra) a971a4 async GlobalCleanup support (#923) (by @dlemstra) e4c7b8 Added support for async GlobalCleanup. (#926), fixes #521 (by @dlemstra) Introduced ParamsAllValues If you want to use all possible values of an enum or another type with a small number of values, you can use the [ParamsAllValues] attribute, instead of listing all the values by hand. The types supported by the attribute are: bool any enum that is not marked with [Flags] Nullable<T>, where T is an enum or boolean An example: public class IntroParamsAllValues { public enum CustomEnum { A, BB, CCC } [ParamsAllValues] public CustomEnum E { get; set; } [ParamsAllValues] public bool? B { get; set; } [Benchmark] public void Benchmark() { Thread.Sleep( E.ToString().Length * 100 + (B == true ? 20 : B == false ? 10 : 0)); } } Output: Method | E | B | Mean | Error | ---------- |---- |------ |---------:|------:| Benchmark | A | ? | 101.9 ms | NA | Benchmark | A | False | 111.9 ms | NA | Benchmark | A | True | 122.3 ms | NA | Benchmark | BB | ? | 201.5 ms | NA | Benchmark | BB | False | 211.8 ms | NA | Benchmark | BB | True | 221.4 ms | NA | Benchmark | CCC | ? | 301.8 ms | NA | Benchmark | CCC | False | 312.3 ms | NA | Benchmark | CCC | True | 322.2 ms | NA | // * Legends * E : Value of the 'E' parameter B : Value of the 'B' parameter #658 [Params] for enums should include all values by default #908 Added [ParamsAllValues] (by @gsomix) 922dff Added [ParamsAllValues] (#908), fixes #658 (by @gsomix) 846d08 ParamsAllValuesValidator fixes (by @AndreyAkinshin) Selecting Baseline across Methods and Jobs Now it's possible to mark a method and a job as baselines at the same time: public class TheBaselines { [Benchmark(Baseline = true)] public void Sleep100ms() => Thread.Sleep(TimeSpan.FromMilliseconds(100)); [Benchmark] public void Sleep50ms() => Thread.Sleep(TimeSpan.FromMilliseconds(50)); } static void Main(string[] args) => BenchmarkSwitcher .FromTypes(new[] { typeof(TheBaselines) }) .Run(args, DefaultConfig.Instance .With(Job.Core.AsBaseline()) .With(Job.Clr.WithId(\"CLR 4.7.2\"))); #880 Select Baseline across Methods and Jobs (assignee: @AndreyAkinshin) 21a007 Support method-job baseline pairs, fixes #880 (by @AndreyAkinshin) Statistics Statistical tests In this release, statistical testing was significantly improved. Now it's possible to compare all benchmarks against baseline with the help of Welch's t-test or Mann–Whitney U test. An example: [StatisticalTestColumn( StatisticalTestKind.Welch, ThresholdUnit.Microseconds, 1, true)] [StatisticalTestColumn( StatisticalTestKind.MannWhitney, ThresholdUnit.Microseconds, 1, true)] [StatisticalTestColumn( StatisticalTestKind.Welch, ThresholdUnit.Ratio, 0.03, true)] [StatisticalTestColumn( StatisticalTestKind.MannWhitney, ThresholdUnit.Ratio, 0.03, true)] [SimpleJob(warmupCount: 0, targetCount: 5)] public class IntroStatisticalTesting { [Benchmark] public void Sleep50() => Thread.Sleep(50); [Benchmark] public void Sleep97() => Thread.Sleep(97); [Benchmark] public void Sleep99() => Thread.Sleep(99); [Benchmark(Baseline = true)] public void Sleep100() => Thread.Sleep(100); [Benchmark] public void Sleep101() => Thread.Sleep(101); [Benchmark] public void Sleep103() => Thread.Sleep(103); [Benchmark] public void Sleep150() => Thread.Sleep(150); } Output: Method Mean Error StdDev Ratio Welch(1us)/p-values Welch(3%)/p-values MannWhitney(1us)/p-values MannWhitney(3%)/p-values Sleep50 53.13 ms 0.5901 ms 0.1532 ms 0.51 Faster: 1.0000/0.0000 Faster: 1.0000/0.0000 Faster: 1.0000/0.0040 Faster: 1.0000/0.0040 Sleep97 100.07 ms 0.9093 ms 0.2361 ms 0.97 Faster: 1.0000/0.0000 Same: 1.0000/0.1290 Faster: 1.0000/0.0040 Same: 1.0000/0.1111 Sleep99 102.23 ms 2.4462 ms 0.6353 ms 0.99 Faster: 0.9928/0.0072 Same: 1.0000/0.9994 Faster: 0.9960/0.0079 Same: 1.0000/1.0000 Sleep100 103.34 ms 0.8180 ms 0.2124 ms 1.00 Base: 0.5029/0.5029 Base: 1.0000/1.0000 Base: 0.7262/0.7262 Base: 1.0000/1.0000 Sleep101 103.73 ms 2.1591 ms 0.5607 ms 1.00 Same: 0.1041/0.8969 Same: 0.9999/1.0000 Same: 0.1111/0.9246 Same: 1.0000/1.0000 Sleep103 106.21 ms 1.2511 ms 0.3249 ms 1.03 Slower: 0.0000/1.0000 Same: 0.9447/1.0000 Slower: 0.0040/1.0000 Same: 0.9246/1.0000 Sleep150 153.16 ms 3.4929 ms 0.9071 ms 1.48 Slower: 0.0000/1.0000 Slower: 0.0000/1.0000 Slower: 0.0040/1.0000 Slower: 0.0040/1.0000 // * Legends * Mean : Arithmetic mean of all measurements Error : Half of 99.9% confidence interval StdDev : Standard deviation of all measurements Ratio : Mean of the ratio distribution ([Current]/[Baseline]) Welch(1us)/p-values : Welch-based TOST equivalence test with 1 us threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' Welch(3%)/p-values : Welch-based TOST equivalence test with 3% threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' MannWhitney(1us)/p-values : MannWhitney-based TOST equivalence test with 1 us threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' MannWhitney(3%)/p-values : MannWhitney-based TOST equivalence test with 3% threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' 1 ms : 1 Millisecond (0.001 sec) The statistical testing is a work-in-progress feature. In future versions of BenchmarkDotNet, we are planning to improve API, fill missed docs, and introduce more parameters for customization. See also: BenchmarkDotNet.Samples.IntroStatisticalTesting 60eca0 Threshold API for WelchTTest; Improve Student accuracy for small n (by @AndreyAkinshin) 05cc8d Statistical testing improvements (by @AndreyAkinshin) ZeroMeasurementAnalyser When you have an empty benchmark like this [Benchmark] public void Empty() { } The expected duration of this method is zero. However, you can get the mean value like 0.0023ns because of the natural noise. It's a pretty confusing result for many developers. Since v0.11.2, we have ZeroMeasurementAnalyser which warn you about such methods. By default, BenchmarkDotNet automatically evaluate overhead. In this case, ZeroMeasurementAnalyser runs Welch's t-test and compare actual and overhead measurements. If the overhead evaluation is disabled, it runs one-sample Student's t-test against a half of CPU cycle. #906 Zero measurement analyser (by @Rizzen) 48d193 Zero measurement analyser (#906) (by @Rizzen) RatioColumn The Ratio column was formerly known as Scaled. The old title was a source of misunderstanding and confusion because many developers interpreted it as the ratio of means (e.g., 50.46/100.39 for Time50). The ratio of distribution means and the mean of the ratio distribution are pretty close to each other in most cases, but they are not equal. See also: BenchmarkDotNet.Samples.IntroBenchmarkBaseline, BenchmarkDotNet.Samples.IntroRatioSD, Benchmark and Job Baselines. 4e64c9 Ratio/RatioSD columns (by @AndreyAkinshin) Milestone details In the v0.11.2 scope, 28 issues were resolved and 33 pull requests were merged. This release includes 84 commits by 20 contributors. Resolved issues (28) #221 Investigate why CanEnableServerGcMode test fails for Core on appveyor #290 Question: Any official way to benchmark same method between different assembly versions? #447 Implement ColoredLogger for LinqPad #521 Support async Setup/Cleanup #544 Diff view for disassembler output (assignee: @WojciechNagorski) #560 Suggestion: markdown output for DisassemblyDiagnoser (assignee: @adamsitnik) #601 Surprising results #658 [Params] for enums should include all values by default #731 Add constant folding analyser #788 Detect correct version of .NET Core in Docket container #842 Benchmark filter: wildcards on *nix CLI (assignee: @adamsitnik) #858 Should the Engine iterate over and consume IEnumerable and IQueryable results? (assignee: @adamsitnik) #859 Strange max frequency values on Windows (assignee: @Rizzen) #862 Don't print parse errors to the output (assignee: @adamsitnik) #863 Make it easier to understand which process belongs to which benchmark (assignee: @adamsitnik) #864 Make the filter case insensitive (assignee: @adamsitnik) #874 .NET Core 3.0 support (assignee: @adamsitnik) #879 Benchmark attributed with \"HardwareCounters\" throws an exception (assignee: @adamsitnik) #880 Select Baseline across Methods and Jobs (assignee: @AndreyAkinshin) #889 ArgumentsSource doesn't work if method takes 1 arg (assignee: @adamsitnik) #891 Add docs about debugging BDN issues (assignee: @adamsitnik) #904 Implement --info #905 Implement --list #909 Improve CPU Brand Strings without frequency #911 Excluding specific namespaces from disassembly (assignee: @adamsitnik) #925 Make it possible to run the benchmark with multiple CoreRun.exe (assignee: @adamsitnik) #931 Same NuGet version used when benchmarking different packages #936 Producing the asm diff reports on demand Merged pull requests (33) #860 Fix strange CPU Frequency values (by @Rizzen) #878 EtwProfiler Diagnoser (by @adamsitnik) #886 Enabled GcModeTests.CanEnableServerGcMode (by @dlemstra) #887 Dependencies update (by @adamsitnik) #888 Fix duplicate example in RunStrategy guide (by @SteveDesmond-ca) #890 RPlotExporter: use https to download dependencies (by @xavero) #892 Added support for async GlobalSetup. (by @dlemstra) #894 Fix GlobalCleanupAttributeTest.GlobalCleanupMethodRunsTest (by @dlemstra) #898 Add workaround for Full framework on *NIX (by @mfilippov) #900 Fixing aspnet/KestrelHttpServer url (by @facundofarias) #901 Fixing SignalR and EntityFrameworkCore url as well (by @facundofarias) #902 More command line args (by @adamsitnik) #903 Add LINQPad logging (by @bgrainger) #906 Zero measurement analyser (by @Rizzen) #907 fixes #904 Implement --info (by @lahma) #908 Added [ParamsAllValues] (by @gsomix) #910 Simplify AMD Ryzen CPU brand info (by @lahma) #913 .NET Core Toolchains improvements (by @adamsitnik) #914 Implement --list - fixes #905 (by @WojciechNagorski) #915 Use a monospaced font for LINQPad logging output (by @bgrainger) #916 Update console-args.md - add information about --list option (by @WojciechNagorski) #917 Add Azure Pipelines support (by @Ky7m) #920 OCD Whitespace and tabs cleanup (by @dlemstra) #922 Enables benchmarking betweeen different Nuget packages (by @Shazwazza) #923 async GlobalCleanup support (by @dlemstra) #926 Added support for async GlobalCleanup. (by @dlemstra) #927 Improve Disassembly exporters and add PrettyGithubMarkdownDiffDisassemblyExporter (by @WojciechNagorski) #929 Add build status badges for Azure Pipelines (by @Ky7m) #930 Fix minor spelling issues and typos (by @KonH) #932 Partition benchmark run info based on added nuget packages (by @blairconrad) #934 Detect correct version of .NET Core in Docker (by @Rizzen) #935 Add Timeout for dotnet cli build commands to our toolchains (by @adamsitnik) #937 Producing the asm diff reports on demand - fix for #936 (by @WojciechNagorski) Commits (84) 22b020 Postrelease update of v0.11.1 changelog (by @AndreyAkinshin) 3e26df docs: fix NuGet package lists in footers (v0.11.x) (by @AndreyAkinshin) cebe2a Deferred Execution Validator, fixes #858 (by @adamsitnik) 50fd57 exported json file should contain correct type name for generic types, not Ge... (by @adamsitnik) 30b885 benchmarked code can be defining IHost so we need to provide full name (examp... (by @adamsitnik) b7104e Don't print parse errors to the output, fixes #862 (by @adamsitnik) 3a21b4 Make it easier to understand which process belongs to which benchmark, fixes ... (by @adamsitnik) 99ea2d Fix behavior of Baseline property of Benchmark attribute in integration with ... (by @Caballero77) 2e398c detect .NET Core 3.0 and use the appropriate target framework moniker, fixes ... (by @adamsitnik) ff1214 Update IntroSetupCleanupTarget.md (#876) (by @fredeil) 1721b4 Fixed typo in the NodaTime name (#877) (by @YohDeadfall) f411a5 Fix typo in example code (#869) (by @NRKirby) 21a007 Support method-job baseline pairs, fixes #880 (by @AndreyAkinshin) a78b38 Fix strange CPU Frequency values (#860) (by @Rizzen) 60eca0 Threshold API for WelchTTest; Improve Student accuracy for small n (by @AndreyAkinshin) 05cc8d Statistical testing improvements (by @AndreyAkinshin) 557752 Fix compilation (by @AndreyAkinshin) a03307 Enabled GcModeTests.CanEnableServerGcMode (#886) fixes #221 (by @dlemstra) add585 Fix duplicate example in RunStrategy guide (#888) (by @SteveDesmond-ca) d8b008 Use NoInlining for CommonExporterApprovalTests (by @AndreyAkinshin) eacfd7 Dependencies update (#887) (by @adamsitnik) 579986 improve the docs, explain how to use ArgumentsSource for single arugment, fix... (by @adamsitnik) 1ceee3 Fix compilation after merge (by @AndreyAkinshin) 9ff772 RPlotExporter: use https to download dependencies (#890) (by @xavero) 41d6b8 added xml docs, made some methods virtual/public to make it easier to write y... (by @adamsitnik) cd0791 restore --no-dependencies was good when we were generating multiple projects,... (by @adamsitnik) ad1feb expose KeepBenchmarkFiles as --keepFiles command line argument, #891 (by @adamsitnik) 6880b5 add DebugInProcessConfig and DebugBuildConfig to make troubleshooting easier,... (by @adamsitnik) 12e01a add Troubleshooting docs, fixes #891 (by @adamsitnik) 106777 make the filter case insensitive invariant culture, fixes #864 (by @adamsitnik) 1b8051 wrap * in '*' on Unix when showing users the help, fixes #842 (by @adamsitnik) 382a4a Fix GlobalCleanupAttributeTest.GlobalCleanupMethodRunsTest (#894) (by @dlemstra) 0f721c make it possible to specify runtimes using explicit tfms like net472 or netco... (by @adamsitnik) 1e3df7 make it possible to specify hardware counters from command line (by @adamsitnik) ba0d22 allow to configure the number of invocations and iterations from command line (by @adamsitnik) b90be6 Add workaround for Full framework on *NIX (#898) (by @mfilippov) 4afdb8 Fixing aspnet/KestrelHttpServer url (#900) (by @facundofarias) 3319ab Fixing SignalR and EntityFrameworkCore url as well (#901) (by @facundofarias) b72aab allow the users to specify programmatically custom default job settings and o... (by @adamsitnik) 2e7042 Merge pull request #902 from dotnet/moreCommandLineArgs (by @adamsitnik) 04a715 EtwProfiler Diagnoser (#878) (by @adamsitnik) 220bae DotNetCliGenerator.TargetFrameworkMoniker must be public (by @adamsitnik) 4e64c9 Ratio/RatioSD columns (by @AndreyAkinshin) 177c07 Add Windows 10 (1809) in OsBrandStringHelper (by @AndreyAkinshin) 4be28d fixes #904 Implement --info (#907) (by @lahma) c3b609 Add LINQPad logging (#903) (by @bgrainger) 922dff Added [ParamsAllValues] (#908), fixes #658 (by @gsomix) 1e6235 github markdown exporter for Disassembler, fixes #560 (by @adamsitnik) 330f66 Implement --list - fixes #905 (#914) (by @WojciechNagorski) 10fdd0 Use a monospaced font for LINQPad logging output. (#915) (by @bgrainger) 846d08 ParamsAllValuesValidator fixes (by @AndreyAkinshin) 1c581e .NET Core Toolchains improvements (#913) (by @adamsitnik) 8949df BenchmarkSwitcher should ask the user for choosing the benchmarks when the gl... (by @adamsitnik) fb8f89 Make WindowsDisassembler public to allow for late resutls filtering in diagno... (by @adamsitnik) 0bcbce allow configuring disasm recursive depth from console line arguments; --todo; (by @adamsitnik) 5e3cee make sure BenchmarkSwitcher handles all possible cases and gives nice errors (by @adamsitnik) 6c7521 Update console-args.md - add information about --list option (#916) (by @WojciechNagorski) 8773ff when user provides categories via command line to benchmark switcher we don't... (by @adamsitnik) 901616 when user provides CoreRun path and runtime in explicit way, we should use th... (by @adamsitnik) 5df1e6 Simplify AMD Ryzen CPU brand info (#910) (by @lahma) 1b4c7f OCD Whitespace and tabs cleanup (#920) (by @dlemstra) d917e6 don't parse the trace file if there are no counters configured, wait for dela... (by @adamsitnik) e0f7a6 Added support for async GlobalSetup. (#892) (by @dlemstra) 46bebf allow the users to run the same benchmarks using few different CoreRun.exe, f... (by @adamsitnik) a4f91a better handling of edge cases for parsing hardware counters from the console ... (by @adamsitnik) 98925b initial 0.11.2 release notes (by @adamsitnik) a971a4 async GlobalCleanup support (#923) (by @dlemstra) e4c7b8 Added support for async GlobalCleanup. (#926), fixes #521 (by @dlemstra) 92a786 Enables benchmarking betweeen different Nuget packages (#922) fixes #290 (by @Shazwazza) 601c66 Add Azure Pipelines support (#917) (by @Ky7m) f9ac68 Add build status badges (#929) (by @Ky7m) 8a2eec Fix minor spelling issues and typos (#930) (by @KonH) 510685 Partition benchmark run info based on added nuget packages (#932) (by @blairconrad) 1903a1 Improve Disassembly exporters and add PrettyGithubMarkdownDiffDisassemblyExpo... (by @WojciechNagorski) 48d193 Zero measurement analyser (#906) (by @Rizzen) cf84a4 NuGet casing fix (by @AndreyAkinshin) fd459f Remove remark about prerelease version in etwprofiler.md (by @AndreyAkinshin) db444c Add Timeout for dotnet cli build commands to our toolchains (#935) fixes #933 (by @adamsitnik) bb0b18 Detect correct version of .NET Core in Docker (#934), fixes #788 (by @Rizzen) dd103b Producing the asm diff reports on demand - fixes #936 (#937) (by @WojciechNagorski) 864400 Update v0.11.2 changelog (by @AndreyAkinshin) 15c035 Minor IntroSamples fixes (by @AndreyAkinshin) a5b692 Update v0.11.2 changelog (by @AndreyAkinshin) 2341c7 Set library version: 0.11.2 (by @AndreyAkinshin) Contributors (20) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Blair Conrad (@blairconrad) Bradley Grainger (@bgrainger) Caballero77 (@Caballero77) Dirk Lemstra (@dlemstra) Evgeniy Andreev (@gsomix) Facundo Farias (@facundofarias) Flavio Coelho (@xavero) Fredrik Eilertsen (@fredeil) Igor Fesenko (@Ky7m) KonH (@KonH) Mark Tkachenko (@Rizzen) Marko Lahma (@lahma) Mikhail Filippov (@mfilippov) Nick Kirby (@NRKirby) Shannon Deminick (@Shazwazza) Steve Desmond (@SteveDesmond-ca) Wojciech Nagórski (@WojciechNagorski) Yoh Deadfall (@YohDeadfall) Thank you very much! Additional details Date: November 1, 2018 Milestone: v0.11.2 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.2 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.2 BenchmarkDotNet v0.11.1 This release includes some minor improvements and bug fixes: Fixed RPlotExporter (#852, #855). In v0.11.0, the plot generation was broken because of the huge renaming in #787. ArgumentsSource now supports additional types like Type (#840), BigInteger (#850), DateTime (#853), and special double values like double.NaN (#851) Generated projects ignore Directory.Build.props and Directory.Build.targets files #854 Now it's possible to run benchmarks with CoreRun (de152c, #857) Milestone details In the v0.11.1 scope, 7 issues were resolved and 2 pull requests were merged. This release includes 29 commits by 4 contributors. Resolved issues (7) #840 ArgumentsSource doesn't work with System.RuntimeType (assignee: @AndreyAkinshin) #850 Handle BigIntegers arguments properly (assignee: @adamsitnik) #851 Handle double special values like NaN etc (assignee: @adamsitnik) #852 BuildPlots script generates empty pictures (assignee: @AndreyAkinshin) #853 ArgumentsSource containing IFormattable leads to Compile Exceptions (assignee: @adamsitnik) #855 Empty plot (assignee: @AndreyAkinshin) #857 Improve user experience for working with local CoreFX builds (assignee: @adamsitnik) Merged pull requests (2) #839 Small Typo in changelog (by @Tornhoof) #854 Exclude Directory.Build.props/targets from generated csproj files (by @agocke) Commits (29) c37aa8 Postrelease update of v0.11.0 changelog (by @AndreyAkinshin) b7f7fc Handle private types in GetCorrectCSharpTypeName, fixes #840 (by @AndreyAkinshin) 522158 Handle private types in GetCorrectCSharpTypeName (part 2), fixes #840 (by @AndreyAkinshin) 64acde small typo (#839) (by @Tornhoof) 521c22 Add travis_wait for build.sh (by @AndreyAkinshin) a8a0da Update BenchmarkDotNet.sln.DotSettings (by @AndreyAkinshin) 9ab58a Introduce BenchmarkDotNet.Samples.csproj.DotSettings (by @AndreyAkinshin) 3ce9fe BenchmarkDotNet.Samples Cleanup (by @AndreyAkinshin) a04a23 Cleanup: spelling issues in BenchmarkDotNet (by @AndreyAkinshin) c37784 Cleanup: code style issues in BenchmarkDotNet (by @AndreyAkinshin) 5f8452 Cleanup: Redundancies in Code issues in BenchmarkDotNet (by @AndreyAkinshin) a76f43 Cleanup: Common Practices and Code Improvements in BenchmarkDotNet (by @AndreyAkinshin) 2d0629 Cleanup: Redundancies in Symbol Declarations Issues in BenchmarkDotNet (by @AndreyAkinshin) 5a7689 Cleanup: Constraints Violations Issues in BenchmarkDotNet (by @AndreyAkinshin) 02df24 Cleanup: Language Usage Opportunities in BenchmarkDotNet (by @AndreyAkinshin) 93ed39 Cleanup: Potential Code Quality Issues in BenchmarkDotNet (by @AndreyAkinshin) 538f56 Cleanup: more issues in BenchmarkDotNet (by @AndreyAkinshin) 559773 Cleanup: more issues in BenchmarkDotNet (by @AndreyAkinshin) 29471e add support for BigIntegers + include namespace of the arugments, fixes #850 (by @adamsitnik) 2aff9f Handle double and float special values like NaN, PositiveInfinity etc, fixes ... (by @adamsitnik) 1a68ed properties of SummaryStyle must have public setter (by @adamsitnik) 5cfb5b support DateTimes for [Arguments/Params Source], fixes #853 (by @adamsitnik) 2be698 Fix RPlots, fixes #852 (by @AndreyAkinshin) 7ee3cf Exclude Directory.Build.props/targets from generated csproj files (by @agocke) 20e901 Merge pull request #854 from agocke/fix-csproj-template (by @adamsitnik) de152c allow the users to run benchmarks with CoreRun, #857 (by @adamsitnik) f00ac0 Increase travis timeout (by @AndreyAkinshin) 071e58 docs: add changelog for v0.11.1 (by @AndreyAkinshin) c5e586 Set library version: 0.11.1 (by @AndreyAkinshin) Contributors (4) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Andy Gocke (@agocke) Stefan (@Tornhoof) Thank you very much! Additional details Date: August 22, 2018 Milestone: v0.11.1 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.1 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.1 BenchmarkDotNet v0.11.0 This is one of the biggest releases of BenchmarkDotNet ever. There are so many improvements. We have new documentation, many performance improvements, Job Mutators, better user experience, correct Ctrl+C handling, better generic benchmarks support, more scenarios for passing arguments to benchmarks, awesome support of console arguments, unicode support, LLVM support in MonoDisassembler, and many-many other improvements and bug fixes! A big part of the features and bug fixes were implemented to meet the enterprise requirements of Microsoft to make it possible to port CoreCLR, CoreFX, and CoreFXLab to BenchmarkDotNet. The release would not be possible without many contributions from amazing community members. This release is a combined effort. We build BenchmarkDotNet together to make benchmarking .NET code easy and available to everyone for free! New documentation We have many improvements in our documentation! The new docs include: DocFX under the hood Detailed changelogs which includes all commits, merged pull requests and resolved issues API references Code samples for main features: we generate it automatically based on the BenchmarkDotNet.Samples project; it means that all samples can always be compiled (no more samples with outdated API) Better UI Documentation versioning: now it's possible to look at the documentation for recent BenchmarkDotNet versions Performance improvements BenchmarkDotNet needs to be capable of running few thousands of CoreFX and CoreCLR benchmarks in an acceptable amount of time. The code itself was already optimized so we needed architectural and design changes to meet this requirement. Generate one executable per runtime settings To ensure that the side effects of one benchmark run does not affect another benchmark run BenchmarkDotNet generates, builds and runs every benchmark in a dedicated process. So far we were generating and building one executable per benchmark, now we generate and build one executable per runtime settings. So if you want to run ten thousands of benchmarks for .NET Core 2.1 we are going to generate and build single executable, not ten thousand. If you target multiple runtimes the build is going to be executed in parallel. Moreover, if one of the parallel builds fail it's going to be repeated in a sequential way. Previously the time to generate and build 650 benchmarks from our Samples project was one hour. Now it's something around 13 seconds which means 276 X improvement for this particular scenario. You can see the changes here. Don't execute long operations more than once per iteration BenchmarkDotNet was designed to allow for very accurate and stable micro-benchmarking. One of the techniques that we use is manual loop unrolling. In practice, it meant that for every iteration we were executing the benchmark at least 16 times (the default UnrollFactor value). It was of course not desired for the very time-consuming benchmarks. So far this feature was always enabled by default and users would need to configure UnrollFactor=1 to disable it. Now BenchmarkDotNet is going to discover such scenario and don't perform manual loop unrolling for the very time-consuming benchmarks. BenchmarkDotNet uses Job.IterationTime setting (the default is 0.5s) in the Pilot Experiment stage to determine how many times given benchmark should be executed per iteration. Example: public class Program { static void Main() => BenchmarkRunner.Run<Program>(); [Benchmark] public void Sleep1s() => Thread.Sleep(TimeSpan.FromSeconds(1)); } Time to run with the previous version: 374 seconds. With 0.11.0 it's 27 seconds which gives us almost 14 X improvement. A good example of benchmarks that are going to benefit from this change are computer game benchmarks and ML.NET benchmarks. You can see the changes here and here. Exposing more configuration settings The default settings were configured to work well with every scenario. Before running the benchmark, BenchmarkDotNet does not know anything about it. This is why it performs many warmup iterations before running the benchmarks. When you author benchmarks and run them many times you can come up with custom settings that produce similar results but in a shorter manner of time. To allow you to do that we have exposed: Job.MinIterationCount (default value is 15) Job.MaxIterationCount (default value is 100) Job.MinWarmupIterationCount (default value is 6) Job.MaxWarmupIterationCount (default value is 50) User Experience One of the biggest success factors of BenchmarkDotNet is a great user experience. The tool just works as expected and makes your life easy. We want to make it even better! .NET Standard 2.0 We have ported BenchmarkDotNet to .NET Standard 2.0 and thanks to that we were able to not only simplify our code and build process but also merge BenchmarkDotNet.Core.dll and BenchmarkDotNet.Toolchains.Roslyn.dll into BenchmarkDotNet.dll. We still support .NET 4.6 but we have dropped .NET Core 1.1 support. More information and full discussion can be found here. Note: Our BenchmarkDotNet.Diagnostics.Windows package which uses EventTrace to implement ETW-based diagnosers was also ported to .NET Standard 2.0 and you can now use all the ETW diagnosers with .NET Core on Windows. We plan to add EventPipe support and make this page fully cross-platform and Unix compatible soon. Using complex types as benchmark arguments So far we have required the users to implement IParam interface to make the custom complex types work as benchmark arguments/parameters. This has changed, now the users can use any complex types as arguments and it will just work (more). public class Program { static void Main(string[] args) => BenchmarkRunner.Run<Program>(); public IEnumerable<object> Arguments() { yield return new Point2D(10, 200); } [Benchmark] [ArgumentsSource(nameof(Arguments))] public int WithArgument(Point2D point) => point.X + point.Y; } public class Point2D { public int X, Y; public Point2D(int x, int y) { X = x; Y = y; } public override string ToString() => $\"[{X},{Y}]\"; } Note: If you want to control what will be displayed in the summary you should override ToString. If IterationSetup is provided run benchmark once per iteration When Stephen Toub says that something is buggy, it most probably is. BenchmarkDotNet performs multiple invocations of benchmark per every iteration. When we have exposed the [IterationSetup] attribute many users were expecting that the IterationSetup is going to be invoked before every benchmark execution. It was invoked before every iteration, and iteration was more than one benchmark call if the user did not configure that explicitly. We have changed that and now if you provide an [IterationSetup] method it is going to be executed before every iteration and iteration will invoke the benchmark just once. public class Test { public static void Main() => BenchmarkRunner.Run<Test>(); [IterationSetup] public void MySetup() => Console.WriteLine(\"MySetup\"); [Benchmark] public void MyBenchmark() => Console.WriteLine(\"MyBenchmark\"); } Before: MySetup MyBenchmark MyBenchmark MyBenchmark MyBenchmark (...) After: MySetup MyBenchmark MySetup MyBenchmark MySetup MyBenchmark (...) Note: If you want to configure how many times benchmark should be invoked per iteration you can use the new [InvocationCountAttribute]. Job Mutators Job represents a set of settings to run the benchmarks. We run every benchmark for every job defined by the user. The problem was that so far many jobs were just added to the config instead of being merged with other jobs. An example: [ClrJob, CoreJob] [GcServer(true)] public class MyBenchmarkClass Resulted in 3 jobs and 3 benchmark executions: ClrJob, CoreJob and GcServer(true) for current runtime. Now all Jobs and their corresponding attributes marked as mutators are going to be applied to other jobs, not just added to the config. So in this particular scenario, the benchmarks from MyBenchmarkClass are going to be executed for .NET with Server GC enabled and .NET Core with Server GC enabled. Mutators are great when you want to have a single, global config for all benchmarks and apply given settings only to selected types. You can find out more about mutators here. Ctrl+C When the user: presses Ctrl+C presses Ctrl+Break logs off closes console window We are now going to close any existing ETW session created by BenchmarkDotNet and restore console colors (read more). Handle OutOfMemoryException more gracefully When our benchmark hits OutOfMemoryException we print some nice explanation: public class Program { static void Main(string[] args) => BenchmarkRunner.Run<Program>(); private List<object> list = new List<object>(); [Benchmark] public void AntiPattern() => list.Add(new int[int.MaxValue / 2]); } OutOfMemoryException! BenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects. If your benchmark allocates memory and keeps it alive, you are creating a memory leak. You should redesign your benchmark and remove the side-effects. You can use `OperationsPerInvoke`, `IterationSetup` and `IterationCleanup` to do that. Trimming long strings We used to display the values \"as is\" which was bad for long strings. Now the values are trimmed (more). public class Long { [Params(\"text/plain,text/html;q=0.9,application/xhtml+xml;q=0.9,application/xml;q=0.8,*/*;q=0.7\")] public string Text; [Benchmark] public int HashCode() => Text.GetHashCode(); } Method Text HashCode text/(...)q=0.7 [86] More features Generic benchmarks BenchmarkDotNet supports generic benchmarks, all you need to do is to tell it which types should be used as generic arguments (read more). [GenericTypeArguments(typeof(int))] [GenericTypeArguments(typeof(char))] public class IntroGenericTypeArguments<T> { [Benchmark] public T Create() => Activator.CreateInstance<T>(); } Arguments We now support more scenarios for passing arguments to benchmarks: passing arguments to asynchronous benchmarks (more) passing generic types passing arguments by reference passing jagged arrays (more) types with implicit cast operator to stack only types can be passed as given stack-only types to Benchmarks (more) Example: public class WithStringToReadOnlySpan { [Benchmark] [Arguments(\"some string\")] public void AcceptsReadOnlySpan(ReadOnlySpan<char> notString) } Console Arguments BenchmarkSwitcher supports various console arguments (PR), to make it work you need to pass the args to switcher: class Program { static void Main(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args); } Note: to get the most up-to-date info about supported console arguments run the benchmarks with --help. Filter The --filter or just -f allows you to filter the benchmarks by their full name (namespace.typeName.methodName) using glob patterns. Examples: Run all benchmarks from System.Memory namespace: -f System.Memory* Run all benchmarks: -f * Run all benchmarks from ClassA and ClassB -f *ClassA* *ClassB* Note: If you would like to join all the results into a single summary, you need to use --join. Categories You can also filter the benchmarks by categories: --anyCategories - runs all benchmarks that belong to any of the provided categories --allCategories- runs all benchmarks that belong to all provided categories Diagnosers -m, --memory - enables MemoryDiagnoser and prints memory statistics -d, --disassm- enables DisassemblyDiagnoser and exports diassembly of benchmarked code Runtimes The --runtimes or just -r allows you to run the benchmarks for selected Runtimes. Available options are: Clr, Mono, Core and CoreRT. Example: run the benchmarks for .NET and .NET Core: dotnet run -c Release -- --runtimes clr core More arguments -j, --job (Default: Default) Dry/Short/Medium/Long or Default -e, --exporters GitHub/StackOverflow/RPlot/CSV/JSON/HTML/XML -i, --inProcess (Default: false) Run benchmarks in Process -a, --artifacts Valid path to accessible directory --outliers (Default: OnlyUpper) None/OnlyUpper/OnlyLower/All --affinity Affinity mask to set for the benchmark process --allStats (Default: false) Displays all statistics (min, max & more) --attribute Run all methods with given attribute (applied to class or method) Other small improvements Unicode support: now you can enable support of Unicode symbols like μ or ± with [EncodingAttribute.Unicode], an example: BenchmarkDotNet.Samples.IntroEncoding (see #735) Better benchmark validation (see #693, #737) Improve .NET Framework version detection: now we support .NET Framework 4.7.2 (see #743) OutlierModes: now it's possible to control how to process outliers, an example BenchmarkDotNet.Samples.IntroOutliers (see #766) LLVM support in MonoDisassembler (see a7426e) Grand API renaming we try not to change public API, but sometimes it's necessary because we want to get a consistent and understandable API in v1.0.0. (see #787) Many-many small improvements and bug fixes Milestone details In the v0.11.0 scope, 65 issues were resolved and 34 pull requests were merged. This release includes 214 commits by 11 contributors. Resolved issues (65) #136 Fastcheck for correctness of benchmark implementations #175 Add .NET Core support for Diagnostics package (assignee: @adamsitnik) #368 Memory leak and crash with [Setup] (assignee: @adamsitnik) #420 Make BenchmarkDotNet.Core runtime independent (assignee: @adamsitnik) #464 Iteration setup / cleanup should not be called for Idle() (assignee: @adamsitnik) #484 Broken HTTPS on site (assignee: @jongalloway) #487 Please consider using 'µs' instead of 'us' #551 List of structs and OutOfMemoryException #583 BenchmarkDotNet.Samples refactoring (assignee: @AndreyAkinshin) #586 IParam interface improvement (assignee: @adamsitnik) #638 Config with ryujit but it doesnt actually use ryujit? (assignee: @morgan-kn) #649 Searching docs leads to 404 page (assignee: @AndreyAkinshin) #665 Handle OutOfMemoryException more gracefully (assignee: @adamsitnik) #671 Why does BenchmarkRunner generate an isolated project per each benchmark method/job/params? (assignee: @adamsitnik) #698 Port to .NET Standard 2.0, drop .NET Core 1.1 support (assignee: @adamsitnik) #699 Generate one executable per runtime settings (assignee: @adamsitnik) #700 Improve local CoreCLR support (assignee: @adamsitnik) #701 Extend exported json file with FullName using xunit naming convention for integration purpose (assignee: @adamsitnik) #710 Use DocFX as a documentation generator (assignee: @AndreyAkinshin) #712 [Params] with arrays as params throws System.Reflection.TargetInvocationException (assignee: @adamsitnik) #713 How to specify the invocation/launch count per type when using Config for multiple runtimes? (assignee: @adamsitnik) #718 CoreRT support (assignee: @adamsitnik) #719 If fail to build in Parallel due to file access issues, try to build sequentially (assignee: @adamsitnik) #720 Add SummaryOrderPolicy.Declared #724 Allocated Memory results are not scaled with OperationPerInvoke (assignee: @adamsitnik) #726 Improve building guideline #729 Handle Ctrl+C/Break (assignee: @adamsitnik) #730 IterationSetup is not running before each benchmark invocation (assignee: @adamsitnik) #733 IOException when running in OneDrive Folder (assignee: @adamsitnik) #734 Handle missing Mono runtime more gracefully (assignee: @adamsitnik) #736 Reduce number of initial pilot ops to 1 or make it configurable (assignee: @adamsitnik) #738 Params string containing characters like quotes is not being escaped properly (assignee: @adamsitnik) #741 Give users nice warning when T in generic benchmark is not public #745 It should be possible to specify the generic arguments by using attributes #747 Better docs that explain what is target/launch/iteration/invocation count (assignee: @adamsitnik) #748 Very long string params/arguments should be trimmed (assignee: @adamsitnik) #749 WithId(…) is ignored unless it’s at the end of the fluent calls chain. (assignee: @adamsitnik) #763 Make MaxIterationCount configurable, keep current value as default (assignee: @adamsitnik) #765 Add .NET Core 2.2 support (assignee: @adamsitnik) #769 ArgumentsSource does not support Jagged Arrays (assignee: @adamsitnik) #774 Make it possible to use Span and other ByRefLike types with implicit cast operators as benchmark argument (assignee: @adamsitnik) #778 CS0104: 'Job' is an ambiguous reference between 'BenchmarkDotNet.Jobs.Job' and 'Nest.Job' (assignee: @adamsitnik) #779 StackOnlyTypesWithImplicitCastOperatorAreSupportedAsArguments doesn't work on .NET Core 2.0 (assignee: @adamsitnik) #787 Grand renaming #793 job=core for BenchmarkSwitcher (assignee: @adamsitnik) #794 Don't exclude allocation quantum side effects for .NET Core 2.0+ (assignee: @adamsitnik) #795 Broken BenchmarkSwitcher (assignee: @adamsitnik) #797 Allocated is not divided by OperationsPerInvoke (assignee: @adamsitnik) #802 AdaptiveHistogramBuilder.BuildWithFixedBinSize error when running benchmarks (assignee: @AndreyAkinshin) #804 What is the point of BuildScriptFilePath ? (assignee: @adamsitnik) #809 Make it possible to configure Min and Max Warmup Iteration Count (assignee: @adamsitnik) #810 handle new *Ansi events to make Inlining and TailCall Diagnosers work with .NET Core 2.2 (assignee: @adamsitnik) #811 Question/Suggestion is GcStats forcing a GC.Collect when it doesn't need to (assignee: @adamsitnik) #812 When will the next release be available on NuGet? (assignee: @adamsitnik) #813 Problems with MemoryDiagnoserTests on Mono and .NET Core 2.0 (assignee: @adamsitnik) #814 For type arguments we should display simple, not-trimmed name (assignee: @adamsitnik) #816 BenchmarkDotNet.Autogenerated.csproj is not working on .NET Core 2.1 (assignee: @adamsitnik) #817 Autogenerated project is missing dependencies (assignee: @adamsitnik) #818 Arguments should be passed to asynchronous benchmarks (assignee: @adamsitnik) #820 set DOTNET_MULTILEVEL_LOOKUP=0 when custom dotnet cli path is provided (assignee: @adamsitnik) #821 ArgumentsAttribute causes an error when used with a string containing quotes (assignee: @adamsitnik) #823 Allow to set multiple Setup/Cleanup targets without string concatenation (assignee: @adamsitnik) #827 An easy way to run a specific benchmark class via command line (assignee: @adamsitnik) #829 Error message for wrong command line filter (assignee: @adamsitnik) #832 Compilation Error CS0119 with ParamsSource (assignee: @adamsitnik) Merged pull requests (34) #693 Jit runtime validation (by @morgan-kn) #717 V11 (by @adamsitnik) #725 Extend exported json file with FullName using xunit naming convention for integration purpose (by @adamsitnik) #727 Building guideline improvement (by @Rizzen) #728 BenchmarkReport Exporter (by @Rizzen) #735 Unicode support (by @Rizzen) #737 Return value validator (by @ltrzesniewski) #740 Follow up to #737 (by @ltrzesniewski) #742 Add .NET Framework 4.7.2 version constant (by @epeshk) #743 Improve .NET Framework version detection (by @epeshk) #744 BenchmarkClass Validator (by @Rizzen) #746 Addition to #743: use HasValue instead of casting (by @epeshk) #750 Addition to #744: Using single variable in test instead of two (by @Rizzen) #752 Update HowItWorks.md (by @Tornhoof) #753 Ability to pass multiple assemblies. (by @paulness) #754 generate IParams for users in smart way (by @adamsitnik) #757 Add SummaryOrderPolicy.Defined to return benchmarks as instantiated (by @afmorris) #758 Generic Benchmark Attribute (by @Rizzen) #760 don't execute long operations more than once per iteration (by @adamsitnik) #761 stop the ETW session on Ctrl+C + restore console colors ;), fixes #729 (by @adamsitnik) #764 if IterationSetup is provided, and InvocationCount and UnrollFactor are not, run benchmark once per iteration to avoid user confusion (by @adamsitnik) #766 Introduce OutlierMode (by @AndreyAkinshin) #771 have two main actions: with unroll and without, for no unroll icrease the step by 1 in pilot (not *2) (by @adamsitnik) #781 Initial DocFX support, fixes #710 (by @AndreyAkinshin) #783 BenchmarkDotNet.Samples refactoring, fixes #583 (by @AndreyAkinshin) #785 Improve filtering from console args (by @adamsitnik) #789 docs: add changelog (by @AndreyAkinshin) #790 add link to inprocesstoolchain (by @IanKemp) #796 docs: multiversion combobox (by @AndreyAkinshin) #799 Cpu info improvement (by @Rizzen) #800 job Mutators (by @adamsitnik) #824 Use 3rd party lib for console args parsing + support globs for filtering (by @adamsitnik) #830 Read StandardOutput in a smart way to avoid infinite loops (by @houseofcat) #833 initial release notes (by @adamsitnik) Commits (214) defa7e port to .NET Standard 2.0 (by @adamsitnik) 626b03 keep .NET 4.6 in case somebody is on full framework, but not using .NET Standard (by @adamsitnik) ae4e22 merge BenchmarkDotNet.Toolchains.Roslyn into BenchmarkDotNet.Core (by @adamsitnik) 260704 update TraceEvent, port BenchmarkDotNet.Diagnostics.Windows to .NET Standard,... (by @adamsitnik) 324973 remove .NET Core 1.1 support, update tests (by @adamsitnik) 64d732 get it working (by @adamsitnik) 54b829 remove .NET Core 1.1 from the CI jobs (by @adamsitnik) ebf3d9 ups ;) (by @adamsitnik) 42d9ae Merge branch 'master' into annotations (by @adamsitnik) bc9975 cleanup (by @adamsitnik) 96dd4f merge BenchmarkDotNet and BenchmarkDotNet.Core (by @adamsitnik) 2dc21b group the benchmarks by runtime settings into partitions, #699 (by @adamsitnik) fbb283 generate one .cs with all types inside, #699 (by @adamsitnik) 334af2 build single exe, #699 (by @adamsitnik) b958a1 run selected type from all types in exe #699 (by @adamsitnik) 4f5714 polishing the code, #699 (by @adamsitnik) 0c26a4 reverting some magic .sln change which has most probably broken the Travis bu... (by @adamsitnik) c8a368 restore to a dedicated temp folder, rebuild only bare minumum, store everythi... (by @adamsitnik) bd04bd better debugging experience (#699): when building only 1 thing at a time, pri... (by @adamsitnik) fcf691 Improved local CoreCLR/CoreFX support, tested on all OSes #700, #702 (by @adamsitnik) 7fbd6c allow the users to define an extra nuget feed, don't force clear tag for loca... (by @adamsitnik) ad0fc8 Merge branch 'master' into v11 (by @adamsitnik) 8070e4 Merge remote-tracking branch 'origin/master' into v11 (by @adamsitnik) 0cccba post code review fixes, part of #175 (by @adamsitnik) 4acc15 new Runtime and Toolchain for CoreRT, #718 (by @adamsitnik) 657f05 don't use Expressions in Engine to avoid .NET Native compiler errors, #718 (by @adamsitnik) 8c93cf the .NET Native compiler complained about some dependencies from referenced p... (by @adamsitnik) c8ba5c If fail to build in Parallel due to file access issues, try to build sequenti... (by @adamsitnik) 7173f7 CoreRT does not support reflection yet, so we need to target .NET Core 2.1 to... (by @adamsitnik) 889270 trying to install Clang 3.9 for CoreRT tests purpose, #718 (by @adamsitnik) 967167 code review fixes, #718 (by @adamsitnik) 94863a Merge pull request #717 from dotnet/v11 (by @adamsitnik) 448752 Improved docs for Disassembly Diagnoser (by @adamsitnik) 600e5f add FromAssemblyAndTypes method to make it possible to auto-detect all benchm... (by @adamsitnik) 289292 Allocated Memory must be scaled with OperationPerInvoke, fixes #724 (by @adamsitnik) 1aa414 Actual Building Guide (by @Rizzen) cfd9fa Merge pull request #727 from Rizzen/master (by @adamsitnik) 7cfe09 Created Exporter and moved logic into (by @Rizzen) b9ff75 Merge pull request #728 from Rizzen/BenchmarkReportExporter (by @adamsitnik) adea8f support by ref Arguments (by @adamsitnik) 0ecd7e ignore auto-generated files cleanup errors, #733 (by @adamsitnik) cf5cd6 Handle missing Mono runtime more gracefully, fixes #734 (by @adamsitnik) 49495f Remove unused usings (by @AndreyAkinshin) 160516 Return value validator (#737), fixes #136 (by @ltrzesniewski) 396f0a Follow up to #737 (#740) (by @ltrzesniewski) 9dc4e8 Add .NET Framework 4.7.2 release number constant to GetCurrentVersionBasedOnW... (by @epeshk) 06ff2d Update link to manual with .NET Framework version constants (by @epeshk) f7d9ac Don't check Reference Assemblies folder existence for .NET Framework version ... (by @epeshk) ebc1f6 Remove hardcoded Program Files directory location (by @epeshk) 490304 Refactor framework version determining, extract logic from CsProjClassicNetTo... (by @epeshk) cbea7e Fix Program Files path on x86 systems (by @epeshk) 8071c8 ProgramFilesX86DirectoryPath field (by @epeshk) f1d726 Merge pull request #743 from epeshk/frameworkVersion (by @AndreyAkinshin) a36442 use HasValue instead of casting (by @epeshk) c7efcc Merge pull request #746 from epeshk/frameworkVersion (by @adamsitnik) 58f704 Give users nice warning when T in generic benchmark is not public, fixes #741 (by @Rizzen) 66f958 when dotnet build --no-restore fails, try to run with restore (by @adamsitnik) 52067c custom job Id should be preserved, fixes #749 (by @adamsitnik) 24ec6e Very long string params/arguments should be trimmed, fixes #748 (by @adamsitnik) b2e5b6 Params string containing characters like quotes is must be escaped properly, ... (by @adamsitnik) 10865c Better docs that explain what is target/launch/iteration/invocation count by ... (by @adamsitnik) 32ed86 Addition to #744: Using single variable instead of two (by @Rizzen) f2a71f Merge pull request #750 from Rizzen/744_addition (by @adamsitnik) eabfdd Update HowItWorks.md (by @Tornhoof) 8fc754 Merge pull request #752 from Tornhoof/patch-1 (by @adamsitnik) 2d79b6 Ability to pass multiple assemblies. (by @paulness) ba07b0 Merge pull request #753 from paulness/feature-allow-multiple-assemblies-to-be... (by @adamsitnik) d1b037 generate IParams for users in smart way (by @adamsitnik) 4665ec Merge pull request #754 from dotnet/noIParam (by @adamsitnik) 02c7c0 Generic Benchmark Attribute (#758), fixes #745 (by @Rizzen) 7caf28 Add SummaryOrderPolicy.Defined to return benchmarks as instantiated (#757), f... (by @afmorris) 449002 renamed Defined to Declared to keep consistency, renamed GenericBenchmark to ... (by @adamsitnik) 8855a2 Jit runtime validation (#693) (by @morgan-kn) 41614b stop the ETW session on Ctrl+C + restore console colors ;), fixes #729 (#761) (by @adamsitnik) b0c251 Make MaxIterationCount configurable, keep current value as default, fixes #763 (by @adamsitnik) 6f693e warn the users (once!) that if they run less than 15 iterations, the Multimod... (by @adamsitnik) a9664f don't execute long operations more than once per iteration (#760), fixes #736 (by @adamsitnik) 7e8448 if IterationSetup is provided, and InvocationCount and UnrollFactor are not, ... (by @adamsitnik) a40c75 explain the users why they did hit OOM, fixes #665, #368, #551 (by @adamsitnik) e66bb0 arrays can be arguments and params, fixes #712 (by @adamsitnik) 94b83e don't call IterationSetup and Cleanup for Idle, fixes #464 (by @adamsitnik) 90f9ca Add .NET Core 2.2 support, fixes #765 (by @adamsitnik) 132048 Better mValue formatting in MultimodalDistributionAnalyzer (by @AndreyAkinshin) 5f08c2 Merge pull request #764 from dotnet/iterationSetupRunOnce (by @AndreyAkinshin) 2b5dde Introduce OutlierMode (by @AndreyAkinshin) 226716 OutliersAnalyserTests (by @AndreyAkinshin) cabef0 support Jagged Arrays for ArgumentsSource, fixes #769 (by @adamsitnik) 808a9d support generic by ref arguments with an ugly hack due to reflection limitati... (by @adamsitnik) ea9f70 remove the ugly hack (by @adamsitnik) cb4291 make it possible to use arrays of types with no public parameterless ctor (li... (by @adamsitnik) 272e42 diassembly diagnoser: handle case where two different methods have same meta... (by @adamsitnik) ea16d1 update preview dependencies to 4.5.0 (by @adamsitnik) 97ddd6 Make it possible to use Span as benchmark argumen, fixes #774 (by @adamsitnik) 4863be more generic solution for #774 (by @adamsitnik) f63726 update build to use rc1 (to fix the build) (by @adamsitnik) a38c70 make it possible to pass array(s) of reference types as arguments (by @adamsitnik) 306adc use full Job type name to avoid naming conflicts, fixes #778 (by @adamsitnik) e92c5b use DOTNET_MULTILEVEL_LOOKUP and IgnoreCorLibraryDuplicatedTypes to fix the... (by @adamsitnik) 4e9844 Trimming the argument values makes them actually shorter #748 cc @ahsonkhan (by @adamsitnik) 846d80 Merge branch 'master' of https://github.com/dotnet/BenchmarkDotNet (by @adamsitnik) 3c3b47 have two main actions: with unroll and without, for no unroll icrease the ste... (by @adamsitnik) 56f02c use full names in the auto-generated code to avoid possible conflicts (I just... (by @adamsitnik) e75c44 Update documentations for WithOutlierMode (by @AndreyAkinshin) 1840ae Merge pull request #766 from dotnet/outliers (by @AndreyAkinshin) 5ae4bc Fixed BrandString support for Windows 10.0.17134 (by @AndreyAkinshin) 4d6dfe BrandString support for macOS Mojave (by @AndreyAkinshin) 426fbc Initial DocFX support, fixes #710 (by @AndreyAkinshin) fe00d7 Merge pull request #781 from dotnet/docfx (by @AndreyAkinshin) f0c06e Allow to pass string as ReadOnlySpan only for .NET Core 2.1 where the i... (by @adamsitnik) bbe273 make netcoreapp2.1 default for .NET Core 2.1 + expose few things which are re... (by @adamsitnik) bd22b3 BenchmarkDotNet.Samples refactoring, fixes #583 (by @AndreyAkinshin) 149e5e Merge pull request #783 from dotnet/docfx-samples (by @AndreyAkinshin) 237e36 Flat namespace for BenchmarkDotNet.Attributes (by @AndreyAkinshin) 24d2fe Remove obsolete namespaces in IntegrationTests (by @AndreyAkinshin) cb25a7 docs: Visual Studio-like style for code snippets (by @AndreyAkinshin) 914922 docs: add samples for baselines (by @AndreyAkinshin) 159e85 docs: fix year in license (by @AndreyAkinshin) 0b02d0 docs: add IntroEnvVars (by @AndreyAkinshin) 4b0f38 Unicode support (#735) (by @Rizzen) 971236 Unicode support: cleanup (by @AndreyAkinshin) 7c43da CommonExtensions cleanup (by @AndreyAkinshin) 04c0ad Fix link to rplot.png in README.md (by @AndreyAkinshin) b16b83 docs: samples for setup and cleanup (by @AndreyAkinshin) c05ac6 add link to inprocesstoolchain (#790) (by @IanKemp) 44ea0f docs: add changelog (#789) (by @AndreyAkinshin) 8a31aa docs: save changelog details for old versions in repo (by @AndreyAkinshin) edd0a3 docs: customizing-runtime.md (by @AndreyAkinshin) edf7f6 Improve filtering from console args (#785) (by @adamsitnik) d9e18d a type can have no namespace (by @adamsitnik) 4bbffe docs: update docfx version (by @AndreyAkinshin) 52e769 Don't exclude allocation quantum side effects for .NET Core 2.0+, fixes #794 (by @adamsitnik) 24f8da Cake targets for DocFX (by @AndreyAkinshin) db0724 docs: add api/index.md (by @AndreyAkinshin) 026c00 docs: statistics (by @AndreyAkinshin) ae5baf docs: misc fixes (by @AndreyAkinshin) fa5cf5 docs: multiversion combobox (by @AndreyAkinshin) a49cf9 docs: add full contributor list (by @AndreyAkinshin) 803686 always use FQDN to avoid any possible duplicates, #529 strikes back after a year (by @adamsitnik) 315530 make sure DisassemblyDiagnoser output is exported, fixes bug introduced in #785 (by @adamsitnik) 167476 docs: improved diagnosers.md (by @AndreyAkinshin) b7f9aa docs: improved choosing-run-strategy (by @AndreyAkinshin) 5da534 remove MultimodalDistributionAnalyzer hint introduced in #763 (by @adamsitnik) 376339 Merge pull request #796 from dotnet/docs-versions (by @adamsitnik) 57005f Extend exported json file with FullName using xunit naming convention for int... (by @adamsitnik) 9c0a2e docs: improved exporters.md (by @AndreyAkinshin) 22f553 docs: better sample generation (by @AndreyAkinshin) 734635 docs: improved columns.md (by @AndreyAkinshin) a82562 docs: improved configs.md (by @AndreyAkinshin) e7a458 docs: InProcess samples (by @AndreyAkinshin) 602562 docs: imrpovded order-providers.md (by @AndreyAkinshin) 8576c5 docs: fix the rest of WithoutDocs samples (by @AndreyAkinshin) 13b44e docs: rename changelog-generator to _changelog (by @AndreyAkinshin) 9a9648 docs: fix link to InProcessToolchain (by @AndreyAkinshin) 5716c1 escape tabs and enters in the exported benchmark id (to keep it in sync with ... (by @adamsitnik) 4be9bf MemoryDiagnoser handles IterationSetup and Cleanup since #606, removing old i... (by @adamsitnik) f92532 add --job=core to command line arguments, fixes #793 (by @adamsitnik) 1c656d update the docs with the change in IterationSetup behavior, #764 (by @adamsitnik) 6fd39b job Mutators (#800)fixes #713 (by @adamsitnik) 8954dc Rename: OrderProvider -> Orderer (#787) (by @AndreyAkinshin) 7b47c6 Rename: Benchmark -> BenchmarkCase (#787) (by @AndreyAkinshin) cc6f1b Rename: Target -> Descriptor (#787) (by @AndreyAkinshin) 17bb68 Rename: EnvMode -> EnvironmentMode (#787) (by @AndreyAkinshin) 73a6cc Rename: Infrastructure.EnvironmentVariables -> Environment.EnvironmentVariabl... (by @AndreyAkinshin) 6118f1 Huge IterationMode renaming (#787) (by @AndreyAkinshin) 035452 Handle super narrow distributions in AdaptiveHistogramBuilder, fixes #802 (by @AndreyAkinshin) b705b3 print Processor Affinity as a bitmask in the summary (by @adamsitnik) 0db126 fix MacOs build where the default affinity is 0 or we can't read it for some ... (by @adamsitnik) 5e6e33 make sure the characteristic names match the properties names + rename Target... (by @adamsitnik) f4cd0d Baseline improvements (#787) (by @AndreyAkinshin) 124a52 Fix tests (#787) (by @AndreyAkinshin) e8bf99 fix mac test, make sure IsMutator does not flow to applied job (by @adamsitnik) 95750c Make it possible to configure Min and Max Warmup Iteration Count, fixes #809 (by @adamsitnik) 99e753 handle new *Ansi events to make Inlining and TailCall Diagnosers work with .N... (by @adamsitnik) 62e75c docs: update articles/contributing/documentation (by @AndreyAkinshin) 41c5f9 Cake: update DocFX (2.36.2->2.37) (by @AndreyAkinshin) e4b37c Cake: update .NET Core SDK (2.1.300-rc1-008673->2.1.300) (by @AndreyAkinshin) ad1645 Cpu info improvement (#799) (by @Rizzen) 61e95e [Params] exported to json should be delimited by \", \" #701 (by @adamsitnik) 4cd1df handle the types as arguments to match xunit naming convention for porting pu... (by @adamsitnik) ff6613 for type parameters we should display non-trimmed type name without namespace... (by @adamsitnik) 89f195 explain how we measure GC stats in the docs, fixes #811 (by @adamsitnik) c7731c Arguments should be passed to asynchronous benchmarks, fixes #818 (by @adamsitnik) 0f9c48 add info about Min/Max counts to docs (by @adamsitnik) 33e568 fix MemoryDiagnoserTests issues, fixes #813 (by @adamsitnik) 844e95 set DOTNET_MULTILEVEL_LOOKUP=0 to get customDotNetCli path working, fixes #820 (by @adamsitnik) 7e2d54 if iteration cleanup is provided, the benchmark should be executed once per i... (by @adamsitnik) 2132d0 allow to set summary style in fluent way (by @adamsitnik) dfea69 allow to set multuple targets for attributes without string concatenation, fi... (by @adamsitnik) 6267b2 Use 3rd party lib for console args parsing + support globs for filtering (#824) (by @adamsitnik) 9c269f make sure the generic type arguments are displayed in the summary, not `1 (by @adamsitnik) c7d0b9 don't duplicate the jobs when parsing config (by @adamsitnik) d7825e show generic type name in a joined summary (by @adamsitnik) 528c9c make sure the config parsing and job merging works as expected (by @adamsitnik) a7426e LLVM support in MonoDisassembler (by @AndreyAkinshin) c724e9 Fix typos (by @AndreyAkinshin) cdbb37 allow to filter benchmarks by simple type name, fixes #827 (by @adamsitnik) eac833 Read StandardOutput in a smart way to avoid infinite loops (#830), #828 (by @houseofcat) a298c2 Error message for wrong command line filter, fixes #829 (by @adamsitnik) a7ecda initial release notes (#833) (by @adamsitnik) 36bf7c Rename: General -> Actual (#787) (by @AndreyAkinshin) a1ec4b Add _changelog/details/v0.11.0.md (by @AndreyAkinshin) 558cae Improved docs for v0.11.0 (by @AndreyAkinshin) e45f69 docs: update main.js (by @AndreyAkinshin) 53e576 Update links to docs in README (by @AndreyAkinshin) 3a8990 update links in docs/index.md (by @AndreyAkinshin) 5ad710 Repair obsolete logo link (by @AndreyAkinshin) e38afb Cake: update DocFX (2.37->2.37.1) (by @AndreyAkinshin) 5b8f91 docs: add analytics scripts in template (by @AndreyAkinshin) 3ec8f7 docs: add redirects to v0.10.14 (by @AndreyAkinshin) a00bf6 docs: update how-it-works (by @AndreyAkinshin) 73980e docs: add redirect for index.htm (by @AndreyAkinshin) fad583 docs: update changelog for v0.11.0 (by @AndreyAkinshin) 74d552 Update list of NuGet packages in changelog/footer/v0.11.0 (by @AndreyAkinshin) 74084f Set library version: 0.11.0 (by @AndreyAkinshin) Contributors (11) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Evgeny Peshkov (@epeshk) Ian Kemp (@IanKemp) Irina Ananeva (@morgan-kn) Lucas Trzesniewski (@ltrzesniewski) Mark Tkachenko (@Rizzen) Paul Ness (@paulness) Stefan (@Tornhoof) Tony Morris (@afmorris) Tristan Hyams (@houseofcat) Thank you very much! Additional details Date: July 23, 2018 Milestone: v0.11.0 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.0 BenchmarkDotNet v0.10.14 Per-method parameterization (Read more) Console histograms and multimodal disribution detection Many improvements for Mono disassembly support on Windows (Read more) Many bugfixes Milestone details In the v0.10.14 scope, 8 issues were resolved and 11 pull requests were merged. This release includes 47 commits by 8 contributors. Resolved issues (8) #256 Per-method parameterization (assignee: @AndreyAkinshin) #429 Detect multimodal distributions (assignee: @AndreyAkinshin) #496 Integration with TravisCI (assignee: @jongalloway) #684 Horology.ClockTests.ChronometerTest fails on Travis CI (macOS) (assignee: @AndreyAkinshin) #689 DisassemblyDiagnoser for Mono does not work on Windows and Linux (assignee: @morgan-kn) #691 Cannot run F# benchmarks when benchmark returns F# generic (assignee: @adamsitnik) #697 Copy custom setting from app.config in multitarget projects (assignee: @adamsitnik) #706 Support private builds of .NET Runtime (assignee: @adamsitnik) Merged pull requests (11) #577 Arguments (by @adamsitnik) #647 Histograms and multimodal distribution detection, fixes #429 (by @AndreyAkinshin) #674 Cleanup suggested by VS2017 Code Analysis (plus one typo) (by @shoelzer) #675 Fix IDE0034: 'default' expression can be simplified (by @shoelzer) #676 Correct NodeTime text which links to NodaTime api (by @MishaHusiuk) #681 Fix typo (Perdictor -> Predictor) (by @dmitry-ra) #682 Fix typo (Perdictor -> Predictor) (by @dmitry-ra) #683 Integration with TravisCI (by @Ky7m) #694 Fix 689 (by @morgan-kn) #695 Rename Program to UniqueProgramName to avoid conflicts, fixes #691 (by @adamsitnik) #696 Build system: Update dotnet SDK and dotnet runtime. Enable FastTests netcoreapp1.1 on non-Windows. (by @Ky7m) Commits (47) 41aeea Histograms and multimodal distribution detection, fixes #429 (by @AndreyAkinshin) 960e58 Handle measurements with zero operations (by @AndreyAkinshin) 19cddd Fix typo in BaselineScaledColumn.cs (by @dfederm) a99594 Merge pull request #673 from dfederm/dfederm/fix-typo (by @AndreyAkinshin) 5b3425 Cleanup suggested by VS2017 Code Analysis (plus one typo) (#674) (by @shoelzer) 16b611 Fix IDE0034: 'default' expression can be simplified (by @shoelzer) 048b32 Merge pull request #675 from shoelzer/master (by @AndreyAkinshin) 9d5f71 Correct NodeTime text which links to NodaTime lib (by @MishaHusiuk) c450c7 Merge pull request #676 from MishaHusiuk/patch-1 (by @adamsitnik) 9fad52 Fix typo (Perdictor -> Predictor) (by @dmitry-ra) 3d906f Fix typo (Perdictor -> Predictor) (by @dmitry-ra) d1a48e Merge pull request #681 from dmitry-ra/master (by @AndreyAkinshin) 4ccd35 Merge pull request #682 from dmitry-ra/patch-1 (by @AndreyAkinshin) f743a1 CakeBuild 0.24.0 -> 0.26.1 (by @Ky7m) c5eb40 Remove postProjects from solution file. (by @Ky7m) e60387 Pass correct configuration to test settings (by @Ky7m) 224ab8 Disable public sign option for F# project (by @Ky7m) ee98f3 Limit Max CPU count for msbuild workers (by @Ky7m) 17031d Fix readme file (by @Ky7m) 6fbae8 One more update to readme file (by @Ky7m) cb90f2 disable Travis failing test #684 to unblock #683 (by @adamsitnik) 782ca7 Merge pull request #683 from Ky7m/Integration-with-TravisCI (by @adamsitnik) eebf92 Merge branch 'master' into multimodal (by @adamsitnik) 10511b Merge pull request #647 from dotnet/multimodal (by @adamsitnik) 57bc17 Fix bug in ClockTests.ChronometerTest, fixes #684 (by @AndreyAkinshin) 7c4b14 Arguments (#577), fixes #256 (by @adamsitnik) 40771c Update dotnet SDK (2.1.4 -> 2.1.101) and dotnet runtime (1.1.6 -> 1.1.7). (by @Ky7m) 88a9db Merge pull request #696 from Ky7m/build-runtime-update (by @adamsitnik) 4ac6ad we need different name than typical \"Program\" to avoid problems with referenc... (by @adamsitnik) 1178d6 Update build badges (by @AndreyAkinshin) 24ed1f ProcessHelper: handle null Data values in OutputDataReceived, fix #689 (by @morgan-kn) 7a3d2b MonoDisassembler improvements (by @morgan-kn) f1a0f5 Merge pull request #694 from morgan-kn/Fix689 (by @AndreyAkinshin) 428905 .NET Core apps are .dlls (not .exes), fixes #697 (by @adamsitnik) befbc8 Add FAQ notes about #692 (by @AndreyAkinshin) b4504b Support private builds of .NET Runtime, fixes #706 (by @adamsitnik) c93e1e Introduce separate logic for Windows10 brand strings (by @AndreyAkinshin) 685766 Shortify Windows 10 brand strings in the summary (by @AndreyAkinshin) 9bdd0c Shortify cpu info in summary (by @AndreyAkinshin) 2288ad Prettify macOS brand string (by @AndreyAkinshin) 8a0b48 Handle tailed nop instructions in mono disasm output (by @AndreyAkinshin) d80834 Advanced DryJob attributes (by @AndreyAkinshin) 9a37ad Handle invalid mono disasm outputs (by @AndreyAkinshin) 21d6d7 Add IntroDisasm (by @AndreyAkinshin) 5e37b5 Add \"Disassembly Diagnoser for Mono on Windows\" in docs (by @AndreyAkinshin) c2c4e8 set COMPLUS_Version env var for private Clr builds even if no env vars were d... (by @adamsitnik) 88b088 Set library version: 0.10.14 (by @AndreyAkinshin) Contributors (8) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) David Federman (@dfederm) Dmitry Razumikhin (@dmitry-ra) Igor Fesenko (@Ky7m) Irina Ananeva (@morgan-kn) MishaHusiuk (@MishaHusiuk) Steve Hoelzer (@shoelzer) Thank you very much! Additional details Date: April 09, 2018 Milestone: v0.10.14 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.14 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.14 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.14 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.14 BenchmarkDotNet v0.10.13 Overview post: BenchmarkDotNet v0.10.13 Milestone details In the v0.10.13 scope, 15 issues were resolved and 9 pull requests were merged. This release includes 50 commits by 9 contributors. Resolved issues (15) #541 Mono Support for DisassemblyDiagnoser (assignee: @morgan-kn) #614 Build fails with \"'Microsoft.NETCore.App', version '1.1.2' was not found\" probably due to 1.1.4 runtime not being available #626 Support Visual Basic project files (.vbroj) targeting .NET Core (assignee: @adamsitnik) #630 Bug: Statistics.DivMean - NullReferenceException (assignee: @AndreyAkinshin) #631 Bug: Generic benchmark class fails for DisassemblyDiagnoser with \"Sequence contains no matching element\" (assignee: @adamsitnik) #632 ParamsSource no longer sorted in results (assignee: @AndreyAkinshin) #634 Extend SummaryOrderPolicy (assignee: @adamsitnik) #636 Unable to run Runner.exe --method MethodName (assignee: @adamsitnik) #640 Disassembler fails with generic instance (assignee: @adamsitnik) #643 BenchmarkDotNet should respect LangVersion project setting (assignee: @adamsitnik) #644 BenchmarkDotNet.Mathematics.RankHelper again. (assignee: @AndreyAkinshin) #648 BenchmarkDotNet requires dotnet cli toolchain to be installed (assignee: @adamsitnik) #651 Support ANY CoreFX and CoreCLR builds (assignee: @adamsitnik) #652 BenchmarkSwitcher should support generic types with parameterless public ctors (assignee: @adamsitnik) #653 Proper way to run BenchmarkDotNet on macOS/Linux (assignee: @adamsitnik) Merged pull requests (9) #624 Upgrade build tools (by @Ky7m) #625 Fix xunit warnings connected to usage of Assert.Equal() to check for Null (by @Ky7m) #633 HostEnvironmentInfo: remove LogicalCoreCount (by @morgan-kn) #637 Mono Support for DisassemblyDiagnoser #541 (by @morgan-kn) #639 Portability.Cpu tests improvements (by @morgan-kn) #642 sync DataContracts to CopiedDataContracts (by @morgan-kn) #645 Fixing --help display for options (by @ENikS) #646 Allow sorting by the Method name in DefaultOrderProvider and OrderProviderAttribute (by @ENikS) #666 Plots...Examples...Added A config example in F# (by @ScottHutchinson) Commits (50) a26e82 Upgrade build tools: (by @Ky7m) 1643cb Merge pull request #624 from Ky7m/upgrade-build-tools (by @adamsitnik) abae51 Fix xunit warnings connected to usage of Assert.Equal() to check for null val... (by @Ky7m) fb68bc support Visual Basic .NET Core projects, fixes #626 (by @adamsitnik) 067a33 Remove redundant properties in common.props (by @AndreyAkinshin) 80deb9 BuildNumber fix in common.props (by @AndreyAkinshin) 87b458 Add CONTRIBUTING.md (by @AndreyAkinshin) 8bcf42 Add CODE_OF_CONDUCT.md (by @AndreyAkinshin) d3867d HostEnvironmentInfo: remove LogicalCoreCount (#633) (by @morgan-kn) 06e66a Specify PLACE_SIMPLE_EMBEDDED_STATEMENT_ON_SAME_LINE in DotSettings (by @AndreyAkinshin) d8ac43 Mono Support for DisassemblyDiagnoser #541 (by @morgan-kn) 4356da Merge pull request #637 from morgan-kn/MonoSupportForDisassemblyDiagnoser (by @AndreyAkinshin) 7572f4 Fix paths to images in docs (by @AndreyAkinshin) f076df Portability.Cpu tests improvements (by morgan_kn) da6499 Merge pull request #639 from morgan-kn/TestsImprovment (by @AndreyAkinshin) 5dd1a5 Disassembly Diagnoser: support for generic types, fixes #640 fixes #631 (by @adamsitnik) 3c0e71 diassembly diangoser: different methods can have same metadata id, add type i... (by @adamsitnik) 294801 test fix ;) (by @adamsitnik) 9e66bb sync DataContracts to CopiedDataContracts (by @morgan-kn) 690f34 Merge pull request #642 from morgan-kn/sync (by @adamsitnik) e1e3e2 don't use type.Fullname for file names, it's too long for generics (by @adamsitnik) 43d7c2 we restore before build, so build does need to restore too (it's new default ... (by @adamsitnik) 9d4c33 trying harder to trick the JIT (#640, #631) (by @adamsitnik) f8f70f Natural ordering for logical groups, fixes #632 (by @AndreyAkinshin) a2ec34 copy LanguageVersion to the output .csproj, fixes #643 (by @adamsitnik) 31e6dd Fixing --help display for options (#645), fixes #636 (by @ENikS) 45ace9 Allow sorting by the Method name in DefaultOrderProvider and OrderProviderAtt... (by @ENikS) 8811f2 Fix typo in docs/guide/Contributing/Disassembler.md (by @AndreyAkinshin) 7da7b9 allow the users to customize Artifacts Path, #377 (by @adamsitnik) 7554bf validate CustomDotNetCliPath, fixes #648 (by @adamsitnik) 683964 Support ANY CoreFX and CoreCLR builds, fixes #651 (by @adamsitnik) 695386 support also only custom CoreFX scenario (default runtime), part of #651 (by @adamsitnik) eb4dcf allow the users to copy some files after the publish, part of #651 (by @adamsitnik) b076a3 Add Newtonsoft.Json in the README (by @AndreyAkinshin) b4eef5 better generics support, fixes #652 (by @adamsitnik) 77fd46 Handle null values in Statistics.DivMean and Statistics.DivVariance, fixes #630 (by @AndreyAkinshin) e547f8 Fix NRE in RankColumn, fixes #644 (by @AndreyAkinshin) 28aa94 allow the users to choose .NET 4.7.1 (by @adamsitnik) 503570 Fixed image link (by @svick) 93cc85 Merge pull request #655 from svick/patch-1 (by @adamsitnik) d33cde Fixed code block formatting (by @svick) cb7c09 Merge pull request #657 from svick/patch-1 (by @adamsitnik) 650b4a host Mono process should be able to build .NET Core child process, fixes #653 (by @adamsitnik) d1dcab List formatting for FAQ (by @svick) fe52e3 Merge pull request #663 from svick/faq-formatting (by @adamsitnik) 7792cb Example in F#: with corrected code formatting (by @ScottHutchinson) e6b225 Merge pull request #666 from ScottHutchinson/patch-2 (by @AndreyAkinshin) f90207 Allow restore and build command override (#670) (by @BonnieSoftware) 4443cd Update example in README (by @AndreyAkinshin) de0b68 Set library version: 0.10.13 (by @AndreyAkinshin) Contributors (9) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) BonnieSoftware (@BonnieSoftware) Eugene Sadovoi (@ENikS) Igor Fesenko (@Ky7m) Irina Ananeva (@morgan-kn) morgan_kn Petr Onderka (@svick) Scott Hutchinson (@ScottHutchinson) Thank you very much! Additional details Date: March 02, 2018 Milestone: v0.10.13 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.13 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.13 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.13 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.13 BenchmarkDotNet v0.10.12 Overview post: BenchmarkDotNet v0.10.12 Highlights Improved DisassemblyDiagnoser: BenchmarkDotNet contains an embedded disassembler so that it can print assembly code for all benchmarks; it's not easy, but the disassembler evolves in every release. Improved MemoryDiagnoser: it has a better precision level, and it takes less time to evaluate memory allocations in a benchmark. New TailCallDiagnoser: now you get notifications when JIT applies the tail call optimizations to your methods. Better environment info: when your share performance results, it's very important to share information about your environment. The library generates the environment summary for you by default. Now it contains information about the amount of physical CPU, physical cores, and logic cores. If you run a benchmark on a virtual machine, you will get the name of the hypervisor (e.g., Hyper-V, VMware, or VirtualBox). Better summary table: one of the greatest features of BenchmarkDotNet is the summary table. It shows all important information about results in a compact and understandable form. Now it has better customization options: you can display relative performance of different environments (e.g., compare .NET Framework and .NET Core) and group benchmarks by categories. Milestone details In the v0.10.12 scope, 15 issues were resolved and 10 pull requests were merged. This release includes 42 commits by 9 contributors. Resolved issues (15) #273 Create a tail call diagnoser #442 Is it possible to configure benchmark to assign rank for runtime? (assignee: @AndreyAkinshin) #543 Run Disassembly Diagnoser without extra run (assignee: @adamsitnik) #546 Synthesizing labels for jump targets (assignee: @adamsitnik) #574 Display VM hypervisor in summary section (assignee: @lukasz-pyrzyk) #582 Print amount of logical and physical core (assignee: @morgan-kn) #599 Proper HTML escaping of BenchmarkAttribute Description #606 Improve Memory Diagnoser (assignee: @adamsitnik) #608 Properly escaping generated markdown (assignee: @AndreyAkinshin) #612 Disassembler DisassembleMethod fails with \"Object reference not set to an instance of an object.\", (assignee: @adamsitnik) #617 Allow baseline per category (assignee: @AndreyAkinshin) #618 Enable ApprovalTests in .NET Core 2.0 tests (assignee: @AndreyAkinshin) #621 Try to search for missing references if build fails (assignee: @adamsitnik) #622 Support of new GC settings (assignee: @adamsitnik) #623 RPlotExporter uses wrong path to csv measurements (assignee: @AndreyAkinshin) Merged pull requests (10) #573 Сreate a tail call diagnoser (by @GeorgePlotnikov) #576 Display VM name in summary section, fixes #574 (by @lukasz-pyrzyk) #595 Migrate all project to new project system. (by @mfilippov) #598 Added info about the new TailCallDiagnoser (by @GeorgePlotnikov) #603 Fix HTML Encoding for Html Exporter (by @Chrisgozd) #605 Grammar (by @onionhammer) #607 Print amount of logical and physical core #582 (by @morgan-kn) #615 Quick fix Disassembler.Program.GetMethod when more than one method found just return null (by @nietras) #619 Logical group support, fixes #617 (by @AndreyAkinshin) #620 New README.md (by @AndreyAkinshin) Commits (42) 6f587d Migrate all project to new project system. (by @mfilippov) 47ba57 added info about the new TailCallDiagnoser (by @GeorgePlotnikov) c1a4b2 Сreate a tail call diagnoser (#573) (by @GeorgePlotnikov) ebe3e2 Merge pull request #598 from GeorgePlotnikov/patch-1 (by @adamsitnik) 6249f0 some polishing of the JIT diagnosers (by @adamsitnik) 119231 Fix HTML Encoding for Html Exporter (#603), fixes #599 (by @Chrisgozd) fe3f30 Disassembly Prettifier, fixes #546 (by @adamsitnik) 3eb63f Merge pull request #595 from mfilippov/new-fs-vb-proj (by @adamsitnik) 16d03f make our F# samples work for .NET Core 2.0 (by @adamsitnik) d06de7 bring back our old Visual Basic and F# integration tests (by @adamsitnik) 63249b \"Kaby Lake R\" and \"Coffee Lake\" support in ProcessorBrandStringHelper (by @AndreyAkinshin) a8a09e disassembly prettifier: highlighting references to labels, jumping to next on... (by @adamsitnik) e6d747 Grammar (by @onionhammer) fef4aa Merge pull request #605 from onionhammer/patch-1 (by @adamsitnik) ffacd7 don't require extra run for DisassemblyDiagnoser, fixes #543, #542 (by @adamsitnik) bcac26 revert last commit change (run global setup regardless of Jitting) (by @adamsitnik) 3e87d8 don't perform an extra run to get GC stats for .NET Core, part of #550 (by @adamsitnik) f87dbc obtain GC stats in separate iteration run, no overhead, support for iteration... (by @adamsitnik) e5fe0f update to C# 7.1 so we can use all the latest features (by @adamsitnik) bc50b2 build benchmarks in Parallel, part of #550 (by @adamsitnik) e59590 Display VM name in summary section, fixes #574 (#576) (by @lukasz-pyrzyk) 8908f8 fix GetMethod (by @nietras) 4ca82d Merge pull request #615 from nietras/disassembler-more-than-one-method-fix (by @adamsitnik) 387ae5 be more defensive when trying to read source code with disassembler, part of ... (by @adamsitnik) 703815 docs: how to contribute to disassembler (by @adamsitnik) 242671 Enable ApprovalTests in .NET Core 2.0 tests, fixes #618 (by @AndreyAkinshin) c4d21b Print amount of logical and physical core #582 (#607) (by @morgan-kn) e33e84 Add HtmlReady dialect for MarkdownExporter, fixes #608 (by @AndreyAkinshin) cf167b Enable html escaping for GitHub markdown dialect, fixes #608 (by @AndreyAkinshin) 8bb28b Logical group support, fixes #617 (by @AndreyAkinshin) ae87c6 Merge pull request #619 from dotnet/logical-groups (by @adamsitnik) 14e90b parallel build post fix: don't write the compilation errors to NullLogger, re... (by @adamsitnik) db4ae8 Try to search for missing references if build fails, fixes #621 (by @adamsitnik) 0eba0f Support of new GC settings, fixes #622 (by @adamsitnik) e31b2d Revert Samples/Program.cs (by @AndreyAkinshin) 7f126b Add logs in RPlotExporter (by @AndreyAkinshin) f8a447 Fix path to csv in RPlotExporter, fixes #623 (by @AndreyAkinshin) 273f50 New plots in RPlotExporter (by @AndreyAkinshin) f293f0 New README.md (#620) (by @AndreyAkinshin) 5e3366 Update copyright year in docs (by @AndreyAkinshin) ab7458 Update index in docs (by @AndreyAkinshin) 4616d4 Set library version: 0.10.12 (by @AndreyAkinshin) Contributors (9) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Christopher Gozdziewski (@Chrisgozd) Erik O'Leary (@onionhammer) Georgii Plotnikov (@GeorgePlotnikov) Irina Ananeva (@morgan-kn) Łukasz Pyrzyk (@lukasz-pyrzyk) Mikhail Filippov (@mfilippov) nietras (@nietras) Thank you very much! Additional details Date: January 15, 2018 Milestone: v0.10.12 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.12 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.12 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.12 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.12 BenchmarkDotNet v0.10.11 Highlights ByRef and Stack-only support (#492, sample) .NET Core 2.1 support (#587) Improved LINQPad support Smart logic for precision in ScaledColumn (#509, #590) Better macOS version detection (15d72388) Minor fixes and improvements Milestone details In the v0.10.11 scope, 6 issues were resolved and 8 pull requests were merged. This release includes 18 commits by 8 contributors. Resolved issues (6) #509 Better formatting for the Scaled column #579 Improve error message about non-optimized dependencies (assignee: @adamsitnik) #580 How to get benchmarks running from LINQPad? (assignee: @adamsitnik) #587 Support netcoreapp2.1 (assignee: @eerhardt) #588 Broken appveyor build #593 BenchmarkDotNet is not working with LinqPad (assignee: @adamsitnik) Merged pull requests (8) #492 ByRef and Stack-only support (by @adamsitnik) #575 xUnit runner upgrade and small tests refactoring (by @Ky7m) #584 Fixed typo. (by @cincuranet) #589 Add support for netcoreapp2.1 (by @eerhardt) #590 Add precision to Scaled Column (by @Chrisgozd) #591 Fix CI build (by @Ky7m) #592 Removed a xunit workaround because an issue has been fixed (by @AlekseiKudelia) #597 Fix typo in WithCustomBuildConfiguration API (by @benjamin-hodgson) Commits (18) 2a2e6c ByRef and Stack-only support (#492) (by @adamsitnik) 676c77 xUnit runner upgrade and small tests refactoring (#575) (by @Ky7m) 7a89cd Fixed typo. (by @cincuranet) dd28b2 add better error text for non-optimized dlls + add it to FAQ, fixes #579 (by @adamsitnik) 67e659 detect LINQPad problems and tell the user how to change them, fixes #580 (by @adamsitnik) 543bd6 don't warn about non-optimized LINQPad dependency (it's OK), #580 (by @adamsitnik) 8a94f2 Add support for netcoreapp2.1 (by @eerhardt) fb39db Merge pull request #589 from eerhardt/SupportNetCoreApp21 (by @adamsitnik) ef11f0 Add CoverageFilterXml in DotSettings (by @AndreyAkinshin) 962b6a Update DotSetttings (by @AndreyAkinshin) 717b62 BenchmarkDotNet.Horology cleanup (by @AndreyAkinshin) d1720b Upgrade version to 2.0.3 and explicitly specify fx version for .netcoreapp2.0 (by @Ky7m) 94d47a Removed a xunit workaround because an issue has been fixed (by Aleksei Kudelia) 15d723 More details in GetOsVersion on macOS (by @AndreyAkinshin) 696f89 Add precision to Scaled Column (#590) (by @Chrisgozd) e54924 Fix typo in WithCustomBuildConfiguration API (by Benjamin Hodgson) 8de978 Merge pull request #597 from benjamin-hodgson/patch-1 (by @adamsitnik) af1510 Set library version: 0.10.11 (by @AndreyAkinshin) Contributors (8) Adam Sitnik (@adamsitnik) Aleksei Kudelia Andrey Akinshin (@AndreyAkinshin) Benjamin Hodgson Christopher Gozdziewski (@Chrisgozd) Eric Erhardt (@eerhardt) Igor Fesenko (@Ky7m) Jiri Cincura ↹ (@cincuranet) Thank you very much! Additional details Date: December 01, 2017 Milestone: v0.10.11 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.11 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.11 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.11 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.11 BenchmarkDotNet v0.10.10 Highlights: Disassembly Diagnoser (read more here: Disassembling .NET Code with BenchmarkDotNet) ParamsSources .NET Core x86 support Environment variables and Mono args support Better environment description More: additional sections in the documentation, bug fixes, build script improvements, internal refactoring. Overview post: BenchmarkDotNet v0.10.10 Milestone details In the v0.10.10 scope, 34 issues were resolved and 18 pull requests were merged. This release includes 95 commits by 12 contributors. Resolved issues (34) #160 Make ClrMd Source diagnoser working with new ClrMD api (assignee: @adamsitnik) #167 Detect virtual machine environment (assignee: @lukasz-pyrzyk) #262 Runtime knobs (assignee: @adamsitnik) #310 Support 32bit benchmarks for .NET Core (assignee: @adamsitnik) #350 ParamsSource (assignee: @adamsitnik) #437 Add DisassemblyDiagnoser for outputting disassembled JITed code. (assignee: @adamsitnik) #466 MSBuild parameters are not passed to generated benchmark project (assignee: @adamsitnik) #495 Attributes put on base methods are not considered in derived class (assignee: @lukasz-pyrzyk) #500 Borken compilation for net46 projects when .NET Framework 4.7 is installed (assignee: @adamsitnik) #505 JsonExporterBase doesn't include MemoryDiagnoser stats in output #511 [bug] Bug in GetTargetedMatchingMethod() logic #513 IterationSetup not run in Job.InProcess #516 Get a compilation error \"CS1009: Unrecognized escape sequence\" when using verbatim strings #519 BenchmarkSwitcher.RunAllJoined throws InvalidOperationException (assignee: @AndreyAkinshin) #526 Remove project.json support (assignee: @adamsitnik) #529 No namespace in export filenames can lead to data loss #530 Build error on Appveyor with recent changes. #533 When I clone, build, and run BenchmarkDotNet.Samples I get an error #534 Allow the users to compare 32 vs 64 RyuJit for .NET Core (assignee: @adamsitnik) #535 No way to set RuntimeFrameworkVersion in multiple-version config (assignee: @adamsitnik) #536 Strange disassembly ordering/truncation (assignee: @adamsitnik) #537 Can't benchmark a netstandard2.0 project (assignee: @adamsitnik) #538 Duplicate using causing benchmark not to work (assignee: @adamsitnik) #539 Target .NET Core 2.0 to take advantage of the new APIs (assignee: @adamsitnik) #540 Artifacts for disassembler projects (assignee: @adamsitnik) #542 Problems with Disassembler + Job.Dry (assignee: @adamsitnik) #555 Test \"CanDisassembleAllMethodCalls\" fails on Ubuntu (assignee: @adamsitnik) #556 Table in report is broken in VSCode markdown viewer (assignee: @adamsitnik) #558 Warn the users when running Benchmarks from xUnit with shadow copy enabled (assignee: @adamsitnik) #559 DissassemblyDiagnoser jit/arch info seems to be wrong (assignee: @adamsitnik) #561 Strange behaviour when benchmark project is build in debug mode (assignee: @adamsitnik) #562 DisassemblyDiagnoser crashes on overloaded benchmark (assignee: @adamsitnik) #564 [Bug] Benchmarking a method doesn't run global setup when filter is applied (assignee: @adamsitnik) #571 Allow users to use non compile-time constants as Parameters (assignee: @adamsitnik) Merged pull requests (18) #507 Fix a typo in Jobs.md (by @aidmsu) #508 Fixed some typos and grammar (by @lukasz-pyrzyk) #512 Warning about antivirus software after benchmark failure (by @lukasz-pyrzyk) #514 #495 - Unit test for reading attributes from the base class (by @lukasz-pyrzyk) #515 Fix #513 - IterationSetup not run in Job.InProcess (by @ig-sinicyn) #518 Fixed information about MemoryDiagnoser. (by @cincuranet) #520 XML Exporter documentation and samples (by @Teknikaali) #525 adding validator for setup cleanup attributes (by @ipjohnson) #527 Detecting virtual machine hypervisor, #167 (by @lukasz-pyrzyk) #531 Remove --no-build argument for dotnet test & pack commands. (by @Ky7m) #532 Fix type of local in EmitInvokeMultipleBody (by @pentp) #547 Fix markdown headers (by @jawn) #548 Fix condition in package reference list and update dotnet cli version from 1.0.4 to 2.0.0 for non-Windows system (by @Ky7m) #549 Project files cleanup (by @Ky7m) #552 Fix exporters to use fully qualified filenames (by @Teknikaali) #563 Remove leading space character in a MD table row, #556 (by @rolshevsky) #565 Single point of full config creation (by @ig-sinicyn) #569 Update cakebuild scripts (by @Ky7m) Commits (95) 682820 Fix typo in Jobs.md (by @aidmsu) e82a8b Fixed some typos and grammar (by @lukasz-pyrzyk) a0e9b9 Disassembly Diagnoser: displaying ASM, IL and C# for any JIT (by @adamsitnik) 57e0f0 recursive disassembling (by @adamsitnik) 1975ae return structured results from Disassembler (by @adamsitnik) 9ae365 Warning about antivirus software after benchmark failure (#512) (by @lukasz-pyrzyk) 74b41e Unit test for reading attributes from the base class, fixes #495 (by @lukasz-pyrzyk) 3bab2d Fix #513 - IterationSetup not run in Job.InProcess (#515) (by @ig-sinicyn) 769a39 use the IL instructions to detect more calls (by @adamsitnik) b69537 use InstructionPointer to combine asm with hardware counters (by @adamsitnik) 200244 Fixed information about MemoryDiagnoser. (by Jiri Cincura) 848a1a handling the lovely edge cases (Cecil vs ClrMD differences in naming types an... (by @adamsitnik) 40049b single text representation of asm is a range of IPs! (by @adamsitnik) 56e252 XML Exporter documentation and samples (#520) (by @Teknikaali) c18597 eliminate duplicates (ClrMD fault), be more defensive for edge cases (by @adamsitnik) a9262f allow the users to specify recursive depth limit (50MB output for simple lock... (by @adamsitnik) fbe329 Support params which include slashes, fixes #516 (by @AndreyAkinshin) f2b9c0 Fix RunAllJoined, fixes #519 (by @AndreyAkinshin) 983764 UX ;) (by @adamsitnik) c010de adding validator for setup cleanup attributes (by @ipjohnson) 424723 Merge pull request #525 from ipjohnson/master (by @adamsitnik) 7b680a prefer unit tests over integration tests if possible (by @adamsitnik) 93dc6e Remove project.json support, fixes #526 (by @adamsitnik) 19f22b Merge pull request #518 from cincuranet/docs (by @adamsitnik) fe2db1 configurable, runtime specific diagnosers, hard part transparent to end users (by @adamsitnik) fb60e5 disassembly diagnoser for Mono (by @adamsitnik) 55ce0d smart diagnoser can choose the right disassembler (by @adamsitnik) 46c911 one test to verify all scenarios (by @adamsitnik) d06086 minor improvements (by @adamsitnik) 116119 group instructions into maps for better visualization (by @adamsitnik) d19b1e test fix: split on any new line ;) (by @adamsitnik) 647a67 Merge branch 'asm' (by @adamsitnik) 91c8e4 move disassembler stuff to resources of Core project to make it super easy to... (by @adamsitnik) 363900 Remove --no-build argument for dotnet test & pack commands. (by @Ky7m) 22e993 Disable parallel build option (by @Ky7m) 9c327c Merge pull request #531 from Ky7m/removes-no-build-argument (by @adamsitnik) 20db28 the docs for Disassembly Diagnoser, #437 (by @adamsitnik) 13732b added asm report with navigation (by @adamsitnik) 33ee03 fix type of local in EmitInvokeMultipleBody (by @pentp) 7d943f Merge pull request #532 from pentp/master (by @adamsitnik) 4d173d RyuJit 32bit support for .NET Core, fixes #310, fixes #533 (by @adamsitnik) 5f5237 test fix (set platform in explicit way to avoid lack of 32-bit .NET Core sdk ... (by @adamsitnik) f359c9 allow the users to set custom RuntimeFrameworkVersion, fixes #535 (by @adamsitnik) 264150 disassembler: print the results in machine code order, not il, part of #536 (by @adamsitnik) 0088bd Detecting virtual machine hypervisor, #167 (#527) (by @lukasz-pyrzyk) 007444 print all returns (maps with negative ILOffset are not always prolog or epilo... (by @adamsitnik) aebc32 empty methods for LegacyJit64 have only maps with negative ILOffset, #536 (by @adamsitnik) ba7489 docs for Toolchains, closes #537 (by @adamsitnik) 8c4f53 allow the users to specify custom build configuration, #466, close #528 (by @adamsitnik) eb80b2 Environment Variables support, #262 (by @adamsitnik) ab7045 test fixes ;) (by @adamsitnik) 455c60 allow the users to specify custom arguments (Mono, MsBuild), #466, #262 (by @adamsitnik) e03384 make sure that all new custom settings are presented in human friendly way, #262 (by @adamsitnik) cc8d07 enforce TreatWarningsAsErrors=False in auto-generated csproj to override glob... (by @adamsitnik) 97ab49 target .NET Core 2.0 to take full advantage of the new API, fixes #539 (by @adamsitnik) 8b2c7e check if reference assemblies are installed when choosing the default .NET fr... (by @adamsitnik) feabd1 bump the .NET Core version, #539 (by @adamsitnik) a21f86 for .NET Core 1.1 we should run only the Backward Compatibility tests. #539 (by @adamsitnik) b7a966 typo fix (by @adamsitnik) 73a30a docs: Customizing Mono, Env Variables & minor updates, fixes #262 (by @adamsitnik) 612b41 exclude Artifacts for disassembler projects, fixes #540 (by @adamsitnik) 360326 typo, #540 (by @adamsitnik) f3e4ae show nice error when Job.Dry is used for Disassembler, fixes #542 (by @adamsitnik) c6bbda allow to specify custom dotnet cli path to compare RyuJit 32 vs 64 for .NET C... (by @adamsitnik) a0c7e5 Add info about Redstone 3,4 in WindowsBrandVersions (by @AndreyAkinshin) d42262 Additional info about WindowsBrandVersions (by @AndreyAkinshin) cd0a1f Improve formatting in WindowsBrandVersions (by @AndreyAkinshin) 1cd844 Fix OsBrandStringTests.WindowsIsPrettified (by @AndreyAkinshin) f00787 Fix markdown headers (by @jawn) 363814 Merge pull request #547 from jawn/patch-1 (by @adamsitnik) 405c4c Update dotnet cli version from 1.0.4 to 2.0.0 for non-Windows system. (#548) (by @Ky7m) 97a9b2 Fix compiler warning connected to problem with the XML tag. (by @Ky7m) 24585d Remove PackageTargetFallback element. (by @Ky7m) 174c19 Merge pull request #549 from Ky7m/csproj-files-cleanup (by @AndreyAkinshin) 84a4e2 Fix exporters to use fully qualified filenames (#552), fixes #529 (by @Teknikaali) a7578a disable Disassembler tests for non-Windows OS, fixes #555 (by @adamsitnik) a147dd Remove leading space character in a MD table row, fixes #556 (by @rolshevsky) 9c194c DisassemblyDiagnoser crashes on overloaded benchmark, fixes #562 (by @adamsitnik) 9076a6 give users nice warning when they run into shadow copy issues, fixes #558 (by @adamsitnik) 1670ca the build fix ;) (by @adamsitnik) d5854d Include UBR in Windows versions (by @AndreyAkinshin) 1fcfee display correct runtime info in exported disassembly result, fixes #559 (by @adamsitnik) de45ad Single point of full config creation (#565) (by @ig-sinicyn) 395a52 make sure filters don't exclude Setup/Cleanup methods, fixes #564 (by @adamsitnik) 4276ac fail when running benchmarks in Debug with DefaultConfig, fixes #561 (by @adamsitnik) 0145f8 Fix build number for Windows 10 Fall Creators Update (by @AndreyAkinshin) 7f7a7c Update cakebuild scripts (#569) (by @Ky7m) cff577 introduce ParamsSource attribute, fixes #350, part of #256 (by @adamsitnik) 3af915 introduce IParam to support complex, not-compile time constants as parameters... (by @adamsitnik) 4a877f build the disassemblers before .Core, but don't add the dependency to them to... (by @adamsitnik) 188850 specify all the embedded resources in explicit way to avoid some crazy MSBuil... (by @adamsitnik) b5fbbf Typo fix (by @AndreyAkinshin) eb90ce Update message in JitOptimizationsValidator (by @AndreyAkinshin) 6c1137 Updated DotSettings (by @AndreyAkinshin) 3d0dfe Set library version: 0.10.10 (by @AndreyAkinshin) Contributors (12) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Andrey Dorokhov (@aidmsu) Anssi Kettunen (@Teknikaali) Bernard Vander Beken (@jawn) Ian Johnson (@ipjohnson) ig-sinicyn (@ig-sinicyn) Igor Fesenko (@Ky7m) Jiri Cincura Łukasz Pyrzyk (@lukasz-pyrzyk) Pent Ploompuu (@pentp) Rostislav Olshevsky (@rolshevsky) Thank you very much! Additional details Date: November 03, 2017 Milestone: v0.10.10 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.10 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.10 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.10 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.10 BenchmarkDotNet v0.10.9 Migrate from custom build scripts to Cake (C# Make) (#426, #475, thanks @Ky7m) Target Setup methods for specific Benchmarks (#469, #501, thanks @ipjohnson) Many improvements in XmlExporter (#476, #488, thanks @Teknikaali) Add MemoryDiagnoser results to JsonExporter output (#453, #478, thanks @Teknikaali) Detect correct version of .NET Core (+ improved presentation for information about runtime) (#448, ed586585...ed586585) Fix UnauthorizedAccessException (#380, #390, #490, #491, 8505abb5) Fix app.config generation (#499, dc6dc411) Fix incorrect order of IterationCleanup and Benchmark jitting (#481, #503) Fix test scripts for MacOS+zsh (1177c8) Unix-related ProcessorAffinity fixes (#474, 26d44411) Minor fixes in docs (#465, #467, #473, #480, #483, thanks @mtschneiders, @davkean, @aarondandy, @AmadeusW) Temporary hacks for appveyor connectivity incident (#497, #506) Additional warnings for incorrect Configs (#482, eb84825f) Additional warnings for F# methods with spaces (#479, 3c2c8dec, 7ba1c809, 3ca39afe) Milestone details In the v0.10.9 scope, 13 issues were resolved and 14 pull requests were merged. This release includes 37 commits by 10 contributors. Resolved issues (13) #380 Problem running benchmark due to \"could not copy\" during build (assignee: @adamsitnik) #390 Crashing benchmark (assignee: @adamsitnik) #426 Migrate from custom build scripts to Cake (C# Make) #448 Detect correct version of .NET Core (assignee: @AndreyAkinshin) #453 MemoryDiagnoser and JsonExporter #469 [Suggestion] Specify Setup per benchmark (assignee: @AndreyAkinshin) #474 PlatformNotSupportedException when reading ProcessorAffinity on non-Windows platforms (assignee: @AndreyAkinshin) #479 Invalid C# code generated for valid F# identifiers (assignee: @adamsitnik) #481 Iteration cleanup runs before the benchmark (assignee: @AndreyAkinshin) #482 Benchmark seems to hang when no logger is defined (assignee: @adamsitnik) #490 BDN.Generated.exe is locking files when killed with ctrl+c (assignee: @adamsitnik) #491 UnauthorizedAccessException preventing report to be written (assignee: @adamsitnik) #499 Opting into app-compat switches in a benchmark doesn't work (assignee: @adamsitnik) Merged pull requests (14) #465 Small correction in Filters.md (by @mtschneiders) #467 Small improvements to FAQ.md (by @mtschneiders) #471 Corrected typos in Filters.md and IntroFilters.cs (by @mtschneiders) #473 Adds ISummaryStyle information to the Exporters guide (by @AmadeusW) #475 Cake (C# Make) integration. Migration from custom build scripts. (by @Ky7m) #476 Improve Xml exporter's discoverability (by @Teknikaali) #478 Add MemoryDiagnoser results to JsonExporter output (by @Teknikaali) #480 Fix links to Overview/FAQ (by @davkean) #483 Update jobs docs (by @aarondandy) #488 Improve XmlExporter (by @Teknikaali) #497 Add temporary solution to address connectivity issues to nuget.org (by @Ky7m) #501 Target Setup methods for specific Benchmarks (by @ipjohnson) #503 Make sure IterationCleanup is run after Jitting (by @smitpatel) #506 Removes a temporary solution related to connectivity issues to nuget (by @Ky7m) Commits (37) 0b5657 Small correction in comments (by @mtschneiders) b1ad2c Merge pull request #465 from mtschneiders/patch-1 (by @adamsitnik) 3bb154 Small corrections to FAQ.md (by @mtschneiders) 1a8559 Merge pull request #467 from mtschneiders/patch-2 (by @adamsitnik) fc4dfe Corrected typos in Filters.md and IntroFilters.cs (by @mtschneiders) cb5072 Remove UpgradeLog.htm (by @AndreyAkinshin) 7013bd Adds ISummaryStyle information to the Exporters guide (by @AmadeusW) 345af7 wording (by @AmadeusW) a114ea Merge pull request #473 from AmadeusW/docs/exporters (by @adamsitnik) 26d444 Unix-related ProcessorAffinity fixes (fix #474) (by @AndreyAkinshin) 2d8a53 Improve Xml exporter's discoverability (#476) (by @Teknikaali) baebf9 Add MemoryDiagnoser results to JsonExporter output (#478) (by @Teknikaali) 32993c Fix links to Overview/FAQ (by @davkean) 8e712c Merge pull request #480 from davkean/FixLinks (by @adamsitnik) 43405d Update jobs docs (by @aarondandy) 1bacac Merge pull request #483 from aarondandy/docs-changes (by @adamsitnik) 3c2c8d print nice error for F# methods that contain whitespaces, fixes #479 (by @adamsitnik) 7ba1c8 post code review #479 (by @adamsitnik) 3ca39a even more post code review #479 (by @adamsitnik) eb8482 warn the users if no logger, columns or exporters were defined, fixes #482 (by @adamsitnik) 8505ab unique file names by default, are removed after printing the results, fix #49... (by @adamsitnik) 3e74aa Improve XmlExporter (#488) (by @Teknikaali) 6e2577 Cake (C# Make) integration. Migration from custom build scripts. (#475) (by @Ky7m) 6e6fcc Add temporary solution to address connectivity issues to nuget.org https://ap... (by @Ky7m) dc6dc4 all runtime settings, that do not belong to Job must be rewritten by default ... (by @adamsitnik) ed5865 Rename \"dotnet cli version\" to \".NET Core SDK\", see #448 (by @AndreyAkinshin) 857f2b Detecting the correct version of .NET Core, fixing #448 (by @AndreyAkinshin) 7ec001 Don't print information about unknown timers in HostEnvironmentInfo (by @AndreyAkinshin) 4c3c82 Add missing space in HostRuntimeInfo (by @AndreyAkinshin) da8226 Print actual information about .NET Framework version in summary, see #448 (by @AndreyAkinshin) cea199 Fix MultipleRuntimesTest.SingleBenchmarkCanBeExecutedForMultpleRuntimes (by @AndreyAkinshin) db56bc Make sure IterationCleanup is run after Jitting (by @smitpatel) 3df90f Merge pull request #503 from smitpatel/orderingissue (by @adamsitnik) 1177c8 Improve tests/runCoreTests.sh (by @AndreyAkinshin) 976900 Removes a temporary solution related to connectivity issues to nuget.org http... (by @Ky7m) 557246 Target Setup methods for specific Benchmarks (#501) (by @ipjohnson) 80d70a Set library version: 0.10.9 (by @AndreyAkinshin) Contributors (10) Aaron Dandy (@aarondandy) Adam Sitnik (@adamsitnik) Amadeusz Wieczorek (@AmadeusW) Andrey Akinshin (@AndreyAkinshin) Anssi Kettunen (@Teknikaali) David Kean (@davkean) Ian Johnson (@ipjohnson) Igor Fesenko (@Ky7m) Mateus Artur Schneiders (@mtschneiders) Smit Patel (@smitpatel) Thank you very much! Additional details Date: July 28, 2017 Milestone: v0.10.9 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.9 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.9 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.9 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.9 BenchmarkDotNet v0.10.8 Legend for time units (#349, #459, f14e508e) XML exporter (#157, #452, a0148db8) .NET Framework 4.7 support (#461, 3f2b5c3c, 5513873a) Public API for AllocationQuantum (#450, #462, a0148db8) Milestone details In the v0.10.8 scope, 5 issues were resolved and 3 pull requests were merged. This release includes 8 commits by 4 contributors. Resolved issues (5) #157 Implement export to xml #349 What the report title and value means? (assignee: @AndreyAkinshin) #450 [Minor feature request] Please make GcStats.AllocationQuantum public #459 [Question] What does the unit of measurement us stand for #461 .NET Framework 4.7 support (assignee: @adamsitnik) Merged pull requests (3) #452 Feature: XML Exporter (by @Teknikaali) #455 Wrong xml doc comment (by @ig-sinicyn) #462 make allocation quantum public, deal with a spelling error and expose… (by @RichLinnell) Commits (8) f14e50 Add legend for time units (by @AndreyAkinshin) e59550 Add info about OrderProviders in docs (by @AndreyAkinshin) 6fc245 Fix ConfigPassingTest (by @AndreyAkinshin) ef0583 Feature: XML Exporter (#452) (by @Teknikaali) 3f2b5c .NET 4.7 support from .NET Core host process on Windows, fixes #461 (by @adamsitnik) a0148d make allocation quantum public, deal with a spelling error and expose allocat... (by @RichLinnell) 551387 add Windows check to our CsProjClassicNetToolchain (by @adamsitnik) 971565 Set library version: 0.10.8 (by @AndreyAkinshin) Contributors (4) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Anssi Kettunen (@Teknikaali) Rich Linnell (@RichLinnell) Thank you very much! Additional details Date: June 09, 2017 Milestone: v0.10.8 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.8 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.8 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.8 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.8 BenchmarkDotNet v0.10.7 LINQPad support (5.22.05+) (#66, #445) Benchmark filters and categories (#248) Updated setup/cleanup attributes: [GlobalSetup], [GlobalCleanup], [IterationSetup], [IterationCleanup] (#270, #274, #325, #456) Better Value Types support (afa803d0) Building Sources on Linux: it's possible to build the solution (with unloaded F#/VB projects), run samples (for both net46/netcoreapp1.1), run unit tests (for netcoreapp1.1 only) Fix minor bugs in JsonExporter (#451) Milestone details In the v0.10.7 scope, 6 issues were resolved and 1 pull requests were merged. This release includes 24 commits by 4 contributors. Resolved issues (6) #66 Friendliness to LinqPad (assignee: @adamsitnik) #248 Support a \"category\" attribute for selecting benchmarks (assignee: @AndreyAkinshin) #270 Add support for Cleanup and Setup between benchmarks (assignee: @AndreyAkinshin) #274 Support for run-once Setup and Clean-up with Parameters available (assignee: @AndreyAkinshin) #325 Setup & Cleanup versions of attribute which would run before/after each benchmark iteration (assignee: @AndreyAkinshin) #445 Missing reference to Microsoft.CodeAnalysis.CSharp when using BenchmarkDotNet in Linqpad (assignee: @adamsitnik) Merged pull requests (1) #451 Fix minor bugs in JsonExporter (by @Teknikaali) Commits (24) a54645 handle the LINQPad shadow copying, #445, #66 (by @adamsitnik) fe3032 Add Filters (by @AndreyAkinshin) 2e7427 Add categories (by @AndreyAkinshin) f96346 Add categories filters (by @AndreyAkinshin) 34f808 Support category filters in BenchmarkSwitcher (by @AndreyAkinshin) 786afe Implement join mode in BenchmarkSwitcher (by @AndreyAkinshin) a77a77 Post code review changes (by @AndreyAkinshin) cc7006 Fix minor bugs in JsonExporter (#451) (by @Teknikaali) 4dd789 Rename Setup/Cleanup to GlobalSetup/GlobalCleanup (by @AndreyAkinshin) 21369c Introduce IterationSetup/IterationCleanup (by @AndreyAkinshin) 0e9be7 Add IterationSetupCleanupAnalyser (by @AndreyAkinshin) 4f3703 docs: update structure (by @AndreyAkinshin) 5fe564 docs: add info about RunStrategy.Monitoring and new Setup/Cleanup attributes (by @AndreyAkinshin) 87ce0f Mark ProcessPropertiesTests as WindowsOnly (by @AndreyAkinshin) 7e479e Fix typo in File_StreamVsMemoryMapperVewStream.cs (by @AndreyAkinshin) 975514 Wrong xml doc comment (by @ig-sinicyn) 165b13 Merge pull request #455 from ig-sinicyn/patch-1 (by @adamsitnik) afa803 better Value Types support (by @adamsitnik) d16ddb workaround for weird AppVeyor behavior (by @adamsitnik) 9f3d68 support recursive nesting for returned types (by @adamsitnik) b7668e Add tests/runCoreTests.sh (by @AndreyAkinshin) 3cceb6 runCoreTests.sh: fix output file for integration-tests (by @AndreyAkinshin) a21421 Make some tests Windows-only (by @AndreyAkinshin) 00a156 Set library version: 0.10.7 (by @AndreyAkinshin) Contributors (4) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Anssi Kettunen (@Teknikaali) ig-sinicyn (@ig-sinicyn) Thank you very much! Additional details Date: June 05, 2017 Milestone: v0.10.7 Overview post: https://aakinshin.net/posts/bdn-v0_10_7/ NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.7 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.7 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.7 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.7 BenchmarkDotNet v0.10.6 Removed buggy allocation from Engine which was spoiling the results of MemoryDiagnoser for micro benchmarks. This part of the code is now guarded with very strict integration tests, it should never happen again. We now also exclude the side effects of the Allocation Quantum. This bug was serious, you must update to 0.10.6 (#439) Support of the PackageTargetFallback setting which allows to reference components that target old framework monikers (like dotnet5.4 or portable-net45+win8) (#438) Added InstructionRetiredPerCycleColumn which shows up automatically when HardwareCounter.InstructionRetired and HardwareCounter.TotalCycles are used. Support benchmark classes without namespace (#446) Fix problem with RPlotExporter and quoted directories in %PATH% (#446) Show Windows brand version in summary Milestone details In the v0.10.6 scope, 3 issues were resolved and 1 pull requests were merged. This release includes 11 commits by 3 contributors. Resolved issues (3) #438 Need to Update Autogenerated csproj file (assignee: @adamsitnik) #439 Question - This benchmark apparently allocates, but why? (assignee: @adamsitnik) #446 ArgumentNullException if RPlotExporter is used (assignee: @AndreyAkinshin) Merged pull requests (1) #444 Added line separator at the end in JsonExporters (by @alinasmirnova) Commits (11) 3c1f09 copy the PackageTargetFallback setting if present in csproj to support older ... (by @adamsitnik) ffab7d remove allocation from Engine, make sure tests detect breaking change in the ... (by @adamsitnik) 7c9a0f consider Allocation Quantum side effects to have correct results for micro be... (by @adamsitnik) 4af5f3 Added line separator in JsonExporters (by @alinasmirnova) 8ac913 added Instruction Retired per Cycle (IPC) to the predefined columns for Pmc D... (by @adamsitnik) 0898c3 post code review changes (by @adamsitnik) b4d68e 'kB' -> 'KB' (by @AndreyAkinshin) 23bd4f Handle null values in CsvHelper.Escape (by @AndreyAkinshin) 77ed63 RPlotExporter.FindInPath: handle exceptions, trim quotes #446 (by @AndreyAkinshin) 626e3a Show Windows brand versions in summary (by @AndreyAkinshin) 247634 Set library version: 0.10.6 (by @AndreyAkinshin) Contributors (3) Adam Sitnik (@adamsitnik) Alina Smirnova (@alinasmirnova) Andrey Akinshin (@AndreyAkinshin) Thank you very much! Additional details Date: May 12, 2017 Milestone: v0.10.6 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.6 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.6 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.6 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.6 BenchmarkDotNet v0.10.5 Fixed SizeUnit presentation in the summary table (#434) In MemoryDiagnoser, now 1kB = 1024B (instead of 1000 in v0.10.4) (#434) Fix false allocations detection (#436 9b44de70) Hide ScaledSD column for small values (da857ad7) Autoselecting amount of digits after the decimal point (#404) Milestone details In the v0.10.5 scope, 3 issues were resolved and 2 pull requests were merged. This release includes 16 commits by 4 contributors. Resolved issues (3) #404 Autoselecting amount of digits after the decimal point (assignee: @AndreyAkinshin) #428 Cleanup NuGet.Config (assignee: @adamsitnik) #434 Allocation output suddenly is 0 GB (assignee: @AndreyAkinshin) Merged pull requests (2) #435 Joined approved files according to cultures (by @alinasmirnova) #436 Fix false allocations detection (by @ig-sinicyn) Commits (16) d9eefd NuGet feeds cleanup, fixes #428 (by @adamsitnik) 2a95b0 Fix SizeUnit presentation, fixes #434 (by @AndreyAkinshin) 8eca28 Add a note about kilobytes in docs (by @AndreyAkinshin) ae483e Separate approved files only for cultures, not for exporters (by @alinasmirnova) 78a6a0 Improved legend for MemoryDiagnoser (by @AndreyAkinshin) 47ae20 SizeUnitTests (by @AndreyAkinshin) 9b44de fix false allocations detection (by @ig-sinicyn) ffd535 Merge pull request #436 from ig-sinicyn/fix_allocations_on_run (by @adamsitnik) 87c2bd Inclusive ConfidenceInterval.Contains (by @AndreyAkinshin) da857a Don't show the ScaledSD column if values are small (by @AndreyAkinshin) e0cf24 Add DefaultColumnProvidersTests (by @AndreyAkinshin) f2baa3 Fix typo in DefaultColumnProvidersTests (by @AndreyAkinshin) 117560 Fix BaselineScaledColumnTest.ColumnsWithBaselineGetsScaled (by @AndreyAkinshin) 3a1fb7 Implement BestAmountOfDecimalDigits for statistics columns in SummaryTable, f... (by @AndreyAkinshin) 4201ee Fix ToolchainTest.CustomToolchainsAreSupported (by @AndreyAkinshin) cba245 Set library version: 0.10.5 (by @AndreyAkinshin) Contributors (4) Adam Sitnik (@adamsitnik) Alina Smirnova (@alinasmirnova) Andrey Akinshin (@AndreyAkinshin) ig-sinicyn (@ig-sinicyn) Thank you very much! Additional details Date: April 26, 2017 Milestone: v0.10.5 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.5 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.5 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.5 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.5 BenchmarkDotNet v0.10.4 New logo Update to Roslyn 2.0, drop .NET 4.5 support (#303) Initial support of HardwareCounters (Windows only) Initial experimental support of in-process benchmarks Optional configs for BenchmarkSwitcher (#391, #392) Host API interface (#356) Improved measurements for async benchmarks (#415) Improved precision level (MinIterationTimes is 500ms instead of 200ms; introduced AccuracyMode.MaxAbsoluteError and AccuracyMode.MaxRelativeError instead of AccuracyMode.MaxStdErrRelative; logic which select amount of iterations uses confidence intervals instead of standard errors; the Error column (half of CI99.9%) is shown by default instead of StdErr) Introduced ISummaryStyle, raw data in CSV reports (#118, #146, #396) Handle cases when report files are existed and locked (#414, #416) MarkdownExporter right-justifies numeric columns (#421) Better colors for console output (#376) Column legends Add information about CPU microarchitecture for well-known processors to summary Fix AssemblyInformationalVersionAttribute (#382) Fix incorrect method filtering in BenchmarkSwitcher (#365) Fix OS Version in Summary for Windows 10 (#351) Fix OS Version on Mono Fix --class and --method filtering (#249) Fix --exporters option (#189) Fix escaping logic in CsvExporter (#294, #409) Fix MacOS detection Minor bugfixes and API improvements Milestone details In the v0.10.4 scope, 23 issues were resolved and 14 pull requests were merged. This release includes 103 commits by 9 contributors. Resolved issues (23) #118 Raw data in CSV reports (assignee: @AmadeusW) #146 Ability to specify units / easier comparison (assignee: @AmadeusW) #159 Warn user if no Columns were defined (assignee: @adamsitnik) #189 --exporters option appears not to be working (assignee: @adamsitnik) #249 --class and --method should combine as \"AND\" filtering (assignee: @adamsitnik) #294 [Suggestion] CSVHelper.Escape() method should check for actual separator value (assignee: @alinasmirnova) #303 Update to Roslyn 2.0 when RTM is shipped to nuget.org (assignee: @adamsitnik) #351 Fix OS Version in Summary for Windows 10 (assignee: @adamsitnik) #352 Troubles with CoreJob on Linux (assignee: @adamsitnik) #365 [Minor bug] Benchmark switcher: incorrect method filtering (assignee: @adamsitnik) #376 Pick better background colors for output (assignee: @AndreyAkinshin) #382 AssemblyInformationalVersion doesn't work (assignee: @AndreyAkinshin) #388 Precise Machine Counter Diagnoser (assignee: @adamsitnik) #391 BenchmarkSwitcher should take an optinal IConfig #393 Troubles with ClrJob in .NET Core applications (assignee: @adamsitnik) #395 Could not load file or assembly 'System.Reflection.Metadata' (assignee: @adamsitnik) #401 Exceptions in Roslyn.Builder (assignee: @adamsitnik) #406 BenchmarkDotNet with netcoreapp2.0 requires using RuntimeFrameworkVersion directly in the project file (assignee: @adamsitnik) #410 Troubles with Classic applications on nightly BenchmarkDotNet (assignee: @adamsitnik) #412 HardwareCounter.InstructionRetired failing with ArgumentNullException. Build 82 (assignee: @adamsitnik) #415 Allocations for async methods measures BenchmarkDotNet (assignee: @adamsitnik) #419 Suspicious warnings about MemoryMappedFiles (assignee: @adamsitnik) #424 Make InliningDiagnoser filtering more flexible (assignee: @adamsitnik) Merged pull requests (14) #356 Feature: host API interface (by @ig-sinicyn) #379 Feature: in-process benchmarks (by @ig-sinicyn) #392 Add an optional config to BenchmarkSwitcher. (by @ILMTitan) #396 Allow users to pick, show and hide measurement units in the reports and exports. (by @AmadeusW) #400 fix spelling error: misspredict => mispredict (by @SteveDesmond-ca) #405 Make RoslynToolchain types public (by @cdmihai) #407 Propagate benchmark to hooks (by @cdmihai) #408 Small fixes before approval tests (by @alinasmirnova) #409 CSVHelper.Escape() method should check for actual separator value (by @alinasmirnova) #416 Exports file to temporary location if target is locked (by @AmadeusW) #421 MarkdownExporter right-justifies numeric columns (by @SteveDesmond-ca) #423 Updated Microsoft.Net.Test.Sdk (by @alinasmirnova) #430 Fix unix OS detection. (by @mfilippov) #432 Fix macOS detection (by @mfilippov) Commits (103) bd790c Simplify BenchmarkDotNet.IntegrationTests.Classic.ReferencesTests (by @AndreyAkinshin) bf9f4e Feature: host API interface (by @ig-sinicyn) f85ffe Merge pull request #356 from ig-sinicyn/feature-host-api (by @AndreyAkinshin) 8ffff0 Feature: in-process benchmarks (by @ig-sinicyn) 51fc0c Feature: in-process benchmarks, FixAffinity() helper (by @ig-sinicyn) c5179f Feature: in-process benchmarks, review fixes (by @ig-sinicyn) 6c5990 Feature: in-process benchmarks, review fixes, part 2 (by @ig-sinicyn) c6b046 Feature: in-process benchmarks, STA & priority on full .Net FW (by @ig-sinicyn) cc2c89 Feature: in-process benchmarks, env validation in toolchain, intro example ad... (by @ig-sinicyn) 101a80 Improved versioning system (by @AndreyAkinshin) 846532 Update links to appveyor (by @AndreyAkinshin) 5464e4 Improved versioning system, part 2 (by @AndreyAkinshin) e39a50 Merge pull request #379 from ig-sinicyn/feature-inprocess (by @adamsitnik) ae4cc8 AssemblyInformationalVersion fix in common.props, resolves #382 (by @AndreyAkinshin) d036f9 Precise Machine Counter Diagnoser #388 (by @adamsitnik) 390442 Improved invocationCount behavior in SimpleJobAttribute (by @AndreyAkinshin) 7b61ed add possibility to set Hardware Counters per class in runtime-independent way... (by @adamsitnik) 6e208c Add an optional config to BenchmarkSwitcher. (by ILMTitan) 935d23 Merge pull request #392 from ILMTitan/master (by @adamsitnik) 6b9a88 update to Roslyn 2.0, drop .NET 4.5 support, fixes #303 (by @adamsitnik) ea4c55 BenchmarkDotNet.IntegrationTests.csproj: fix formatting (by @AndreyAkinshin) 20a537 Update year in LICENSE.md (by @AndreyAkinshin) 878796 Update logo (by @AndreyAkinshin) faba77 Update README.md (by @AndreyAkinshin) 6dce74 Update logo in README.md (by @AndreyAkinshin) 7a750f Another fix in README.md (by @AndreyAkinshin) 1caa0d fix spelling error: misspredict => mispredict (by @SteveDesmond-ca) 742912 use Array.Empty and Task.Completed (after upgrading to .NET 4.6) (by @adamsitnik) 0dafac there is no need to set up with latest VS, fixes #393 (by @adamsitnik) f5d88e Catch exceptions in BenchmarkDotNet.Running.BenchmarkRunnerCore.Run (by @AndreyAkinshin) fa176f Merge pull request #400 from stevedesmond-ca/missspelling (by @AndreyAkinshin) 90c3b1 Docs improvements (by @AndreyAkinshin) 84c524 Mark SimpleJobAttribute with AllowMultiple (by @AndreyAkinshin) 531804 Update README.md (by @AndreyAkinshin) 7f2221 Make RoslynToolchain types public (#405) (by @cdmihai) be8c33 Improved confidence intervals (by @AndreyAkinshin) 767811 Propagate benchmark to hooks (#407) (by @cdmihai) ec5e54 All exporters should not use static environment info (by @alinasmirnova) 2b8a9e Culculate csv separator when it is needed, not in constructor (by @alinasmirnova) 95aeb5 clean up (by @alinasmirnova) 2e74c2 Name field for all exporters (by @alinasmirnova) badb0b Merge pull request #408 from alinasmirnova/small-fixes (by @AndreyAkinshin) 9da9ca search for .NET Core 2.0 settings in imported props files, fixes #406 (by @adamsitnik) 2b08c5 filter sealed, generic and abstract classes from BenchmarkSwitcher, fixes #365 (by @adamsitnik) 14ad55 print correct OS version in summary, fixes #351 (by @adamsitnik) b86f48 BenchmarkDotNet does not support running .NET Core benchmarks when host proce... (by @adamsitnik) 11b51b refactoring in TypeParser (by @adamsitnik) 8047a7 use AND when filtering with args from command line, fixes #249 (by @adamsitnik) 3cf8d8 handle cmd line arguments without '=', fixes #189 (by @adamsitnik) cdc71f test fix after recent changes, #249 (by @adamsitnik) 97c211 detect situation when users want to use Hardware Counters with InProcessToolc... (by @adamsitnik) ba972b Warn user if no Columns were defined, fixes #159 (by @adamsitnik) 2520f2 migrate old csprojs to the new format to get the tests running in common way,... (by @adamsitnik) dd1b4d Improvements in StatisticsTests (by @AndreyAkinshin) 07d149 emptyEnumerable.All(whatever) returns true (by @adamsitnik) 0d61a7 improve dynamic diagnoser loading (case when diagnosers NuGet pacakge is inst... (by @adamsitnik) 5a6937 Ignore BenchmarkProject.json in BenchmarkDotNet.sln.DotSettings (by @AndreyAkinshin) 5895c4 Improvements in TypeParserTests (by @AndreyAkinshin) 1124ae BenchmarkDotNet.Tests: cleanup (by @AndreyAkinshin) d37ef4 CSVHelper.Escape() method should check for actual separator value (by @alinasmirnova) 43643c move hardwareCounters from Job to Config, fixes #412 (by @adamsitnik) 303fff pass config from runner => executor => diagnoser #412 (by @adamsitnik) 5b432e Addded approval tests for exporters (by @alinasmirnova) ac6507 Added more info in mock summary (by @alinasmirnova) a59b17 MockEnvironmentInfo for approval tests (by @alinasmirnova) 610f3b Awaiting Tasks should not interfere allocation results, fixes #415 (by @adamsitnik) cf16f6 I forgot about aligning, #415 (by @adamsitnik) 2860d2 help the .NET framework to resolve assemblies when binding redirects are miss... (by @adamsitnik) e7ad36 don't log false alarms, fixes #419 (by @adamsitnik) 803081 Allow users to pick, show and hide measurement units in the reports and expor... (by @AmadeusW) fa3128 Exports file to temporary location if target is locked (#416) (by @AmadeusW) c923ba MarkdownExporter right-justifies numeric columns (#421) (by @SteveDesmond-ca) aa290d Add column legends (by @AndreyAkinshin) 8d8db5 Handle case when there are no columns with legends (by @AndreyAkinshin) dc201c Add empty line before legends (by @AndreyAkinshin) ff7fc9 Approved files (by @alinasmirnova) 3f6372 Updated Microsoft.Net.Test.Sdk (by @alinasmirnova) 7d23d1 Merge remote-tracking branch 'upstream/master' (by @alinasmirnova) 57cbbb Merge branch 'new-test-sdk-version' (by @alinasmirnova) c0c563 Updated Microsoft.Net.Test.Sdk (by @alinasmirnova) 539834 Updated spproved files according last changes in md exporter (by @alinasmirnova) f117f0 Added *.received and *.orig in .gitignore (by @alinasmirnova) 0d7e72 Make InliningDiagnoser filtering more flexible, fixes #424 (by @adamsitnik) d25eb0 allow to set InProcessToolchain via attribute /cc @ig-sinicyn (by @adamsitnik) 8cf041 Mock strings in mock environment info (by @alinasmirnova) 0db804 Changed file naming in approval files (by @alinasmirnova) 29aeaf correct Idle implementation for Task-returning benchmarks, fixes #418 (by @adamsitnik) c81aa5 the missing docs for Hardware Counters, fixes #388 (by @adamsitnik) 6076e2 Improved precision (by @AndreyAkinshin) 72b3a6 Show \"NA\" for statistic columns with double.NaN values (by @AndreyAkinshin) ea2222 Processor brand string prettifying (by @AndreyAkinshin) 678d43 Added approval files info links to docs (by @alinasmirnova) 33911c Merge remote-tracking branch 'upstream/master' (by @alinasmirnova) d4c928 Fixed approval tests according to recent changes in master (by @alinasmirnova) eb9f4f Fix typos in docs (by @AndreyAkinshin) 271b27 Merge pull request #348 from alinasmirnova/master (by @AndreyAkinshin) 152f3e Parsing Gulftown processor brand strings (by @AndreyAkinshin) 74d793 Minor improvements in docs (by @AndreyAkinshin) 764bd3 Minor improvements in docs, part 2 (by @AndreyAkinshin) 0a251b Fix unix OS detection. (by @mfilippov) 5c3b39 Fix typo in PlatformID (by @mfilippov) 7f3d06 Always use PlatformAbstractions in RuntimeInformation.GetOsVersion() (by @AndreyAkinshin) 46d34f Set library version: 0.10.4 (by @AndreyAkinshin) Contributors (9) Adam Sitnik (@adamsitnik) Alina Smirnova (@alinasmirnova) Amadeusz Wieczorek (@AmadeusW) Andrey Akinshin (@AndreyAkinshin) ig-sinicyn (@ig-sinicyn) ILMTitan Mihai Codoban (@cdmihai) Mikhail Filippov (@mfilippov) Steve Desmond (@SteveDesmond-ca) Thank you very much! Additional details Date: April 21, 2017 Milestone: v0.10.4 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.4 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.4 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.4 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.4 BenchmarkDotNet v0.10.3 New .csprojs support for .NET Core. Also for F# (#366)! New plots and RPlotExporter (density plots for each job; cumulative mean plots) Fixed exporter order (now RPlotExporer uses the actual measurements instead of previous version) Xplat improvments in RuntimeInformation Introduced RunStrategy.Monitoring Possibility to set custom path for Mono (#306) Possibility to set any .NET Core version >= 1.1 (#336) MemoryDiagnoser is now disabled by default (Breaking changes!!) (#369) Milestone details In the v0.10.3 scope, 10 issues were resolved and 2 pull requests were merged. This release includes 79 commits by 3 contributors. Resolved issues (10) #300 Switch back from project.json and xproj to csproj, support dotnet cli preview 3 (assignee: @adamsitnik) #306 Custom path for mono (assignee: @adamsitnik) #320 Results table should be a GitHub Flavored Markdown table (assignee: @alinasmirnova) #322 First benchmark always fails when running on .NET Core with -c release (assignee: @adamsitnik) #336 allow the users to choose the target .NET Core version (1.2, 2.0 etc) (assignee: @adamsitnik) #366 Support the new .fsprojs targetting .NET Core (F# + .NET Core + MSBuild) (assignee: @adamsitnik) #369 Consider to disable MemoryDiagnoser by default (assignee: @adamsitnik) #372 Troubles with ClrJob from CoreCLR project (assignee: @adamsitnik) #374 BenchmarkDotNet doesn't understand netcoreapp2.0 (assignee: @adamsitnik) #375 Troubles with dotnet pack (assignee: @adamsitnik) Merged pull requests (2) #355 Fixed typo in IntroBasic.cs (by @mmayr-at) #357 Farewell project json (by @adamsitnik) Commits (79) 8099a5 Print process.StartInfo in Executor (by @AndreyAkinshin) abd931 Update BenchmarkDotNet.sln.DotSettings (by @AndreyAkinshin) 5c8c75 toolchains should not require parameterless ctors, the real fix for #327 (by @adamsitnik) b22cf2 allow the users to choose the target .NET Core version, fixes #336 (by @adamsitnik) f99c82 .net core toolchain: root folder detection bug fix (by @adamsitnik) c7aba1 experimental .NET Core support for the new VS 2017 csproj files, #300 (by @adamsitnik) bca146 Additional density plots in RPlotExporter (by @AndreyAkinshin) 4bb147 Additional cummean plots in RPlotExporter (by @AndreyAkinshin) 8bf40c Implement top sort in CompositeExporter (by @AndreyAkinshin) ad771d Always print the AllocationColumn in the Summary table (if MemoryDiagnoser is... (by @AndreyAkinshin) 8a1f0e Fix order of exporters in ExporterDependencyTests (by @AndreyAkinshin) a7366e xproj to csproj auto migration (by @adamsitnik) cec3e2 xproj to csproj: manual changes (conditional recursive dependencies not suppo... (by @adamsitnik) 74006d xproj to csproj: I did not ask for the .NET Standard dependency (by @adamsitnik) bf7093 xproj to csproj: manual changes (conditional dependencies not supported anymo... (by @adamsitnik) 4e060f xproj to csproj: manual changes (simple case not supported) (by @adamsitnik) 59602c remove F# .NET Core samples (not working now) (by @adamsitnik) 2488ae cleanup (by @adamsitnik) d7925b get our toolchain up and running, thanks to @cesarbs (by @adamsitnik) e719e7 Update IntroBasic.cs (by @mmayr-at) 1ef000 Merge pull request #355 from mmayr-at/patch-1 (by @AndreyAkinshin) 5cf1dc making diagnosers, ctrl+c, custom priority and affinity work for the new csprojs (by @adamsitnik) d0f334 getting net46 toolchain work again for new .csprojs when called from .NET Cor... (by @adamsitnik) d1bf9b removing old project.json workarounds (by @adamsitnik) e0b134 taking advantage of the csproj (by @adamsitnik) 001b3f appveyor stuff (by @adamsitnik) 63d674 don't introduce limit for .sln file search depth (by @adamsitnik) 81adbb make VS stop complaining about root namespace for BenchmarkDotNet.Core project (by @adamsitnik) 2eee5f let's round it to reduce the side effects of Allocation quantum (by @adamsitnik) f38e93 a project that targets AnyCPU cany be referenced by any other executable (32 ... (by @adamsitnik) 8ed5a4 post code review changes (by @adamsitnik) 50c938 add possibility to use RetainVMGarbageCollection config switch (by @adamsitnik) ca1bc8 final Cleanup and some renaming ;) (by @adamsitnik) a26d61 Update BenchmarkDotNet.sln.DotSettings (by @AndreyAkinshin) 008819 getting all the test runnable again (by @adamsitnik) a66913 trying to get the versioning done right (by @adamsitnik) c6f245 the updated docs (by @adamsitnik) f1a1fd update to the latest xUnit 2.2 + minor cleanup (by @adamsitnik) 262c87 appveyor config + minor bug fixes (by @adamsitnik) 1a7bd4 Support the new .fsprojs targetting .NET Core (F# + .NET Core + MSBuild), fix... (by @adamsitnik) e8f6ac support projects without .sln file (dotnet cli only) (by @adamsitnik) 1b71c5 update our tests to net452 because XUnit VS runner 2.2 does no longer support... (by @adamsitnik) 6121ad disable shadow copy for our integration tests (by @adamsitnik) 54375c warn the users when code optimization was not enabled (debug build can be opt... (by @adamsitnik) 03ed32 stop using --binaries option which started producing new folder for every re... (by @adamsitnik) 27f280 dotnet cli like to not release used files for a while.. (by @adamsitnik) 7886ad Merge pull request #357 from dotnet/farewellProjectJson (by @AndreyAkinshin) 751f64 Xplat RuntimeInformation.GetProcessorName() (by @AndreyAkinshin) b327b7 tell why dotnet command failed + how much time it took to execute (by @adamsitnik) b740bb WindowsVersion on CoreCLR (by @AndreyAkinshin) 5b879b Lazty HostEnvironmentInfo.OsVersion (by @AndreyAkinshin) 76d081 Lazy HostEnvironmentInfo.OsVersion, fix in ToFormattedString() (by @AndreyAkinshin) 5dafb9 do not restore or build the dependent projects, just the auto-generated one (by @adamsitnik) 5c1914 better troubleshooting: when dll is not found but somehow build has succeeded... (by @adamsitnik) 322998 using csproj to tell msbuild where to put output so appveyor custom settings ... (by @adamsitnik) e2a8fa post code review changes (by @adamsitnik) 6fe93d MinIterationTimeAnalyser (by @AndreyAkinshin) 3ac892 RunStrategy.Monitoring (by @AndreyAkinshin) f412b9 Docs: add FAQ section about supported version of Visual Studio (by @AndreyAkinshin) 67a007 fixing ProjectJsonToolchains after recent CsProjToolchain optimizations (by @adamsitnik) 2b5c6e Improved RuntimeInformation.GetProcessorName() (by @AndreyAkinshin) a44638 Improved RuntimeInformation.GetOsVersion() (by @AndreyAkinshin) f58e06 Improved RuntimeInformation.GetRuntimeVersion() for Mono (by @AndreyAkinshin) fdca26 Minor RuntimeInformation fixes (by @AndreyAkinshin) 2a2168 Fix bug in ExternalToolsHelper (by @AndreyAkinshin) 9dfd95 Custom path for mono, fixes #306 (by @adamsitnik) 448b07 disable MemoryDiagnoser by default, BREAKING CHANGE, fixes #369 (by @adamsitnik) 125b71 docs for Custom Mono Paths, #306 (by @adamsitnik) a3d6e0 docs/FAQ: Add section about new .NET Core Console App in VS2017 (by @AndreyAkinshin) b04195 give users the AnyCpu hint when they struggle with BadImageFormatException, f... (by @adamsitnik) 7de671 generate the projects in the bin folder, not solution's root (by @adamsitnik) 1d52ae docs/FAQ: add another question (by @AndreyAkinshin) 06aaa0 copy NetCoreAppImplicitPackageVersion and RuntimeFrameworkVersion settings to... (by @adamsitnik) f1fe16 shame on me for not building the code for all TFMs before pushing (by @adamsitnik) fe33dd GitHub Markdown: every table row should start with \"|\" , fixes #320 (by @adamsitnik) 7d0d73 remove old results, otherwise, the file will be overwritten and remaining old... (by @adamsitnik) 80348b Change Hint color to DarkCyan #376 (by @AndreyAkinshin) 0b35ec Increase MinIterationTime (Accuracy improvement) (by @AndreyAkinshin) cdee09 Set library version: 0.10.3 (by @AndreyAkinshin) Contributors (3) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Michael Mayr (@mmayr-at) Thank you very much! Additional details Date: March 01, 2017 Milestone: v0.10.3 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.3 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.3 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.3 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.3 BenchmarkDotNet v0.10.2 Closed #307: culture invariant statistics output Closed #321: persist optimized, auto-generated dll compiled from url/plain code Closed #322: always restore the console foreground color Closed #337: Better detection of Rscript.exe in RPlotExporter Closed #345: fix bug in WelchTTestPValueColumn for DryJob VS 2017 compatibility fix fix bold markup for Atlassian exporter Improved precision of nanobenchmarks Minor infrastructure changes and misc fixes Milestone details In the v0.10.2 scope, 10 issues were resolved and 3 pull requests were merged. This release includes 30 commits by 8 contributors. Resolved issues (10) #295 Fix CLS-compliant warnings in Diagnostics (assignee: @adamsitnik) #307 Output: interpolated strings & culture (assignee: @alinasmirnova) #319 [Request] some API to public? (assignee: @adamsitnik) #321 BenchmarkRunner.RunUrl throws BenchmarkSystem.IO.FileNotFoundException (assignee: @adamsitnik) #327 Unable to use ClassicToolchain in explicit way (assignee: @adamsitnik) #332 default color of terminal is changed after the run is completed (assignee: @adamsitnik) #335 Support benchmarking startup performance (assignee: @AndreyAkinshin) #337 Problematic mechanism/docs for locating Rscript.exe #340 [FeatureRequest] Enable Characteristic-based properties for non-job types. (assignee: @ig-sinicyn) #345 Fail to run IntroAdvancedStats in dry mode (assignee: @AndreyAkinshin) Merged pull requests (3) #338 Fix typo (by @roji) #339 Better detection of Rscript in RPlotExporter (by @roji) #341 Base types for characteristic objects: (by @ig-sinicyn) Commits (30) e7c398 Fixes parentheses error (by Josef Ottosson) 2655b3 Merge pull request #318 from joseftw/patch-1 (by @adamsitnik) 4115a2 make GcStats and Net46Toolchain internal members public, fixes #319 (by @adamsitnik) 52f953 ignore the CLS compilant errors for Diagnosers package, fixes #295 (by @adamsitnik) d96b68 Improved Consumer (by @AndreyAkinshin) 943c49 CLSCompliant fixes in Consumer (by @AndreyAkinshin) f4bdae specify the .NET Core sdk version in explicit way to get the solution working... (by @adamsitnik) df8c55 always restore the console foreground color, fixes #332 (by @adamsitnik) 24dea4 fix bold markup for Atlassian exporter (by @lahma) 4d3c75 persist optimized, auto-generated dll compiled from url/plain code, fixes #321 (by @adamsitnik) 2e92a2 allow to set Classic/Roslyn tool chain in explicit way, fixes #327 (by @adamsitnik) aabece Merge pull request #329 from lahma/features/atlassian-bold-format (by @adamsitnik) 91152c ExportToFiles now accepts console logger (by @roji) 299375 Base types for characteristic objects: (by @ig-sinicyn) afc65d Better detection of Rscript.exe in RPlotExporter (by @roji) 15869b Merge pull request #339 from roji/rscript-detect (by @AndreyAkinshin) 9f6a82 Merge pull request #341 from ig-sinicyn/feature-characteristic-object (by @AndreyAkinshin) 432adf Fix typo (by @roji) cfa015 Merge pull request #338 from roji/dependencies-typo (by @AndreyAkinshin) 4d953f Temporary rollback of the link to appveyor (by @AndreyAkinshin) 1f5a6e Update year in docs footer (by @AndreyAkinshin) 183ab6 Fix warning in RoslynToolchain (by @AndreyAkinshin) 6fd9f3 Used ToStr to make statistics builder culture invariant (fixed #307) (by @alinasmirnova) 3a3100 Merge pull request #346 from alinasmirnova/master (by @AndreyAkinshin) 7ee2f1 Fix in WelchTTestPValueColumn for DryJob, fixes #345 (by @AndreyAkinshin) 795f4a Disable jitting for RunStrategy=ColdStart, fixes #335 (by @AndreyAkinshin) 5b5a8c Fixed typo (by @lukasz-pyrzyk) 54519c Merge pull request #347 from lukasz-pyrzyk/master (by @adamsitnik) fbac75 Introduced Dummy actions (by @AndreyAkinshin) 484f53 Set library version: 0.10.2 (by @AndreyAkinshin) Contributors (8) Adam Sitnik (@adamsitnik) Alina Smirnova (@alinasmirnova) Andrey Akinshin (@AndreyAkinshin) ig-sinicyn (@ig-sinicyn) Josef Ottosson Łukasz Pyrzyk (@lukasz-pyrzyk) Marko Lahma (@lahma) Shay Rojansky (@roji) Thank you very much! Additional details Date: January 21, 2017 Milestone: v0.10.2 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.2 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.2 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.2 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.2 BenchmarkDotNet v0.10.1 MemoryDiagnoser got improved. The changes: Memory Diagnoser is now part of BenchmarkDotNet.Core.dll, and it's enabled by default MemoryDiagnoser is 100% accurate about allocated memory when using default settings or Job.ShortRun or any longer job. (see #284) Memory Diagnoser no longer includes allocations from Cleanup/Setup methods (see #186) the results are now scaled so they are stable across the runs. (see #133) .NET Core 1.1+ support, we no longer support 1.0, we target netcoreapp1.1 now. Reason: we wanted to use GC.GetAllocatedBytesForCurrentThread in MemoryDiagnoser which is available only in 1.1+ Improved information about environment in summary Minor bugfixes Milestone details In the v0.10.1 scope, 9 issues were resolved and 2 pull requests were merged. This release includes 38 commits by 2 contributors. Resolved issues (9) #133 High differences between run for GC Diagnoser (assignee: @adamsitnik) #186 GC Diagnoser should not include allocations done by Setup method (assignee: @adamsitnik) #200 be accurate about allocated bytes/op (assignee: @adamsitnik) #208 Troubles with MemoryDiagnoserTests (assignee: @adamsitnik) #298 PlatformNotSupportedException when reading ProcessorAffinity on MacOS (assignee: @adamsitnik) #301 netcoreapp1.1 support (assignee: @adamsitnik) #309 Diagnosers don't export data to the measurements.csv files (assignee: @adamsitnik) #312 RuntimeInformation can be made static and internal (assignee: @AndreyAkinshin) #313 Bug in Generator (interface as a return type) (assignee: @AndreyAkinshin) Merged pull requests (2) #284 built-in accurate and cross platform Memory Diagnoser (by @adamsitnik) #314 Improved information about job environments in summary (by @AndreyAkinshin) Commits (38) 23f3b2 built-in accurate and cross platform Memory Diagnoser, fixes #186, fixes #200 (by @adamsitnik) 4cabc2 don't try to use AppDomain's Monitoring in Mono since it's not implemented there (by @adamsitnik) 99c21e scale GC collections count / op, makes MemoryDiagnoser output stable for benc... (by @adamsitnik) e91255 use per mille to make the Memory Diagnoser output more human-friendly + reduc... (by @adamsitnik) a0536d Merge branch 'master' into universalMemoryDiagnoser (by @adamsitnik) ade1be preallocate results list in more safe, but still ugly way (by @adamsitnik) 102282 closed the ugly code in separate class (by @adamsitnik) 7825b7 Update links in docs (by @AndreyAkinshin) aaf720 Fix typo (by @AndreyAkinshin) 1e2d38 update to netcoreapp1.1 in order to get universal cross platform memory diagn... (by @adamsitnik) e69e80 don't show Gen 1 and Gen 2 columns if empty for all benchmarks (by @adamsitnik) b10a84 PlatformNotSupportedException when reading ProcessorAffinity on MacOS, fixes ... (by @adamsitnik) 2a529a update to .NET Core 1.1, fixes #301 (by @adamsitnik) e6ccee always show Gen 0 column, display Gen 0/1/2 per 1k op (by @adamsitnik) 3bcc59 Merge branch 'master' into universalMemoryDiagnoser (by @adamsitnik) a09810 make public things readonly, expensive things lazy and extend's validators in... (by @adamsitnik) eae2cd added documentation and smarter bytes formatting (by @adamsitnik) 1208c3 Merge branch 'master' into universalMemoryDiagnoser (by @adamsitnik) f1f231 Merge pull request #284 from dotnet/universalMemoryDiagnoser (by @AndreyAkinshin) 6300a2 include MemoryDiagnoser's results in CsvMeasurementsExporter, fixes #309 (by @adamsitnik) ddb37e don't use spaces in columns names in CSV, #309 (by @adamsitnik) 112f62 Fix stupid bug with condition for optional MedianColumn (by @AndreyAkinshin) 60127c Remove Cpu_Ilp_RyuJit.cs because it's obsolete (by @AndreyAkinshin) 401456 Print full information about a GenerateException (by @AndreyAkinshin) 0b9177 Support of benchmark methods with an interface as a return type, fixed #313 (by @AndreyAkinshin) b42b9e Improved information about job environments in summary (by @AndreyAkinshin) 92f1db Improved information about job environments in summary, part 2 (by @AndreyAkinshin) 5d8dd7 Merge pull request #314 from dotnet/summary (by @AndreyAkinshin) d279f6 Make RuntimeInformation static internal, fix #312 (by @AndreyAkinshin) 1df6ca Minor API improvements in BenchmarkSwitcher (by @AndreyAkinshin) c12daf Dot't show the median column for the N=1 case (by @AndreyAkinshin) 19caa2 RyuJit is always avaiable for .NET Core (by @adamsitnik) 13e12c make JitOptimizationsValidator work for .NET Core (needed properties are avai... (by @adamsitnik) c17b43 hide the AllocatedBytes column for Mono, show Gen 0 only if any of the benchm... (by @adamsitnik) 29ac91 updated docs about Diagnosers in the Overview ;) (by @adamsitnik) cc974e Improved information about job environments in summary, part 3 (by @AndreyAkinshin) 8846af Update docs (by @AndreyAkinshin) 37b126 Set library version: 0.10.1 (by @AndreyAkinshin) Contributors (2) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Thank you very much! Additional details Date: December 04, 2016 Milestone: v0.10.1 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.1 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.1 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.1 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.1 BenchmarkDotNet v0.10.0 Now BenchmarkDotNet is a part of .NET Foundation Job and Column API refactoring (see new documentation) Measurement engine improvements Horology enhancement (see TimeInterval and Frequency) Introduced RankColumn which is based on WelchTTest (see 157aabc3) JsonExporters refactoring (see the Exporters/Json section in the documentation) Renamed JsonExporters classed and attributes JsonExporters with custom settings JsonExporters now includes information about the target type namespace (see #246). Add JetBrains.Annotations (see #253) RFC 4180 support in CSV exporters (see #241) Many bugfixes Milestone details In the v0.10.0 scope, 19 issues were resolved and 7 pull requests were merged. This release includes 85 commits by 7 contributors. Resolved issues (19) #30 Better information when we haven't got a valid measurement #121 Strange # of \"Launches\" chosen with Count.Auto #154 PathTooLong exception on custom config #185 Report if difference between 2 benchmarks is statistically significance #241 .csv results output does not play well with Excel or Google Sheets #244 DefaultConfig StatisticColumn values #246 No namespace information? #265 Add ability to specify that benchmark requires STAThread #266 Don't assume that TargetType has reference to BenchmarkDotNet (assignee: @adamsitnik) #268 Print runtime of child processes in summary #271 Params attribute does not handle nullable types #272 [Setup] error when doing inheritance #276 System.EntryPointNotFoundException #280 Cannot run on OSX / Mono (System.Xml.XmlException: Root element is missing) #281 Results are exported twice for single run #288 IdleWarmup running off forever #291 [Bug] Incorrect results for targetCount:Auto #292 Support for Beta versions #296 [BUG] NRE in OutliersAnalyser Merged pull requests (7) #253 Mark [Benchmark] as implying implicit use (by @roji) #267 Make shipped assemblies have CLSCompliant(true) applied (by @lahma) #277 Changed diagnosers flow, reduced heap allocations in Engine to 0 (by @adamsitnik) #278 Support Atlassian flavored wiki markup (by @lahma) #286 Mutable Job implementation (by @ig-sinicyn) #287 Fix docs: job API changed (by @ig-sinicyn) #293 Presenters: IFormattable support (by @ig-sinicyn) Commits (85) a8b4e7 JsonExporters refactoring (by @AndreyAkinshin) e6a4ae JsonExporters: add information about namespaces, resolves #246 (by @AndreyAkinshin) 29ee0a Add Namespace column (by @AndreyAkinshin) 26c333 Better error message (by @arthrp) 12b313 Merge pull request #251 from arthrp/master (by @AndreyAkinshin) 03d00c Mark [Benchmark] as implying implicit use (by @roji) 394a93 Merge pull request #253 from roji/resharper-annotations (by @AndreyAkinshin) 4912ea Remove unnecessary specific shell reference (by @factormystic) 023115 Merge pull request #254 from factormystic/patch-1 (by @AndreyAkinshin) 972fee Big refactoring (by @AndreyAkinshin) cf839a Improved ranks (by @AndreyAkinshin) ef3ecf Extended TimeInterval and Frequency API (by @AndreyAkinshin) dfcc98 Minor fixes (by @AndreyAkinshin) fb3757 Improved CSV export, fixes #241 (by @AndreyAkinshin) f490d1 further root folder cleanup #228 (by @adamsitnik) f7a6a0 Added [MeansImplicitUse] and explanation to summary for SetupAttribute and Cl... (by @adamsitnik) 56b1f2 Configuration fix in JitOptimizationsTests (by @AndreyAkinshin) faac58 Introduce AnaylyzeLaunchVariance (by @AndreyAkinshin) 9953a9 Smart statistics in StatisticsColumnProvider (by @AndreyAkinshin) 2a6578 Minor fixes in docs (by @AndreyAkinshin) 03fb04 Introduce UnrollFactor (by @AndreyAkinshin) 137636 NewLine fix in OutputLogger (by @AndreyAkinshin) b35d52 Unique column support (by @AndreyAkinshin) 24e944 Don't assume that TargetType has reference to BenchmarkDotNet, fixes #266 (by @adamsitnik) 69330a Make shipped assemblies have CLSCompliant(true) applied (by @lahma) fb8402 Merge pull request #267 from lahma/features/cls-compliancy (by @adamsitnik) 0944b5 Make exported HTML valid, add alternating color to result table (by @lahma) 748a2c Merge pull request #269 from lahma/features/html-export-enhancements (by @adamsitnik) afff51 ExecutionValidator should not throw on overridden [Setup] methods, fixes #272 (by @adamsitnik) ab9db4 Support nullable types as [Params], fixes #271 (by @adamsitnik) ce4994 support for [STAThread], fixes #265 (by @adamsitnik) 13fa5c move ConsoleHandler to separate file for better readability (by @adamsitnik) 0e8e82 Print runtime of child processes in summary, fixes #268 (by @adamsitnik) 491a28 Print more info about runtime of child processes in summary (and in a nicer w... (by @adamsitnik) 0580a5 updated docs for #265 (by @adamsitnik) f9baa6 catch native exceptions when determining clock type, #276 (by @adamsitnik) 93a23d Check OS version in WindowsClock, fixed #276 (by @AndreyAkinshin) 8d65fe changed diagnosers flow, possibility to hook up before jitting, after setup a... (by @adamsitnik) f346ff added predefined attributes for diagnosers (by @adamsitnik) e7cc6b Support Atlassian flavored wiki markup (by @lahma) 376bd8 reduce memory allocated by Engine during run to increase MemoryDiagnoser accu... (by @adamsitnik) b5ab55 display results when runing when no diagnoser is attached (by @adamsitnik) 7ae2b5 Improved idle method for primitive types (by @AndreyAkinshin) e1213a Fix NRE in BuildJobRuntimes (by @AndreyAkinshin) 572fa4 Make code CLS-Compliant, fix CS3015 warning (by @AndreyAkinshin) 4070a1 preload all settings in ctors, introduced IEngineFactory (by @adamsitnik) 2f0df7 make Engine use InvocationCount (by @adamsitnik) 8a7a12 calculate Statistics without allocations! makes the code look bad, but saves ... (by @adamsitnik) d8fa70 remove last allocations from Engine.Run (by @adamsitnik) f2a106 perform Jitting after first Setup call, better naming, test fix (by @adamsitnik) be3ce3 introduce general catch with hopes to help with #280 (by @adamsitnik) 3c5e70 post code review changes (by @adamsitnik) 16e258 possibility to define custom Engine (by @adamsitnik) afa586 Merge pull request #277 from PerfDotNet/diagnosersFlow (by @adamsitnik) 534189 export files only once, not twice, fixes #281 (by @adamsitnik) a733b5 Mutable Job implementation (by @ig-sinicyn) 259647 Merge pull request #286 from ig-sinicyn/feature-mutable-characteristics (by @AndreyAkinshin) c184b8 Fix docs: job API changed (by @ig-sinicyn) 47b152 Merge pull request #287 from ig-sinicyn/fix-docs-jobs-updated (by @AndreyAkinshin) 868ffc Jobs: WithXxx() extension methods added back, docs updated (by @ig-sinicyn) eede54 Jobs: .With() methods now create new instances of the Job. (by @ig-sinicyn) 40f160 Test fixed (by @ig-sinicyn) fd92f7 Jobs: helper for .With() methods (by @ig-sinicyn) 307b72 Merge pull request #289 from ig-sinicyn/features-jobs-with (by @AndreyAkinshin) d576f5 Presenters: IFormattable support (by @ig-sinicyn) 8647e7 Fix #291 (by @AndreyAkinshin) 49c000 Merge pull request #293 from ig-sinicyn/fix-presenter-culture (by @AndreyAkinshin) 684334 Merge pull request #278 from lahma/features/atlassian-wiki-markup (by @AndreyAkinshin) 7f3ca5 Make BenchmarkRunnerCore.Run public (by @AndreyAkinshin) 10a91e Allow using newer versions of Microsoft.NETCore.App, fixes #292 (by @adamsitnik) 134d74 Misc improvements in Exporters (by @AndreyAkinshin) 33c63f Respect RemoveOutliers in the RunResults (by @AndreyAkinshin) 5e022b Fix #291, part 2 (by @AndreyAkinshin) 4b6ea9 Improved name for the Id CharacteristicColumn (by @AndreyAkinshin) af6f8a Fix some compilation warnings (by @AndreyAkinshin) 2f8584 Analysers refactoring + OutliersAnalyser (by @AndreyAkinshin) b11935 Make BenchmarkRunnerCore public (by @AndreyAkinshin) 781740 Specify generated id for the default job (by @AndreyAkinshin) 846255 JobTests.Test01Create fix (by @AndreyAkinshin) 9f9544 Check if there is no MainTarget measurements in OutliersAnalyser, fixes #296 (by @AndreyAkinshin) 503b04 Proper exception in GetStatistics for empty input, see #296 (by @AndreyAkinshin) c667aa Fix path to logo (by @AndreyAkinshin) 0b91c3 Fix null check in JobMode.ApplyCore (by @AndreyAkinshin) 2edb56 Copyrights and links update (by @AndreyAkinshin) 2edb9a Set library version: 0.10.0 (by @AndreyAkinshin) Contributors (7) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Arthur (@arthrp) factormystic (@factormystic) ig-sinicyn (@ig-sinicyn) Marko Lahma (@lahma) Shay Rojansky (@roji) Thank you very much! Additional details Date: November 10, 2016 Milestone: v0.10.0 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.0 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.0 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.0 Online Documentation: https://dotnet.github.io/BenchmarkDotNet/ BenchmarkDotNet v0.9.9 Attribute config style (see #166) Online documentation (see #219) Mono LLVM support (see #226) Async method support (see #236) NuGet packages and repo layout restructuring (see #225, #228) [Cleanup] attribute (see #215) New statistics columns: Skewness, Kurtosis, WelchTTestPValue, Improved math for the Scaled column Now current default branch is master Minor improvements and bug fixes Milestone details In the v0.9.9 scope, 14 issues were resolved and 1 pull requests were merged. This release includes 46 commits by 4 contributors. Resolved issues (14) #166 Suggestion: Attribute Config style (assignee: @AndreyAkinshin) #215 Allow a [Cleanup] method to be specified #219 Online documentation and API reference #223 Add support for System.Type in Params #224 [Breaking change] BenchmarkAttribute become sealed. #225 Refactoring the roslyn dependency into another package #226 Support Mono/LLVM as a runtime/jit #227 Suggestion: change default branch (assignee: @AndreyAkinshin) #228 Suggestion: clean up the root folder #231 Add references to default framework assemblies (System.Runtime etc) #232 Make all tests use OutputLogger (assignee: @adamsitnik) #235 Don't show non-error output of dotnet cli (assignee: @adamsitnik) #236 Possibility to benchmark asynchronous methods (assignee: @adamsitnik) #240 Total Time reports hour rounded up Merged pull requests (1) #233 Add support of Cleanup attribute #215 (by @DenisIstomin) Commits (46) f9f748 Improved \"Scaled\" column (by @AndreyAkinshin) 5d7ba9 Warmup improvements (by @AndreyAkinshin) 664c64 Add Skewness, Kurtosis, and WelchTTestPValue columns and configs (by @AndreyAkinshin) c9e802 Attribute Config style, fixes #166 (by @AndreyAkinshin) 378173 README: add supported OS (by @AndreyAkinshin) 50ac57 Make Benchmark, Params and Setup attributes non-sealed again, fixes #224, #57 (by @adamsitnik) b9c815 Support Mono/LLVM as a runtime/jit, fixes #226 (by @adamsitnik) cdfbd5 Update info about default branch, see #227 (by @AndreyAkinshin) 42e9b9 Add System.Type support in Params, fixes #223 (by @AndreyAkinshin) db3dc3 Suggestion: clean up the root folder, fixes #228 (by @adamsitnik) 4e1db3 use shorter names for test for xunit test runner (method name instead of full... (by @adamsitnik) a35b22 make sure all framework assemblies are referenced, #231 (by @adamsitnik) 19426a spliting BenchmarkDotNet.dll to few dlls to avoid mandatory Roslyn dependency... (by @adamsitnik) 356a39 move BenchmarkRunner's core to separate class to .Core project so it can be ... (by @adamsitnik) 0121a6 minor cleanup: rename LLVM => Llvm, remove [Obsolete] things (by @adamsitnik) fb8047 Make all tests use OutputLogger, fixes #232 (by @adamsitnik) ae17a7 Add support of Cleanup attribute, fix #215 (by @DenisIstomin) 3bf9c0 Merge branch 'master' of https://github.com/PerfDotNet/BenchmarkDotNet (by @adamsitnik) 355c6f Don't show non-error output of dotnet cli, fixes #235 (by @adamsitnik) 76df80 Possibility to benchmark asynchronous methods #236 (by @adamsitnik) 3ab578 use GetAwaiter().GetResult() for Tasks instead of .Wait or .Result, #236 (by @adamsitnik) d1db7d Added documentation source and output based on readme.md (by @FransBouma) ac8cf2 Updated folder structure, removed html output, updated gitignore (by @FransBouma) bed0f9 Removed unused folder copy directive from docnet.json (by @FransBouma) 650fca Merge pull request #239 from FransBouma/master (by @AndreyAkinshin) aceb96 Added Api docs generation directives (by @FransBouma) a9ee7c Fix in total time formatting, fix #240 (by @AndreyAkinshin) 1d2141 Update README.md (by @AndreyAkinshin) 7b9fdb Fixed a couple of issues with api doc generation (by @FransBouma) 682837 Merge pull request #243 from FransBouma/master (by @AndreyAkinshin) 9a2cf2 docs improvements (by @AndreyAkinshin) 334925 Rename: GarbageCollection -> GcMode (by @AndreyAkinshin) 7a740a SummaryTableTests and minor refactorings (by @AndreyAkinshin) c9d358 Transform GcModeColumn with null values to a trivial column (by @AndreyAkinshin) cb6359 Improved HardwareTimerKind detection (by @AndreyAkinshin) 04f736 Fix references in the IntegrationTests project files (by @AndreyAkinshin) a9403a Fix warnings (by @AndreyAkinshin) 691a05 BenchmarkDotNet.Tests: Remove the System.Globalization dependency (by @AndreyAkinshin) 9e97d7 Show JitModules in EnvInfo only for the classic toolchain (by @AndreyAkinshin) 823518 Improved docs (by @AndreyAkinshin) 5fb854 Update README (by @AndreyAkinshin) 5ebf8b Minor fixes (by @AndreyAkinshin) 086dfd generic wrapper for config values (by @adamsitnik) cf58b0 Merge branch 'gc' (by @adamsitnik) bbccbe docs: add informations about NuGet packages (by @AndreyAkinshin) 60bea3 Set library version: 0.9.9 (by @AndreyAkinshin) Contributors (4) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Denis Istomin (@DenisIstomin) Frans Bouma (@FransBouma) Thank you very much! Additional details Date: August 18, 2016 Milestone: v0.9.9 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.9 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.9.9 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.9.9 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.9 Online Documentation: https://perfdotnet.github.io/BenchmarkDotNet/ BenchmarkDotNet v0.9.8 CoreCLR RTM support (see #216). Breaking change: we have dropped dnx451 and dnxcore50 support. Migration from MSBuild to Roslyn, which supports Mono on Linux and MacOS (see #149). Breaking change: we have dropped .NET 4.0 support. Ability to manage GC mode: turn on/off the Server/Concurrent GC modes, extend to CPU groups, set gcAllowVeryLargeObjects and avoid BenchmarkDotNet from forcing GC.Collect (see #188, #76 and #211) Support CopyToOutput (see #212). Now you can use native dependencies as well as custom files. Copying custom settings from app.config (see #108). It means we support assembly binding redirects as well as custom connection strings etc. AsciiDocExporter (see #169) Framework setting in Job has been removed (see #194) Minor bugfixes and improvements Milestone details In the v0.9.8 scope, 21 issues were resolved and 1 pull requests were merged. This release includes 69 commits by 5 contributors. Resolved issues (21) #57 Make Benchmark, Setup and Params attribute sealed in explicit way #76 Allow users to set gcAllowVeryLargeObjects for Runtime Settings (assignee: @AndreyAkinshin) #77 Implement a C.I build (assignee: @mattwarren) #108 Copy custom setting from app.config #131 [Mono] BenchmarkDotNet doesn't work on Mac OS #149 Migrate from MSBuild to Roslyn #174 NRE in Summary indexer property. #176 Split and simplify printed summaries #188 Ability to manage GC mode: turn on/off the Server/Concurrent GC modes and extend to CPU groups #191 MSBuild dependency - best way of fixing? #194 Framework settings in Jobs (assignee: @mattwarren) #196 Allow specifying a gist url to RunUrl #197 Regression in 0.9.7: --help option fails under dotnet run #203 Third-party libraries must be explicitly included in test context to be loaded by runner #209 Fix appveyor bug #211 Possibility to turn off GC.Collect after each benchmark run (assignee: @adamsitnik) #212 Support CopyToOutput #214 Benchmark ignores binding redirects #216 Update to .NET Core RTM (assignee: @adamsitnik) #218 Errors in BenchmarkDotNet.Samples.FSharp.Core/projects.json #222 A problem with System.Threading.Tasks Merged pull requests (1) #169 Support export to asciidoc (by @russcam) Commits (69) fcf48e Support export to asciidoc (by @russcam) 590a0a Road to Roslyn: first attempt (by @AndreyAkinshin) 704605 Added appveyor ci build (by @gigi81) 3859a1 Catch exception when accessing Console.WindowWidth, fixes #197 (by @mattwarren) 7b92eb Filter tests by attribute (see #130) (by @mattwarren) dd3464 Merge pull request #202 from gigi81/appveyor-build-2 (by @adamsitnik) 29d106 Added missing 'build dependency' (by @gigi81) 2e8209 Merge pull request #205 from gigi81/fix-missing-dependency (by @AndreyAkinshin) ff298d Appveyor build improvements (by @gigi81) 600cdd Merge pull request #206 from gigi81/appveyor-4 (by @AndreyAkinshin) 68b070 Fixed tests not using OutputLogger (by @gigi81) 7d0501 Renamed _output to output (by @gigi81) ae5eab Merge pull request #207 from gigi81/fix-outputlogger (by @AndreyAkinshin) dfe110 Small cleanup: remove compilation warnings (by @AndreyAkinshin) ffe9f7 Clean up, part 2 (by @AndreyAkinshin) 559f20 appveyor specific test fixes (by @AndreyAkinshin) 38af24 MemoryDiagnoserTests: double.Parse Culture fix (by @AndreyAkinshin) 02048d StatResultExtenderTests: SpeedUp (by @AndreyAkinshin) f2b21f Clean up, part 3 (by @AndreyAkinshin) d32328 SpeedUp: BaselineScaledColumnsTest, StatResultExtenderTests (by @AndreyAkinshin) 5e37fa MemoryDiagnoserTests: additional parsing fixes (by @AndreyAkinshin) 45c66f Merge branch 'develop' into Roslyn (by @adamsitnik) a4cb8c MemoryDiagnoserTests: Temporarily suppressed (by @AndreyAkinshin) ae38a5 README: add the appveyor badge (by @AndreyAkinshin) 77bd64 README: update badges (by @AndreyAkinshin) a74f82 README: update badges, part 2 (by @AndreyAkinshin) 453a49 merging recent changes from develop with Roslyn branch to get it working again (by @adamsitnik) ce4af5 add dependencies in recursive way, fixes #203 (by @adamsitnik) a36af4 farewell MSBuid (by @adamsitnik) d2dd83 Workaround for xunit bug (by @gigi81) 46f2b7 Merge pull request #210 from gigi81/xunit-workaround-2 (by @AndreyAkinshin) c5b4ae Merge remote-tracking branch 'refs/remotes/origin/develop' into Roslyn (by @AndreyAkinshin) 54109b copy custom settings from app.config file, fixes #108 (by @adamsitnik) 20c41f enable GC settings customization, fixes #188 (by @adamsitnik) dd0bc4 tests fix ;) (by @adamsitnik) 0726b5 Possibility to turn off GC.Collect after each benchmark run, fixes #211 (by @adamsitnik) da24b4 rename GC to GarbageCollection to avoid conflicts with System.GC (by @adamsitnik) 3bf420 gcAllowVeryLargeObjects, fixes #76 (by @adamsitnik) bdce98 split EnvironmentInfo into Host and Benchmark specific, make expensive method... (by @adamsitnik) e819c8 added GC info to BenchmarkEnvironmentInfo (by @adamsitnik) 9e0480 change GC settings display order (Workstation Concurrent => Concurrent Workst... (by @adamsitnik) d03d17 support CopyToOutput: build in output directory + some refacotring, fixes #212 (by @adamsitnik) 237370 minor bug fix: support spaces in parameters representation (by @adamsitnik) 06349a Update to .NET Core RTM, drop DNX* support, fixes #216 (by @adamsitnik) 106477 Merge branch 'develop' of https://github.com/russcam/BenchmarkDotNet into rus... (by @AndreyAkinshin) 2e18db Merge branch 'russcam-develop' into develop (by @AndreyAkinshin) 388155 Fix a NRE bug in Summary indexer, fixes #174 (by @AndreyAkinshin) d448b4 Now RunUrl can work with non-raw github and gist urls, fixes #196 (by @AndreyAkinshin) 7e1b95 Welch's Two Sample t-test (by @AndreyAkinshin) cc70cb specify version of F# compiler in explicit way to workaround nuget bug, fixes... (by @adamsitnik) e21373 use Roslyn's managed API for compilation, drop .NET 4.0 support!! fixes #149 (by @adamsitnik) cd25cc use single reflection api after update to .NET 4.5 (by @adamsitnik) 785d92 make Benchmark, Setup and Params Attribute sealed #57 (by @adamsitnik) 8a3212 hopefully a workaround for appveyor build (by @adamsitnik) ef7e35 hopefully a workaround for appveyor build, which does not have the latest dot... (by @adamsitnik) 918a6d Remove xmlns for packages.config in IntegrationTests.Classic (by @AndreyAkinshin) b897ed Merge branch 'Roslyn' into develop (by @adamsitnik) 742a16 skip test that fails for Core on appveyor, #221 (by @adamsitnik) a94a8b skip test that fails for Classic on appveyor, #221 (by @adamsitnik) fec206 Fix incorrect xml-docs in MathHelper (by @AndreyAkinshin) 1567d9 DEVELOPING.md: add a section about develop NuGet feed (by @AndreyAkinshin) 5c3c31 appveyor: add BenchmarkDotNet.Diagnostics.Windows.nupkg to artifacts (by @AndreyAkinshin) a69188 DEVELOPING.md: fix a typo (by @AndreyAkinshin) 4e99b4 project.json: add tags (by @AndreyAkinshin) 61b4c1 use System.Threading.Tasks as nuget package to fix nuget installation problem... (by @adamsitnik) 976118 remove Framework settings from Jobs, fixes #194 (by @adamsitnik) be0b71 try to remove the directory few more times when it's still not released to ma... (by @adamsitnik) 0647a0 use the Configuration from the hosting process, not BDN dll (by @adamsitnik) c6405a Set library version: 0.9.8 (by @AndreyAkinshin) Contributors (5) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Luigi Grilli (@gigi81) Matt Warren (@mattwarren) Russ Cam (@russcam) Thank you very much! Additional details Milestone: v0.9.8 Date: July 07, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.8 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.8 BenchmarkDotNet v0.9.7 .NET Core RC2 support (see #187) Bugfixes Milestone details In the v0.9.7 scope, 8 issues were resolved and 0 pull requests were merged. This release includes 27 commits by 3 contributors. Resolved issues (8) #168 Unable to run tests locally #170 Error handling in the spawned Benchmark process (assignee: @mattwarren) #172 Ensure CsvMeasurementsExporter is enabled when RPlotExporter is used (assignee: @mattwarren) #179 Job.GetAllProperties(): old property names are used #181 CompositeValidator: some validators will be skipped #183 [Suggestion] Make ValidationError public #187 .NET Core RC2 (assignee: @adamsitnik) #192 Avoid creating .cs files at execution time Merged pull requests (0) Commits (27) 7568c0 Initial work on #130 (currently just matching existing behaviour) (by @mattwarren) 34965e Fixes #170 (by @mattwarren) 4d6d32 Remove \"@\" from the ProcessorName (by @AndreyAkinshin) 57b402 Specify HintPath for all referenced assemblies (for mono support) (by @AndreyAkinshin) 0d065b Merge branch 'develop' of github.com:PerfDotNet/BenchmarkDotNet into develop (by @mattwarren) c24a9c Less \"magic\" strings - Fixes #179 (by @mattwarren) 1371ea Allow Exporters to have dependencies, fixes #172 (by @mattwarren) d6a55c Further work on #130 (by @mattwarren) e0ebd4 Tidy up of the Json exporter code (part of #189) (by @mattwarren) ae330c Allow formatted/indented Json (see #189) (by @mattwarren) 83fd20 Also allow args with \"--\", i.e. --exporters=json (see #189) (by @mattwarren) 78af45 File missing from previous check-in \"ae330c4\" (#189) (by @mattwarren) 9352d0 \"Measurments\" -> \"Measurements\" (by @mattwarren) a34507 .NET Core RC2 support, fixes #187 (by @adamsitnik) 0c9524 remove IValidationError interface, make the implementation public, fixes #183 (by @adamsitnik) 30a6ec Avoid creating .cs files at execution time, fixes #192 (by @adamsitnik) 792176 hiding CompositeValidator, fix few typos, fixes #181 (by @adamsitnik) a345e7 Use short, hard coded name for folders to avoid PathTooLongEx if user does no... (by @adamsitnik) 354b28 minor cleanup after moving to RC2 (by @adamsitnik) 53b7ff dotnet cli bug workaround, Tornhoof's idea (by @adamsitnik) 8e6d30 added missing Nuget feeds to NuGet.Config, removed launchSettings which we do... (by @adamsitnik) 9addd0 Improvements in MethodInvoker (by @AndreyAkinshin) ccd91d Update Chronometer.HardwareTimerKind (by @AndreyAkinshin) e9db3d Update year in LICENSE.md (by @AndreyAkinshin) acd019 updated docs for .NET Core RC2 #187 (by @adamsitnik) 605aa1 README.md: add a link to BenchmarkDotNet.Diagnostics.Windows (by @AndreyAkinshin) 571b3d Set library version: 0.9.7 (by @AndreyAkinshin) Contributors (3) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Matt Warren (@mattwarren) Thank you very much! Additional details Milestone: v0.9.7 Date: May 29, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.7 https://www.nuget.org/packages/BenchmarkDotNet/0.9.7-beta https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.7 BenchmarkDotNet v0.9.6 Added Percentiles (see #164) Added support for Json export (see #84) Bugfixes Milestone details In the v0.9.6 scope, 11 issues were resolved and 2 pull requests were merged. This release includes 40 commits by 5 contributors. Resolved issues (11) #100 Code generation doesn't support generic classes #112 Generic benchmark classes are not supported #140 Readd an ability to define and to use custom Toolchain #141 [Request for comments] Assembly-level config attribute? #151 Crash during benchmark with baseline #152 MarkdownExporter.Default.ExportToLog fails with NRE for Summary with Critical Validation Errors #153 ManualConfig.Add(IConfig config) does not add the validators. #156 Cleanup benchmark folders #158 BaselineDiffColumn: NullReferenceException if one of the benchmark methods was failed. #161 Build warnings after update to 0.9.5 #171 Problem with ExceptionDispatchInfo (assignee: @AndreyAkinshin) Merged pull requests (2) #138 Percentiles added into Statistics, StatisticColumn, BaselineDiffColumn (by @ig-sinicyn) #164 Percentiles added into Statistics, StatisticColumn, BaselineDiffColumn (by @ig-sinicyn) Commits (40) 9e625a copying validators when merging configs, fixes #153 (by @adamsitnik) 5d0a7d returning empty objects instead of nulls, fixes #152 (by @adamsitnik) cfff3b switching back to the old moniker that is supported not only by dnx and dotne... (by @adamsitnik) 522fde Initial work on Json export (#84) (by @mattwarren) 31452f Make SimpleJson build under \"DNXCore,Version=v5.0\" - (#84) (by @mattwarren) 48b17a Merge branch 'develop' of github.com:PerfDotNet/BenchmarkDotNet into develop (by @mattwarren) d8dad6 removing ClrMD dependencies that were causing troubles with nuget package rel... (by @adamsitnik) 0a81d4 removing ClrMd diagnosers, they are kept in clrmd branch (by @adamsitnik) 972ea2 setting BenchmarkDotNet version to one that is not in the Nuget yet to get do... (by @adamsitnik) 1e6581 Removing final traces or Runtime and Source SourceDiagnosers (by @mattwarren) 3576d4 Make BaselineDiffColumn more robust - fixes #158 and #151 (by @mattwarren) 3f0d7b Exclude \"BenchmarkDotNet.Artifacts\" folder (can get in the way when building) (by @mattwarren) 00995d Percentiles added into Statistics, StatisticColumn, BaselineDiffColumn (by @ig-sinicyn) 2410d4 Update project.json files (by @AndreyAkinshin) ed75f6 Assembly-level config attribute, Fixes #141 (by @AndreyAkinshin) 6f3a0c Add a BenchmarkSwitcher constructor for assembly, see #141 (by @AndreyAkinshin) 4124d0 Catch InvalidOperationException in ClassicBuilder (by @AndreyAkinshin) 9c8513 Cleanup benchmark folders (by default!), fixes #156 (by @adamsitnik) d0179f merge KeepBenchmarkFiles and allow fluent api usage, #156 (by @adamsitnik) b8130a Readd an ability to define and to use custom Toolchain, fixes #140 (by @adamsitnik) 8a263b moving KeepBenchmarkFiles merge logic to Add method (by @adamsitnik) e1e5c7 Sample & documentation for percentiles (by @ig-sinicyn) 0d4262 Merge commit '00995dfac270ae71e81897348ec379cd97fb01c3' into feature-percentiles (by @ig-sinicyn) 54b4f0 Merge pull request #164 from ig-sinicyn/feature-percentiles (by @AndreyAkinshin) f8278c Generic benchmark support, fixes #100, fixes #112 (by @AndreyAkinshin) c28056 Support Mono+.NET4.6 in CommonExtensions.ToStr. (by @AndreyAkinshin) 285f77 set dependencies to MSBuild dlls as \"type\": \"build\" to make them implicit dep... (by @adamsitnik) 42abd1 Merge remote-tracking branch 'refs/remotes/origin/develop' into develop (by @mattwarren) 030d6c Rename \"GCDiagnoser\" -> \"MemoryDiagnoser\" (by @mattwarren) 4e96e6 give compilation error instead of warning or exception at runtime (by @adamsitnik) 0fbe10 Revert \"give compilation error instead of warning or exception at runtime\" (by @adamsitnik) 19708a Tidy up of the Integration tests (by @mattwarren) f7b3a4 Thread safe jobs, fixes #171 (by @AndreyAkinshin) edf293 DisableTestParallelization for Classic integration tests to avoid races (by @adamsitnik) 89165f moving dll that is required for custom path integration tests out of root folder (by @adamsitnik) cbaa3b README: Add additional info about RPlotExprter (by @AndreyAkinshin) 1cc936 The benchmark is improperly testing the Max operation because as all the numb... (by @redknightlois) 40a1ea Merge pull request #173 from redknightlois/develop (by @AndreyAkinshin) a9bf3b README: add information about the diagnostics package (by @AndreyAkinshin) 5191bc Set library version: 0.9.6 (by @AndreyAkinshin) Contributors (5) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Federico Andres Lois (@redknightlois) ig-sinicyn (@ig-sinicyn) Matt Warren (@mattwarren) Thank you very much! Additional details Milestone: v0.9.6 Date: May 11, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.6 https://www.nuget.org/packages/BenchmarkDotNet/0.9.6-beta https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.6 BenchmarkDotNet v0.9.5 Added validators, JitOptimizationsValidator detects all non-optimzied dlls that were referenced #134 Strong naming #101 Add IOrderProvider #107 Putting all the generated artifacts in a separate folder: ./BenchmarkDotNet.Artifacts/results and ./BenchmarkDotNet.Artifacts/bin #94 Printing dotnet cli version for .NET Core and Dnx451, informing user when not installed. Closed #128 Supporting assembly redirects #67 Changed used msbuild version: 12 for .NET 4.5 (VS 2013), 14 for .NET 4.6 (VS 2015). Closed #132 and #137 Switched to new ‘dotnet’ target framework monikers (dotnet5.4 instead of dnxcore50), why dnx452, dnx46, net462 support added Executing single Benchmark for multiple Runtimes also with Diagnoser attached (see #117) Misc minor changes Milestone details In the v0.9.5 scope, 13 issues were resolved and 0 pull requests were merged. This release includes 45 commits by 4 contributors. Resolved issues (13) #67 F# requiring assembly binding redirects for FSharp.Core #94 Put all the generated artifacts in a separate folder #101 Strong naming? #107 Specify benchmark method order #122 Reports: Move params columns next to Method column #128 Print dotnet cli version in EnvironmentInfo #129 Improve DnxAndCoreTests #132 [Bug] FileNotFoundException On 0.9.4. #134 [Feature request] Release builds only? #137 Brand new machine with VS 2015 only b0rks #142 [Suggestion] BenchmarkDotNet.Analyzers.IAnalyser - use same spelling for namespace and type? #148 Crash on [Params] with a string value that contains an invalid path char #150 Declaring nested enums and using them as parameter value make incorrectly generated code/ Merged pull requests (0) Commits (45) 2645ef use AutoGenerateBindingRedirects to avoid assembly conflicts, fixes #67 (by @adamsitnik) 693b21 warn user if dotnet cli is not installed and print it's version in summary, f... (by @adamsitnik) bfb017 target NET46 to reference msbuild 14 that comes with VS 2015 to make BDN work... (by @adamsitnik) fceb3c fallback to bat if MSBuild dlls are not found + generate bat when needed (by @adamsitnik) 49bdf0 restore: generating build script file (now for all runtimes) (by @adamsitnik) b9b0bc scripts: cleanup -> build -> show failed tests if any ->cleanup, fixes #129 (by @adamsitnik) ad64d8 Put all the generated artifacts in a separate folder, fixes #94 (by @adamsitnik) 902de6 F# samples targeting .NET Core +classic F# part reorganization (by @adamsitnik) b31c0b supported languages: updated readme & integration tests for Visual Basic (by @adamsitnik) 24ade7 handle missing MSBuild.dll, get latest msbuild in fallback script scenario, s... (by @adamsitnik) d371de Spelling mistake in errors message (see #139) (by @mattwarren) c882dd core: dependencies cleanup + getting rid of warnings (by @adamsitnik) b14e35 Add IOrderProvider, fixes #107 (by @AndreyAkinshin) c95267 warn user if non-optimized dll is used, fixes #134 (by @adamsitnik) 5876f5 Strong naming, fixes #101 (by @adamsitnik) 036168 Analys(z)ers unification, lets use single spelling, fixes #142 (by @adamsitnik) 2fa5c0 Update README.md (by @JohanLarsson) 8b8641 Merge pull request #145 from JohanLarsson/master (by @AndreyAkinshin) 734533 introducing Validators: validate benchmarks before running, return errors in ... (by @adamsitnik) eaa943 ExecutionValidator: allow users to verify that all their benchmarks are runna... (by @adamsitnik) e4fa4b support overriding with 'stronger' validators, eliminate duplicates (by @adamsitnik) 57666a Add column order for SummaryTable, fixes #122 (by @AndreyAkinshin) 62af92 Minor fixes in README (by @AndreyAkinshin) 5e6877 updated README (by @adamsitnik) 1255a4 Initial work on BenchmarkDotNet.Diagnostics.Windows rename (by @mattwarren) 59ca8c Ensure renamed diagnostics dll is loaded (BenchmarkDotNet.Diagnostics.Windows... (by @mattwarren) 825193 Added info about Diagnosers (by @mattwarren) b836c5 Spelling/formatting (by @mattwarren) 3f74c7 Fixing project.json (after I overwrite previous changes) (by @mattwarren) c24a78 Merge branch 'develop' of https://github.com/PerfDotNet/BenchmarkDotNet into ... (by @mattwarren) 8c678f reflecting recent Diagnosers->Diagnostics.Windows changes (by @adamsitnik) 9bcdca Executing single Benchmark for multiple Runtimes [with Diagnoser attached] #117 (by @adamsitnik) 4dffdb Switching to new ‘dotnet’ target framework monikers (by @adamsitnik) 81b1e4 improved Runtimes descriptions + .NET 4.6.2 support (by @adamsitnik) 8e92e1 dnx452 and dnx46 support (by @adamsitnik) 06efde Fix in BaselineDiffColumnTest, see also #122 (by @AndreyAkinshin) f79f83 DEVELOPING.md: use stable version of dotnet cli (by @AndreyAkinshin) c2206d BenchmarkDotNet/project.json: correct version for System.IO.FileSystem (by @AndreyAkinshin) 1b650d Support for nested Enums as Params values, fixes #150 (by @adamsitnik) 76ef44 characters as Params support, including invalid path characters, fixes #148 (by @adamsitnik) 14e45c Distinct jobs to avoid possible duplication when config is doubled (by @adamsitnik) 837254 cleanup (by @adamsitnik) d0cf6b added NETCore.Platforms dependency to make dotnet cli restore our Core projects (by @adamsitnik) f7a20e replacing the chars that are invalid for file names, not only paths #148 (by @adamsitnik) e31872 Set library version: 0.9.5 (by @AndreyAkinshin) Contributors (4) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Johan Larsson (@JohanLarsson) Matt Warren (@mattwarren) Thank you very much! Additional details Milestone: v0.9.5 Date: May 02, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.5 https://www.nuget.org/packages/BenchmarkDotNet/0.9.5-beta BenchmarkDotNet v0.9.4 Improved messages about error in benchmarks, see #104 Natural sort order, see #92, #95, #97 Improved double/float/decimal/enum support for Params, see #96, #105, #116 Now environment info includes information about HardwareTimerKind and JitModules Added DryConfig Improved export performance, closed #119, merged #124 Better cmd-line discoverability (see #78), e.g. run Benchmark.exe --help and some useful information will be printed Supporting all kinds of references for generated project (exact version, custom paths, GAC, sub-folders, dependent assemblies not copied), closed #41, #49, #72, #123, merged #125 Friendliness to LinqPad restored, closed #66, merged #125 Milestone details In the v0.9.4 scope, 13 issues were resolved and 2 pull requests were merged. This release includes 55 commits by 4 contributors. Resolved issues (13) #41 Seems, not supported \"sub-folder\" #49 Dependent assemblies are not copied or added to the project file. #72 Referenced assembly dll-file (directly via file) not referenced in generated Program.csproj #78 Better command line discoverability (assignee: @mattwarren) #92 Results in the R graphs aren't displayed in a \"Natural Sort Order\" #95 Results should preserve the order of param values definition #96 Implement enums as valid Param for test #97 Params changes an order #104 System.InvalidOperationException: StatSummary: Sequence contains no elements #105 Params Attribute bug with float type #116 Issue when ParamAttribute decorated property is double and current system culture has comma as decimal separator #119 For large benchmarks report exporting is very, very slow and has a massive Gen2 heap #123 Can not run benchmark that references custom framework library (like WindowsBase) Merged pull requests (2) #124 Faster export (by @adamsitnik) #125 supporting all kinds of references for generated project (by @adamsitnik) Commits (55) 74789d Sort results by Parameter, in a Natural Sort Order (by @mattwarren) fec115 ParameterComparer refacotring (by @AndreyAkinshin) 9d3856 Add information about JIT modules in EnvironmentHelper (by @AndreyAkinshin) 7667ee Adding TraceEvent library for parsing ETW Events (by @mattwarren) ae71f2 More work on the GC/Allocation diagnostics (by @mattwarren) efa739 Allow diagnosers to be run from cmd line or via [Config(..)] (by @mattwarren) 633f1c Throw an error when invalid Config(..) options are specified (by @mattwarren) 04678a Add information about HardwareTimerKind (by @AndreyAkinshin) 7f3cf0 Fix in GetCorrectTypeNameTest (by @AndreyAkinshin) d9b890 Fix in HardwareTimerKind (by @AndreyAkinshin) 416e36 Natural sort order for CsvMeasurementsExporter and plots, Fixed #92 (by @AndreyAkinshin) dfc54a Ensure we sort the results by Method Name/Description (by @mattwarren) fa6c62 Changed GCDiagnoser to inspect live ETW event stream instead of recording to ... (by @goldshtn) d3f7ce Params: float/double/decimal support, Fixed #105 (by @AndreyAkinshin) 7bce9b Params: enum support, Fixed #96 (by @AndreyAkinshin) 4890dd Merge pull request #106 from goldshtn/develop (by @mattwarren) 9072b9 More robust when a benchmark throws an exception (see #104) (by @mattwarren) 2b9162 Work on #73 - highlighting in the Console output (by @mattwarren) f62483 Work on #73 - highlighting in the Console output (by @mattwarren) a639d5 Work on #73 - highlighting in Markdown output (by @mattwarren) 1457fe Changing [ConfigWithDryJobs] -> [DryConfig] (by @mattwarren) 396b7d Diagnostics for \"JIT In-lining\" events (by @mattwarren) 7a1027 Merge remote-tracking branch 'origin/master' into develop (by @adamsitnik) 6ec7f0 GC Diagnosers: reference to nuget package, unit test for both CLASSIC and DNX (by @adamsitnik) 9e7059 Proper XML Doc comment for DryConfig attribute (by @mattwarren) ad6be7 README.md: update (by @AndreyAkinshin) a4d0b8 Merge branch 'master' into develop (by @adamsitnik) 71e911 perf: CSV export: less allocations, reusing JobShortInfo (by @adamsitnik) 409b5e perf: logging with less allocations (by @adamsitnik) be6bfc perf: simpified LoggerWithPrefix, no need to check for multiple lines because... (by @adamsitnik) ade8a1 perf: avoid string.Concat and string.PadLeft (by @adamsitnik) f070eb perf: reuse AllProperties, reduced complexity (by @adamsitnik) 57c88b perf: deffer export to enable continuous progress updates instead of single l... (by @adamsitnik) 40071d loggers: final cleanup and fix for doubled new lines for diagnosers (by @adamsitnik) c46854 supporting all kinds of references for generated project. This closes #49, cl... (by @adamsitnik) a36e34 Initial work on better cmd line discoverability (part of #78) (by @mattwarren) 3f0752 Better formatting in the Baseline column (by @mattwarren) 8ab1a2 More samples (by @mattwarren) 1981a3 Refactoring of ConfigParser code (part of #78) (by @mattwarren) 3d1eba Allows \"Exporters\" and \"Analysers\" to be specified via cmd line (part of #78) (by @mattwarren) 5d195a Allow \"all\" option, i.e. \"exporters=all\" (part of #78) (by @mattwarren) 2146b8 Added some tests for ConfigParser (by @mattwarren) 582e08 Merge pull request #124 from PerfDotNet/perf (by @AndreyAkinshin) 84e67d README: Update team section (by @AndreyAkinshin) 4d6001 README: add FAQ question (by @AndreyAkinshin) 43ade3 BenchmarkDotNet.Samples: add #CLASSIC_RELEASE in launchSettings (by @AndreyAkinshin) e3c2d1 README: some improvements (by @AndreyAkinshin) c416c4 use the highest used target framework version to avoid framework mismatches +... (by @adamsitnik) 8a49b3 Merge branch 'develop' into references (by @adamsitnik) 23b2ea integration tests for complex references scenarios (by @adamsitnik) ddfa4a classic: specify full name and use newer msbuild dlls to avoid calling extra bat (by @adamsitnik) 79e8eb code cleanup after LINQPad 4 & 5 verification (by @adamsitnik) 445137 Merge pull request #125 from PerfDotNet/references (by @AndreyAkinshin) 4f1e1f Update package description (by @AndreyAkinshin) 0f5531 Set library version: 0.9.4 (by @AndreyAkinshin) Contributors (4) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Matt Warren (@mattwarren) Sasha Goldshtein (@goldshtn) Thank you very much! Additional details Milestone: v0.9.4 Date: March 24, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.4 https://www.nuget.org/packages/BenchmarkDotNet/0.9.4-beta BenchmarkDotNet v0.9.3 CoreCLR support (Closed #52, Merged #113) Milestone details In the v0.9.3 scope, 2 issues were resolved and 1 pull requests were merged. This release includes 12 commits by 2 contributors. Resolved issues (2) #52 CoreCLR Compatibility #114 Update NETStandard.Library dependency Merged pull requests (1) #113 Core Clr support (by @adamsitnik) Commits (12) 5b6460 Core: compilable main project (by @adamsitnik) cfdde6 Core: compilable samples and tests projects (by @adamsitnik) ab8b26 Core: new profile for running Samples from VS (by @adamsitnik) 9e1372 Core: new toolchain implementation with dnx451 code reuse (by @adamsitnik) de8bcc Core: tests: script to run both dnx and core (by @adamsitnik) 05d50f Core: dotnet cli supports only x64 now, workaround (by @adamsitnik) 726c66 Core: executing only supported benchmarks (x86 and Legacy Jit are not supported) (by @adamsitnik) de3371 Core: Dnx and Core as Runtimes, removed Toolchain configuration (by @adamsitnik) e7a3a8 Core: generating path in Linux-friendly way ;) (by @adamsitnik) fede7c Core: notify user when the process.Priority can not be set and continue execu... (by @adamsitnik) d59827 Merge pull request #113 from PerfDotNet/coreclr (by @AndreyAkinshin) 939891 Set library version: 0.9.3 (by @AndreyAkinshin) Contributors (2) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Thank you very much! Additional details Milestone: v0.9.3 Date: March 13, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.3 https://www.nuget.org/packages/BenchmarkDotNet/0.9.3-beta BenchmarkDotNet v0.9.2 Dnx451 support (Closed #51, Merged #87) Milestone details In the v0.9.2 scope, 1 issues were resolved and 1 pull requests were merged. This release includes 48 commits by 2 contributors. Resolved issues (1) #51 DNX Compatibility Merged pull requests (1) #87 DNX451 support (by @adamsitnik) Commits (48) f25427 road to DNX: part I: moving from csproj to xproj (by @adamsitnik) 2fe5cf road to DNX: part II: added dnx451 target (DNX SDK running on .Net 4.5.1) (by @adamsitnik) 6b4400 road to DNX: part II: the moment when Unit Test has shown up in VS! (by @adamsitnik) c97792 road to DNX: part II: able to debug Samples (by @adamsitnik) f901d6 road to DNX: part II: the moment when Integration Test has shown up in VS! (by @adamsitnik) f46296 road to DNX: part II: including *.txt files as resources, excluding auto-gene... (by @adamsitnik) cfc1b6 updated gitignore to exclude files created during integration tests run (by @adamsitnik) 60b343 Road to DNX: benchmark execution : building project.json instead of .csproj (by @adamsitnik) 0d41cb Road to DNX: benchmark execution : compiling project.json with Microsoft.Dnx.... (by @adamsitnik) 31bc59 updated versions in .json files after sync with master, (by @adamsitnik) c8e826 road to DNX: compilation: adding MetadataReferences for dlls required to comp... (by @adamsitnik) 2ebe6c road to DNX: compilation: adding executing assembly as dependency to project.... (by @adamsitnik) 76a74e Road to DNX: removing dependencies to BenchmarkDotNet.Diagnostics for DNX451 ... (by @adamsitnik) 40419a road to DNX: handling \"nuget-like\" package versions that can contain text (as... (by @adamsitnik) 8f06a7 it should have never happened but it does when debugging: DirectoryNotFoundEx... (by @adamsitnik) 7c2a96 Road to DNX: reusing MS dnu to restore and build. Simple solution that just w... (by @adamsitnik) e51d4d Road to DNX: alternative to MS dnu. reuses nuget and roslyn but as for now it... (by @adamsitnik) ada7cb Road to DNX: replacing dnu build with dnx run. +putting files in a folder tha... (by @adamsitnik) 18e969 road to DNX: referencing the right thing, bitness the same as hosting process (by @adamsitnik) 8e870c road to DNX: setting the compiler EXPLICIT to finally make it WORKING (at lea... (by @adamsitnik) 466d13 Road to DNX: removing failed PoC,dependencies cleanup, added some comments (by @adamsitnik) 5b3675 Road to DNX: removing dependencies to MSBuild for DNX target, some project.js... (by @adamsitnik) 3e65e8 road to DNU: reference project during development, but package when released (by @adamsitnik) 617a61 road to DNX: logging output from dnu restore/dnx run + default timeout (by @adamsitnik) 075cdc road to DNX: new value for toolchain enum: DNX451 (by @adamsitnik) bd3fea road to DNX: being able to debug NET40 from VS (by @adamsitnik) da5a9a road to DNX: copying all files that used to be copied in \".csproj times\" (by @adamsitnik) 5d8717 road to DNX: new debug profile with DNX trace mode ON, use when troubleshooti... (by @adamsitnik) 8272f6 road to DNX: fixing tests (by @adamsitnik) 96bcf8 road to DNX: make sure that our child process get the right priority and affi... (by @adamsitnik) cd0ba8 road to DNX: respecting specified benchmark processor architecture (by @adamsitnik) b1eb28 road to DNX: added all output files from integration tests to .gitignore (by @adamsitnik) aa62d1 fix for 4.0 (was passing arguments in wrong order) (by @adamsitnik) 0c1251 merge (by @adamsitnik) 46cd5e F# support, limited to existing tools possibilities (can not run from VS, onl... (by @adamsitnik) 74020c Merge remote-tracking branch 'upstream/master' (by @adamsitnik) 3402f0 replacing dnx with dotnet cli (by @adamsitnik) d634f4 road to DNX: final cleanup (by @adamsitnik) 24cd3a removing project.lock.json files (by @adamsitnik) 80becb removing all .csproj & packages.config file + keeping only single .sln file (by @adamsitnik) 9633d5 removing nuspec (now auto-generated by VS based on project.json) + version in... (by @adamsitnik) 617d82 running Classic Framework tests from console + minor cleanup (by @adamsitnik) fc9d98 DNX: running once compiled assembly directly without dotnet cli (perf+abble t... (by @adamsitnik) 8adad8 dnx: Diagnosers support. Currently only these which do not need umanaged libs... (by @adamsitnik) 34c3c9 DNX: changed folder of the auto-generated files to benchmark-specific + samples (by @adamsitnik) 9cf009 DNX: description for development (by @adamsitnik) 43af33 update to dotnet cli changes: output path and exit codes , now we set output... (by @adamsitnik) f59d3e Merge pull request #87 from adamsitnik/master (by @AndreyAkinshin) Contributors (2) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Thank you very much! Additional details Milestone: v0.9.2 Date: March 5, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.2 BenchmarkDotNet v0.9.1 Milestone details In the v0.9.1 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 5 commits by 2 contributors. Resolved issues (0) Merged pull requests (0) Commits (5) a0cfba use benchmarkSwitcher and 0.9.0 api features (by @cloudRoutine) a88fc0 Merge pull request #89 from cloudRoutine/patch-1 (by @AndreyAkinshin) 99d7c5 Improved ReflectionExtensions.GetCorrectTypeName; Fixed #90 (by @AndreyAkinshin) 770510 Improved work with idle method that returns a value type; Fixed #70 (by @AndreyAkinshin) 3c4410 Set library version: 0.9.1 (by @AndreyAkinshin) Contributors (2) Andrey Akinshin (@AndreyAkinshin) Jared Hester (@cloudRoutine) Thank you very much! Additional details Date: February 10, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.1 BenchmarkDotNet v0.9.0 New API Autodetermination of amount iteration for warmup/target idle/main iterations, duration of iteration, amount of CLR launches. Milestone details In the v0.9.0 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 34 commits by 4 contributors. Resolved issues (0) Merged pull requests (0) Commits (34) 71369d Add benchmarks to tests different ways of accessing arrays. Copypasted from h... (by @alexandrnikitin) 9a5930 Merge pull request #79 from alexandrnikitin/samples-array-access (by @AndreyAkinshin) 1b8cf9 MathSummaryTests: fix output (by @AndreyAkinshin) 92503b BenchmarkSwitcher improvements (by @AndreyAkinshin) ebaeea Big API refactoring (by @AndreyAkinshin) f149cb Big API refactoring, Part 2 (by @AndreyAkinshin) 380d9a Big API refactoring, Part 3 (by @AndreyAkinshin) 6cd2ce Big API refactoring, Part 4 (by @AndreyAkinshin) 1665d8 Big API refactoring, Part 5 (by @AndreyAkinshin) 140312 A better way of running a F# integration test (by @mattwarren) 8e58ab Big API refactoring, Part 6 (by @AndreyAkinshin) 9ec71b Add html export, resolved #75 (by @alinasmirnova) 7ae4ed Merge pull request #86 from alinasmirnova/refactoring (by @AndreyAkinshin) bfbc80 Big API refactoring, Part 7 (by @AndreyAkinshin) 256ed4 Re-design of the IDiagnoser API (by @mattwarren) f4bad8 Initial work on ETW Diagnostic Providers (by @mattwarren) da2e3f Big API refactoring, Part 8 (by @AndreyAkinshin) 5df553 Big API refactoring, Part 9 (by @AndreyAkinshin) 120b7c Big API refactoring, Part 10 (by @AndreyAkinshin) e61425 Big API refactoring, Part 11 (by @AndreyAkinshin) 171ba0 Big API refactoring, Part 12 (by @AndreyAkinshin) 854633 Big API refactoring, Part 13 (by @AndreyAkinshin) caafa9 Fix a bug in Templates/BenchmarkProgram.txt (by @AndreyAkinshin) 568c44 Add BenchmarkDotNet.Samples.FSharp (by @AndreyAkinshin) 2fa773 Fix a bug in Generator (by @AndreyAkinshin) 30e855 Update README (by @AndreyAkinshin) 1164ef Update README (by @AndreyAkinshin) 9c357c Improved plots for benchmarks with Params (by @AndreyAkinshin) ef41f6 Fix a bug in ClassicBuilder (by @AndreyAkinshin) 02babc Add BaselineDiffColumn.Scaled (by @AndreyAkinshin) 4388c8 Remove construction with description in BenchmarkAttribute (by @AndreyAkinshin) c9c25f Update README (by @AndreyAkinshin) 1cef82 RPlotExporter improvements (by @AndreyAkinshin) 173abf Set library version: 0.9.0 (by @AndreyAkinshin) Contributors (4) Alexandr Nikitin (@alexandrnikitin) Alina Smirnova (@alinasmirnova) Andrey Akinshin (@AndreyAkinshin) Matt Warren (@mattwarren) Thank you very much! Additional details Date: February 9, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.0 BenchmarkDotNet v0.8.2 Changes in the Summary table Summary table now supports ResultExtenders that can add new column to the table Now we use StandardError (aka Error) as the main accuracy metric Columns op/s, StdDev are disabled by default (you can add it via ResultExtenders) Statistic improvements, now you have detailed statistic in the console log like follows: Mean = 118.5298 us, StdError = 1.2863 us (N = 30, StdDev = 7.0454 us) Min = 109.1602 us, Median = 117.1794 us, Max = 132.5764 us IQR = 10.1244 us, LowerFence = 98.0834 us, UpperFence = 138.5810 us ConfidenceInterval = [116.0086 us; 121.0510 us] (CI 95%) Added the Baseline feature, see #64 Export improvements, now you have files <BenchmarkName>-report-github.md, <BenchmarkName>-report-stackoverflow.md for easy publishing results on GitHub and StackOverflow. Basic plotting. Added new BenchmarkRPlotExporter that creates BuildPlots.R in the bin directory. It is an R script that generates boxplot and barplot for your benchmarks (you should have installed R with defined R_HOME environment variable) Updated environment info Added Stopwatch Frequency and Resolution Split common benchmark properties (like Mode, Platform, Runtime) in several lines (3 properties per line) Log improvements: add total time, statistics, list of exported files Bug fixes Milestone details In the v0.8.2 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 34 commits by 3 contributors. Resolved issues (0) Merged pull requests (0) Commits (34) de0140 Add BenchmarkEnvironmentAnalyser (by @AndreyAkinshin) 9ea78f Improved confidence intervals (by @AndreyAkinshin) b8d4b6 Rename: PreWarmup -> Pilot (by @AndreyAkinshin) 988efc Reporting: change StandardDeviation to StandardError (by @AndreyAkinshin) 4da39d Big refactoring (by @AndreyAkinshin) 6a0caa Add BenchmarkRPlotExporter (by @AndreyAkinshin) 3a6ea4 Allow plugins to extend the Results Table (by @mattwarren) 7a7991 Create a \"Result Extender\" plug-in for #64 (by @mattwarren) 70ea89 Integration tests for #64 (by @mattwarren) a2d0ec Separate class for string extensions. (by @alinasmirnova) 5d6c78 Multiline prefix string extension. (by @alinasmirnova) bdd84e New logger type for adding prefix. StackOverflow markdowns. (by @alinasmirnova) ba9ec5 Move ExportToFile to ExporterBase. Add file suffix. (by @alinasmirnova) 38cd8c GitHub markdown support. (by @alinasmirnova) 732420 Markdown readme edits (by @alinasmirnova) 541eef Merge pull request #71 from alinasmirnova/refactoring (by @AndreyAkinshin) c53618 Merge remote-tracking branch 'refs/remotes/origin/develop' into refactoring (by @AndreyAkinshin) e3f420 Samples: add Intro_08_Baseline (by @AndreyAkinshin) 145b78 README: add NuGet badge (by @AndreyAkinshin) b0e108 Minor fixes (by @AndreyAkinshin) 565c25 Update README (by @AndreyAkinshin) 045e2a Add BenchmarkStatResultExtender (by @AndreyAkinshin) 20c6d2 Minor fixes (by @AndreyAkinshin) f80edc Update README (by @AndreyAkinshin) 3d2309 README: links to wiki (by @AndreyAkinshin) d60d0f Fix bug in TimeUnit (by @AndreyAkinshin) 034961 Unit tests for TimeUnit (by @AndreyAkinshin) f2c6f1 Logs: add total time (by @AndreyAkinshin) 140dec Merge branch 'refs/heads/refactoring' into develop (by @AndreyAkinshin) 9e16e8 Ensure that the DeltaResultExtender doesn't throw (by @mattwarren) 60f7c9 Merge branch 'develop' of https://github.com/PerfDotNet/BenchmarkDotNet into ... (by @mattwarren) 77b24b Rollback of bad changes from the last merge (by @AndreyAkinshin) 3df71a More robust way of wiring up BenchmarkBaselineDeltaResultExtender (by @mattwarren) 8e5a0e Set library version: 0.8.2 (by @AndreyAkinshin) Contributors (3) Alina Smirnova (@alinasmirnova) Andrey Akinshin (@AndreyAkinshin) Matt Warren (@mattwarren) Thank you very much! Additional details Date: January 19, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.8.2 BenchmarkDotNet v0.8.1 Milestone details In the v0.8.1 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 12 commits by 2 contributors. Resolved issues (0) Merged pull requests (0) Commits (12) 79ee93 README.md: small fixes (by @AndreyAkinshin) a3e2dc Adding missing CLRMD binary dependencies (by @mattwarren) 7492c1 Merge branch 'master' of https://github.com/PerfDotNet/BenchmarkDotNet (by @mattwarren) ddae06 Lazy-load the Diagnostic plug-ins, fixes #63 (by @mattwarren) 5df0df More robust version of the Diagnostic Library (see #53) (by @mattwarren) 9f3ba0 Ensure that non-void SingleRun Benchmarks work (by @mattwarren) de5bca Allow Benchmarks that use Inner classes (see #55) (by @mattwarren) 5d000f Ensure we can run Benchmarks produced by F# (see #59) (by @mattwarren) 8b0563 Added missing binary dependency (part of #59) (by @mattwarren) 60047e Fixing #45 (by @mattwarren) 3bede9 Implemented Ctrl-C handling in the Console (Fixes #50) (by @mattwarren) 719391 Set library version: 0.8.1 (by @AndreyAkinshin) Contributors (2) Andrey Akinshin (@AndreyAkinshin) Matt Warren (@mattwarren) Thank you very much! BenchmarkDotNet v0.8.0 Milestone details In the v0.8.0 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 67 commits by 5 contributors. Resolved issues (0) Merged pull requests (0) Commits (67) 042631 Atomics sample (by @redknightlois) 6ce693 Merge pull request #35 from redknightlois/master (by @AndreyAkinshin) e73ce4 Update Intro_03_SingleRun (by @AndreyAkinshin) add75c Samples: add Js_AsVsCast (by @AndreyAkinshin) 1d4653 Samples: updates Js_AsVsCast (by @AndreyAkinshin) 73f48f BenchmarkRuntime support (by @AndreyAkinshin) 8e9fec BenchmarkRuntime: fix a bug (by @AndreyAkinshin) 0d8a86 Added RotateBits (will be interested when https://github.com/dotnet/coreclr/i... (by @redknightlois) 724970 Added and special case which we know it must not be optimized at all (for com... (by @redknightlois) 30ba93 Merge pull request #43 from redknightlois/master (by @AndreyAkinshin) a2338c Big refactoring (by @AndreyAkinshin) dc8d02 Make the \"Getting Started\" guide read better (by @mattwarren) 9883ca Update README.md (by @mattwarren) 3cd76b Update README.md (by @mattwarren) 6a3d00 Update README.md (by @mattwarren) 7de832 Better way of generating Benchmark competition list (by @mattwarren) 10ded0 Add Jit_GenericsMethod (by @AndreyAkinshin) e5538b Fix for #42 (make benchmarks work in LINQPad) (by @mattwarren) 873450 Make logging robust when strings contain '{' or '} (by @mattwarren) 2ee55a Create a batch file that builds the benchmark (by @mattwarren) d14b18 Adding \"Advanced Features\" section (by @mattwarren) deb1a9 Sample benchmark for different types of loops (by @mattwarren) 26e7b0 Move sample to correct namespace (by @mattwarren) 505711 Grouping parameter results together (fixes #36) (by @mattwarren) 1ee786 Merge branch 'master' of https://github.com/PerfDotNet/BenchmarkDotNet (by @mattwarren) 496ae1 Add support for benchmarking methods of generic classes (#44) (by @mattwarren) ad12e1 Return of the Params (by @AndreyAkinshin) f80613 Little cleanup (by @AndreyAkinshin) 52a076 Little refactoring (Flow -> Toolchain) (by @AndreyAkinshin) 2f383e Moar samples (by @mattwarren) 30b162 Initial work on code for asm/IL viewing (by @mattwarren) 6a8873 Initial support for printing Assembly code (by @mattwarren) 8cd841 Print diagnostic info (with flag \"-printDiagnostics\") (by @mattwarren) 236043 Adding missing CLRMD dependancies (by @mattwarren) 58b7a3 Print the method when we have a \"call\" asm instruction (by @mattwarren) 1dae2b Change Jit_GenericsMethod benchmark to reproduce on x64 both Legacy & RuyJit (by @alexandrnikitin) 6ae157 Merge pull request #47 from alexandrnikitin/samples-Jit_GenericsMethod-x64repro (by @AndreyAkinshin) c39b7c README: add gitter link (by @AndreyAkinshin) b0768e Ensure we \"close\" the code section in the markdown we generate (by @mattwarren) 6c9ae7 Merge branch 'master' of https://github.com/PerfDotNet/BenchmarkDotNet (by @mattwarren) 9ed66d Show how you can write \"Performance\" Unit Tests (by @mattwarren) 7c9c6d Helper methods for Performance Unit Tests (by @mattwarren) 3a2c75 Make Perf Unit Test more robust!! (by @mattwarren) d1ddd3 Ensure the Description is used when sorting (if available) (by @mattwarren) 27d662 Moving assembly viewer into BenchmarkDotNet.Diagnostics (by @mattwarren) 1ef961 Load BenchmarkDotNet.Diagnostics dynamically (by @mattwarren) 7eb70a New plugin system (by @AndreyAkinshin) 2114d7 Fix typos in API (by @AndreyAkinshin) e0a488 Fix in PerformanceUnitTest (by @AndreyAkinshin) 02cddd BenchmarkDotNet.Tests: upgrade xunit to 2.1 (by @AndreyAkinshin) 3d8ff2 IntegrationTests: replace GetTestOutput by AccumulationLogger (by @AndreyAkinshin) 5ebf69 IntegrationTests: upgrade xunit to 2.1 (by @AndreyAkinshin) 280834 Diagnostic refactoring (by @AndreyAkinshin) 79ee42 Custom toolchains (by @AndreyAkinshin) 527df6 Analysers (by @AndreyAkinshin) 3d8199 Fix in BuildTable (by @AndreyAkinshin) 699588 Tidy up of Source Diagnoser code (part of #53) (by @mattwarren) 5ab029 Better way of getting the called method name (part of #53) (by @mattwarren) 37f468 Integration test for Source Diagnostics (see #53) (by @mattwarren) da0093 Spelling mistakes and remove unused using stmts (by @mattwarren) fbf409 Fix typo in README (by @ForNeVeR) 4895c6 Merge pull request #61 from ForNeVeR/patch-1 (by @AndreyAkinshin) dd5f1f Rename: exec -> execute (by @AndreyAkinshin) 6826a9 BenchmarkSwitcher: update the promt message (by @AndreyAkinshin) f2a63f Update README.md (by @AndreyAkinshin) 54cfdc Samples/Program.cs: small fix (by @AndreyAkinshin) a927e9 Set library version: 0.8.0 (by @AndreyAkinshin) Contributors (5) Alexandr Nikitin (@alexandrnikitin) Andrey Akinshin (@AndreyAkinshin) Federico Andres Lois (@redknightlois) Friedrich von Never (@ForNeVeR) Matt Warren (@mattwarren) Thank you very much! BenchmarkDotNet v0.7.8 Milestone details In the v0.7.8 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 36 commits by 5 contributors. Resolved issues (0) Merged pull requests (0) Commits (36) 6ede76 Reporting: better number formats for ops/sec. (by @ppanyukov) 118bc9 Merge pull request #17 from ppanyukov/feature/report-num-align (by @AndreyAkinshin) 994cbc Markdown friendly reporting (by @AndreyAkinshin) 91bbb4 Reporting: use fixed precision for AvrTime and StdDev. (by @ppanyukov) e9b8fe Merge pull request #18 from ppanyukov/feature/report-num-align (by @AndreyAkinshin) 121c3d Reporting: uniform time units across all benchmarks. (by @ppanyukov) 1cb520 Merge pull request #21 from ppanyukov/feature/report-num-align (by @AndreyAkinshin) a4f53e Reporting: refactor use of BenchmarkTimeSpan. (by @ppanyukov) 7fbf63 Merge pull request #24 from ppanyukov/feature/report-num-align (by @AndreyAkinshin) c8c893 message for Obsolete warning which tells what to use now + updated README (by @adamsitnik) b48756 Merge pull request #26 from adamsitnik/master (by @AndreyAkinshin) 36f849 Add Jit_RegistersVsStack (by @AndreyAkinshin) 32cafc Allow a [Setup] method to be used on Benchmarks (by @mattwarren) 8a14a8 Missed out of last commit (by @mattwarren) 0103b7 Integration tests for [Setup] method closes #23, closes #7 (by @mattwarren) 1e7c25 Display MSBuild errors in the console output, see #22 (by @mattwarren) 876303 Added new benchmark for Stopwatch v DateTime (by @mattwarren) e5f748 New ReportExporter system (by @AndreyAkinshin) e0fdbc Add BenchmarkDotNet.Visualizer (by @AndreyAkinshin) 954d08 Fix bug in op/s reporting (by @mattwarren) d9dcf4 Tidying up BenchmarkDotNet.Samples layout see #29 (by @mattwarren) 7abb1b Making Visualizer samples point to the new location (see #29) (by @mattwarren) 96d5b9 Speed up the integration tests, closes #23 (by @mattwarren) 2568a1 Initial work on Params attribute (see #8) (by @mattwarren) 47fad8 Ensure Benchmarks with Params show up properly in Reports (by @mattwarren) 36e060 Integration tests and sample for Params attribute (by @mattwarren) 76ad88 Fixing some spelling mistakes (by @mattwarren) 81e6eb Update BenchmarkProgram.txt (by @mattwarren) 4008cf Merge pull request #32 from PerfDotNet/mattwarren-exception-handling (by @mattwarren) 9e893e Statistic improvements (by @AndreyAkinshin) 9ce9f9 Ensure that Params attribute can work with static fields/properties (by @mattwarren) 7c3782 Update README.md (by @AndreyAkinshin) 5a1783 Update Array_HeapAllocVsStackAlloc.cs (by @mattwarren) 50ff16 Allow just number param in RunCompetitions. (by @vkkoshelev) 04c306 Merge pull request #34 from vedun-z/master (by @AndreyAkinshin) a630dc Set library version: 0.7.8 (by @AndreyAkinshin) Contributors (5) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Matt Warren (@mattwarren) Philip Panyukov (@ppanyukov) vkkoshelev (@vkkoshelev) Thank you very much! BenchmarkDotNet v0.7.7 Milestone details In the v0.7.7 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 14 commits by 2 contributors. Resolved issues (0) Merged pull requests (0) Commits (14) c94525 Add Cpu_BranchPerdictor (by @AndreyAkinshin) 44cbb0 Add Algo_Md5VsSha256 (by @AndreyAkinshin) 4d789c Most significant bit and bool to int conversions. (by @redknightlois) 09446b Updated to avoid using an array. (by @redknightlois) b16153 Fixed a bug where converting a bool to int instead to byte (which is the nati... (by @redknightlois) 52acca Merge pull request #15 from redknightlois/master (by @AndreyAkinshin) 66cce4 Fix troubles with inlining (by @AndreyAkinshin) a8e641 Fixes in Jit_BoolToInt (by @AndreyAkinshin) cfbb88 Rename task parameters: Current -> Host (by @AndreyAkinshin) 209b4f Rename Task to BenchmarkTask, fix #9 (by @AndreyAkinshin) 74be9d Fix typos (by @AndreyAkinshin) adc6c2 Fix Intro_01_MethodTasks (by @AndreyAkinshin) 438042 Add BenchmarkRunner.RunUrl (by @AndreyAkinshin) 72d606 Set library version: 0.7.7 (by @AndreyAkinshin) Contributors (2) Andrey Akinshin (@AndreyAkinshin) Federico Andres Lois (@redknightlois) Thank you very much! BenchmarkDotNet v0.7.6 Milestone details In the v0.7.6 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 9 commits by 5 contributors. Resolved issues (0) Merged pull requests (0) Commits (9) 8e9942 Update README.md (by @NN---) 51ef26 Merge pull request #11 from NN---/patch-2 (by @AndreyAkinshin) db8791 Fixed link to samples. (by @redknightlois) 14ddf4 Merge pull request #12 from redknightlois/patch-1 (by @mattwarren) d70b4c Accessibility and genericness checks added for benchmark methods. (by @krk) 04ce12 Benchmark methods defined in nested classes are supported. (by @krk) a5caba Improvements in log parser (by @AndreyAkinshin) d750b9 Merge pull request #13 from krk/master (by @AndreyAkinshin) eab4bd Set library version: 0.7.6 (by @AndreyAkinshin) Contributors (5) Andrey Akinshin (@AndreyAkinshin) Federico Andres Lois (@redknightlois) Kerem Kat (@krk) Matt Warren (@mattwarren) NN (@NN---) Thank you very much! BenchmarkDotNet v0.7.5 Milestone details In the v0.7.5 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 4 commits by 1 contributors. Resolved issues (0) Merged pull requests (0) Commits (4) 957a01 Update samples (by @AndreyAkinshin) 118e2f Add the Cpu_Ilp_RyuJit sample (by @AndreyAkinshin) b7e564 Update copyrights (by @AndreyAkinshin) b6cce3 v0.7.5: Improved project building (by @AndreyAkinshin) Contributors (1) Andrey Akinshin (@AndreyAkinshin) Thank you very much! BenchmarkDotNet v0.7.4 Milestone details In the v0.7.4 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 2 commits by 1 contributors. Resolved issues (0) Merged pull requests (0) Commits (2) c5e924 Update README (by @AndreyAkinshin) 641c95 v0.7.4: New benchmark Invoker, new samples, refactoring, minor fixes (by @AndreyAkinshin) Contributors (1) Andrey Akinshin (@AndreyAkinshin) Thank you very much! BenchmarkDotNet v0.7.3 Milestone details In the v0.7.3 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 1 commits by 1 contributors. Resolved issues (0) Merged pull requests (0) Commits (1) 42e13b v0.7.3: Small bug fixes (by @AndreyAkinshin) Contributors (1) Andrey Akinshin (@AndreyAkinshin) Thank you very much! BenchmarkDotNet v0.7.2 Milestone details In the v0.7.2 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 2 commits by 1 contributors. Resolved issues (0) Merged pull requests (0) Commits (2) 19f1e2 Add templates for BenchmarkProjectGenerator (by @AndreyAkinshin) 043c04 v0.7.2: BenchmarkMode.Throughput, OperationCountAttribute, minor improvements... (by @AndreyAkinshin) Contributors (1) Andrey Akinshin (@AndreyAkinshin) Thank you very much! BenchmarkDotNet v0.7.1 Milestone details In the v0.7.1 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 4 commits by 1 contributors. Resolved issues (0) Merged pull requests (0) Commits (4) b2bc76 A bugfix (MSBuild fail case) (by @AndreyAkinshin) ce7f58 Improved SingleRun (by @AndreyAkinshin) 295cc2 Current values for JitVersion, Platform, and Framework (by @AndreyAkinshin) 744eba Set library version: 0.7.1 (by @AndreyAkinshin) Contributors (1) Andrey Akinshin (@AndreyAkinshin) Thank you very much! BenchmarkDotNet v0.7.0 Milestone details In the v0.7.0 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 59 commits by 2 contributors. Resolved issues (0) Merged pull requests (0) Commits (59) 7f1c49 Add ShiftVsMultiplyBenchmark (by @AndreyAkinshin) 21298c Renaming (by @AndreyAkinshin) 86aada Add ReverseSortProgram (by @AndreyAkinshin) 5830ef Add MakeRefVsBoxingProgram (by @AndreyAkinshin) fe121e Automatic adjustment WarmUpIterationCount (by @AndreyAkinshin) d3dd9c Improved console output (by @AndreyAkinshin) 5e5df2 Update IncrementProgram (by @AndreyAkinshin) dca61d Change Average statistic to Median (by @AndreyAkinshin) 9d57e6 Update README.md (by @AndreyAkinshin) 7cca77 StaticFieldProgram -> ArrayIterationProgram (by @AndreyAkinshin) e02906 Add ForeachArray and ForeachList programs (by @AndreyAkinshin) 8e3f6e Add StandardDeviation calculation (by @AndreyAkinshin) 8b0c50 Add BenchmarkSettings singleton with DetailedMode property (by @AndreyAkinshin) eae5bf Add useful arguments for console application (by @AndreyAkinshin) 6f15f0 Update README.md (by @AndreyAkinshin) c1c44b Add StackFrameProgram (by @AndreyAkinshin) bbc6e7 Update StackFrameProgram (by @AndreyAkinshin) 5f8121 Set version number and add NuGet package metadata (by @AndreyAkinshin) 9425cb Add ProcessorAffinity to settings (by @AndreyAkinshin) bcc037 Add single result benchmark mode (--single) and disable warmup mode (--disabl... (by @AndreyAkinshin) 4ce0b4 Add build.bat for Benchmarks project (by @AndreyAkinshin) 69fbc7 Add --output-file option (by @AndreyAkinshin) df2092 Update build system (by @AndreyAkinshin) addd25 Update run.bat (by @AndreyAkinshin) b5c154 Add Mono support to run.bat (by @AndreyAkinshin) a4b42a Update build system (by @AndreyAkinshin) 65bbf7 Benchmarks: add support of selecting target program via number (by @AndreyAkinshin) d4317b Add MedianTicks to CompetitionResult report in DetailedMode fixed #1 (by @AndreyAkinshin) 3999e0 Update README.md (by @AndreyAkinshin) bd7452 Update EnvironmentTickCount hack (by @AndreyAkinshin) cf7aa6 Add CultureInfo setting (by @AndreyAkinshin) 16bb5e Set BenchmarkDotNet version: 0.5.1 (by @AndreyAkinshin) 07cf52 Add CompetitionBase: now competitions can be created in form of unit tests. (by @mijay) 284b78 Full refactoring (by @AndreyAkinshin) 2943d9 Add BenchmarkDotNet.Samples project (by @AndreyAkinshin) 572483 Merge branch 'dev' (by @AndreyAkinshin) 324d99 Remove ReflectionVsExpressionCompetition (by @AndreyAkinshin) ce5c67 Add CacheConsiousBinarySearchCompetition (by @AndreyAkinshin) ba8725 Add SelectVsConvertAllCompetition (by @AndreyAkinshin) 60b002 Set BenchmarkDotNet version: 0.5.2 (by @AndreyAkinshin) 3a4213 Fix in GetBenchmarkMethodClean (by @AndreyAkinshin) 73ee56 Add BitCountCompetition (by @AndreyAkinshin) 72836a Add missed Clean in BenchmarkCompetitionTask, Fixed #4 (by @AndreyAkinshin) 1258cb Big refactoring (by @AndreyAkinshin) 03bf14 Attributes renaming (by @AndreyAkinshin) 98a3cd Improved environment info (by @AndreyAkinshin) fe6e4e New benchmarks: ArrayBoundEliminationCompetition, InstructionLevelParallelism... (by @AndreyAkinshin) c89054 Fix in EnvironmentHelper.GetConfiguration() (by @AndreyAkinshin) 90d260 Add icon (by @AndreyAkinshin) beb681 Improved WarmUp (by @AndreyAkinshin) 7a63b6 Big refactoring (by @AndreyAkinshin) 8197e5 Update samples (by @AndreyAkinshin) c8d348 Add BenchmarkProperties (by @AndreyAkinshin) 97c73a Update Cpu_InstructionLevelParallelism (by @AndreyAkinshin) 957714 Small fixes (by @AndreyAkinshin) fdf4dd Update README (by @AndreyAkinshin) 8ac1ab Merge branch 'big-refactoring' (by @AndreyAkinshin) 18a256 Small fixes (by @AndreyAkinshin) 20df13 NuGet version: 0.7.0 (by @AndreyAkinshin) Contributors (2) Andrey Akinshin (@AndreyAkinshin) Mitya Kononchuk (@mijay) Thank you very much!"
  },
  "changelog/index.html": {
    "href": "changelog/index.html",
    "title": "ChangeLog | BenchmarkDotNet",
    "summary": "ChangeLog BenchmarkDotNet v0.15.0 BenchmarkDotNet v0.14.0 BenchmarkDotNet v0.13.12 BenchmarkDotNet v0.13.11 BenchmarkDotNet v0.13.10 BenchmarkDotNet v0.13.9 BenchmarkDotNet v0.13.8 BenchmarkDotNet v0.13.7 BenchmarkDotNet v0.13.6 BenchmarkDotNet v0.13.5 BenchmarkDotNet v0.13.4 BenchmarkDotNet v0.13.3 BenchmarkDotNet v0.13.2 BenchmarkDotNet v0.13.1 BenchmarkDotNet v0.13.0 BenchmarkDotNet v0.12.1 BenchmarkDotNet v0.12.0 BenchmarkDotNet v0.11.5 BenchmarkDotNet v0.11.4 BenchmarkDotNet v0.11.3 BenchmarkDotNet v0.11.2 BenchmarkDotNet v0.11.1 BenchmarkDotNet v0.11.0 BenchmarkDotNet v0.10.14 BenchmarkDotNet v0.10.13 BenchmarkDotNet v0.10.12 BenchmarkDotNet v0.10.11 BenchmarkDotNet v0.10.10 BenchmarkDotNet v0.10.9 BenchmarkDotNet v0.10.8 BenchmarkDotNet v0.10.7 BenchmarkDotNet v0.10.6 BenchmarkDotNet v0.10.5 BenchmarkDotNet v0.10.4 BenchmarkDotNet v0.10.3 BenchmarkDotNet v0.10.2 BenchmarkDotNet v0.10.1 BenchmarkDotNet v0.10.0 BenchmarkDotNet v0.9.9 BenchmarkDotNet v0.9.8 BenchmarkDotNet v0.9.7 BenchmarkDotNet v0.9.6 BenchmarkDotNet v0.9.5 BenchmarkDotNet v0.9.4 BenchmarkDotNet v0.9.3 BenchmarkDotNet v0.9.2 BenchmarkDotNet v0.9.1 BenchmarkDotNet v0.9.0 BenchmarkDotNet v0.8.2 BenchmarkDotNet v0.8.1 BenchmarkDotNet v0.8.0 BenchmarkDotNet v0.7.8 BenchmarkDotNet v0.7.7 BenchmarkDotNet v0.7.6 BenchmarkDotNet v0.7.5 BenchmarkDotNet v0.7.4 BenchmarkDotNet v0.7.3 BenchmarkDotNet v0.7.2 BenchmarkDotNet v0.7.1 BenchmarkDotNet v0.7.0 Full ChangeLog"
  },
  "changelog/v0.10.0.html": {
    "href": "changelog/v0.10.0.html",
    "title": "BenchmarkDotNet v0.10.0 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.0 Now BenchmarkDotNet is a part of .NET Foundation Job and Column API refactoring (see new documentation) Measurement engine improvements Horology enhancement (see TimeInterval and Frequency) Introduced RankColumn which is based on WelchTTest (see 157aabc3) JsonExporters refactoring (see the Exporters/Json section in the documentation) Renamed JsonExporters classed and attributes JsonExporters with custom settings JsonExporters now includes information about the target type namespace (see #246). Add JetBrains.Annotations (see #253) RFC 4180 support in CSV exporters (see #241) Many bugfixes Milestone details In the v0.10.0 scope, 19 issues were resolved and 7 pull requests were merged. This release includes 85 commits by 7 contributors. Resolved issues (19) #30 Better information when we haven't got a valid measurement #121 Strange # of \"Launches\" chosen with Count.Auto #154 PathTooLong exception on custom config #185 Report if difference between 2 benchmarks is statistically significance #241 .csv results output does not play well with Excel or Google Sheets #244 DefaultConfig StatisticColumn values #246 No namespace information? #265 Add ability to specify that benchmark requires STAThread #266 Don't assume that TargetType has reference to BenchmarkDotNet (assignee: @adamsitnik) #268 Print runtime of child processes in summary #271 Params attribute does not handle nullable types #272 [Setup] error when doing inheritance #276 System.EntryPointNotFoundException #280 Cannot run on OSX / Mono (System.Xml.XmlException: Root element is missing) #281 Results are exported twice for single run #288 IdleWarmup running off forever #291 [Bug] Incorrect results for targetCount:Auto #292 Support for Beta versions #296 [BUG] NRE in OutliersAnalyser Merged pull requests (7) #253 Mark [Benchmark] as implying implicit use (by @roji) #267 Make shipped assemblies have CLSCompliant(true) applied (by @lahma) #277 Changed diagnosers flow, reduced heap allocations in Engine to 0 (by @adamsitnik) #278 Support Atlassian flavored wiki markup (by @lahma) #286 Mutable Job implementation (by @ig-sinicyn) #287 Fix docs: job API changed (by @ig-sinicyn) #293 Presenters: IFormattable support (by @ig-sinicyn) Commits (85) a8b4e7 JsonExporters refactoring (by @AndreyAkinshin) e6a4ae JsonExporters: add information about namespaces, resolves #246 (by @AndreyAkinshin) 29ee0a Add Namespace column (by @AndreyAkinshin) 26c333 Better error message (by @arthrp) 12b313 Merge pull request #251 from arthrp/master (by @AndreyAkinshin) 03d00c Mark [Benchmark] as implying implicit use (by @roji) 394a93 Merge pull request #253 from roji/resharper-annotations (by @AndreyAkinshin) 4912ea Remove unnecessary specific shell reference (by @factormystic) 023115 Merge pull request #254 from factormystic/patch-1 (by @AndreyAkinshin) 972fee Big refactoring (by @AndreyAkinshin) cf839a Improved ranks (by @AndreyAkinshin) ef3ecf Extended TimeInterval and Frequency API (by @AndreyAkinshin) dfcc98 Minor fixes (by @AndreyAkinshin) fb3757 Improved CSV export, fixes #241 (by @AndreyAkinshin) f490d1 further root folder cleanup #228 (by @adamsitnik) f7a6a0 Added [MeansImplicitUse] and explanation to summary for SetupAttribute and Cl... (by @adamsitnik) 56b1f2 Configuration fix in JitOptimizationsTests (by @AndreyAkinshin) faac58 Introduce AnaylyzeLaunchVariance (by @AndreyAkinshin) 9953a9 Smart statistics in StatisticsColumnProvider (by @AndreyAkinshin) 2a6578 Minor fixes in docs (by @AndreyAkinshin) 03fb04 Introduce UnrollFactor (by @AndreyAkinshin) 137636 NewLine fix in OutputLogger (by @AndreyAkinshin) b35d52 Unique column support (by @AndreyAkinshin) 24e944 Don't assume that TargetType has reference to BenchmarkDotNet, fixes #266 (by @adamsitnik) 69330a Make shipped assemblies have CLSCompliant(true) applied (by @lahma) fb8402 Merge pull request #267 from lahma/features/cls-compliancy (by @adamsitnik) 0944b5 Make exported HTML valid, add alternating color to result table (by @lahma) 748a2c Merge pull request #269 from lahma/features/html-export-enhancements (by @adamsitnik) afff51 ExecutionValidator should not throw on overridden [Setup] methods, fixes #272 (by @adamsitnik) ab9db4 Support nullable types as [Params], fixes #271 (by @adamsitnik) ce4994 support for [STAThread], fixes #265 (by @adamsitnik) 13fa5c move ConsoleHandler to separate file for better readability (by @adamsitnik) 0e8e82 Print runtime of child processes in summary, fixes #268 (by @adamsitnik) 491a28 Print more info about runtime of child processes in summary (and in a nicer w... (by @adamsitnik) 0580a5 updated docs for #265 (by @adamsitnik) f9baa6 catch native exceptions when determining clock type, #276 (by @adamsitnik) 93a23d Check OS version in WindowsClock, fixed #276 (by @AndreyAkinshin) 8d65fe changed diagnosers flow, possibility to hook up before jitting, after setup a... (by @adamsitnik) f346ff added predefined attributes for diagnosers (by @adamsitnik) e7cc6b Support Atlassian flavored wiki markup (by @lahma) 376bd8 reduce memory allocated by Engine during run to increase MemoryDiagnoser accu... (by @adamsitnik) b5ab55 display results when runing when no diagnoser is attached (by @adamsitnik) 7ae2b5 Improved idle method for primitive types (by @AndreyAkinshin) e1213a Fix NRE in BuildJobRuntimes (by @AndreyAkinshin) 572fa4 Make code CLS-Compliant, fix CS3015 warning (by @AndreyAkinshin) 4070a1 preload all settings in ctors, introduced IEngineFactory (by @adamsitnik) 2f0df7 make Engine use InvocationCount (by @adamsitnik) 8a7a12 calculate Statistics without allocations! makes the code look bad, but saves ... (by @adamsitnik) d8fa70 remove last allocations from Engine.Run (by @adamsitnik) f2a106 perform Jitting after first Setup call, better naming, test fix (by @adamsitnik) be3ce3 introduce general catch with hopes to help with #280 (by @adamsitnik) 3c5e70 post code review changes (by @adamsitnik) 16e258 possibility to define custom Engine (by @adamsitnik) afa586 Merge pull request #277 from PerfDotNet/diagnosersFlow (by @adamsitnik) 534189 export files only once, not twice, fixes #281 (by @adamsitnik) a733b5 Mutable Job implementation (by @ig-sinicyn) 259647 Merge pull request #286 from ig-sinicyn/feature-mutable-characteristics (by @AndreyAkinshin) c184b8 Fix docs: job API changed (by @ig-sinicyn) 47b152 Merge pull request #287 from ig-sinicyn/fix-docs-jobs-updated (by @AndreyAkinshin) 868ffc Jobs: WithXxx() extension methods added back, docs updated (by @ig-sinicyn) eede54 Jobs: .With() methods now create new instances of the Job. (by @ig-sinicyn) 40f160 Test fixed (by @ig-sinicyn) fd92f7 Jobs: helper for .With() methods (by @ig-sinicyn) 307b72 Merge pull request #289 from ig-sinicyn/features-jobs-with (by @AndreyAkinshin) d576f5 Presenters: IFormattable support (by @ig-sinicyn) 8647e7 Fix #291 (by @AndreyAkinshin) 49c000 Merge pull request #293 from ig-sinicyn/fix-presenter-culture (by @AndreyAkinshin) 684334 Merge pull request #278 from lahma/features/atlassian-wiki-markup (by @AndreyAkinshin) 7f3ca5 Make BenchmarkRunnerCore.Run public (by @AndreyAkinshin) 10a91e Allow using newer versions of Microsoft.NETCore.App, fixes #292 (by @adamsitnik) 134d74 Misc improvements in Exporters (by @AndreyAkinshin) 33c63f Respect RemoveOutliers in the RunResults (by @AndreyAkinshin) 5e022b Fix #291, part 2 (by @AndreyAkinshin) 4b6ea9 Improved name for the Id CharacteristicColumn (by @AndreyAkinshin) af6f8a Fix some compilation warnings (by @AndreyAkinshin) 2f8584 Analysers refactoring + OutliersAnalyser (by @AndreyAkinshin) b11935 Make BenchmarkRunnerCore public (by @AndreyAkinshin) 781740 Specify generated id for the default job (by @AndreyAkinshin) 846255 JobTests.Test01Create fix (by @AndreyAkinshin) 9f9544 Check if there is no MainTarget measurements in OutliersAnalyser, fixes #296 (by @AndreyAkinshin) 503b04 Proper exception in GetStatistics for empty input, see #296 (by @AndreyAkinshin) c667aa Fix path to logo (by @AndreyAkinshin) 0b91c3 Fix null check in JobMode.ApplyCore (by @AndreyAkinshin) 2edb56 Copyrights and links update (by @AndreyAkinshin) 2edb9a Set library version: 0.10.0 (by @AndreyAkinshin) Contributors (7) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Arthur (@arthrp) factormystic (@factormystic) ig-sinicyn (@ig-sinicyn) Marko Lahma (@lahma) Shay Rojansky (@roji) Thank you very much! Additional details Date: November 10, 2016 Milestone: v0.10.0 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.0 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.0 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.0 Online Documentation: https://dotnet.github.io/BenchmarkDotNet/"
  },
  "changelog/v0.10.1.html": {
    "href": "changelog/v0.10.1.html",
    "title": "BenchmarkDotNet v0.10.1 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.1 MemoryDiagnoser got improved. The changes: Memory Diagnoser is now part of BenchmarkDotNet.Core.dll, and it's enabled by default MemoryDiagnoser is 100% accurate about allocated memory when using default settings or Job.ShortRun or any longer job. (see #284) Memory Diagnoser no longer includes allocations from Cleanup/Setup methods (see #186) the results are now scaled so they are stable across the runs. (see #133) .NET Core 1.1+ support, we no longer support 1.0, we target netcoreapp1.1 now. Reason: we wanted to use GC.GetAllocatedBytesForCurrentThread in MemoryDiagnoser which is available only in 1.1+ Improved information about environment in summary Minor bugfixes Milestone details In the v0.10.1 scope, 9 issues were resolved and 2 pull requests were merged. This release includes 38 commits by 2 contributors. Resolved issues (9) #133 High differences between run for GC Diagnoser (assignee: @adamsitnik) #186 GC Diagnoser should not include allocations done by Setup method (assignee: @adamsitnik) #200 be accurate about allocated bytes/op (assignee: @adamsitnik) #208 Troubles with MemoryDiagnoserTests (assignee: @adamsitnik) #298 PlatformNotSupportedException when reading ProcessorAffinity on MacOS (assignee: @adamsitnik) #301 netcoreapp1.1 support (assignee: @adamsitnik) #309 Diagnosers don't export data to the measurements.csv files (assignee: @adamsitnik) #312 RuntimeInformation can be made static and internal (assignee: @AndreyAkinshin) #313 Bug in Generator (interface as a return type) (assignee: @AndreyAkinshin) Merged pull requests (2) #284 built-in accurate and cross platform Memory Diagnoser (by @adamsitnik) #314 Improved information about job environments in summary (by @AndreyAkinshin) Commits (38) 23f3b2 built-in accurate and cross platform Memory Diagnoser, fixes #186, fixes #200 (by @adamsitnik) 4cabc2 don't try to use AppDomain's Monitoring in Mono since it's not implemented there (by @adamsitnik) 99c21e scale GC collections count / op, makes MemoryDiagnoser output stable for benc... (by @adamsitnik) e91255 use per mille to make the Memory Diagnoser output more human-friendly + reduc... (by @adamsitnik) a0536d Merge branch 'master' into universalMemoryDiagnoser (by @adamsitnik) ade1be preallocate results list in more safe, but still ugly way (by @adamsitnik) 102282 closed the ugly code in separate class (by @adamsitnik) 7825b7 Update links in docs (by @AndreyAkinshin) aaf720 Fix typo (by @AndreyAkinshin) 1e2d38 update to netcoreapp1.1 in order to get universal cross platform memory diagn... (by @adamsitnik) e69e80 don't show Gen 1 and Gen 2 columns if empty for all benchmarks (by @adamsitnik) b10a84 PlatformNotSupportedException when reading ProcessorAffinity on MacOS, fixes ... (by @adamsitnik) 2a529a update to .NET Core 1.1, fixes #301 (by @adamsitnik) e6ccee always show Gen 0 column, display Gen 0/1/2 per 1k op (by @adamsitnik) 3bcc59 Merge branch 'master' into universalMemoryDiagnoser (by @adamsitnik) a09810 make public things readonly, expensive things lazy and extend's validators in... (by @adamsitnik) eae2cd added documentation and smarter bytes formatting (by @adamsitnik) 1208c3 Merge branch 'master' into universalMemoryDiagnoser (by @adamsitnik) f1f231 Merge pull request #284 from dotnet/universalMemoryDiagnoser (by @AndreyAkinshin) 6300a2 include MemoryDiagnoser's results in CsvMeasurementsExporter, fixes #309 (by @adamsitnik) ddb37e don't use spaces in columns names in CSV, #309 (by @adamsitnik) 112f62 Fix stupid bug with condition for optional MedianColumn (by @AndreyAkinshin) 60127c Remove Cpu_Ilp_RyuJit.cs because it's obsolete (by @AndreyAkinshin) 401456 Print full information about a GenerateException (by @AndreyAkinshin) 0b9177 Support of benchmark methods with an interface as a return type, fixed #313 (by @AndreyAkinshin) b42b9e Improved information about job environments in summary (by @AndreyAkinshin) 92f1db Improved information about job environments in summary, part 2 (by @AndreyAkinshin) 5d8dd7 Merge pull request #314 from dotnet/summary (by @AndreyAkinshin) d279f6 Make RuntimeInformation static internal, fix #312 (by @AndreyAkinshin) 1df6ca Minor API improvements in BenchmarkSwitcher (by @AndreyAkinshin) c12daf Dot't show the median column for the N=1 case (by @AndreyAkinshin) 19caa2 RyuJit is always avaiable for .NET Core (by @adamsitnik) 13e12c make JitOptimizationsValidator work for .NET Core (needed properties are avai... (by @adamsitnik) c17b43 hide the AllocatedBytes column for Mono, show Gen 0 only if any of the benchm... (by @adamsitnik) 29ac91 updated docs about Diagnosers in the Overview ;) (by @adamsitnik) cc974e Improved information about job environments in summary, part 3 (by @AndreyAkinshin) 8846af Update docs (by @AndreyAkinshin) 37b126 Set library version: 0.10.1 (by @AndreyAkinshin) Contributors (2) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Thank you very much! Additional details Date: December 04, 2016 Milestone: v0.10.1 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.1 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.1 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.1 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.1"
  },
  "changelog/v0.10.10.html": {
    "href": "changelog/v0.10.10.html",
    "title": "BenchmarkDotNet v0.10.10 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.10 Highlights: Disassembly Diagnoser (read more here: Disassembling .NET Code with BenchmarkDotNet) ParamsSources .NET Core x86 support Environment variables and Mono args support Better environment description More: additional sections in the documentation, bug fixes, build script improvements, internal refactoring. Overview post: BenchmarkDotNet v0.10.10 Milestone details In the v0.10.10 scope, 34 issues were resolved and 18 pull requests were merged. This release includes 95 commits by 12 contributors. Resolved issues (34) #160 Make ClrMd Source diagnoser working with new ClrMD api (assignee: @adamsitnik) #167 Detect virtual machine environment (assignee: @lukasz-pyrzyk) #262 Runtime knobs (assignee: @adamsitnik) #310 Support 32bit benchmarks for .NET Core (assignee: @adamsitnik) #350 ParamsSource (assignee: @adamsitnik) #437 Add DisassemblyDiagnoser for outputting disassembled JITed code. (assignee: @adamsitnik) #466 MSBuild parameters are not passed to generated benchmark project (assignee: @adamsitnik) #495 Attributes put on base methods are not considered in derived class (assignee: @lukasz-pyrzyk) #500 Borken compilation for net46 projects when .NET Framework 4.7 is installed (assignee: @adamsitnik) #505 JsonExporterBase doesn't include MemoryDiagnoser stats in output #511 [bug] Bug in GetTargetedMatchingMethod() logic #513 IterationSetup not run in Job.InProcess #516 Get a compilation error \"CS1009: Unrecognized escape sequence\" when using verbatim strings #519 BenchmarkSwitcher.RunAllJoined throws InvalidOperationException (assignee: @AndreyAkinshin) #526 Remove project.json support (assignee: @adamsitnik) #529 No namespace in export filenames can lead to data loss #530 Build error on Appveyor with recent changes. #533 When I clone, build, and run BenchmarkDotNet.Samples I get an error #534 Allow the users to compare 32 vs 64 RyuJit for .NET Core (assignee: @adamsitnik) #535 No way to set RuntimeFrameworkVersion in multiple-version config (assignee: @adamsitnik) #536 Strange disassembly ordering/truncation (assignee: @adamsitnik) #537 Can't benchmark a netstandard2.0 project (assignee: @adamsitnik) #538 Duplicate using causing benchmark not to work (assignee: @adamsitnik) #539 Target .NET Core 2.0 to take advantage of the new APIs (assignee: @adamsitnik) #540 Artifacts for disassembler projects (assignee: @adamsitnik) #542 Problems with Disassembler + Job.Dry (assignee: @adamsitnik) #555 Test \"CanDisassembleAllMethodCalls\" fails on Ubuntu (assignee: @adamsitnik) #556 Table in report is broken in VSCode markdown viewer (assignee: @adamsitnik) #558 Warn the users when running Benchmarks from xUnit with shadow copy enabled (assignee: @adamsitnik) #559 DissassemblyDiagnoser jit/arch info seems to be wrong (assignee: @adamsitnik) #561 Strange behaviour when benchmark project is build in debug mode (assignee: @adamsitnik) #562 DisassemblyDiagnoser crashes on overloaded benchmark (assignee: @adamsitnik) #564 [Bug] Benchmarking a method doesn't run global setup when filter is applied (assignee: @adamsitnik) #571 Allow users to use non compile-time constants as Parameters (assignee: @adamsitnik) Merged pull requests (18) #507 Fix a typo in Jobs.md (by @aidmsu) #508 Fixed some typos and grammar (by @lukasz-pyrzyk) #512 Warning about antivirus software after benchmark failure (by @lukasz-pyrzyk) #514 #495 - Unit test for reading attributes from the base class (by @lukasz-pyrzyk) #515 Fix #513 - IterationSetup not run in Job.InProcess (by @ig-sinicyn) #518 Fixed information about MemoryDiagnoser. (by @cincuranet) #520 XML Exporter documentation and samples (by @Teknikaali) #525 adding validator for setup cleanup attributes (by @ipjohnson) #527 Detecting virtual machine hypervisor, #167 (by @lukasz-pyrzyk) #531 Remove --no-build argument for dotnet test & pack commands. (by @Ky7m) #532 Fix type of local in EmitInvokeMultipleBody (by @pentp) #547 Fix markdown headers (by @jawn) #548 Fix condition in package reference list and update dotnet cli version from 1.0.4 to 2.0.0 for non-Windows system (by @Ky7m) #549 Project files cleanup (by @Ky7m) #552 Fix exporters to use fully qualified filenames (by @Teknikaali) #563 Remove leading space character in a MD table row, #556 (by @rolshevsky) #565 Single point of full config creation (by @ig-sinicyn) #569 Update cakebuild scripts (by @Ky7m) Commits (95) 682820 Fix typo in Jobs.md (by @aidmsu) e82a8b Fixed some typos and grammar (by @lukasz-pyrzyk) a0e9b9 Disassembly Diagnoser: displaying ASM, IL and C# for any JIT (by @adamsitnik) 57e0f0 recursive disassembling (by @adamsitnik) 1975ae return structured results from Disassembler (by @adamsitnik) 9ae365 Warning about antivirus software after benchmark failure (#512) (by @lukasz-pyrzyk) 74b41e Unit test for reading attributes from the base class, fixes #495 (by @lukasz-pyrzyk) 3bab2d Fix #513 - IterationSetup not run in Job.InProcess (#515) (by @ig-sinicyn) 769a39 use the IL instructions to detect more calls (by @adamsitnik) b69537 use InstructionPointer to combine asm with hardware counters (by @adamsitnik) 200244 Fixed information about MemoryDiagnoser. (by Jiri Cincura) 848a1a handling the lovely edge cases (Cecil vs ClrMD differences in naming types an... (by @adamsitnik) 40049b single text representation of asm is a range of IPs! (by @adamsitnik) 56e252 XML Exporter documentation and samples (#520) (by @Teknikaali) c18597 eliminate duplicates (ClrMD fault), be more defensive for edge cases (by @adamsitnik) a9262f allow the users to specify recursive depth limit (50MB output for simple lock... (by @adamsitnik) fbe329 Support params which include slashes, fixes #516 (by @AndreyAkinshin) f2b9c0 Fix RunAllJoined, fixes #519 (by @AndreyAkinshin) 983764 UX ;) (by @adamsitnik) c010de adding validator for setup cleanup attributes (by @ipjohnson) 424723 Merge pull request #525 from ipjohnson/master (by @adamsitnik) 7b680a prefer unit tests over integration tests if possible (by @adamsitnik) 93dc6e Remove project.json support, fixes #526 (by @adamsitnik) 19f22b Merge pull request #518 from cincuranet/docs (by @adamsitnik) fe2db1 configurable, runtime specific diagnosers, hard part transparent to end users (by @adamsitnik) fb60e5 disassembly diagnoser for Mono (by @adamsitnik) 55ce0d smart diagnoser can choose the right disassembler (by @adamsitnik) 46c911 one test to verify all scenarios (by @adamsitnik) d06086 minor improvements (by @adamsitnik) 116119 group instructions into maps for better visualization (by @adamsitnik) d19b1e test fix: split on any new line ;) (by @adamsitnik) 647a67 Merge branch 'asm' (by @adamsitnik) 91c8e4 move disassembler stuff to resources of Core project to make it super easy to... (by @adamsitnik) 363900 Remove --no-build argument for dotnet test & pack commands. (by @Ky7m) 22e993 Disable parallel build option (by @Ky7m) 9c327c Merge pull request #531 from Ky7m/removes-no-build-argument (by @adamsitnik) 20db28 the docs for Disassembly Diagnoser, #437 (by @adamsitnik) 13732b added asm report with navigation (by @adamsitnik) 33ee03 fix type of local in EmitInvokeMultipleBody (by @pentp) 7d943f Merge pull request #532 from pentp/master (by @adamsitnik) 4d173d RyuJit 32bit support for .NET Core, fixes #310, fixes #533 (by @adamsitnik) 5f5237 test fix (set platform in explicit way to avoid lack of 32-bit .NET Core sdk ... (by @adamsitnik) f359c9 allow the users to set custom RuntimeFrameworkVersion, fixes #535 (by @adamsitnik) 264150 disassembler: print the results in machine code order, not il, part of #536 (by @adamsitnik) 0088bd Detecting virtual machine hypervisor, #167 (#527) (by @lukasz-pyrzyk) 007444 print all returns (maps with negative ILOffset are not always prolog or epilo... (by @adamsitnik) aebc32 empty methods for LegacyJit64 have only maps with negative ILOffset, #536 (by @adamsitnik) ba7489 docs for Toolchains, closes #537 (by @adamsitnik) 8c4f53 allow the users to specify custom build configuration, #466, close #528 (by @adamsitnik) eb80b2 Environment Variables support, #262 (by @adamsitnik) ab7045 test fixes ;) (by @adamsitnik) 455c60 allow the users to specify custom arguments (Mono, MsBuild), #466, #262 (by @adamsitnik) e03384 make sure that all new custom settings are presented in human friendly way, #262 (by @adamsitnik) cc8d07 enforce TreatWarningsAsErrors=False in auto-generated csproj to override glob... (by @adamsitnik) 97ab49 target .NET Core 2.0 to take full advantage of the new API, fixes #539 (by @adamsitnik) 8b2c7e check if reference assemblies are installed when choosing the default .NET fr... (by @adamsitnik) feabd1 bump the .NET Core version, #539 (by @adamsitnik) a21f86 for .NET Core 1.1 we should run only the Backward Compatibility tests. #539 (by @adamsitnik) b7a966 typo fix (by @adamsitnik) 73a30a docs: Customizing Mono, Env Variables & minor updates, fixes #262 (by @adamsitnik) 612b41 exclude Artifacts for disassembler projects, fixes #540 (by @adamsitnik) 360326 typo, #540 (by @adamsitnik) f3e4ae show nice error when Job.Dry is used for Disassembler, fixes #542 (by @adamsitnik) c6bbda allow to specify custom dotnet cli path to compare RyuJit 32 vs 64 for .NET C... (by @adamsitnik) a0c7e5 Add info about Redstone 3,4 in WindowsBrandVersions (by @AndreyAkinshin) d42262 Additional info about WindowsBrandVersions (by @AndreyAkinshin) cd0a1f Improve formatting in WindowsBrandVersions (by @AndreyAkinshin) 1cd844 Fix OsBrandStringTests.WindowsIsPrettified (by @AndreyAkinshin) f00787 Fix markdown headers (by @jawn) 363814 Merge pull request #547 from jawn/patch-1 (by @adamsitnik) 405c4c Update dotnet cli version from 1.0.4 to 2.0.0 for non-Windows system. (#548) (by @Ky7m) 97a9b2 Fix compiler warning connected to problem with the XML tag. (by @Ky7m) 24585d Remove PackageTargetFallback element. (by @Ky7m) 174c19 Merge pull request #549 from Ky7m/csproj-files-cleanup (by @AndreyAkinshin) 84a4e2 Fix exporters to use fully qualified filenames (#552), fixes #529 (by @Teknikaali) a7578a disable Disassembler tests for non-Windows OS, fixes #555 (by @adamsitnik) a147dd Remove leading space character in a MD table row, fixes #556 (by @rolshevsky) 9c194c DisassemblyDiagnoser crashes on overloaded benchmark, fixes #562 (by @adamsitnik) 9076a6 give users nice warning when they run into shadow copy issues, fixes #558 (by @adamsitnik) 1670ca the build fix ;) (by @adamsitnik) d5854d Include UBR in Windows versions (by @AndreyAkinshin) 1fcfee display correct runtime info in exported disassembly result, fixes #559 (by @adamsitnik) de45ad Single point of full config creation (#565) (by @ig-sinicyn) 395a52 make sure filters don't exclude Setup/Cleanup methods, fixes #564 (by @adamsitnik) 4276ac fail when running benchmarks in Debug with DefaultConfig, fixes #561 (by @adamsitnik) 0145f8 Fix build number for Windows 10 Fall Creators Update (by @AndreyAkinshin) 7f7a7c Update cakebuild scripts (#569) (by @Ky7m) cff577 introduce ParamsSource attribute, fixes #350, part of #256 (by @adamsitnik) 3af915 introduce IParam to support complex, not-compile time constants as parameters... (by @adamsitnik) 4a877f build the disassemblers before .Core, but don't add the dependency to them to... (by @adamsitnik) 188850 specify all the embedded resources in explicit way to avoid some crazy MSBuil... (by @adamsitnik) b5fbbf Typo fix (by @AndreyAkinshin) eb90ce Update message in JitOptimizationsValidator (by @AndreyAkinshin) 6c1137 Updated DotSettings (by @AndreyAkinshin) 3d0dfe Set library version: 0.10.10 (by @AndreyAkinshin) Contributors (12) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Andrey Dorokhov (@aidmsu) Anssi Kettunen (@Teknikaali) Bernard Vander Beken (@jawn) Ian Johnson (@ipjohnson) ig-sinicyn (@ig-sinicyn) Igor Fesenko (@Ky7m) Jiri Cincura Łukasz Pyrzyk (@lukasz-pyrzyk) Pent Ploompuu (@pentp) Rostislav Olshevsky (@rolshevsky) Thank you very much! Additional details Date: November 03, 2017 Milestone: v0.10.10 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.10 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.10 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.10 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.10"
  },
  "changelog/v0.10.11.html": {
    "href": "changelog/v0.10.11.html",
    "title": "BenchmarkDotNet v0.10.11 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.11 Highlights ByRef and Stack-only support (#492, sample) .NET Core 2.1 support (#587) Improved LINQPad support Smart logic for precision in ScaledColumn (#509, #590) Better macOS version detection (15d72388) Minor fixes and improvements Milestone details In the v0.10.11 scope, 6 issues were resolved and 8 pull requests were merged. This release includes 18 commits by 8 contributors. Resolved issues (6) #509 Better formatting for the Scaled column #579 Improve error message about non-optimized dependencies (assignee: @adamsitnik) #580 How to get benchmarks running from LINQPad? (assignee: @adamsitnik) #587 Support netcoreapp2.1 (assignee: @eerhardt) #588 Broken appveyor build #593 BenchmarkDotNet is not working with LinqPad (assignee: @adamsitnik) Merged pull requests (8) #492 ByRef and Stack-only support (by @adamsitnik) #575 xUnit runner upgrade and small tests refactoring (by @Ky7m) #584 Fixed typo. (by @cincuranet) #589 Add support for netcoreapp2.1 (by @eerhardt) #590 Add precision to Scaled Column (by @Chrisgozd) #591 Fix CI build (by @Ky7m) #592 Removed a xunit workaround because an issue has been fixed (by @AlekseiKudelia) #597 Fix typo in WithCustomBuildConfiguration API (by @benjamin-hodgson) Commits (18) 2a2e6c ByRef and Stack-only support (#492) (by @adamsitnik) 676c77 xUnit runner upgrade and small tests refactoring (#575) (by @Ky7m) 7a89cd Fixed typo. (by @cincuranet) dd28b2 add better error text for non-optimized dlls + add it to FAQ, fixes #579 (by @adamsitnik) 67e659 detect LINQPad problems and tell the user how to change them, fixes #580 (by @adamsitnik) 543bd6 don't warn about non-optimized LINQPad dependency (it's OK), #580 (by @adamsitnik) 8a94f2 Add support for netcoreapp2.1 (by @eerhardt) fb39db Merge pull request #589 from eerhardt/SupportNetCoreApp21 (by @adamsitnik) ef11f0 Add CoverageFilterXml in DotSettings (by @AndreyAkinshin) 962b6a Update DotSetttings (by @AndreyAkinshin) 717b62 BenchmarkDotNet.Horology cleanup (by @AndreyAkinshin) d1720b Upgrade version to 2.0.3 and explicitly specify fx version for .netcoreapp2.0 (by @Ky7m) 94d47a Removed a xunit workaround because an issue has been fixed (by Aleksei Kudelia) 15d723 More details in GetOsVersion on macOS (by @AndreyAkinshin) 696f89 Add precision to Scaled Column (#590) (by @Chrisgozd) e54924 Fix typo in WithCustomBuildConfiguration API (by Benjamin Hodgson) 8de978 Merge pull request #597 from benjamin-hodgson/patch-1 (by @adamsitnik) af1510 Set library version: 0.10.11 (by @AndreyAkinshin) Contributors (8) Adam Sitnik (@adamsitnik) Aleksei Kudelia Andrey Akinshin (@AndreyAkinshin) Benjamin Hodgson Christopher Gozdziewski (@Chrisgozd) Eric Erhardt (@eerhardt) Igor Fesenko (@Ky7m) Jiri Cincura ↹ (@cincuranet) Thank you very much! Additional details Date: December 01, 2017 Milestone: v0.10.11 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.11 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.11 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.11 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.11"
  },
  "changelog/v0.10.12.html": {
    "href": "changelog/v0.10.12.html",
    "title": "BenchmarkDotNet v0.10.12 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.12 Overview post: BenchmarkDotNet v0.10.12 Highlights Improved DisassemblyDiagnoser: BenchmarkDotNet contains an embedded disassembler so that it can print assembly code for all benchmarks; it's not easy, but the disassembler evolves in every release. Improved MemoryDiagnoser: it has a better precision level, and it takes less time to evaluate memory allocations in a benchmark. New TailCallDiagnoser: now you get notifications when JIT applies the tail call optimizations to your methods. Better environment info: when your share performance results, it's very important to share information about your environment. The library generates the environment summary for you by default. Now it contains information about the amount of physical CPU, physical cores, and logic cores. If you run a benchmark on a virtual machine, you will get the name of the hypervisor (e.g., Hyper-V, VMware, or VirtualBox). Better summary table: one of the greatest features of BenchmarkDotNet is the summary table. It shows all important information about results in a compact and understandable form. Now it has better customization options: you can display relative performance of different environments (e.g., compare .NET Framework and .NET Core) and group benchmarks by categories. Milestone details In the v0.10.12 scope, 15 issues were resolved and 10 pull requests were merged. This release includes 42 commits by 9 contributors. Resolved issues (15) #273 Create a tail call diagnoser #442 Is it possible to configure benchmark to assign rank for runtime? (assignee: @AndreyAkinshin) #543 Run Disassembly Diagnoser without extra run (assignee: @adamsitnik) #546 Synthesizing labels for jump targets (assignee: @adamsitnik) #574 Display VM hypervisor in summary section (assignee: @lukasz-pyrzyk) #582 Print amount of logical and physical core (assignee: @morgan-kn) #599 Proper HTML escaping of BenchmarkAttribute Description #606 Improve Memory Diagnoser (assignee: @adamsitnik) #608 Properly escaping generated markdown (assignee: @AndreyAkinshin) #612 Disassembler DisassembleMethod fails with \"Object reference not set to an instance of an object.\", (assignee: @adamsitnik) #617 Allow baseline per category (assignee: @AndreyAkinshin) #618 Enable ApprovalTests in .NET Core 2.0 tests (assignee: @AndreyAkinshin) #621 Try to search for missing references if build fails (assignee: @adamsitnik) #622 Support of new GC settings (assignee: @adamsitnik) #623 RPlotExporter uses wrong path to csv measurements (assignee: @AndreyAkinshin) Merged pull requests (10) #573 Сreate a tail call diagnoser (by @GeorgePlotnikov) #576 Display VM name in summary section, fixes #574 (by @lukasz-pyrzyk) #595 Migrate all project to new project system. (by @mfilippov) #598 Added info about the new TailCallDiagnoser (by @GeorgePlotnikov) #603 Fix HTML Encoding for Html Exporter (by @Chrisgozd) #605 Grammar (by @onionhammer) #607 Print amount of logical and physical core #582 (by @morgan-kn) #615 Quick fix Disassembler.Program.GetMethod when more than one method found just return null (by @nietras) #619 Logical group support, fixes #617 (by @AndreyAkinshin) #620 New README.md (by @AndreyAkinshin) Commits (42) 6f587d Migrate all project to new project system. (by @mfilippov) 47ba57 added info about the new TailCallDiagnoser (by @GeorgePlotnikov) c1a4b2 Сreate a tail call diagnoser (#573) (by @GeorgePlotnikov) ebe3e2 Merge pull request #598 from GeorgePlotnikov/patch-1 (by @adamsitnik) 6249f0 some polishing of the JIT diagnosers (by @adamsitnik) 119231 Fix HTML Encoding for Html Exporter (#603), fixes #599 (by @Chrisgozd) fe3f30 Disassembly Prettifier, fixes #546 (by @adamsitnik) 3eb63f Merge pull request #595 from mfilippov/new-fs-vb-proj (by @adamsitnik) 16d03f make our F# samples work for .NET Core 2.0 (by @adamsitnik) d06de7 bring back our old Visual Basic and F# integration tests (by @adamsitnik) 63249b \"Kaby Lake R\" and \"Coffee Lake\" support in ProcessorBrandStringHelper (by @AndreyAkinshin) a8a09e disassembly prettifier: highlighting references to labels, jumping to next on... (by @adamsitnik) e6d747 Grammar (by @onionhammer) fef4aa Merge pull request #605 from onionhammer/patch-1 (by @adamsitnik) ffacd7 don't require extra run for DisassemblyDiagnoser, fixes #543, #542 (by @adamsitnik) bcac26 revert last commit change (run global setup regardless of Jitting) (by @adamsitnik) 3e87d8 don't perform an extra run to get GC stats for .NET Core, part of #550 (by @adamsitnik) f87dbc obtain GC stats in separate iteration run, no overhead, support for iteration... (by @adamsitnik) e5fe0f update to C# 7.1 so we can use all the latest features (by @adamsitnik) bc50b2 build benchmarks in Parallel, part of #550 (by @adamsitnik) e59590 Display VM name in summary section, fixes #574 (#576) (by @lukasz-pyrzyk) 8908f8 fix GetMethod (by @nietras) 4ca82d Merge pull request #615 from nietras/disassembler-more-than-one-method-fix (by @adamsitnik) 387ae5 be more defensive when trying to read source code with disassembler, part of ... (by @adamsitnik) 703815 docs: how to contribute to disassembler (by @adamsitnik) 242671 Enable ApprovalTests in .NET Core 2.0 tests, fixes #618 (by @AndreyAkinshin) c4d21b Print amount of logical and physical core #582 (#607) (by @morgan-kn) e33e84 Add HtmlReady dialect for MarkdownExporter, fixes #608 (by @AndreyAkinshin) cf167b Enable html escaping for GitHub markdown dialect, fixes #608 (by @AndreyAkinshin) 8bb28b Logical group support, fixes #617 (by @AndreyAkinshin) ae87c6 Merge pull request #619 from dotnet/logical-groups (by @adamsitnik) 14e90b parallel build post fix: don't write the compilation errors to NullLogger, re... (by @adamsitnik) db4ae8 Try to search for missing references if build fails, fixes #621 (by @adamsitnik) 0eba0f Support of new GC settings, fixes #622 (by @adamsitnik) e31b2d Revert Samples/Program.cs (by @AndreyAkinshin) 7f126b Add logs in RPlotExporter (by @AndreyAkinshin) f8a447 Fix path to csv in RPlotExporter, fixes #623 (by @AndreyAkinshin) 273f50 New plots in RPlotExporter (by @AndreyAkinshin) f293f0 New README.md (#620) (by @AndreyAkinshin) 5e3366 Update copyright year in docs (by @AndreyAkinshin) ab7458 Update index in docs (by @AndreyAkinshin) 4616d4 Set library version: 0.10.12 (by @AndreyAkinshin) Contributors (9) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Christopher Gozdziewski (@Chrisgozd) Erik O'Leary (@onionhammer) Georgii Plotnikov (@GeorgePlotnikov) Irina Ananeva (@morgan-kn) Łukasz Pyrzyk (@lukasz-pyrzyk) Mikhail Filippov (@mfilippov) nietras (@nietras) Thank you very much! Additional details Date: January 15, 2018 Milestone: v0.10.12 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.12 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.12 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.12 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.12"
  },
  "changelog/v0.10.13.html": {
    "href": "changelog/v0.10.13.html",
    "title": "BenchmarkDotNet v0.10.13 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.13 Overview post: BenchmarkDotNet v0.10.13 Milestone details In the v0.10.13 scope, 15 issues were resolved and 9 pull requests were merged. This release includes 50 commits by 9 contributors. Resolved issues (15) #541 Mono Support for DisassemblyDiagnoser (assignee: @morgan-kn) #614 Build fails with \"'Microsoft.NETCore.App', version '1.1.2' was not found\" probably due to 1.1.4 runtime not being available #626 Support Visual Basic project files (.vbroj) targeting .NET Core (assignee: @adamsitnik) #630 Bug: Statistics.DivMean - NullReferenceException (assignee: @AndreyAkinshin) #631 Bug: Generic benchmark class fails for DisassemblyDiagnoser with \"Sequence contains no matching element\" (assignee: @adamsitnik) #632 ParamsSource no longer sorted in results (assignee: @AndreyAkinshin) #634 Extend SummaryOrderPolicy (assignee: @adamsitnik) #636 Unable to run Runner.exe --method MethodName (assignee: @adamsitnik) #640 Disassembler fails with generic instance (assignee: @adamsitnik) #643 BenchmarkDotNet should respect LangVersion project setting (assignee: @adamsitnik) #644 BenchmarkDotNet.Mathematics.RankHelper again. (assignee: @AndreyAkinshin) #648 BenchmarkDotNet requires dotnet cli toolchain to be installed (assignee: @adamsitnik) #651 Support ANY CoreFX and CoreCLR builds (assignee: @adamsitnik) #652 BenchmarkSwitcher should support generic types with parameterless public ctors (assignee: @adamsitnik) #653 Proper way to run BenchmarkDotNet on macOS/Linux (assignee: @adamsitnik) Merged pull requests (9) #624 Upgrade build tools (by @Ky7m) #625 Fix xunit warnings connected to usage of Assert.Equal() to check for Null (by @Ky7m) #633 HostEnvironmentInfo: remove LogicalCoreCount (by @morgan-kn) #637 Mono Support for DisassemblyDiagnoser #541 (by @morgan-kn) #639 Portability.Cpu tests improvements (by @morgan-kn) #642 sync DataContracts to CopiedDataContracts (by @morgan-kn) #645 Fixing --help display for options (by @ENikS) #646 Allow sorting by the Method name in DefaultOrderProvider and OrderProviderAttribute (by @ENikS) #666 Plots...Examples...Added A config example in F# (by @ScottHutchinson) Commits (50) a26e82 Upgrade build tools: (by @Ky7m) 1643cb Merge pull request #624 from Ky7m/upgrade-build-tools (by @adamsitnik) abae51 Fix xunit warnings connected to usage of Assert.Equal() to check for null val... (by @Ky7m) fb68bc support Visual Basic .NET Core projects, fixes #626 (by @adamsitnik) 067a33 Remove redundant properties in common.props (by @AndreyAkinshin) 80deb9 BuildNumber fix in common.props (by @AndreyAkinshin) 87b458 Add CONTRIBUTING.md (by @AndreyAkinshin) 8bcf42 Add CODE_OF_CONDUCT.md (by @AndreyAkinshin) d3867d HostEnvironmentInfo: remove LogicalCoreCount (#633) (by @morgan-kn) 06e66a Specify PLACE_SIMPLE_EMBEDDED_STATEMENT_ON_SAME_LINE in DotSettings (by @AndreyAkinshin) d8ac43 Mono Support for DisassemblyDiagnoser #541 (by @morgan-kn) 4356da Merge pull request #637 from morgan-kn/MonoSupportForDisassemblyDiagnoser (by @AndreyAkinshin) 7572f4 Fix paths to images in docs (by @AndreyAkinshin) f076df Portability.Cpu tests improvements (by morgan_kn) da6499 Merge pull request #639 from morgan-kn/TestsImprovment (by @AndreyAkinshin) 5dd1a5 Disassembly Diagnoser: support for generic types, fixes #640 fixes #631 (by @adamsitnik) 3c0e71 diassembly diangoser: different methods can have same metadata id, add type i... (by @adamsitnik) 294801 test fix ;) (by @adamsitnik) 9e66bb sync DataContracts to CopiedDataContracts (by @morgan-kn) 690f34 Merge pull request #642 from morgan-kn/sync (by @adamsitnik) e1e3e2 don't use type.Fullname for file names, it's too long for generics (by @adamsitnik) 43d7c2 we restore before build, so build does need to restore too (it's new default ... (by @adamsitnik) 9d4c33 trying harder to trick the JIT (#640, #631) (by @adamsitnik) f8f70f Natural ordering for logical groups, fixes #632 (by @AndreyAkinshin) a2ec34 copy LanguageVersion to the output .csproj, fixes #643 (by @adamsitnik) 31e6dd Fixing --help display for options (#645), fixes #636 (by @ENikS) 45ace9 Allow sorting by the Method name in DefaultOrderProvider and OrderProviderAtt... (by @ENikS) 8811f2 Fix typo in docs/guide/Contributing/Disassembler.md (by @AndreyAkinshin) 7da7b9 allow the users to customize Artifacts Path, #377 (by @adamsitnik) 7554bf validate CustomDotNetCliPath, fixes #648 (by @adamsitnik) 683964 Support ANY CoreFX and CoreCLR builds, fixes #651 (by @adamsitnik) 695386 support also only custom CoreFX scenario (default runtime), part of #651 (by @adamsitnik) eb4dcf allow the users to copy some files after the publish, part of #651 (by @adamsitnik) b076a3 Add Newtonsoft.Json in the README (by @AndreyAkinshin) b4eef5 better generics support, fixes #652 (by @adamsitnik) 77fd46 Handle null values in Statistics.DivMean and Statistics.DivVariance, fixes #630 (by @AndreyAkinshin) e547f8 Fix NRE in RankColumn, fixes #644 (by @AndreyAkinshin) 28aa94 allow the users to choose .NET 4.7.1 (by @adamsitnik) 503570 Fixed image link (by @svick) 93cc85 Merge pull request #655 from svick/patch-1 (by @adamsitnik) d33cde Fixed code block formatting (by @svick) cb7c09 Merge pull request #657 from svick/patch-1 (by @adamsitnik) 650b4a host Mono process should be able to build .NET Core child process, fixes #653 (by @adamsitnik) d1dcab List formatting for FAQ (by @svick) fe52e3 Merge pull request #663 from svick/faq-formatting (by @adamsitnik) 7792cb Example in F#: with corrected code formatting (by @ScottHutchinson) e6b225 Merge pull request #666 from ScottHutchinson/patch-2 (by @AndreyAkinshin) f90207 Allow restore and build command override (#670) (by @BonnieSoftware) 4443cd Update example in README (by @AndreyAkinshin) de0b68 Set library version: 0.10.13 (by @AndreyAkinshin) Contributors (9) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) BonnieSoftware (@BonnieSoftware) Eugene Sadovoi (@ENikS) Igor Fesenko (@Ky7m) Irina Ananeva (@morgan-kn) morgan_kn Petr Onderka (@svick) Scott Hutchinson (@ScottHutchinson) Thank you very much! Additional details Date: March 02, 2018 Milestone: v0.10.13 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.13 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.13 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.13 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.13"
  },
  "changelog/v0.10.14.html": {
    "href": "changelog/v0.10.14.html",
    "title": "BenchmarkDotNet v0.10.14 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.14 Per-method parameterization (Read more) Console histograms and multimodal disribution detection Many improvements for Mono disassembly support on Windows (Read more) Many bugfixes Milestone details In the v0.10.14 scope, 8 issues were resolved and 11 pull requests were merged. This release includes 47 commits by 8 contributors. Resolved issues (8) #256 Per-method parameterization (assignee: @AndreyAkinshin) #429 Detect multimodal distributions (assignee: @AndreyAkinshin) #496 Integration with TravisCI (assignee: @jongalloway) #684 Horology.ClockTests.ChronometerTest fails on Travis CI (macOS) (assignee: @AndreyAkinshin) #689 DisassemblyDiagnoser for Mono does not work on Windows and Linux (assignee: @morgan-kn) #691 Cannot run F# benchmarks when benchmark returns F# generic (assignee: @adamsitnik) #697 Copy custom setting from app.config in multitarget projects (assignee: @adamsitnik) #706 Support private builds of .NET Runtime (assignee: @adamsitnik) Merged pull requests (11) #577 Arguments (by @adamsitnik) #647 Histograms and multimodal distribution detection, fixes #429 (by @AndreyAkinshin) #674 Cleanup suggested by VS2017 Code Analysis (plus one typo) (by @shoelzer) #675 Fix IDE0034: 'default' expression can be simplified (by @shoelzer) #676 Correct NodeTime text which links to NodaTime api (by @MishaHusiuk) #681 Fix typo (Perdictor -> Predictor) (by @dmitry-ra) #682 Fix typo (Perdictor -> Predictor) (by @dmitry-ra) #683 Integration with TravisCI (by @Ky7m) #694 Fix 689 (by @morgan-kn) #695 Rename Program to UniqueProgramName to avoid conflicts, fixes #691 (by @adamsitnik) #696 Build system: Update dotnet SDK and dotnet runtime. Enable FastTests netcoreapp1.1 on non-Windows. (by @Ky7m) Commits (47) 41aeea Histograms and multimodal distribution detection, fixes #429 (by @AndreyAkinshin) 960e58 Handle measurements with zero operations (by @AndreyAkinshin) 19cddd Fix typo in BaselineScaledColumn.cs (by @dfederm) a99594 Merge pull request #673 from dfederm/dfederm/fix-typo (by @AndreyAkinshin) 5b3425 Cleanup suggested by VS2017 Code Analysis (plus one typo) (#674) (by @shoelzer) 16b611 Fix IDE0034: 'default' expression can be simplified (by @shoelzer) 048b32 Merge pull request #675 from shoelzer/master (by @AndreyAkinshin) 9d5f71 Correct NodeTime text which links to NodaTime lib (by @MishaHusiuk) c450c7 Merge pull request #676 from MishaHusiuk/patch-1 (by @adamsitnik) 9fad52 Fix typo (Perdictor -> Predictor) (by @dmitry-ra) 3d906f Fix typo (Perdictor -> Predictor) (by @dmitry-ra) d1a48e Merge pull request #681 from dmitry-ra/master (by @AndreyAkinshin) 4ccd35 Merge pull request #682 from dmitry-ra/patch-1 (by @AndreyAkinshin) f743a1 CakeBuild 0.24.0 -> 0.26.1 (by @Ky7m) c5eb40 Remove postProjects from solution file. (by @Ky7m) e60387 Pass correct configuration to test settings (by @Ky7m) 224ab8 Disable public sign option for F# project (by @Ky7m) ee98f3 Limit Max CPU count for msbuild workers (by @Ky7m) 17031d Fix readme file (by @Ky7m) 6fbae8 One more update to readme file (by @Ky7m) cb90f2 disable Travis failing test #684 to unblock #683 (by @adamsitnik) 782ca7 Merge pull request #683 from Ky7m/Integration-with-TravisCI (by @adamsitnik) eebf92 Merge branch 'master' into multimodal (by @adamsitnik) 10511b Merge pull request #647 from dotnet/multimodal (by @adamsitnik) 57bc17 Fix bug in ClockTests.ChronometerTest, fixes #684 (by @AndreyAkinshin) 7c4b14 Arguments (#577), fixes #256 (by @adamsitnik) 40771c Update dotnet SDK (2.1.4 -> 2.1.101) and dotnet runtime (1.1.6 -> 1.1.7). (by @Ky7m) 88a9db Merge pull request #696 from Ky7m/build-runtime-update (by @adamsitnik) 4ac6ad we need different name than typical \"Program\" to avoid problems with referenc... (by @adamsitnik) 1178d6 Update build badges (by @AndreyAkinshin) 24ed1f ProcessHelper: handle null Data values in OutputDataReceived, fix #689 (by @morgan-kn) 7a3d2b MonoDisassembler improvements (by @morgan-kn) f1a0f5 Merge pull request #694 from morgan-kn/Fix689 (by @AndreyAkinshin) 428905 .NET Core apps are .dlls (not .exes), fixes #697 (by @adamsitnik) befbc8 Add FAQ notes about #692 (by @AndreyAkinshin) b4504b Support private builds of .NET Runtime, fixes #706 (by @adamsitnik) c93e1e Introduce separate logic for Windows10 brand strings (by @AndreyAkinshin) 685766 Shortify Windows 10 brand strings in the summary (by @AndreyAkinshin) 9bdd0c Shortify cpu info in summary (by @AndreyAkinshin) 2288ad Prettify macOS brand string (by @AndreyAkinshin) 8a0b48 Handle tailed nop instructions in mono disasm output (by @AndreyAkinshin) d80834 Advanced DryJob attributes (by @AndreyAkinshin) 9a37ad Handle invalid mono disasm outputs (by @AndreyAkinshin) 21d6d7 Add IntroDisasm (by @AndreyAkinshin) 5e37b5 Add \"Disassembly Diagnoser for Mono on Windows\" in docs (by @AndreyAkinshin) c2c4e8 set COMPLUS_Version env var for private Clr builds even if no env vars were d... (by @adamsitnik) 88b088 Set library version: 0.10.14 (by @AndreyAkinshin) Contributors (8) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) David Federman (@dfederm) Dmitry Razumikhin (@dmitry-ra) Igor Fesenko (@Ky7m) Irina Ananeva (@morgan-kn) MishaHusiuk (@MishaHusiuk) Steve Hoelzer (@shoelzer) Thank you very much! Additional details Date: April 09, 2018 Milestone: v0.10.14 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.14 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.14 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.14 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.14"
  },
  "changelog/v0.10.2.html": {
    "href": "changelog/v0.10.2.html",
    "title": "BenchmarkDotNet v0.10.2 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.2 Closed #307: culture invariant statistics output Closed #321: persist optimized, auto-generated dll compiled from url/plain code Closed #322: always restore the console foreground color Closed #337: Better detection of Rscript.exe in RPlotExporter Closed #345: fix bug in WelchTTestPValueColumn for DryJob VS 2017 compatibility fix fix bold markup for Atlassian exporter Improved precision of nanobenchmarks Minor infrastructure changes and misc fixes Milestone details In the v0.10.2 scope, 10 issues were resolved and 3 pull requests were merged. This release includes 30 commits by 8 contributors. Resolved issues (10) #295 Fix CLS-compliant warnings in Diagnostics (assignee: @adamsitnik) #307 Output: interpolated strings & culture (assignee: @alinasmirnova) #319 [Request] some API to public? (assignee: @adamsitnik) #321 BenchmarkRunner.RunUrl throws BenchmarkSystem.IO.FileNotFoundException (assignee: @adamsitnik) #327 Unable to use ClassicToolchain in explicit way (assignee: @adamsitnik) #332 default color of terminal is changed after the run is completed (assignee: @adamsitnik) #335 Support benchmarking startup performance (assignee: @AndreyAkinshin) #337 Problematic mechanism/docs for locating Rscript.exe #340 [FeatureRequest] Enable Characteristic-based properties for non-job types. (assignee: @ig-sinicyn) #345 Fail to run IntroAdvancedStats in dry mode (assignee: @AndreyAkinshin) Merged pull requests (3) #338 Fix typo (by @roji) #339 Better detection of Rscript in RPlotExporter (by @roji) #341 Base types for characteristic objects: (by @ig-sinicyn) Commits (30) e7c398 Fixes parentheses error (by Josef Ottosson) 2655b3 Merge pull request #318 from joseftw/patch-1 (by @adamsitnik) 4115a2 make GcStats and Net46Toolchain internal members public, fixes #319 (by @adamsitnik) 52f953 ignore the CLS compilant errors for Diagnosers package, fixes #295 (by @adamsitnik) d96b68 Improved Consumer (by @AndreyAkinshin) 943c49 CLSCompliant fixes in Consumer (by @AndreyAkinshin) f4bdae specify the .NET Core sdk version in explicit way to get the solution working... (by @adamsitnik) df8c55 always restore the console foreground color, fixes #332 (by @adamsitnik) 24dea4 fix bold markup for Atlassian exporter (by @lahma) 4d3c75 persist optimized, auto-generated dll compiled from url/plain code, fixes #321 (by @adamsitnik) 2e92a2 allow to set Classic/Roslyn tool chain in explicit way, fixes #327 (by @adamsitnik) aabece Merge pull request #329 from lahma/features/atlassian-bold-format (by @adamsitnik) 91152c ExportToFiles now accepts console logger (by @roji) 299375 Base types for characteristic objects: (by @ig-sinicyn) afc65d Better detection of Rscript.exe in RPlotExporter (by @roji) 15869b Merge pull request #339 from roji/rscript-detect (by @AndreyAkinshin) 9f6a82 Merge pull request #341 from ig-sinicyn/feature-characteristic-object (by @AndreyAkinshin) 432adf Fix typo (by @roji) cfa015 Merge pull request #338 from roji/dependencies-typo (by @AndreyAkinshin) 4d953f Temporary rollback of the link to appveyor (by @AndreyAkinshin) 1f5a6e Update year in docs footer (by @AndreyAkinshin) 183ab6 Fix warning in RoslynToolchain (by @AndreyAkinshin) 6fd9f3 Used ToStr to make statistics builder culture invariant (fixed #307) (by @alinasmirnova) 3a3100 Merge pull request #346 from alinasmirnova/master (by @AndreyAkinshin) 7ee2f1 Fix in WelchTTestPValueColumn for DryJob, fixes #345 (by @AndreyAkinshin) 795f4a Disable jitting for RunStrategy=ColdStart, fixes #335 (by @AndreyAkinshin) 5b5a8c Fixed typo (by @lukasz-pyrzyk) 54519c Merge pull request #347 from lukasz-pyrzyk/master (by @adamsitnik) fbac75 Introduced Dummy actions (by @AndreyAkinshin) 484f53 Set library version: 0.10.2 (by @AndreyAkinshin) Contributors (8) Adam Sitnik (@adamsitnik) Alina Smirnova (@alinasmirnova) Andrey Akinshin (@AndreyAkinshin) ig-sinicyn (@ig-sinicyn) Josef Ottosson Łukasz Pyrzyk (@lukasz-pyrzyk) Marko Lahma (@lahma) Shay Rojansky (@roji) Thank you very much! Additional details Date: January 21, 2017 Milestone: v0.10.2 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.2 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.2 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.2 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.2"
  },
  "changelog/v0.10.3.html": {
    "href": "changelog/v0.10.3.html",
    "title": "BenchmarkDotNet v0.10.3 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.3 New .csprojs support for .NET Core. Also for F# (#366)! New plots and RPlotExporter (density plots for each job; cumulative mean plots) Fixed exporter order (now RPlotExporer uses the actual measurements instead of previous version) Xplat improvments in RuntimeInformation Introduced RunStrategy.Monitoring Possibility to set custom path for Mono (#306) Possibility to set any .NET Core version >= 1.1 (#336) MemoryDiagnoser is now disabled by default (Breaking changes!!) (#369) Milestone details In the v0.10.3 scope, 10 issues were resolved and 2 pull requests were merged. This release includes 79 commits by 3 contributors. Resolved issues (10) #300 Switch back from project.json and xproj to csproj, support dotnet cli preview 3 (assignee: @adamsitnik) #306 Custom path for mono (assignee: @adamsitnik) #320 Results table should be a GitHub Flavored Markdown table (assignee: @alinasmirnova) #322 First benchmark always fails when running on .NET Core with -c release (assignee: @adamsitnik) #336 allow the users to choose the target .NET Core version (1.2, 2.0 etc) (assignee: @adamsitnik) #366 Support the new .fsprojs targetting .NET Core (F# + .NET Core + MSBuild) (assignee: @adamsitnik) #369 Consider to disable MemoryDiagnoser by default (assignee: @adamsitnik) #372 Troubles with ClrJob from CoreCLR project (assignee: @adamsitnik) #374 BenchmarkDotNet doesn't understand netcoreapp2.0 (assignee: @adamsitnik) #375 Troubles with dotnet pack (assignee: @adamsitnik) Merged pull requests (2) #355 Fixed typo in IntroBasic.cs (by @mmayr-at) #357 Farewell project json (by @adamsitnik) Commits (79) 8099a5 Print process.StartInfo in Executor (by @AndreyAkinshin) abd931 Update BenchmarkDotNet.sln.DotSettings (by @AndreyAkinshin) 5c8c75 toolchains should not require parameterless ctors, the real fix for #327 (by @adamsitnik) b22cf2 allow the users to choose the target .NET Core version, fixes #336 (by @adamsitnik) f99c82 .net core toolchain: root folder detection bug fix (by @adamsitnik) c7aba1 experimental .NET Core support for the new VS 2017 csproj files, #300 (by @adamsitnik) bca146 Additional density plots in RPlotExporter (by @AndreyAkinshin) 4bb147 Additional cummean plots in RPlotExporter (by @AndreyAkinshin) 8bf40c Implement top sort in CompositeExporter (by @AndreyAkinshin) ad771d Always print the AllocationColumn in the Summary table (if MemoryDiagnoser is... (by @AndreyAkinshin) 8a1f0e Fix order of exporters in ExporterDependencyTests (by @AndreyAkinshin) a7366e xproj to csproj auto migration (by @adamsitnik) cec3e2 xproj to csproj: manual changes (conditional recursive dependencies not suppo... (by @adamsitnik) 74006d xproj to csproj: I did not ask for the .NET Standard dependency (by @adamsitnik) bf7093 xproj to csproj: manual changes (conditional dependencies not supported anymo... (by @adamsitnik) 4e060f xproj to csproj: manual changes (simple case not supported) (by @adamsitnik) 59602c remove F# .NET Core samples (not working now) (by @adamsitnik) 2488ae cleanup (by @adamsitnik) d7925b get our toolchain up and running, thanks to @cesarbs (by @adamsitnik) e719e7 Update IntroBasic.cs (by @mmayr-at) 1ef000 Merge pull request #355 from mmayr-at/patch-1 (by @AndreyAkinshin) 5cf1dc making diagnosers, ctrl+c, custom priority and affinity work for the new csprojs (by @adamsitnik) d0f334 getting net46 toolchain work again for new .csprojs when called from .NET Cor... (by @adamsitnik) d1bf9b removing old project.json workarounds (by @adamsitnik) e0b134 taking advantage of the csproj (by @adamsitnik) 001b3f appveyor stuff (by @adamsitnik) 63d674 don't introduce limit for .sln file search depth (by @adamsitnik) 81adbb make VS stop complaining about root namespace for BenchmarkDotNet.Core project (by @adamsitnik) 2eee5f let's round it to reduce the side effects of Allocation quantum (by @adamsitnik) f38e93 a project that targets AnyCPU cany be referenced by any other executable (32 ... (by @adamsitnik) 8ed5a4 post code review changes (by @adamsitnik) 50c938 add possibility to use RetainVMGarbageCollection config switch (by @adamsitnik) ca1bc8 final Cleanup and some renaming ;) (by @adamsitnik) a26d61 Update BenchmarkDotNet.sln.DotSettings (by @AndreyAkinshin) 008819 getting all the test runnable again (by @adamsitnik) a66913 trying to get the versioning done right (by @adamsitnik) c6f245 the updated docs (by @adamsitnik) f1a1fd update to the latest xUnit 2.2 + minor cleanup (by @adamsitnik) 262c87 appveyor config + minor bug fixes (by @adamsitnik) 1a7bd4 Support the new .fsprojs targetting .NET Core (F# + .NET Core + MSBuild), fix... (by @adamsitnik) e8f6ac support projects without .sln file (dotnet cli only) (by @adamsitnik) 1b71c5 update our tests to net452 because XUnit VS runner 2.2 does no longer support... (by @adamsitnik) 6121ad disable shadow copy for our integration tests (by @adamsitnik) 54375c warn the users when code optimization was not enabled (debug build can be opt... (by @adamsitnik) 03ed32 stop using --binaries option which started producing new folder for every re... (by @adamsitnik) 27f280 dotnet cli like to not release used files for a while.. (by @adamsitnik) 7886ad Merge pull request #357 from dotnet/farewellProjectJson (by @AndreyAkinshin) 751f64 Xplat RuntimeInformation.GetProcessorName() (by @AndreyAkinshin) b327b7 tell why dotnet command failed + how much time it took to execute (by @adamsitnik) b740bb WindowsVersion on CoreCLR (by @AndreyAkinshin) 5b879b Lazty HostEnvironmentInfo.OsVersion (by @AndreyAkinshin) 76d081 Lazy HostEnvironmentInfo.OsVersion, fix in ToFormattedString() (by @AndreyAkinshin) 5dafb9 do not restore or build the dependent projects, just the auto-generated one (by @adamsitnik) 5c1914 better troubleshooting: when dll is not found but somehow build has succeeded... (by @adamsitnik) 322998 using csproj to tell msbuild where to put output so appveyor custom settings ... (by @adamsitnik) e2a8fa post code review changes (by @adamsitnik) 6fe93d MinIterationTimeAnalyser (by @AndreyAkinshin) 3ac892 RunStrategy.Monitoring (by @AndreyAkinshin) f412b9 Docs: add FAQ section about supported version of Visual Studio (by @AndreyAkinshin) 67a007 fixing ProjectJsonToolchains after recent CsProjToolchain optimizations (by @adamsitnik) 2b5c6e Improved RuntimeInformation.GetProcessorName() (by @AndreyAkinshin) a44638 Improved RuntimeInformation.GetOsVersion() (by @AndreyAkinshin) f58e06 Improved RuntimeInformation.GetRuntimeVersion() for Mono (by @AndreyAkinshin) fdca26 Minor RuntimeInformation fixes (by @AndreyAkinshin) 2a2168 Fix bug in ExternalToolsHelper (by @AndreyAkinshin) 9dfd95 Custom path for mono, fixes #306 (by @adamsitnik) 448b07 disable MemoryDiagnoser by default, BREAKING CHANGE, fixes #369 (by @adamsitnik) 125b71 docs for Custom Mono Paths, #306 (by @adamsitnik) a3d6e0 docs/FAQ: Add section about new .NET Core Console App in VS2017 (by @AndreyAkinshin) b04195 give users the AnyCpu hint when they struggle with BadImageFormatException, f... (by @adamsitnik) 7de671 generate the projects in the bin folder, not solution's root (by @adamsitnik) 1d52ae docs/FAQ: add another question (by @AndreyAkinshin) 06aaa0 copy NetCoreAppImplicitPackageVersion and RuntimeFrameworkVersion settings to... (by @adamsitnik) f1fe16 shame on me for not building the code for all TFMs before pushing (by @adamsitnik) fe33dd GitHub Markdown: every table row should start with \"|\" , fixes #320 (by @adamsitnik) 7d0d73 remove old results, otherwise, the file will be overwritten and remaining old... (by @adamsitnik) 80348b Change Hint color to DarkCyan #376 (by @AndreyAkinshin) 0b35ec Increase MinIterationTime (Accuracy improvement) (by @AndreyAkinshin) cdee09 Set library version: 0.10.3 (by @AndreyAkinshin) Contributors (3) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Michael Mayr (@mmayr-at) Thank you very much! Additional details Date: March 01, 2017 Milestone: v0.10.3 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.3 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.3 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.3 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.3"
  },
  "changelog/v0.10.4.html": {
    "href": "changelog/v0.10.4.html",
    "title": "BenchmarkDotNet v0.10.4 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.4 New logo Update to Roslyn 2.0, drop .NET 4.5 support (#303) Initial support of HardwareCounters (Windows only) Initial experimental support of in-process benchmarks Optional configs for BenchmarkSwitcher (#391, #392) Host API interface (#356) Improved measurements for async benchmarks (#415) Improved precision level (MinIterationTimes is 500ms instead of 200ms; introduced AccuracyMode.MaxAbsoluteError and AccuracyMode.MaxRelativeError instead of AccuracyMode.MaxStdErrRelative; logic which select amount of iterations uses confidence intervals instead of standard errors; the Error column (half of CI99.9%) is shown by default instead of StdErr) Introduced ISummaryStyle, raw data in CSV reports (#118, #146, #396) Handle cases when report files are existed and locked (#414, #416) MarkdownExporter right-justifies numeric columns (#421) Better colors for console output (#376) Column legends Add information about CPU microarchitecture for well-known processors to summary Fix AssemblyInformationalVersionAttribute (#382) Fix incorrect method filtering in BenchmarkSwitcher (#365) Fix OS Version in Summary for Windows 10 (#351) Fix OS Version on Mono Fix --class and --method filtering (#249) Fix --exporters option (#189) Fix escaping logic in CsvExporter (#294, #409) Fix MacOS detection Minor bugfixes and API improvements Milestone details In the v0.10.4 scope, 23 issues were resolved and 14 pull requests were merged. This release includes 103 commits by 9 contributors. Resolved issues (23) #118 Raw data in CSV reports (assignee: @AmadeusW) #146 Ability to specify units / easier comparison (assignee: @AmadeusW) #159 Warn user if no Columns were defined (assignee: @adamsitnik) #189 --exporters option appears not to be working (assignee: @adamsitnik) #249 --class and --method should combine as \"AND\" filtering (assignee: @adamsitnik) #294 [Suggestion] CSVHelper.Escape() method should check for actual separator value (assignee: @alinasmirnova) #303 Update to Roslyn 2.0 when RTM is shipped to nuget.org (assignee: @adamsitnik) #351 Fix OS Version in Summary for Windows 10 (assignee: @adamsitnik) #352 Troubles with CoreJob on Linux (assignee: @adamsitnik) #365 [Minor bug] Benchmark switcher: incorrect method filtering (assignee: @adamsitnik) #376 Pick better background colors for output (assignee: @AndreyAkinshin) #382 AssemblyInformationalVersion doesn't work (assignee: @AndreyAkinshin) #388 Precise Machine Counter Diagnoser (assignee: @adamsitnik) #391 BenchmarkSwitcher should take an optinal IConfig #393 Troubles with ClrJob in .NET Core applications (assignee: @adamsitnik) #395 Could not load file or assembly 'System.Reflection.Metadata' (assignee: @adamsitnik) #401 Exceptions in Roslyn.Builder (assignee: @adamsitnik) #406 BenchmarkDotNet with netcoreapp2.0 requires using RuntimeFrameworkVersion directly in the project file (assignee: @adamsitnik) #410 Troubles with Classic applications on nightly BenchmarkDotNet (assignee: @adamsitnik) #412 HardwareCounter.InstructionRetired failing with ArgumentNullException. Build 82 (assignee: @adamsitnik) #415 Allocations for async methods measures BenchmarkDotNet (assignee: @adamsitnik) #419 Suspicious warnings about MemoryMappedFiles (assignee: @adamsitnik) #424 Make InliningDiagnoser filtering more flexible (assignee: @adamsitnik) Merged pull requests (14) #356 Feature: host API interface (by @ig-sinicyn) #379 Feature: in-process benchmarks (by @ig-sinicyn) #392 Add an optional config to BenchmarkSwitcher. (by @ILMTitan) #396 Allow users to pick, show and hide measurement units in the reports and exports. (by @AmadeusW) #400 fix spelling error: misspredict => mispredict (by @SteveDesmond-ca) #405 Make RoslynToolchain types public (by @cdmihai) #407 Propagate benchmark to hooks (by @cdmihai) #408 Small fixes before approval tests (by @alinasmirnova) #409 CSVHelper.Escape() method should check for actual separator value (by @alinasmirnova) #416 Exports file to temporary location if target is locked (by @AmadeusW) #421 MarkdownExporter right-justifies numeric columns (by @SteveDesmond-ca) #423 Updated Microsoft.Net.Test.Sdk (by @alinasmirnova) #430 Fix unix OS detection. (by @mfilippov) #432 Fix macOS detection (by @mfilippov) Commits (103) bd790c Simplify BenchmarkDotNet.IntegrationTests.Classic.ReferencesTests (by @AndreyAkinshin) bf9f4e Feature: host API interface (by @ig-sinicyn) f85ffe Merge pull request #356 from ig-sinicyn/feature-host-api (by @AndreyAkinshin) 8ffff0 Feature: in-process benchmarks (by @ig-sinicyn) 51fc0c Feature: in-process benchmarks, FixAffinity() helper (by @ig-sinicyn) c5179f Feature: in-process benchmarks, review fixes (by @ig-sinicyn) 6c5990 Feature: in-process benchmarks, review fixes, part 2 (by @ig-sinicyn) c6b046 Feature: in-process benchmarks, STA & priority on full .Net FW (by @ig-sinicyn) cc2c89 Feature: in-process benchmarks, env validation in toolchain, intro example ad... (by @ig-sinicyn) 101a80 Improved versioning system (by @AndreyAkinshin) 846532 Update links to appveyor (by @AndreyAkinshin) 5464e4 Improved versioning system, part 2 (by @AndreyAkinshin) e39a50 Merge pull request #379 from ig-sinicyn/feature-inprocess (by @adamsitnik) ae4cc8 AssemblyInformationalVersion fix in common.props, resolves #382 (by @AndreyAkinshin) d036f9 Precise Machine Counter Diagnoser #388 (by @adamsitnik) 390442 Improved invocationCount behavior in SimpleJobAttribute (by @AndreyAkinshin) 7b61ed add possibility to set Hardware Counters per class in runtime-independent way... (by @adamsitnik) 6e208c Add an optional config to BenchmarkSwitcher. (by ILMTitan) 935d23 Merge pull request #392 from ILMTitan/master (by @adamsitnik) 6b9a88 update to Roslyn 2.0, drop .NET 4.5 support, fixes #303 (by @adamsitnik) ea4c55 BenchmarkDotNet.IntegrationTests.csproj: fix formatting (by @AndreyAkinshin) 20a537 Update year in LICENSE.md (by @AndreyAkinshin) 878796 Update logo (by @AndreyAkinshin) faba77 Update README.md (by @AndreyAkinshin) 6dce74 Update logo in README.md (by @AndreyAkinshin) 7a750f Another fix in README.md (by @AndreyAkinshin) 1caa0d fix spelling error: misspredict => mispredict (by @SteveDesmond-ca) 742912 use Array.Empty and Task.Completed (after upgrading to .NET 4.6) (by @adamsitnik) 0dafac there is no need to set up with latest VS, fixes #393 (by @adamsitnik) f5d88e Catch exceptions in BenchmarkDotNet.Running.BenchmarkRunnerCore.Run (by @AndreyAkinshin) fa176f Merge pull request #400 from stevedesmond-ca/missspelling (by @AndreyAkinshin) 90c3b1 Docs improvements (by @AndreyAkinshin) 84c524 Mark SimpleJobAttribute with AllowMultiple (by @AndreyAkinshin) 531804 Update README.md (by @AndreyAkinshin) 7f2221 Make RoslynToolchain types public (#405) (by @cdmihai) be8c33 Improved confidence intervals (by @AndreyAkinshin) 767811 Propagate benchmark to hooks (#407) (by @cdmihai) ec5e54 All exporters should not use static environment info (by @alinasmirnova) 2b8a9e Culculate csv separator when it is needed, not in constructor (by @alinasmirnova) 95aeb5 clean up (by @alinasmirnova) 2e74c2 Name field for all exporters (by @alinasmirnova) badb0b Merge pull request #408 from alinasmirnova/small-fixes (by @AndreyAkinshin) 9da9ca search for .NET Core 2.0 settings in imported props files, fixes #406 (by @adamsitnik) 2b08c5 filter sealed, generic and abstract classes from BenchmarkSwitcher, fixes #365 (by @adamsitnik) 14ad55 print correct OS version in summary, fixes #351 (by @adamsitnik) b86f48 BenchmarkDotNet does not support running .NET Core benchmarks when host proce... (by @adamsitnik) 11b51b refactoring in TypeParser (by @adamsitnik) 8047a7 use AND when filtering with args from command line, fixes #249 (by @adamsitnik) 3cf8d8 handle cmd line arguments without '=', fixes #189 (by @adamsitnik) cdc71f test fix after recent changes, #249 (by @adamsitnik) 97c211 detect situation when users want to use Hardware Counters with InProcessToolc... (by @adamsitnik) ba972b Warn user if no Columns were defined, fixes #159 (by @adamsitnik) 2520f2 migrate old csprojs to the new format to get the tests running in common way,... (by @adamsitnik) dd1b4d Improvements in StatisticsTests (by @AndreyAkinshin) 07d149 emptyEnumerable.All(whatever) returns true (by @adamsitnik) 0d61a7 improve dynamic diagnoser loading (case when diagnosers NuGet pacakge is inst... (by @adamsitnik) 5a6937 Ignore BenchmarkProject.json in BenchmarkDotNet.sln.DotSettings (by @AndreyAkinshin) 5895c4 Improvements in TypeParserTests (by @AndreyAkinshin) 1124ae BenchmarkDotNet.Tests: cleanup (by @AndreyAkinshin) d37ef4 CSVHelper.Escape() method should check for actual separator value (by @alinasmirnova) 43643c move hardwareCounters from Job to Config, fixes #412 (by @adamsitnik) 303fff pass config from runner => executor => diagnoser #412 (by @adamsitnik) 5b432e Addded approval tests for exporters (by @alinasmirnova) ac6507 Added more info in mock summary (by @alinasmirnova) a59b17 MockEnvironmentInfo for approval tests (by @alinasmirnova) 610f3b Awaiting Tasks should not interfere allocation results, fixes #415 (by @adamsitnik) cf16f6 I forgot about aligning, #415 (by @adamsitnik) 2860d2 help the .NET framework to resolve assemblies when binding redirects are miss... (by @adamsitnik) e7ad36 don't log false alarms, fixes #419 (by @adamsitnik) 803081 Allow users to pick, show and hide measurement units in the reports and expor... (by @AmadeusW) fa3128 Exports file to temporary location if target is locked (#416) (by @AmadeusW) c923ba MarkdownExporter right-justifies numeric columns (#421) (by @SteveDesmond-ca) aa290d Add column legends (by @AndreyAkinshin) 8d8db5 Handle case when there are no columns with legends (by @AndreyAkinshin) dc201c Add empty line before legends (by @AndreyAkinshin) ff7fc9 Approved files (by @alinasmirnova) 3f6372 Updated Microsoft.Net.Test.Sdk (by @alinasmirnova) 7d23d1 Merge remote-tracking branch 'upstream/master' (by @alinasmirnova) 57cbbb Merge branch 'new-test-sdk-version' (by @alinasmirnova) c0c563 Updated Microsoft.Net.Test.Sdk (by @alinasmirnova) 539834 Updated spproved files according last changes in md exporter (by @alinasmirnova) f117f0 Added *.received and *.orig in .gitignore (by @alinasmirnova) 0d7e72 Make InliningDiagnoser filtering more flexible, fixes #424 (by @adamsitnik) d25eb0 allow to set InProcessToolchain via attribute /cc @ig-sinicyn (by @adamsitnik) 8cf041 Mock strings in mock environment info (by @alinasmirnova) 0db804 Changed file naming in approval files (by @alinasmirnova) 29aeaf correct Idle implementation for Task-returning benchmarks, fixes #418 (by @adamsitnik) c81aa5 the missing docs for Hardware Counters, fixes #388 (by @adamsitnik) 6076e2 Improved precision (by @AndreyAkinshin) 72b3a6 Show \"NA\" for statistic columns with double.NaN values (by @AndreyAkinshin) ea2222 Processor brand string prettifying (by @AndreyAkinshin) 678d43 Added approval files info links to docs (by @alinasmirnova) 33911c Merge remote-tracking branch 'upstream/master' (by @alinasmirnova) d4c928 Fixed approval tests according to recent changes in master (by @alinasmirnova) eb9f4f Fix typos in docs (by @AndreyAkinshin) 271b27 Merge pull request #348 from alinasmirnova/master (by @AndreyAkinshin) 152f3e Parsing Gulftown processor brand strings (by @AndreyAkinshin) 74d793 Minor improvements in docs (by @AndreyAkinshin) 764bd3 Minor improvements in docs, part 2 (by @AndreyAkinshin) 0a251b Fix unix OS detection. (by @mfilippov) 5c3b39 Fix typo in PlatformID (by @mfilippov) 7f3d06 Always use PlatformAbstractions in RuntimeInformation.GetOsVersion() (by @AndreyAkinshin) 46d34f Set library version: 0.10.4 (by @AndreyAkinshin) Contributors (9) Adam Sitnik (@adamsitnik) Alina Smirnova (@alinasmirnova) Amadeusz Wieczorek (@AmadeusW) Andrey Akinshin (@AndreyAkinshin) ig-sinicyn (@ig-sinicyn) ILMTitan Mihai Codoban (@cdmihai) Mikhail Filippov (@mfilippov) Steve Desmond (@SteveDesmond-ca) Thank you very much! Additional details Date: April 21, 2017 Milestone: v0.10.4 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.4 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.4 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.4 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.4"
  },
  "changelog/v0.10.5.html": {
    "href": "changelog/v0.10.5.html",
    "title": "BenchmarkDotNet v0.10.5 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.5 Fixed SizeUnit presentation in the summary table (#434) In MemoryDiagnoser, now 1kB = 1024B (instead of 1000 in v0.10.4) (#434) Fix false allocations detection (#436 9b44de70) Hide ScaledSD column for small values (da857ad7) Autoselecting amount of digits after the decimal point (#404) Milestone details In the v0.10.5 scope, 3 issues were resolved and 2 pull requests were merged. This release includes 16 commits by 4 contributors. Resolved issues (3) #404 Autoselecting amount of digits after the decimal point (assignee: @AndreyAkinshin) #428 Cleanup NuGet.Config (assignee: @adamsitnik) #434 Allocation output suddenly is 0 GB (assignee: @AndreyAkinshin) Merged pull requests (2) #435 Joined approved files according to cultures (by @alinasmirnova) #436 Fix false allocations detection (by @ig-sinicyn) Commits (16) d9eefd NuGet feeds cleanup, fixes #428 (by @adamsitnik) 2a95b0 Fix SizeUnit presentation, fixes #434 (by @AndreyAkinshin) 8eca28 Add a note about kilobytes in docs (by @AndreyAkinshin) ae483e Separate approved files only for cultures, not for exporters (by @alinasmirnova) 78a6a0 Improved legend for MemoryDiagnoser (by @AndreyAkinshin) 47ae20 SizeUnitTests (by @AndreyAkinshin) 9b44de fix false allocations detection (by @ig-sinicyn) ffd535 Merge pull request #436 from ig-sinicyn/fix_allocations_on_run (by @adamsitnik) 87c2bd Inclusive ConfidenceInterval.Contains (by @AndreyAkinshin) da857a Don't show the ScaledSD column if values are small (by @AndreyAkinshin) e0cf24 Add DefaultColumnProvidersTests (by @AndreyAkinshin) f2baa3 Fix typo in DefaultColumnProvidersTests (by @AndreyAkinshin) 117560 Fix BaselineScaledColumnTest.ColumnsWithBaselineGetsScaled (by @AndreyAkinshin) 3a1fb7 Implement BestAmountOfDecimalDigits for statistics columns in SummaryTable, f... (by @AndreyAkinshin) 4201ee Fix ToolchainTest.CustomToolchainsAreSupported (by @AndreyAkinshin) cba245 Set library version: 0.10.5 (by @AndreyAkinshin) Contributors (4) Adam Sitnik (@adamsitnik) Alina Smirnova (@alinasmirnova) Andrey Akinshin (@AndreyAkinshin) ig-sinicyn (@ig-sinicyn) Thank you very much! Additional details Date: April 26, 2017 Milestone: v0.10.5 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.5 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.5 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.5 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.5"
  },
  "changelog/v0.10.6.html": {
    "href": "changelog/v0.10.6.html",
    "title": "BenchmarkDotNet v0.10.6 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.6 Removed buggy allocation from Engine which was spoiling the results of MemoryDiagnoser for micro benchmarks. This part of the code is now guarded with very strict integration tests, it should never happen again. We now also exclude the side effects of the Allocation Quantum. This bug was serious, you must update to 0.10.6 (#439) Support of the PackageTargetFallback setting which allows to reference components that target old framework monikers (like dotnet5.4 or portable-net45+win8) (#438) Added InstructionRetiredPerCycleColumn which shows up automatically when HardwareCounter.InstructionRetired and HardwareCounter.TotalCycles are used. Support benchmark classes without namespace (#446) Fix problem with RPlotExporter and quoted directories in %PATH% (#446) Show Windows brand version in summary Milestone details In the v0.10.6 scope, 3 issues were resolved and 1 pull requests were merged. This release includes 11 commits by 3 contributors. Resolved issues (3) #438 Need to Update Autogenerated csproj file (assignee: @adamsitnik) #439 Question - This benchmark apparently allocates, but why? (assignee: @adamsitnik) #446 ArgumentNullException if RPlotExporter is used (assignee: @AndreyAkinshin) Merged pull requests (1) #444 Added line separator at the end in JsonExporters (by @alinasmirnova) Commits (11) 3c1f09 copy the PackageTargetFallback setting if present in csproj to support older ... (by @adamsitnik) ffab7d remove allocation from Engine, make sure tests detect breaking change in the ... (by @adamsitnik) 7c9a0f consider Allocation Quantum side effects to have correct results for micro be... (by @adamsitnik) 4af5f3 Added line separator in JsonExporters (by @alinasmirnova) 8ac913 added Instruction Retired per Cycle (IPC) to the predefined columns for Pmc D... (by @adamsitnik) 0898c3 post code review changes (by @adamsitnik) b4d68e 'kB' -> 'KB' (by @AndreyAkinshin) 23bd4f Handle null values in CsvHelper.Escape (by @AndreyAkinshin) 77ed63 RPlotExporter.FindInPath: handle exceptions, trim quotes #446 (by @AndreyAkinshin) 626e3a Show Windows brand versions in summary (by @AndreyAkinshin) 247634 Set library version: 0.10.6 (by @AndreyAkinshin) Contributors (3) Adam Sitnik (@adamsitnik) Alina Smirnova (@alinasmirnova) Andrey Akinshin (@AndreyAkinshin) Thank you very much! Additional details Date: May 12, 2017 Milestone: v0.10.6 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.6 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.6 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.6 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.6"
  },
  "changelog/v0.10.7.html": {
    "href": "changelog/v0.10.7.html",
    "title": "BenchmarkDotNet v0.10.7 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.7 LINQPad support (5.22.05+) (#66, #445) Benchmark filters and categories (#248) Updated setup/cleanup attributes: [GlobalSetup], [GlobalCleanup], [IterationSetup], [IterationCleanup] (#270, #274, #325, #456) Better Value Types support (afa803d0) Building Sources on Linux: it's possible to build the solution (with unloaded F#/VB projects), run samples (for both net46/netcoreapp1.1), run unit tests (for netcoreapp1.1 only) Fix minor bugs in JsonExporter (#451) Milestone details In the v0.10.7 scope, 6 issues were resolved and 1 pull requests were merged. This release includes 24 commits by 4 contributors. Resolved issues (6) #66 Friendliness to LinqPad (assignee: @adamsitnik) #248 Support a \"category\" attribute for selecting benchmarks (assignee: @AndreyAkinshin) #270 Add support for Cleanup and Setup between benchmarks (assignee: @AndreyAkinshin) #274 Support for run-once Setup and Clean-up with Parameters available (assignee: @AndreyAkinshin) #325 Setup & Cleanup versions of attribute which would run before/after each benchmark iteration (assignee: @AndreyAkinshin) #445 Missing reference to Microsoft.CodeAnalysis.CSharp when using BenchmarkDotNet in Linqpad (assignee: @adamsitnik) Merged pull requests (1) #451 Fix minor bugs in JsonExporter (by @Teknikaali) Commits (24) a54645 handle the LINQPad shadow copying, #445, #66 (by @adamsitnik) fe3032 Add Filters (by @AndreyAkinshin) 2e7427 Add categories (by @AndreyAkinshin) f96346 Add categories filters (by @AndreyAkinshin) 34f808 Support category filters in BenchmarkSwitcher (by @AndreyAkinshin) 786afe Implement join mode in BenchmarkSwitcher (by @AndreyAkinshin) a77a77 Post code review changes (by @AndreyAkinshin) cc7006 Fix minor bugs in JsonExporter (#451) (by @Teknikaali) 4dd789 Rename Setup/Cleanup to GlobalSetup/GlobalCleanup (by @AndreyAkinshin) 21369c Introduce IterationSetup/IterationCleanup (by @AndreyAkinshin) 0e9be7 Add IterationSetupCleanupAnalyser (by @AndreyAkinshin) 4f3703 docs: update structure (by @AndreyAkinshin) 5fe564 docs: add info about RunStrategy.Monitoring and new Setup/Cleanup attributes (by @AndreyAkinshin) 87ce0f Mark ProcessPropertiesTests as WindowsOnly (by @AndreyAkinshin) 7e479e Fix typo in File_StreamVsMemoryMapperVewStream.cs (by @AndreyAkinshin) 975514 Wrong xml doc comment (by @ig-sinicyn) 165b13 Merge pull request #455 from ig-sinicyn/patch-1 (by @adamsitnik) afa803 better Value Types support (by @adamsitnik) d16ddb workaround for weird AppVeyor behavior (by @adamsitnik) 9f3d68 support recursive nesting for returned types (by @adamsitnik) b7668e Add tests/runCoreTests.sh (by @AndreyAkinshin) 3cceb6 runCoreTests.sh: fix output file for integration-tests (by @AndreyAkinshin) a21421 Make some tests Windows-only (by @AndreyAkinshin) 00a156 Set library version: 0.10.7 (by @AndreyAkinshin) Contributors (4) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Anssi Kettunen (@Teknikaali) ig-sinicyn (@ig-sinicyn) Thank you very much! Additional details Date: June 05, 2017 Milestone: v0.10.7 Overview post: https://aakinshin.net/posts/bdn-v0_10_7/ NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.7 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.7 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.7 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.7"
  },
  "changelog/v0.10.8.html": {
    "href": "changelog/v0.10.8.html",
    "title": "BenchmarkDotNet v0.10.8 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.8 Legend for time units (#349, #459, f14e508e) XML exporter (#157, #452, a0148db8) .NET Framework 4.7 support (#461, 3f2b5c3c, 5513873a) Public API for AllocationQuantum (#450, #462, a0148db8) Milestone details In the v0.10.8 scope, 5 issues were resolved and 3 pull requests were merged. This release includes 8 commits by 4 contributors. Resolved issues (5) #157 Implement export to xml #349 What the report title and value means? (assignee: @AndreyAkinshin) #450 [Minor feature request] Please make GcStats.AllocationQuantum public #459 [Question] What does the unit of measurement us stand for #461 .NET Framework 4.7 support (assignee: @adamsitnik) Merged pull requests (3) #452 Feature: XML Exporter (by @Teknikaali) #455 Wrong xml doc comment (by @ig-sinicyn) #462 make allocation quantum public, deal with a spelling error and expose… (by @RichLinnell) Commits (8) f14e50 Add legend for time units (by @AndreyAkinshin) e59550 Add info about OrderProviders in docs (by @AndreyAkinshin) 6fc245 Fix ConfigPassingTest (by @AndreyAkinshin) ef0583 Feature: XML Exporter (#452) (by @Teknikaali) 3f2b5c .NET 4.7 support from .NET Core host process on Windows, fixes #461 (by @adamsitnik) a0148d make allocation quantum public, deal with a spelling error and expose allocat... (by @RichLinnell) 551387 add Windows check to our CsProjClassicNetToolchain (by @adamsitnik) 971565 Set library version: 0.10.8 (by @AndreyAkinshin) Contributors (4) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Anssi Kettunen (@Teknikaali) Rich Linnell (@RichLinnell) Thank you very much! Additional details Date: June 09, 2017 Milestone: v0.10.8 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.8 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.8 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.8 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.8"
  },
  "changelog/v0.10.9.html": {
    "href": "changelog/v0.10.9.html",
    "title": "BenchmarkDotNet v0.10.9 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.10.9 Migrate from custom build scripts to Cake (C# Make) (#426, #475, thanks @Ky7m) Target Setup methods for specific Benchmarks (#469, #501, thanks @ipjohnson) Many improvements in XmlExporter (#476, #488, thanks @Teknikaali) Add MemoryDiagnoser results to JsonExporter output (#453, #478, thanks @Teknikaali) Detect correct version of .NET Core (+ improved presentation for information about runtime) (#448, ed586585...ed586585) Fix UnauthorizedAccessException (#380, #390, #490, #491, 8505abb5) Fix app.config generation (#499, dc6dc411) Fix incorrect order of IterationCleanup and Benchmark jitting (#481, #503) Fix test scripts for MacOS+zsh (1177c8) Unix-related ProcessorAffinity fixes (#474, 26d44411) Minor fixes in docs (#465, #467, #473, #480, #483, thanks @mtschneiders, @davkean, @aarondandy, @AmadeusW) Temporary hacks for appveyor connectivity incident (#497, #506) Additional warnings for incorrect Configs (#482, eb84825f) Additional warnings for F# methods with spaces (#479, 3c2c8dec, 7ba1c809, 3ca39afe) Milestone details In the v0.10.9 scope, 13 issues were resolved and 14 pull requests were merged. This release includes 37 commits by 10 contributors. Resolved issues (13) #380 Problem running benchmark due to \"could not copy\" during build (assignee: @adamsitnik) #390 Crashing benchmark (assignee: @adamsitnik) #426 Migrate from custom build scripts to Cake (C# Make) #448 Detect correct version of .NET Core (assignee: @AndreyAkinshin) #453 MemoryDiagnoser and JsonExporter #469 [Suggestion] Specify Setup per benchmark (assignee: @AndreyAkinshin) #474 PlatformNotSupportedException when reading ProcessorAffinity on non-Windows platforms (assignee: @AndreyAkinshin) #479 Invalid C# code generated for valid F# identifiers (assignee: @adamsitnik) #481 Iteration cleanup runs before the benchmark (assignee: @AndreyAkinshin) #482 Benchmark seems to hang when no logger is defined (assignee: @adamsitnik) #490 BDN.Generated.exe is locking files when killed with ctrl+c (assignee: @adamsitnik) #491 UnauthorizedAccessException preventing report to be written (assignee: @adamsitnik) #499 Opting into app-compat switches in a benchmark doesn't work (assignee: @adamsitnik) Merged pull requests (14) #465 Small correction in Filters.md (by @mtschneiders) #467 Small improvements to FAQ.md (by @mtschneiders) #471 Corrected typos in Filters.md and IntroFilters.cs (by @mtschneiders) #473 Adds ISummaryStyle information to the Exporters guide (by @AmadeusW) #475 Cake (C# Make) integration. Migration from custom build scripts. (by @Ky7m) #476 Improve Xml exporter's discoverability (by @Teknikaali) #478 Add MemoryDiagnoser results to JsonExporter output (by @Teknikaali) #480 Fix links to Overview/FAQ (by @davkean) #483 Update jobs docs (by @aarondandy) #488 Improve XmlExporter (by @Teknikaali) #497 Add temporary solution to address connectivity issues to nuget.org (by @Ky7m) #501 Target Setup methods for specific Benchmarks (by @ipjohnson) #503 Make sure IterationCleanup is run after Jitting (by @smitpatel) #506 Removes a temporary solution related to connectivity issues to nuget (by @Ky7m) Commits (37) 0b5657 Small correction in comments (by @mtschneiders) b1ad2c Merge pull request #465 from mtschneiders/patch-1 (by @adamsitnik) 3bb154 Small corrections to FAQ.md (by @mtschneiders) 1a8559 Merge pull request #467 from mtschneiders/patch-2 (by @adamsitnik) fc4dfe Corrected typos in Filters.md and IntroFilters.cs (by @mtschneiders) cb5072 Remove UpgradeLog.htm (by @AndreyAkinshin) 7013bd Adds ISummaryStyle information to the Exporters guide (by @AmadeusW) 345af7 wording (by @AmadeusW) a114ea Merge pull request #473 from AmadeusW/docs/exporters (by @adamsitnik) 26d444 Unix-related ProcessorAffinity fixes (fix #474) (by @AndreyAkinshin) 2d8a53 Improve Xml exporter's discoverability (#476) (by @Teknikaali) baebf9 Add MemoryDiagnoser results to JsonExporter output (#478) (by @Teknikaali) 32993c Fix links to Overview/FAQ (by @davkean) 8e712c Merge pull request #480 from davkean/FixLinks (by @adamsitnik) 43405d Update jobs docs (by @aarondandy) 1bacac Merge pull request #483 from aarondandy/docs-changes (by @adamsitnik) 3c2c8d print nice error for F# methods that contain whitespaces, fixes #479 (by @adamsitnik) 7ba1c8 post code review #479 (by @adamsitnik) 3ca39a even more post code review #479 (by @adamsitnik) eb8482 warn the users if no logger, columns or exporters were defined, fixes #482 (by @adamsitnik) 8505ab unique file names by default, are removed after printing the results, fix #49... (by @adamsitnik) 3e74aa Improve XmlExporter (#488) (by @Teknikaali) 6e2577 Cake (C# Make) integration. Migration from custom build scripts. (#475) (by @Ky7m) 6e6fcc Add temporary solution to address connectivity issues to nuget.org https://ap... (by @Ky7m) dc6dc4 all runtime settings, that do not belong to Job must be rewritten by default ... (by @adamsitnik) ed5865 Rename \"dotnet cli version\" to \".NET Core SDK\", see #448 (by @AndreyAkinshin) 857f2b Detecting the correct version of .NET Core, fixing #448 (by @AndreyAkinshin) 7ec001 Don't print information about unknown timers in HostEnvironmentInfo (by @AndreyAkinshin) 4c3c82 Add missing space in HostRuntimeInfo (by @AndreyAkinshin) da8226 Print actual information about .NET Framework version in summary, see #448 (by @AndreyAkinshin) cea199 Fix MultipleRuntimesTest.SingleBenchmarkCanBeExecutedForMultpleRuntimes (by @AndreyAkinshin) db56bc Make sure IterationCleanup is run after Jitting (by @smitpatel) 3df90f Merge pull request #503 from smitpatel/orderingissue (by @adamsitnik) 1177c8 Improve tests/runCoreTests.sh (by @AndreyAkinshin) 976900 Removes a temporary solution related to connectivity issues to nuget.org http... (by @Ky7m) 557246 Target Setup methods for specific Benchmarks (#501) (by @ipjohnson) 80d70a Set library version: 0.10.9 (by @AndreyAkinshin) Contributors (10) Aaron Dandy (@aarondandy) Adam Sitnik (@adamsitnik) Amadeusz Wieczorek (@AmadeusW) Andrey Akinshin (@AndreyAkinshin) Anssi Kettunen (@Teknikaali) David Kean (@davkean) Ian Johnson (@ipjohnson) Igor Fesenko (@Ky7m) Mateus Artur Schneiders (@mtschneiders) Smit Patel (@smitpatel) Thank you very much! Additional details Date: July 28, 2017 Milestone: v0.10.9 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.9 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.9 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.9 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.9"
  },
  "changelog/v0.11.0.html": {
    "href": "changelog/v0.11.0.html",
    "title": "BenchmarkDotNet v0.11.0 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.11.0 This is one of the biggest releases of BenchmarkDotNet ever. There are so many improvements. We have new documentation, many performance improvements, Job Mutators, better user experience, correct Ctrl+C handling, better generic benchmarks support, more scenarios for passing arguments to benchmarks, awesome support of console arguments, unicode support, LLVM support in MonoDisassembler, and many-many other improvements and bug fixes! A big part of the features and bug fixes were implemented to meet the enterprise requirements of Microsoft to make it possible to port CoreCLR, CoreFX, and CoreFXLab to BenchmarkDotNet. The release would not be possible without many contributions from amazing community members. This release is a combined effort. We build BenchmarkDotNet together to make benchmarking .NET code easy and available to everyone for free! New documentation We have many improvements in our documentation! The new docs include: DocFX under the hood Detailed changelogs which includes all commits, merged pull requests and resolved issues API references Code samples for main features: we generate it automatically based on the BenchmarkDotNet.Samples project; it means that all samples can always be compiled (no more samples with outdated API) Better UI Documentation versioning: now it's possible to look at the documentation for recent BenchmarkDotNet versions Performance improvements BenchmarkDotNet needs to be capable of running few thousands of CoreFX and CoreCLR benchmarks in an acceptable amount of time. The code itself was already optimized so we needed architectural and design changes to meet this requirement. Generate one executable per runtime settings To ensure that the side effects of one benchmark run does not affect another benchmark run BenchmarkDotNet generates, builds and runs every benchmark in a dedicated process. So far we were generating and building one executable per benchmark, now we generate and build one executable per runtime settings. So if you want to run ten thousands of benchmarks for .NET Core 2.1 we are going to generate and build single executable, not ten thousand. If you target multiple runtimes the build is going to be executed in parallel. Moreover, if one of the parallel builds fail it's going to be repeated in a sequential way. Previously the time to generate and build 650 benchmarks from our Samples project was one hour. Now it's something around 13 seconds which means 276 X improvement for this particular scenario. You can see the changes here. Don't execute long operations more than once per iteration BenchmarkDotNet was designed to allow for very accurate and stable micro-benchmarking. One of the techniques that we use is manual loop unrolling. In practice, it meant that for every iteration we were executing the benchmark at least 16 times (the default UnrollFactor value). It was of course not desired for the very time-consuming benchmarks. So far this feature was always enabled by default and users would need to configure UnrollFactor=1 to disable it. Now BenchmarkDotNet is going to discover such scenario and don't perform manual loop unrolling for the very time-consuming benchmarks. BenchmarkDotNet uses Job.IterationTime setting (the default is 0.5s) in the Pilot Experiment stage to determine how many times given benchmark should be executed per iteration. Example: public class Program { static void Main() => BenchmarkRunner.Run<Program>(); [Benchmark] public void Sleep1s() => Thread.Sleep(TimeSpan.FromSeconds(1)); } Time to run with the previous version: 374 seconds. With 0.11.0 it's 27 seconds which gives us almost 14 X improvement. A good example of benchmarks that are going to benefit from this change are computer game benchmarks and ML.NET benchmarks. You can see the changes here and here. Exposing more configuration settings The default settings were configured to work well with every scenario. Before running the benchmark, BenchmarkDotNet does not know anything about it. This is why it performs many warmup iterations before running the benchmarks. When you author benchmarks and run them many times you can come up with custom settings that produce similar results but in a shorter manner of time. To allow you to do that we have exposed: Job.MinIterationCount (default value is 15) Job.MaxIterationCount (default value is 100) Job.MinWarmupIterationCount (default value is 6) Job.MaxWarmupIterationCount (default value is 50) User Experience One of the biggest success factors of BenchmarkDotNet is a great user experience. The tool just works as expected and makes your life easy. We want to make it even better! .NET Standard 2.0 We have ported BenchmarkDotNet to .NET Standard 2.0 and thanks to that we were able to not only simplify our code and build process but also merge BenchmarkDotNet.Core.dll and BenchmarkDotNet.Toolchains.Roslyn.dll into BenchmarkDotNet.dll. We still support .NET 4.6 but we have dropped .NET Core 1.1 support. More information and full discussion can be found here. Note: Our BenchmarkDotNet.Diagnostics.Windows package which uses EventTrace to implement ETW-based diagnosers was also ported to .NET Standard 2.0 and you can now use all the ETW diagnosers with .NET Core on Windows. We plan to add EventPipe support and make this page fully cross-platform and Unix compatible soon. Using complex types as benchmark arguments So far we have required the users to implement IParam interface to make the custom complex types work as benchmark arguments/parameters. This has changed, now the users can use any complex types as arguments and it will just work (more). public class Program { static void Main(string[] args) => BenchmarkRunner.Run<Program>(); public IEnumerable<object> Arguments() { yield return new Point2D(10, 200); } [Benchmark] [ArgumentsSource(nameof(Arguments))] public int WithArgument(Point2D point) => point.X + point.Y; } public class Point2D { public int X, Y; public Point2D(int x, int y) { X = x; Y = y; } public override string ToString() => $\"[{X},{Y}]\"; } Note: If you want to control what will be displayed in the summary you should override ToString. If IterationSetup is provided run benchmark once per iteration When Stephen Toub says that something is buggy, it most probably is. BenchmarkDotNet performs multiple invocations of benchmark per every iteration. When we have exposed the [IterationSetup] attribute many users were expecting that the IterationSetup is going to be invoked before every benchmark execution. It was invoked before every iteration, and iteration was more than one benchmark call if the user did not configure that explicitly. We have changed that and now if you provide an [IterationSetup] method it is going to be executed before every iteration and iteration will invoke the benchmark just once. public class Test { public static void Main() => BenchmarkRunner.Run<Test>(); [IterationSetup] public void MySetup() => Console.WriteLine(\"MySetup\"); [Benchmark] public void MyBenchmark() => Console.WriteLine(\"MyBenchmark\"); } Before: MySetup MyBenchmark MyBenchmark MyBenchmark MyBenchmark (...) After: MySetup MyBenchmark MySetup MyBenchmark MySetup MyBenchmark (...) Note: If you want to configure how many times benchmark should be invoked per iteration you can use the new [InvocationCountAttribute]. Job Mutators Job represents a set of settings to run the benchmarks. We run every benchmark for every job defined by the user. The problem was that so far many jobs were just added to the config instead of being merged with other jobs. An example: [ClrJob, CoreJob] [GcServer(true)] public class MyBenchmarkClass Resulted in 3 jobs and 3 benchmark executions: ClrJob, CoreJob and GcServer(true) for current runtime. Now all Jobs and their corresponding attributes marked as mutators are going to be applied to other jobs, not just added to the config. So in this particular scenario, the benchmarks from MyBenchmarkClass are going to be executed for .NET with Server GC enabled and .NET Core with Server GC enabled. Mutators are great when you want to have a single, global config for all benchmarks and apply given settings only to selected types. You can find out more about mutators here. Ctrl+C When the user: presses Ctrl+C presses Ctrl+Break logs off closes console window We are now going to close any existing ETW session created by BenchmarkDotNet and restore console colors (read more). Handle OutOfMemoryException more gracefully When our benchmark hits OutOfMemoryException we print some nice explanation: public class Program { static void Main(string[] args) => BenchmarkRunner.Run<Program>(); private List<object> list = new List<object>(); [Benchmark] public void AntiPattern() => list.Add(new int[int.MaxValue / 2]); } OutOfMemoryException! BenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects. If your benchmark allocates memory and keeps it alive, you are creating a memory leak. You should redesign your benchmark and remove the side-effects. You can use `OperationsPerInvoke`, `IterationSetup` and `IterationCleanup` to do that. Trimming long strings We used to display the values \"as is\" which was bad for long strings. Now the values are trimmed (more). public class Long { [Params(\"text/plain,text/html;q=0.9,application/xhtml+xml;q=0.9,application/xml;q=0.8,*/*;q=0.7\")] public string Text; [Benchmark] public int HashCode() => Text.GetHashCode(); } Method Text HashCode text/(...)q=0.7 [86] More features Generic benchmarks BenchmarkDotNet supports generic benchmarks, all you need to do is to tell it which types should be used as generic arguments (read more). [GenericTypeArguments(typeof(int))] [GenericTypeArguments(typeof(char))] public class IntroGenericTypeArguments<T> { [Benchmark] public T Create() => Activator.CreateInstance<T>(); } Arguments We now support more scenarios for passing arguments to benchmarks: passing arguments to asynchronous benchmarks (more) passing generic types passing arguments by reference passing jagged arrays (more) types with implicit cast operator to stack only types can be passed as given stack-only types to Benchmarks (more) Example: public class WithStringToReadOnlySpan { [Benchmark] [Arguments(\"some string\")] public void AcceptsReadOnlySpan(ReadOnlySpan<char> notString) } Console Arguments BenchmarkSwitcher supports various console arguments (PR), to make it work you need to pass the args to switcher: class Program { static void Main(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args); } Note: to get the most up-to-date info about supported console arguments run the benchmarks with --help. Filter The --filter or just -f allows you to filter the benchmarks by their full name (namespace.typeName.methodName) using glob patterns. Examples: Run all benchmarks from System.Memory namespace: -f System.Memory* Run all benchmarks: -f * Run all benchmarks from ClassA and ClassB -f *ClassA* *ClassB* Note: If you would like to join all the results into a single summary, you need to use --join. Categories You can also filter the benchmarks by categories: --anyCategories - runs all benchmarks that belong to any of the provided categories --allCategories- runs all benchmarks that belong to all provided categories Diagnosers -m, --memory - enables MemoryDiagnoser and prints memory statistics -d, --disassm- enables DisassemblyDiagnoser and exports diassembly of benchmarked code Runtimes The --runtimes or just -r allows you to run the benchmarks for selected Runtimes. Available options are: Clr, Mono, Core and CoreRT. Example: run the benchmarks for .NET and .NET Core: dotnet run -c Release -- --runtimes clr core More arguments -j, --job (Default: Default) Dry/Short/Medium/Long or Default -e, --exporters GitHub/StackOverflow/RPlot/CSV/JSON/HTML/XML -i, --inProcess (Default: false) Run benchmarks in Process -a, --artifacts Valid path to accessible directory --outliers (Default: OnlyUpper) None/OnlyUpper/OnlyLower/All --affinity Affinity mask to set for the benchmark process --allStats (Default: false) Displays all statistics (min, max & more) --attribute Run all methods with given attribute (applied to class or method) Other small improvements Unicode support: now you can enable support of Unicode symbols like μ or ± with [EncodingAttribute.Unicode], an example: BenchmarkDotNet.Samples.IntroEncoding (see #735) Better benchmark validation (see #693, #737) Improve .NET Framework version detection: now we support .NET Framework 4.7.2 (see #743) OutlierModes: now it's possible to control how to process outliers, an example BenchmarkDotNet.Samples.IntroOutliers (see #766) LLVM support in MonoDisassembler (see a7426e) Grand API renaming we try not to change public API, but sometimes it's necessary because we want to get a consistent and understandable API in v1.0.0. (see #787) Many-many small improvements and bug fixes Milestone details In the v0.11.0 scope, 65 issues were resolved and 34 pull requests were merged. This release includes 214 commits by 11 contributors. Resolved issues (65) #136 Fastcheck for correctness of benchmark implementations #175 Add .NET Core support for Diagnostics package (assignee: @adamsitnik) #368 Memory leak and crash with [Setup] (assignee: @adamsitnik) #420 Make BenchmarkDotNet.Core runtime independent (assignee: @adamsitnik) #464 Iteration setup / cleanup should not be called for Idle() (assignee: @adamsitnik) #484 Broken HTTPS on site (assignee: @jongalloway) #487 Please consider using 'µs' instead of 'us' #551 List of structs and OutOfMemoryException #583 BenchmarkDotNet.Samples refactoring (assignee: @AndreyAkinshin) #586 IParam interface improvement (assignee: @adamsitnik) #638 Config with ryujit but it doesnt actually use ryujit? (assignee: @morgan-kn) #649 Searching docs leads to 404 page (assignee: @AndreyAkinshin) #665 Handle OutOfMemoryException more gracefully (assignee: @adamsitnik) #671 Why does BenchmarkRunner generate an isolated project per each benchmark method/job/params? (assignee: @adamsitnik) #698 Port to .NET Standard 2.0, drop .NET Core 1.1 support (assignee: @adamsitnik) #699 Generate one executable per runtime settings (assignee: @adamsitnik) #700 Improve local CoreCLR support (assignee: @adamsitnik) #701 Extend exported json file with FullName using xunit naming convention for integration purpose (assignee: @adamsitnik) #710 Use DocFX as a documentation generator (assignee: @AndreyAkinshin) #712 [Params] with arrays as params throws System.Reflection.TargetInvocationException (assignee: @adamsitnik) #713 How to specify the invocation/launch count per type when using Config for multiple runtimes? (assignee: @adamsitnik) #718 CoreRT support (assignee: @adamsitnik) #719 If fail to build in Parallel due to file access issues, try to build sequentially (assignee: @adamsitnik) #720 Add SummaryOrderPolicy.Declared #724 Allocated Memory results are not scaled with OperationPerInvoke (assignee: @adamsitnik) #726 Improve building guideline #729 Handle Ctrl+C/Break (assignee: @adamsitnik) #730 IterationSetup is not running before each benchmark invocation (assignee: @adamsitnik) #733 IOException when running in OneDrive Folder (assignee: @adamsitnik) #734 Handle missing Mono runtime more gracefully (assignee: @adamsitnik) #736 Reduce number of initial pilot ops to 1 or make it configurable (assignee: @adamsitnik) #738 Params string containing characters like quotes is not being escaped properly (assignee: @adamsitnik) #741 Give users nice warning when T in generic benchmark is not public #745 It should be possible to specify the generic arguments by using attributes #747 Better docs that explain what is target/launch/iteration/invocation count (assignee: @adamsitnik) #748 Very long string params/arguments should be trimmed (assignee: @adamsitnik) #749 WithId(…) is ignored unless it’s at the end of the fluent calls chain. (assignee: @adamsitnik) #763 Make MaxIterationCount configurable, keep current value as default (assignee: @adamsitnik) #765 Add .NET Core 2.2 support (assignee: @adamsitnik) #769 ArgumentsSource does not support Jagged Arrays (assignee: @adamsitnik) #774 Make it possible to use Span and other ByRefLike types with implicit cast operators as benchmark argument (assignee: @adamsitnik) #778 CS0104: 'Job' is an ambiguous reference between 'BenchmarkDotNet.Jobs.Job' and 'Nest.Job' (assignee: @adamsitnik) #779 StackOnlyTypesWithImplicitCastOperatorAreSupportedAsArguments doesn't work on .NET Core 2.0 (assignee: @adamsitnik) #787 Grand renaming #793 job=core for BenchmarkSwitcher (assignee: @adamsitnik) #794 Don't exclude allocation quantum side effects for .NET Core 2.0+ (assignee: @adamsitnik) #795 Broken BenchmarkSwitcher (assignee: @adamsitnik) #797 Allocated is not divided by OperationsPerInvoke (assignee: @adamsitnik) #802 AdaptiveHistogramBuilder.BuildWithFixedBinSize error when running benchmarks (assignee: @AndreyAkinshin) #804 What is the point of BuildScriptFilePath ? (assignee: @adamsitnik) #809 Make it possible to configure Min and Max Warmup Iteration Count (assignee: @adamsitnik) #810 handle new *Ansi events to make Inlining and TailCall Diagnosers work with .NET Core 2.2 (assignee: @adamsitnik) #811 Question/Suggestion is GcStats forcing a GC.Collect when it doesn't need to (assignee: @adamsitnik) #812 When will the next release be available on NuGet? (assignee: @adamsitnik) #813 Problems with MemoryDiagnoserTests on Mono and .NET Core 2.0 (assignee: @adamsitnik) #814 For type arguments we should display simple, not-trimmed name (assignee: @adamsitnik) #816 BenchmarkDotNet.Autogenerated.csproj is not working on .NET Core 2.1 (assignee: @adamsitnik) #817 Autogenerated project is missing dependencies (assignee: @adamsitnik) #818 Arguments should be passed to asynchronous benchmarks (assignee: @adamsitnik) #820 set DOTNET_MULTILEVEL_LOOKUP=0 when custom dotnet cli path is provided (assignee: @adamsitnik) #821 ArgumentsAttribute causes an error when used with a string containing quotes (assignee: @adamsitnik) #823 Allow to set multiple Setup/Cleanup targets without string concatenation (assignee: @adamsitnik) #827 An easy way to run a specific benchmark class via command line (assignee: @adamsitnik) #829 Error message for wrong command line filter (assignee: @adamsitnik) #832 Compilation Error CS0119 with ParamsSource (assignee: @adamsitnik) Merged pull requests (34) #693 Jit runtime validation (by @morgan-kn) #717 V11 (by @adamsitnik) #725 Extend exported json file with FullName using xunit naming convention for integration purpose (by @adamsitnik) #727 Building guideline improvement (by @Rizzen) #728 BenchmarkReport Exporter (by @Rizzen) #735 Unicode support (by @Rizzen) #737 Return value validator (by @ltrzesniewski) #740 Follow up to #737 (by @ltrzesniewski) #742 Add .NET Framework 4.7.2 version constant (by @epeshk) #743 Improve .NET Framework version detection (by @epeshk) #744 BenchmarkClass Validator (by @Rizzen) #746 Addition to #743: use HasValue instead of casting (by @epeshk) #750 Addition to #744: Using single variable in test instead of two (by @Rizzen) #752 Update HowItWorks.md (by @Tornhoof) #753 Ability to pass multiple assemblies. (by @paulness) #754 generate IParams for users in smart way (by @adamsitnik) #757 Add SummaryOrderPolicy.Defined to return benchmarks as instantiated (by @afmorris) #758 Generic Benchmark Attribute (by @Rizzen) #760 don't execute long operations more than once per iteration (by @adamsitnik) #761 stop the ETW session on Ctrl+C + restore console colors ;), fixes #729 (by @adamsitnik) #764 if IterationSetup is provided, and InvocationCount and UnrollFactor are not, run benchmark once per iteration to avoid user confusion (by @adamsitnik) #766 Introduce OutlierMode (by @AndreyAkinshin) #771 have two main actions: with unroll and without, for no unroll icrease the step by 1 in pilot (not *2) (by @adamsitnik) #781 Initial DocFX support, fixes #710 (by @AndreyAkinshin) #783 BenchmarkDotNet.Samples refactoring, fixes #583 (by @AndreyAkinshin) #785 Improve filtering from console args (by @adamsitnik) #789 docs: add changelog (by @AndreyAkinshin) #790 add link to inprocesstoolchain (by @IanKemp) #796 docs: multiversion combobox (by @AndreyAkinshin) #799 Cpu info improvement (by @Rizzen) #800 job Mutators (by @adamsitnik) #824 Use 3rd party lib for console args parsing + support globs for filtering (by @adamsitnik) #830 Read StandardOutput in a smart way to avoid infinite loops (by @houseofcat) #833 initial release notes (by @adamsitnik) Commits (214) defa7e port to .NET Standard 2.0 (by @adamsitnik) 626b03 keep .NET 4.6 in case somebody is on full framework, but not using .NET Standard (by @adamsitnik) ae4e22 merge BenchmarkDotNet.Toolchains.Roslyn into BenchmarkDotNet.Core (by @adamsitnik) 260704 update TraceEvent, port BenchmarkDotNet.Diagnostics.Windows to .NET Standard,... (by @adamsitnik) 324973 remove .NET Core 1.1 support, update tests (by @adamsitnik) 64d732 get it working (by @adamsitnik) 54b829 remove .NET Core 1.1 from the CI jobs (by @adamsitnik) ebf3d9 ups ;) (by @adamsitnik) 42d9ae Merge branch 'master' into annotations (by @adamsitnik) bc9975 cleanup (by @adamsitnik) 96dd4f merge BenchmarkDotNet and BenchmarkDotNet.Core (by @adamsitnik) 2dc21b group the benchmarks by runtime settings into partitions, #699 (by @adamsitnik) fbb283 generate one .cs with all types inside, #699 (by @adamsitnik) 334af2 build single exe, #699 (by @adamsitnik) b958a1 run selected type from all types in exe #699 (by @adamsitnik) 4f5714 polishing the code, #699 (by @adamsitnik) 0c26a4 reverting some magic .sln change which has most probably broken the Travis bu... (by @adamsitnik) c8a368 restore to a dedicated temp folder, rebuild only bare minumum, store everythi... (by @adamsitnik) bd04bd better debugging experience (#699): when building only 1 thing at a time, pri... (by @adamsitnik) fcf691 Improved local CoreCLR/CoreFX support, tested on all OSes #700, #702 (by @adamsitnik) 7fbd6c allow the users to define an extra nuget feed, don't force clear tag for loca... (by @adamsitnik) ad0fc8 Merge branch 'master' into v11 (by @adamsitnik) 8070e4 Merge remote-tracking branch 'origin/master' into v11 (by @adamsitnik) 0cccba post code review fixes, part of #175 (by @adamsitnik) 4acc15 new Runtime and Toolchain for CoreRT, #718 (by @adamsitnik) 657f05 don't use Expressions in Engine to avoid .NET Native compiler errors, #718 (by @adamsitnik) 8c93cf the .NET Native compiler complained about some dependencies from referenced p... (by @adamsitnik) c8ba5c If fail to build in Parallel due to file access issues, try to build sequenti... (by @adamsitnik) 7173f7 CoreRT does not support reflection yet, so we need to target .NET Core 2.1 to... (by @adamsitnik) 889270 trying to install Clang 3.9 for CoreRT tests purpose, #718 (by @adamsitnik) 967167 code review fixes, #718 (by @adamsitnik) 94863a Merge pull request #717 from dotnet/v11 (by @adamsitnik) 448752 Improved docs for Disassembly Diagnoser (by @adamsitnik) 600e5f add FromAssemblyAndTypes method to make it possible to auto-detect all benchm... (by @adamsitnik) 289292 Allocated Memory must be scaled with OperationPerInvoke, fixes #724 (by @adamsitnik) 1aa414 Actual Building Guide (by @Rizzen) cfd9fa Merge pull request #727 from Rizzen/master (by @adamsitnik) 7cfe09 Created Exporter and moved logic into (by @Rizzen) b9ff75 Merge pull request #728 from Rizzen/BenchmarkReportExporter (by @adamsitnik) adea8f support by ref Arguments (by @adamsitnik) 0ecd7e ignore auto-generated files cleanup errors, #733 (by @adamsitnik) cf5cd6 Handle missing Mono runtime more gracefully, fixes #734 (by @adamsitnik) 49495f Remove unused usings (by @AndreyAkinshin) 160516 Return value validator (#737), fixes #136 (by @ltrzesniewski) 396f0a Follow up to #737 (#740) (by @ltrzesniewski) 9dc4e8 Add .NET Framework 4.7.2 release number constant to GetCurrentVersionBasedOnW... (by @epeshk) 06ff2d Update link to manual with .NET Framework version constants (by @epeshk) f7d9ac Don't check Reference Assemblies folder existence for .NET Framework version ... (by @epeshk) ebc1f6 Remove hardcoded Program Files directory location (by @epeshk) 490304 Refactor framework version determining, extract logic from CsProjClassicNetTo... (by @epeshk) cbea7e Fix Program Files path on x86 systems (by @epeshk) 8071c8 ProgramFilesX86DirectoryPath field (by @epeshk) f1d726 Merge pull request #743 from epeshk/frameworkVersion (by @AndreyAkinshin) a36442 use HasValue instead of casting (by @epeshk) c7efcc Merge pull request #746 from epeshk/frameworkVersion (by @adamsitnik) 58f704 Give users nice warning when T in generic benchmark is not public, fixes #741 (by @Rizzen) 66f958 when dotnet build --no-restore fails, try to run with restore (by @adamsitnik) 52067c custom job Id should be preserved, fixes #749 (by @adamsitnik) 24ec6e Very long string params/arguments should be trimmed, fixes #748 (by @adamsitnik) b2e5b6 Params string containing characters like quotes is must be escaped properly, ... (by @adamsitnik) 10865c Better docs that explain what is target/launch/iteration/invocation count by ... (by @adamsitnik) 32ed86 Addition to #744: Using single variable instead of two (by @Rizzen) f2a71f Merge pull request #750 from Rizzen/744_addition (by @adamsitnik) eabfdd Update HowItWorks.md (by @Tornhoof) 8fc754 Merge pull request #752 from Tornhoof/patch-1 (by @adamsitnik) 2d79b6 Ability to pass multiple assemblies. (by @paulness) ba07b0 Merge pull request #753 from paulness/feature-allow-multiple-assemblies-to-be... (by @adamsitnik) d1b037 generate IParams for users in smart way (by @adamsitnik) 4665ec Merge pull request #754 from dotnet/noIParam (by @adamsitnik) 02c7c0 Generic Benchmark Attribute (#758), fixes #745 (by @Rizzen) 7caf28 Add SummaryOrderPolicy.Defined to return benchmarks as instantiated (#757), f... (by @afmorris) 449002 renamed Defined to Declared to keep consistency, renamed GenericBenchmark to ... (by @adamsitnik) 8855a2 Jit runtime validation (#693) (by @morgan-kn) 41614b stop the ETW session on Ctrl+C + restore console colors ;), fixes #729 (#761) (by @adamsitnik) b0c251 Make MaxIterationCount configurable, keep current value as default, fixes #763 (by @adamsitnik) 6f693e warn the users (once!) that if they run less than 15 iterations, the Multimod... (by @adamsitnik) a9664f don't execute long operations more than once per iteration (#760), fixes #736 (by @adamsitnik) 7e8448 if IterationSetup is provided, and InvocationCount and UnrollFactor are not, ... (by @adamsitnik) a40c75 explain the users why they did hit OOM, fixes #665, #368, #551 (by @adamsitnik) e66bb0 arrays can be arguments and params, fixes #712 (by @adamsitnik) 94b83e don't call IterationSetup and Cleanup for Idle, fixes #464 (by @adamsitnik) 90f9ca Add .NET Core 2.2 support, fixes #765 (by @adamsitnik) 132048 Better mValue formatting in MultimodalDistributionAnalyzer (by @AndreyAkinshin) 5f08c2 Merge pull request #764 from dotnet/iterationSetupRunOnce (by @AndreyAkinshin) 2b5dde Introduce OutlierMode (by @AndreyAkinshin) 226716 OutliersAnalyserTests (by @AndreyAkinshin) cabef0 support Jagged Arrays for ArgumentsSource, fixes #769 (by @adamsitnik) 808a9d support generic by ref arguments with an ugly hack due to reflection limitati... (by @adamsitnik) ea9f70 remove the ugly hack (by @adamsitnik) cb4291 make it possible to use arrays of types with no public parameterless ctor (li... (by @adamsitnik) 272e42 diassembly diagnoser: handle case where two different methods have same meta... (by @adamsitnik) ea16d1 update preview dependencies to 4.5.0 (by @adamsitnik) 97ddd6 Make it possible to use Span as benchmark argumen, fixes #774 (by @adamsitnik) 4863be more generic solution for #774 (by @adamsitnik) f63726 update build to use rc1 (to fix the build) (by @adamsitnik) a38c70 make it possible to pass array(s) of reference types as arguments (by @adamsitnik) 306adc use full Job type name to avoid naming conflicts, fixes #778 (by @adamsitnik) e92c5b use DOTNET_MULTILEVEL_LOOKUP and IgnoreCorLibraryDuplicatedTypes to fix the... (by @adamsitnik) 4e9844 Trimming the argument values makes them actually shorter #748 cc @ahsonkhan (by @adamsitnik) 846d80 Merge branch 'master' of https://github.com/dotnet/BenchmarkDotNet (by @adamsitnik) 3c3b47 have two main actions: with unroll and without, for no unroll icrease the ste... (by @adamsitnik) 56f02c use full names in the auto-generated code to avoid possible conflicts (I just... (by @adamsitnik) e75c44 Update documentations for WithOutlierMode (by @AndreyAkinshin) 1840ae Merge pull request #766 from dotnet/outliers (by @AndreyAkinshin) 5ae4bc Fixed BrandString support for Windows 10.0.17134 (by @AndreyAkinshin) 4d6dfe BrandString support for macOS Mojave (by @AndreyAkinshin) 426fbc Initial DocFX support, fixes #710 (by @AndreyAkinshin) fe00d7 Merge pull request #781 from dotnet/docfx (by @AndreyAkinshin) f0c06e Allow to pass string as ReadOnlySpan only for .NET Core 2.1 where the i... (by @adamsitnik) bbe273 make netcoreapp2.1 default for .NET Core 2.1 + expose few things which are re... (by @adamsitnik) bd22b3 BenchmarkDotNet.Samples refactoring, fixes #583 (by @AndreyAkinshin) 149e5e Merge pull request #783 from dotnet/docfx-samples (by @AndreyAkinshin) 237e36 Flat namespace for BenchmarkDotNet.Attributes (by @AndreyAkinshin) 24d2fe Remove obsolete namespaces in IntegrationTests (by @AndreyAkinshin) cb25a7 docs: Visual Studio-like style for code snippets (by @AndreyAkinshin) 914922 docs: add samples for baselines (by @AndreyAkinshin) 159e85 docs: fix year in license (by @AndreyAkinshin) 0b02d0 docs: add IntroEnvVars (by @AndreyAkinshin) 4b0f38 Unicode support (#735) (by @Rizzen) 971236 Unicode support: cleanup (by @AndreyAkinshin) 7c43da CommonExtensions cleanup (by @AndreyAkinshin) 04c0ad Fix link to rplot.png in README.md (by @AndreyAkinshin) b16b83 docs: samples for setup and cleanup (by @AndreyAkinshin) c05ac6 add link to inprocesstoolchain (#790) (by @IanKemp) 44ea0f docs: add changelog (#789) (by @AndreyAkinshin) 8a31aa docs: save changelog details for old versions in repo (by @AndreyAkinshin) edd0a3 docs: customizing-runtime.md (by @AndreyAkinshin) edf7f6 Improve filtering from console args (#785) (by @adamsitnik) d9e18d a type can have no namespace (by @adamsitnik) 4bbffe docs: update docfx version (by @AndreyAkinshin) 52e769 Don't exclude allocation quantum side effects for .NET Core 2.0+, fixes #794 (by @adamsitnik) 24f8da Cake targets for DocFX (by @AndreyAkinshin) db0724 docs: add api/index.md (by @AndreyAkinshin) 026c00 docs: statistics (by @AndreyAkinshin) ae5baf docs: misc fixes (by @AndreyAkinshin) fa5cf5 docs: multiversion combobox (by @AndreyAkinshin) a49cf9 docs: add full contributor list (by @AndreyAkinshin) 803686 always use FQDN to avoid any possible duplicates, #529 strikes back after a year (by @adamsitnik) 315530 make sure DisassemblyDiagnoser output is exported, fixes bug introduced in #785 (by @adamsitnik) 167476 docs: improved diagnosers.md (by @AndreyAkinshin) b7f9aa docs: improved choosing-run-strategy (by @AndreyAkinshin) 5da534 remove MultimodalDistributionAnalyzer hint introduced in #763 (by @adamsitnik) 376339 Merge pull request #796 from dotnet/docs-versions (by @adamsitnik) 57005f Extend exported json file with FullName using xunit naming convention for int... (by @adamsitnik) 9c0a2e docs: improved exporters.md (by @AndreyAkinshin) 22f553 docs: better sample generation (by @AndreyAkinshin) 734635 docs: improved columns.md (by @AndreyAkinshin) a82562 docs: improved configs.md (by @AndreyAkinshin) e7a458 docs: InProcess samples (by @AndreyAkinshin) 602562 docs: imrpovded order-providers.md (by @AndreyAkinshin) 8576c5 docs: fix the rest of WithoutDocs samples (by @AndreyAkinshin) 13b44e docs: rename changelog-generator to _changelog (by @AndreyAkinshin) 9a9648 docs: fix link to InProcessToolchain (by @AndreyAkinshin) 5716c1 escape tabs and enters in the exported benchmark id (to keep it in sync with ... (by @adamsitnik) 4be9bf MemoryDiagnoser handles IterationSetup and Cleanup since #606, removing old i... (by @adamsitnik) f92532 add --job=core to command line arguments, fixes #793 (by @adamsitnik) 1c656d update the docs with the change in IterationSetup behavior, #764 (by @adamsitnik) 6fd39b job Mutators (#800)fixes #713 (by @adamsitnik) 8954dc Rename: OrderProvider -> Orderer (#787) (by @AndreyAkinshin) 7b47c6 Rename: Benchmark -> BenchmarkCase (#787) (by @AndreyAkinshin) cc6f1b Rename: Target -> Descriptor (#787) (by @AndreyAkinshin) 17bb68 Rename: EnvMode -> EnvironmentMode (#787) (by @AndreyAkinshin) 73a6cc Rename: Infrastructure.EnvironmentVariables -> Environment.EnvironmentVariabl... (by @AndreyAkinshin) 6118f1 Huge IterationMode renaming (#787) (by @AndreyAkinshin) 035452 Handle super narrow distributions in AdaptiveHistogramBuilder, fixes #802 (by @AndreyAkinshin) b705b3 print Processor Affinity as a bitmask in the summary (by @adamsitnik) 0db126 fix MacOs build where the default affinity is 0 or we can't read it for some ... (by @adamsitnik) 5e6e33 make sure the characteristic names match the properties names + rename Target... (by @adamsitnik) f4cd0d Baseline improvements (#787) (by @AndreyAkinshin) 124a52 Fix tests (#787) (by @AndreyAkinshin) e8bf99 fix mac test, make sure IsMutator does not flow to applied job (by @adamsitnik) 95750c Make it possible to configure Min and Max Warmup Iteration Count, fixes #809 (by @adamsitnik) 99e753 handle new *Ansi events to make Inlining and TailCall Diagnosers work with .N... (by @adamsitnik) 62e75c docs: update articles/contributing/documentation (by @AndreyAkinshin) 41c5f9 Cake: update DocFX (2.36.2->2.37) (by @AndreyAkinshin) e4b37c Cake: update .NET Core SDK (2.1.300-rc1-008673->2.1.300) (by @AndreyAkinshin) ad1645 Cpu info improvement (#799) (by @Rizzen) 61e95e [Params] exported to json should be delimited by \", \" #701 (by @adamsitnik) 4cd1df handle the types as arguments to match xunit naming convention for porting pu... (by @adamsitnik) ff6613 for type parameters we should display non-trimmed type name without namespace... (by @adamsitnik) 89f195 explain how we measure GC stats in the docs, fixes #811 (by @adamsitnik) c7731c Arguments should be passed to asynchronous benchmarks, fixes #818 (by @adamsitnik) 0f9c48 add info about Min/Max counts to docs (by @adamsitnik) 33e568 fix MemoryDiagnoserTests issues, fixes #813 (by @adamsitnik) 844e95 set DOTNET_MULTILEVEL_LOOKUP=0 to get customDotNetCli path working, fixes #820 (by @adamsitnik) 7e2d54 if iteration cleanup is provided, the benchmark should be executed once per i... (by @adamsitnik) 2132d0 allow to set summary style in fluent way (by @adamsitnik) dfea69 allow to set multuple targets for attributes without string concatenation, fi... (by @adamsitnik) 6267b2 Use 3rd party lib for console args parsing + support globs for filtering (#824) (by @adamsitnik) 9c269f make sure the generic type arguments are displayed in the summary, not `1 (by @adamsitnik) c7d0b9 don't duplicate the jobs when parsing config (by @adamsitnik) d7825e show generic type name in a joined summary (by @adamsitnik) 528c9c make sure the config parsing and job merging works as expected (by @adamsitnik) a7426e LLVM support in MonoDisassembler (by @AndreyAkinshin) c724e9 Fix typos (by @AndreyAkinshin) cdbb37 allow to filter benchmarks by simple type name, fixes #827 (by @adamsitnik) eac833 Read StandardOutput in a smart way to avoid infinite loops (#830), #828 (by @houseofcat) a298c2 Error message for wrong command line filter, fixes #829 (by @adamsitnik) a7ecda initial release notes (#833) (by @adamsitnik) 36bf7c Rename: General -> Actual (#787) (by @AndreyAkinshin) a1ec4b Add _changelog/details/v0.11.0.md (by @AndreyAkinshin) 558cae Improved docs for v0.11.0 (by @AndreyAkinshin) e45f69 docs: update main.js (by @AndreyAkinshin) 53e576 Update links to docs in README (by @AndreyAkinshin) 3a8990 update links in docs/index.md (by @AndreyAkinshin) 5ad710 Repair obsolete logo link (by @AndreyAkinshin) e38afb Cake: update DocFX (2.37->2.37.1) (by @AndreyAkinshin) 5b8f91 docs: add analytics scripts in template (by @AndreyAkinshin) 3ec8f7 docs: add redirects to v0.10.14 (by @AndreyAkinshin) a00bf6 docs: update how-it-works (by @AndreyAkinshin) 73980e docs: add redirect for index.htm (by @AndreyAkinshin) fad583 docs: update changelog for v0.11.0 (by @AndreyAkinshin) 74d552 Update list of NuGet packages in changelog/footer/v0.11.0 (by @AndreyAkinshin) 74084f Set library version: 0.11.0 (by @AndreyAkinshin) Contributors (11) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Evgeny Peshkov (@epeshk) Ian Kemp (@IanKemp) Irina Ananeva (@morgan-kn) Lucas Trzesniewski (@ltrzesniewski) Mark Tkachenko (@Rizzen) Paul Ness (@paulness) Stefan (@Tornhoof) Tony Morris (@afmorris) Tristan Hyams (@houseofcat) Thank you very much! Additional details Date: July 23, 2018 Milestone: v0.11.0 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.0"
  },
  "changelog/v0.11.1.html": {
    "href": "changelog/v0.11.1.html",
    "title": "BenchmarkDotNet v0.11.1 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.11.1 This release includes some minor improvements and bug fixes: Fixed RPlotExporter (#852, #855). In v0.11.0, the plot generation was broken because of the huge renaming in #787. ArgumentsSource now supports additional types like Type (#840), BigInteger (#850), DateTime (#853), and special double values like double.NaN (#851) Generated projects ignore Directory.Build.props and Directory.Build.targets files #854 Now it's possible to run benchmarks with CoreRun (de152c, #857) Milestone details In the v0.11.1 scope, 7 issues were resolved and 2 pull requests were merged. This release includes 29 commits by 4 contributors. Resolved issues (7) #840 ArgumentsSource doesn't work with System.RuntimeType (assignee: @AndreyAkinshin) #850 Handle BigIntegers arguments properly (assignee: @adamsitnik) #851 Handle double special values like NaN etc (assignee: @adamsitnik) #852 BuildPlots script generates empty pictures (assignee: @AndreyAkinshin) #853 ArgumentsSource containing IFormattable leads to Compile Exceptions (assignee: @adamsitnik) #855 Empty plot (assignee: @AndreyAkinshin) #857 Improve user experience for working with local CoreFX builds (assignee: @adamsitnik) Merged pull requests (2) #839 Small Typo in changelog (by @Tornhoof) #854 Exclude Directory.Build.props/targets from generated csproj files (by @agocke) Commits (29) c37aa8 Postrelease update of v0.11.0 changelog (by @AndreyAkinshin) b7f7fc Handle private types in GetCorrectCSharpTypeName, fixes #840 (by @AndreyAkinshin) 522158 Handle private types in GetCorrectCSharpTypeName (part 2), fixes #840 (by @AndreyAkinshin) 64acde small typo (#839) (by @Tornhoof) 521c22 Add travis_wait for build.sh (by @AndreyAkinshin) a8a0da Update BenchmarkDotNet.sln.DotSettings (by @AndreyAkinshin) 9ab58a Introduce BenchmarkDotNet.Samples.csproj.DotSettings (by @AndreyAkinshin) 3ce9fe BenchmarkDotNet.Samples Cleanup (by @AndreyAkinshin) a04a23 Cleanup: spelling issues in BenchmarkDotNet (by @AndreyAkinshin) c37784 Cleanup: code style issues in BenchmarkDotNet (by @AndreyAkinshin) 5f8452 Cleanup: Redundancies in Code issues in BenchmarkDotNet (by @AndreyAkinshin) a76f43 Cleanup: Common Practices and Code Improvements in BenchmarkDotNet (by @AndreyAkinshin) 2d0629 Cleanup: Redundancies in Symbol Declarations Issues in BenchmarkDotNet (by @AndreyAkinshin) 5a7689 Cleanup: Constraints Violations Issues in BenchmarkDotNet (by @AndreyAkinshin) 02df24 Cleanup: Language Usage Opportunities in BenchmarkDotNet (by @AndreyAkinshin) 93ed39 Cleanup: Potential Code Quality Issues in BenchmarkDotNet (by @AndreyAkinshin) 538f56 Cleanup: more issues in BenchmarkDotNet (by @AndreyAkinshin) 559773 Cleanup: more issues in BenchmarkDotNet (by @AndreyAkinshin) 29471e add support for BigIntegers + include namespace of the arugments, fixes #850 (by @adamsitnik) 2aff9f Handle double and float special values like NaN, PositiveInfinity etc, fixes ... (by @adamsitnik) 1a68ed properties of SummaryStyle must have public setter (by @adamsitnik) 5cfb5b support DateTimes for [Arguments/Params Source], fixes #853 (by @adamsitnik) 2be698 Fix RPlots, fixes #852 (by @AndreyAkinshin) 7ee3cf Exclude Directory.Build.props/targets from generated csproj files (by @agocke) 20e901 Merge pull request #854 from agocke/fix-csproj-template (by @adamsitnik) de152c allow the users to run benchmarks with CoreRun, #857 (by @adamsitnik) f00ac0 Increase travis timeout (by @AndreyAkinshin) 071e58 docs: add changelog for v0.11.1 (by @AndreyAkinshin) c5e586 Set library version: 0.11.1 (by @AndreyAkinshin) Contributors (4) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Andy Gocke (@agocke) Stefan (@Tornhoof) Thank you very much! Additional details Date: August 22, 2018 Milestone: v0.11.1 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.1 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.1"
  },
  "changelog/v0.11.2.html": {
    "href": "changelog/v0.11.2.html",
    "title": "BenchmarkDotNet v0.11.2 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.11.2 This release includes many PRs from the Hacktoberfest. We are very grateful to all the contributors who spent their time to help us make BenchmarkDotNet even better! Highlights In this release, we have many improvements in different areas: Diagnosers EtwProfiler (allows profiling benchmarks on Windows and exporting the data to a trace file) Execution: Comparing NuGet packages (now it's possible to compare different versions of the same package) .NET Core 3.0 support Deferred Execution Validator Command-line: --list: List of benchmarks --info: Print environment info --runtimes: Choosing execution runtimes (--runtimes net472 netcoreapp2.1 will executed a benchmark on .NET 4.7.2 and .NET Core 2.1) Options for number of invocations and iterations Custom default settings for console argument parser Case-insensitive filter Benchmarking with different CoreRun instances Hardware counters command-line support Exporters: Markdown output for DisassemblyDiagnoser Diff view for disassembler output Improved LINQPad support (colored monospaced logs) Better CPU brand strings Attributes: Async [GlobalSetup] and [GlobalCleanup] support Introduced [ParamsAllValues] Selecting Baseline across Methods and Jobs Statistics: Better statistical tests (Welch's t-test and Mann-Whitney U-test) ZeroMeasurementAnalyser RatioColumn Other: Azure Pipelines support for internal builds Many minor bug fixes Improved documentation New tests Diagnosers EtwProfiler EtwProfiler allows to profile the benchmarked .NET code on Windows and exports the data to a trace file which can be opened with PerfView or Windows Performance Analyzer. EtwProfiler uses TraceEvent library which internally uses Event Tracing for Windows (ETW) to capture stack traces and important .NET Runtime events. Before the process with benchmarked code is started, EtwProfiler starts User and Kernel ETW sessions. Every session writes data to it's own file and captures different data. User session listens for the .NET Runtime events (GC, JIT etc) while the Kernel session gets CPU stacks and Hardware Counter events. After this, the process with benchmarked code is started. During the benchmark execution all the data is captured and written to a trace file. Moreover, BenchmarkDotNet Engine emits it's own events to be able to differentiate jitting, warmup, pilot and actual workload when analyzing the trace file. When the benchmarking is over, both sessions are closed and the two trace files are merged into one. You can find more details in the documentation and in the blog post by Adam Sitnik. #878 EtwProfiler Diagnoser (by @adamsitnik) 04a715 EtwProfiler Diagnoser (#878) (by @adamsitnik) Execution Comparing NuGet packages Now it's possible to compare performance of several versions of the same NuGet package. An example: [Config(typeof(Config))] public class IntroNuGet { // Specify jobs with different versions of the same NuGet package to benchmark. // The NuGet versions referenced on these jobs must be greater or equal to the // same NuGet version referenced in this benchmark project. // Example: This benchmark project references Newtonsoft.Json 9.0.1 private class Config : ManualConfig { public Config() { var baseJob = Job.MediumRun.With(CsProjCoreToolchain.Current.Value); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"11.0.2\").WithId(\"11.0.2\")); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"11.0.1\").WithId(\"11.0.1\")); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"10.0.3\").WithId(\"10.0.3\")); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"10.0.2\").WithId(\"10.0.2\")); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"10.0.1\").WithId(\"10.0.1\")); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"9.0.1\").WithId(\"9.0.1\")); } } [Benchmark] public void SerializeAnonymousObject() => JsonConvert.SerializeObject( new { hello = \"world\", price = 1.99, now = DateTime.UtcNow }); } See also: BenchmarkDotNet.Samples.IntroNuGet #290 Question: Any official way to benchmark same method between different assembly versions? #931 Same NuGet version used when benchmarking different packages #922 Enables benchmarking betweeen different Nuget packages (by @Shazwazza) #932 Partition benchmark run info based on added nuget packages (by @blairconrad) 92a786 Enables benchmarking betweeen different Nuget packages (#922) fixes #290 (by @Shazwazza) 510685 Partition benchmark run info based on added nuget packages (#932) (by @blairconrad) cf84a4 NuGet casing fix (by @AndreyAkinshin) .NET Core 3.0 support Now it's possible to run benchmarks on preview versions of .NET Core 3.0. #874 .NET Core 3.0 support (assignee: @adamsitnik) 2e398c detect .NET Core 3.0 and use the appropriate target framework moniker, fixes ... (by @adamsitnik) Deferred Execution Validator In LINQ, execution of a query is usually deferred until the moment when you actually request the data. If your benchmark just returns IEnumerable or IQueryable it's not measuring the execution of the query, just the creation. This is why we decided to warn you about this issue whenever it happens: Benchmark IntroDeferredExecution.Wrong returns a deferred execution result (IEnumerable<Int32>). You need to either change the method declaration to return a materialized result or consume it on your own. You can use .Consume() extension method to do that. Don't worry! We are also providing you with a Consume extension method which can execute given IEnumerable or IQueryable and consume its results. All you need to do is to create a Consumer instance, preferably store it in a field (to exclude the cost of creating Consumer from the benchmark itself) and pass it to Consume extension method. Do not call .ToArray() because it's an expensive operation and it might dominate given benchmark! See also: BenchmarkDotNet.Samples.IntroDeferredExecution #858 Should the Engine iterate over and consume IEnumerable and IQueryable results? (assignee: @adamsitnik) cebe2a Deferred Execution Validator, fixes #858 (by @adamsitnik) Command-line In this release, we have tons of improvements for command-line experience. --list: List of benchmarks The --list allows you to print all of the available benchmark names. Available options are: flat - prints list of the available benchmarks: --list flat BenchmarkDotNet.Samples.Algo_Md5VsSha256.Md5 BenchmarkDotNet.Samples.Algo_Md5VsSha256.Sha256 BenchmarkDotNet.Samples.IntroArguments.Benchmark BenchmarkDotNet.Samples.IntroArgumentsSource.SingleArgument BenchmarkDotNet.Samples.IntroArgumentsSource.ManyArguments BenchmarkDotNet.Samples.IntroArrayParam.ArrayIndexOf BenchmarkDotNet.Samples.IntroArrayParam.ManualIndexOf BenchmarkDotNet.Samples.IntroBasic.Sleep [...] tree - prints tree of the available benchmarks: --list tree BenchmarkDotNet └─Samples ├─Algo_Md5VsSha256 │ ├─Md5 │ └─Sha256 ├─IntroArguments │ └─Benchmark ├─IntroArgumentsSource │ ├─SingleArgument │ └─ManyArguments ├─IntroArrayParam │ ├─ArrayIndexOf │ └─ManualIndexOf ├─IntroBasic │ ├─Sleep [...] The --list option works with the --filter option. Examples: --list flat --filter *IntroSetupCleanup* prints: BenchmarkDotNet.Samples.IntroSetupCleanupGlobal.Logic BenchmarkDotNet.Samples.IntroSetupCleanupIteration.Benchmark BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkA BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkB BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkC BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkD --list tree --filter *IntroSetupCleanup* prints: BenchmarkDotNet └─Samples ├─IntroSetupCleanupGlobal │ └─Logic ├─IntroSetupCleanupIteration │ └─Benchmark └─IntroSetupCleanupTarget ├─BenchmarkA ├─BenchmarkB ├─BenchmarkC └─BenchmarkD #905 Implement --list #914 Implement --list - fixes #905 (by @wojtpl2) #916 Update console-args.md - add information about --list option (by @wojtpl2) 330f66 Implement --list - fixes #905 (#914) (by @wojtpl2) 6c7521 Update console-args.md - add information about --list option (#916) (by @wojtpl2) --info: Print environment info Some of our users really like the info we print about hardware and OS. Now we have the --info console line argument which does not run the benchmarks, but simply prints the info. BenchmarkDotNet=v0.11.1.786-nightly, OS=Windows 10.0.17134.285 (1803/April2018Update/Redstone4) Intel Xeon CPU E5-1650 v4 3.60GHz, 1 CPU, 12 logical and 6 physical cores Frequency=3507500 Hz, Resolution=285.1033 ns, Timer=TSC .NET Core SDK=3.0.100-alpha1-009642 [Host] : .NET Core 3.0.0-preview1-27004-04 (CoreCLR 4.6.27003.04, CoreFX 4.6.27003.02), 64bit RyuJIT #904 Implement --info #907 fixes #904 Implement --info (by @lahma) 4be28d fixes #904 Implement --info (#907) (by @lahma) --runtimes: Choosing execution runtimes The --runtimes or just -r allows you to run the benchmarks for selected Runtimes. Available options are: Mono, CoreRT, Core, Clr net46, net461, net462, net47, net471, net472, netcoreapp2.0, netcoreapp2.1, netcoreapp2.2, netcoreapp3.0. Example: run the benchmarks for .NET 4.7.2 and .NET Core 2.1: dotnet run -c Release -- --runtimes net472 netcoreapp2.1 #913 .NET Core Toolchains improvements (by @adamsitnik) 0f721c make it possible to specify runtimes using explicit tfms like net472 or netco... (by @adamsitnik) 1c581e .NET Core Toolchains improvements (#913) (by @adamsitnik) Options for number of invocations and iterations --launchCount - how many times we should launch process with target benchmark. The default is 1. --warmupCount - how many warmup iterations should be performed. If you set it, the minWarmupCount and maxWarmupCount are ignored. By default calculated by the heuristic. --minWarmupCount - minimum count of warmup iterations that should be performed. The default is 6. --maxWarmupCount - maximum count of warmup iterations that should be performed. The default is 50. --iterationTime - desired time of execution of an iteration. Used by Pilot stage to estimate the number of invocations per iteration. 500ms by default. --iterationCount - how many target iterations should be performed. By default calculated by the heuristic. --minIterationCount - minimum number of iterations to run. The default is 15. --maxIterationCount - maximum number of iterations to run. The default is 100. --invocationCount - invocation count in a single iteration. By default calculated by the heuristic. --unrollFactor - how many times the benchmark method will be invoked per one iteration of a generated loop. 16 by default --runOncePerIteration - run the benchmark exactly once per iteration. False by default. Example: run single warmup iteration, from 9 to 12 actual workload iterations. dotnet run -c Release -- --warmupCount 1 --minIterationCount 9 --maxIterationCount 12 #902 More command line args (by @adamsitnik) ba0d22 allow to configure the number of invocations and iterations from command line (by @adamsitnik) Custom default settings for console argument parser If you want to have a possibility to specify custom default Job settings programmatically and optionally overwrite it with console line arguments, then you should create a global config with single job marked as .AsDefault and pass it to BenchmarkSwitcher together with the console line arguments. Example: run single warmup iteration by default. static void Main(string[] args) => BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args, GetGlobalConfig()); static IConfig GetGlobalConfig() => DefaultConfig.Instance .With(Job.Default .WithWarmupCount(1) .AsDefault()); // the KEY to get it working Now, the default settings are: WarmupCount=1 but you might still overwrite it from console args like in the example below: dotnet run -c Release -- --warmupCount 2 Case-insensitive filter The --filter or just -f allows you to filter the benchmarks by their full name (namespace.typeName.methodName) using glob patterns. Examples: Run all benchmarks from System.Memory namespace: -f System.Memory* Run all benchmarks: -f * Run all benchmarks from ClassA and ClassB -f *ClassA* *ClassB* Now this filter expression is case-insensitive. #864 Make the filter case insensitive (assignee: @adamsitnik) 106777 make the filter case insensitive invariant culture, fixes #864 (by @adamsitnik) Benchmarking with different CoreRun instances CoreRun is a simpler version of dotnet run, used for developing CoreCLR and CoreFX. Typically when working on the performance of .NET Core a developer has more than 1 copy of CoreRun. Example: CoreRun before my changes, and after my changes. This change allows to simply run same benchmark for few different CoreRuns to compare the perf in easy way. Sample usage: dotnet run -c Release -f netcoreapp2.1 -- -f *Empty.method --job dry --coreRun C:\\Projects\\coreclr_upstream\\bin\\tests\\Windows_NT.x64.Release\\Tests\\Core_Root\\CoreRun.exe C:\\Projects\\coreclr_upstream\\bin\\tests\\Windows_NT.x64.Release\\Tests\\Core_Root_beforeMyChanges\\CoreRun.exe Sample output: #925 Make it possible to run the benchmark with multiple CoreRun.exe (assignee: @adamsitnik) 901616 when user provides CoreRun path and runtime in explicit way, we should use th... (by @adamsitnik) 46bebf allow the users to run the same benchmarks using few different CoreRun.exe, f... (by @adamsitnik) Hardware counters command-line support --counters CacheMisses+InstructionRetired 1e3df7 make it possible to specify hardware counters from command line (by @adamsitnik) a4f91a better handling of edge cases for parsing hardware counters from the console ... (by @adamsitnik) Exporters Markdown output for DisassemblyDiagnoser Now DisassemblyDiagnoser generates markdown version of the assembly listing. #560 Suggestion: markdown output for DisassemblyDiagnoser (assignee: @adamsitnik) 1e6235 github markdown exporter for Disassembler, fixes #560 (by @adamsitnik) Diff view for disassembler output Now we have PrettyGithubMarkdownDiffDisassemblyExporter which can generates nice diffs between assembly listings. This mode can be activated via the --disasmDiff command line argument or the printDiff: true argument of DisassemblyDiagnoserConfig. An output example (Diff between SumLocal and SumField on .NET Core 2.1.4 (CoreCLR 4.6.26814.03, CoreFX 4.6.26814.02), 64bit RyuJIT) -; BenchmarkDotNet.Samples.IntroDisassemblyRyuJit.SumLocal() - var local = field; // we use local variable that points to the field - ^^^^^^^^^^^^^^^^^^ - mov rax,qword ptr [rcx+8] +; BenchmarkDotNet.Samples.IntroDisassemblyRyuJit.SumField() int sum = 0; ^^^^^^^^^^^^ - xor edx,edx - for (int i = 0; i < local.Length; i++) + xor eax,eax + for (int i = 0; i < field.Length; i++) ^^^^^^^^^ - xor ecx,ecx - for (int i = 0; i < local.Length; i++) + xor edx,edx + for (int i = 0; i < field.Length; i++) ^^^^^^^^^^^^^^^^ - mov r8d,dword ptr [rax+8] - test r8d,r8d + mov rcx,qword ptr [rcx+8] + cmp dword ptr [rcx+8],0 jle M00_L01 - sum += local[i]; + sum += field[i]; ^^^^^^^^^^^^^^^^ M00_L00: - movsxd r9,ecx - add edx,dword ptr [rax+r9*4+10h] - for (int i = 0; i < local.Length; i++) + mov r8,rcx + cmp edx,dword ptr [r8+8] + jae 00007ff9`0c412c1f + movsxd r9,edx + add eax,dword ptr [r8+r9*4+10h] + for (int i = 0; i < field.Length; i++) ^^^ - inc ecx - cmp r8d,ecx + inc edx + cmp dword ptr [rcx+8],edx jg M00_L00 return sum; ^^^^^^^^^^^ M00_L01: - mov eax,edx -; Total bytes of code 34 + add rsp,28h +; Total bytes of code 42 #544 Diff view for disassembler output (assignee: @wojtpl2) #927 Improve Disassembly exporters and add PrettyGithubMarkdownDiffDisassemblyExporter (by @wojtpl2) #936 Producing the asm diff reports on demand #937 Producing the asm diff reports on demand - fix for #936 (by @wojtpl2) 1903a1 Improve Disassembly exporters and add PrettyGithubMarkdownDiffDisassemblyExpo... (by @wojtpl2) dd103b Producing the asm diff reports on demand - fixes #936 (#937) (by @wojtpl2) Improved LINQPad support If you run BenchmarkDotNet v0.11.2+ in LINQPad, your logs will be colored and monospaced: #447 Implement ColoredLogger for LinqPad #903 Add LINQPad logging (by @bgrainger) #915 Use a monospaced font for LINQPad logging output (by @bgrainger) c3b609 Add LINQPad logging (#903) (by @bgrainger) 10fdd0 Use a monospaced font for LINQPad logging output. (#915) (by @bgrainger) Better CPU brand strings We did a lot of changes which improve the presentation form of the CPU brand string. Here is an example of such string in the previous version of BenchmarkDotNet: AMD Ryzen 7 2700X Eight-Core Processor (Max: 4.10GHz), 1 CPU, 16 logical and 8 physical cores Now it becomes: AMD Ryzen 7 2700X 4.10GHz, 1 CPU, 16 logical and 8 physical cores As you can see, \"Eight-Core Processor\" was removed (because we already have \"8 physical cores\"); \"(Max: 4.10GHz)\" was replaced by 4.10GHz (because the original CPU brand string doesn't contain the nominal frequency). #859 Strange max frequency values on Windows (assignee: @Rizzen) #909 Improve CPU Brand Strings without frequency #860 Fix strange CPU Frequency values (by @Rizzen) #910 Simplify AMD Ryzen CPU brand info (by @lahma) a78b38 Fix strange CPU Frequency values (#860) (by @Rizzen) 5df1e6 Simplify AMD Ryzen CPU brand info (#910) (by @lahma) Attributes Async GlobalSetup and GlobalCleanup Now GlobalSetup and GlobalCleanup methods can be async. See also: docs.setup-and-cleanup #521 Support async Setup/Cleanup #892 Added support for async GlobalSetup. (by @dlemstra) #923 async GlobalCleanup support (by @dlemstra) #926 Added support for async GlobalCleanup. (by @dlemstra) e0f7a6 Added support for async GlobalSetup. (#892) (by @dlemstra) a971a4 async GlobalCleanup support (#923) (by @dlemstra) e4c7b8 Added support for async GlobalCleanup. (#926), fixes #521 (by @dlemstra) Introduced ParamsAllValues If you want to use all possible values of an enum or another type with a small number of values, you can use the [ParamsAllValues] attribute, instead of listing all the values by hand. The types supported by the attribute are: bool any enum that is not marked with [Flags] Nullable<T>, where T is an enum or boolean An example: public class IntroParamsAllValues { public enum CustomEnum { A, BB, CCC } [ParamsAllValues] public CustomEnum E { get; set; } [ParamsAllValues] public bool? B { get; set; } [Benchmark] public void Benchmark() { Thread.Sleep( E.ToString().Length * 100 + (B == true ? 20 : B == false ? 10 : 0)); } } Output: Method | E | B | Mean | Error | ---------- |---- |------ |---------:|------:| Benchmark | A | ? | 101.9 ms | NA | Benchmark | A | False | 111.9 ms | NA | Benchmark | A | True | 122.3 ms | NA | Benchmark | BB | ? | 201.5 ms | NA | Benchmark | BB | False | 211.8 ms | NA | Benchmark | BB | True | 221.4 ms | NA | Benchmark | CCC | ? | 301.8 ms | NA | Benchmark | CCC | False | 312.3 ms | NA | Benchmark | CCC | True | 322.2 ms | NA | // * Legends * E : Value of the 'E' parameter B : Value of the 'B' parameter #658 [Params] for enums should include all values by default #908 Added [ParamsAllValues] (by @gsomix) 922dff Added [ParamsAllValues] (#908), fixes #658 (by @gsomix) 846d08 ParamsAllValuesValidator fixes (by @AndreyAkinshin) Selecting Baseline across Methods and Jobs Now it's possible to mark a method and a job as baselines at the same time: public class TheBaselines { [Benchmark(Baseline = true)] public void Sleep100ms() => Thread.Sleep(TimeSpan.FromMilliseconds(100)); [Benchmark] public void Sleep50ms() => Thread.Sleep(TimeSpan.FromMilliseconds(50)); } static void Main(string[] args) => BenchmarkSwitcher .FromTypes(new[] { typeof(TheBaselines) }) .Run(args, DefaultConfig.Instance .With(Job.Core.AsBaseline()) .With(Job.Clr.WithId(\"CLR 4.7.2\"))); #880 Select Baseline across Methods and Jobs (assignee: @AndreyAkinshin) 21a007 Support method-job baseline pairs, fixes #880 (by @AndreyAkinshin) Statistics Statistical tests In this release, statistical testing was significantly improved. Now it's possible to compare all benchmarks against baseline with the help of Welch's t-test or Mann–Whitney U test. An example: [StatisticalTestColumn( StatisticalTestKind.Welch, ThresholdUnit.Microseconds, 1, true)] [StatisticalTestColumn( StatisticalTestKind.MannWhitney, ThresholdUnit.Microseconds, 1, true)] [StatisticalTestColumn( StatisticalTestKind.Welch, ThresholdUnit.Ratio, 0.03, true)] [StatisticalTestColumn( StatisticalTestKind.MannWhitney, ThresholdUnit.Ratio, 0.03, true)] [SimpleJob(warmupCount: 0, targetCount: 5)] public class IntroStatisticalTesting { [Benchmark] public void Sleep50() => Thread.Sleep(50); [Benchmark] public void Sleep97() => Thread.Sleep(97); [Benchmark] public void Sleep99() => Thread.Sleep(99); [Benchmark(Baseline = true)] public void Sleep100() => Thread.Sleep(100); [Benchmark] public void Sleep101() => Thread.Sleep(101); [Benchmark] public void Sleep103() => Thread.Sleep(103); [Benchmark] public void Sleep150() => Thread.Sleep(150); } Output: Method Mean Error StdDev Ratio Welch(1us)/p-values Welch(3%)/p-values MannWhitney(1us)/p-values MannWhitney(3%)/p-values Sleep50 53.13 ms 0.5901 ms 0.1532 ms 0.51 Faster: 1.0000/0.0000 Faster: 1.0000/0.0000 Faster: 1.0000/0.0040 Faster: 1.0000/0.0040 Sleep97 100.07 ms 0.9093 ms 0.2361 ms 0.97 Faster: 1.0000/0.0000 Same: 1.0000/0.1290 Faster: 1.0000/0.0040 Same: 1.0000/0.1111 Sleep99 102.23 ms 2.4462 ms 0.6353 ms 0.99 Faster: 0.9928/0.0072 Same: 1.0000/0.9994 Faster: 0.9960/0.0079 Same: 1.0000/1.0000 Sleep100 103.34 ms 0.8180 ms 0.2124 ms 1.00 Base: 0.5029/0.5029 Base: 1.0000/1.0000 Base: 0.7262/0.7262 Base: 1.0000/1.0000 Sleep101 103.73 ms 2.1591 ms 0.5607 ms 1.00 Same: 0.1041/0.8969 Same: 0.9999/1.0000 Same: 0.1111/0.9246 Same: 1.0000/1.0000 Sleep103 106.21 ms 1.2511 ms 0.3249 ms 1.03 Slower: 0.0000/1.0000 Same: 0.9447/1.0000 Slower: 0.0040/1.0000 Same: 0.9246/1.0000 Sleep150 153.16 ms 3.4929 ms 0.9071 ms 1.48 Slower: 0.0000/1.0000 Slower: 0.0000/1.0000 Slower: 0.0040/1.0000 Slower: 0.0040/1.0000 // * Legends * Mean : Arithmetic mean of all measurements Error : Half of 99.9% confidence interval StdDev : Standard deviation of all measurements Ratio : Mean of the ratio distribution ([Current]/[Baseline]) Welch(1us)/p-values : Welch-based TOST equivalence test with 1 us threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' Welch(3%)/p-values : Welch-based TOST equivalence test with 3% threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' MannWhitney(1us)/p-values : MannWhitney-based TOST equivalence test with 1 us threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' MannWhitney(3%)/p-values : MannWhitney-based TOST equivalence test with 3% threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' 1 ms : 1 Millisecond (0.001 sec) The statistical testing is a work-in-progress feature. In future versions of BenchmarkDotNet, we are planning to improve API, fill missed docs, and introduce more parameters for customization. See also: BenchmarkDotNet.Samples.IntroStatisticalTesting 60eca0 Threshold API for WelchTTest; Improve Student accuracy for small n (by @AndreyAkinshin) 05cc8d Statistical testing improvements (by @AndreyAkinshin) ZeroMeasurementAnalyser When you have an empty benchmark like this [Benchmark] public void Empty() { } The expected duration of this method is zero. However, you can get the mean value like 0.0023ns because of the natural noise. It's a pretty confusing result for many developers. Since v0.11.2, we have ZeroMeasurementAnalyser which warn you about such methods. By default, BenchmarkDotNet automatically evaluate overhead. In this case, ZeroMeasurementAnalyser runs Welch's t-test and compare actual and overhead measurements. If the overhead evaluation is disabled, it runs one-sample Student's t-test against a half of CPU cycle. #906 Zero measurement analyser (by @Rizzen) 48d193 Zero measurement analyser (#906) (by @Rizzen) RatioColumn The Ratio column was formerly known as Scaled. The old title was a source of misunderstanding and confusion because many developers interpreted it as the ratio of means (e.g., 50.46/100.39 for Time50). The ratio of distribution means and the mean of the ratio distribution are pretty close to each other in most cases, but they are not equal. See also: BenchmarkDotNet.Samples.IntroBenchmarkBaseline, BenchmarkDotNet.Samples.IntroRatioSD, Benchmark and Job Baselines. 4e64c9 Ratio/RatioSD columns (by @AndreyAkinshin) Milestone details In the v0.11.2 scope, 28 issues were resolved and 33 pull requests were merged. This release includes 84 commits by 20 contributors. Resolved issues (28) #221 Investigate why CanEnableServerGcMode test fails for Core on appveyor #290 Question: Any official way to benchmark same method between different assembly versions? #447 Implement ColoredLogger for LinqPad #521 Support async Setup/Cleanup #544 Diff view for disassembler output (assignee: @WojciechNagorski) #560 Suggestion: markdown output for DisassemblyDiagnoser (assignee: @adamsitnik) #601 Surprising results #658 [Params] for enums should include all values by default #731 Add constant folding analyser #788 Detect correct version of .NET Core in Docket container #842 Benchmark filter: wildcards on *nix CLI (assignee: @adamsitnik) #858 Should the Engine iterate over and consume IEnumerable and IQueryable results? (assignee: @adamsitnik) #859 Strange max frequency values on Windows (assignee: @Rizzen) #862 Don't print parse errors to the output (assignee: @adamsitnik) #863 Make it easier to understand which process belongs to which benchmark (assignee: @adamsitnik) #864 Make the filter case insensitive (assignee: @adamsitnik) #874 .NET Core 3.0 support (assignee: @adamsitnik) #879 Benchmark attributed with \"HardwareCounters\" throws an exception (assignee: @adamsitnik) #880 Select Baseline across Methods and Jobs (assignee: @AndreyAkinshin) #889 ArgumentsSource doesn't work if method takes 1 arg (assignee: @adamsitnik) #891 Add docs about debugging BDN issues (assignee: @adamsitnik) #904 Implement --info #905 Implement --list #909 Improve CPU Brand Strings without frequency #911 Excluding specific namespaces from disassembly (assignee: @adamsitnik) #925 Make it possible to run the benchmark with multiple CoreRun.exe (assignee: @adamsitnik) #931 Same NuGet version used when benchmarking different packages #936 Producing the asm diff reports on demand Merged pull requests (33) #860 Fix strange CPU Frequency values (by @Rizzen) #878 EtwProfiler Diagnoser (by @adamsitnik) #886 Enabled GcModeTests.CanEnableServerGcMode (by @dlemstra) #887 Dependencies update (by @adamsitnik) #888 Fix duplicate example in RunStrategy guide (by @SteveDesmond-ca) #890 RPlotExporter: use https to download dependencies (by @xavero) #892 Added support for async GlobalSetup. (by @dlemstra) #894 Fix GlobalCleanupAttributeTest.GlobalCleanupMethodRunsTest (by @dlemstra) #898 Add workaround for Full framework on *NIX (by @mfilippov) #900 Fixing aspnet/KestrelHttpServer url (by @facundofarias) #901 Fixing SignalR and EntityFrameworkCore url as well (by @facundofarias) #902 More command line args (by @adamsitnik) #903 Add LINQPad logging (by @bgrainger) #906 Zero measurement analyser (by @Rizzen) #907 fixes #904 Implement --info (by @lahma) #908 Added [ParamsAllValues] (by @gsomix) #910 Simplify AMD Ryzen CPU brand info (by @lahma) #913 .NET Core Toolchains improvements (by @adamsitnik) #914 Implement --list - fixes #905 (by @WojciechNagorski) #915 Use a monospaced font for LINQPad logging output (by @bgrainger) #916 Update console-args.md - add information about --list option (by @WojciechNagorski) #917 Add Azure Pipelines support (by @Ky7m) #920 OCD Whitespace and tabs cleanup (by @dlemstra) #922 Enables benchmarking betweeen different Nuget packages (by @Shazwazza) #923 async GlobalCleanup support (by @dlemstra) #926 Added support for async GlobalCleanup. (by @dlemstra) #927 Improve Disassembly exporters and add PrettyGithubMarkdownDiffDisassemblyExporter (by @WojciechNagorski) #929 Add build status badges for Azure Pipelines (by @Ky7m) #930 Fix minor spelling issues and typos (by @KonH) #932 Partition benchmark run info based on added nuget packages (by @blairconrad) #934 Detect correct version of .NET Core in Docker (by @Rizzen) #935 Add Timeout for dotnet cli build commands to our toolchains (by @adamsitnik) #937 Producing the asm diff reports on demand - fix for #936 (by @WojciechNagorski) Commits (84) 22b020 Postrelease update of v0.11.1 changelog (by @AndreyAkinshin) 3e26df docs: fix NuGet package lists in footers (v0.11.x) (by @AndreyAkinshin) cebe2a Deferred Execution Validator, fixes #858 (by @adamsitnik) 50fd57 exported json file should contain correct type name for generic types, not Ge... (by @adamsitnik) 30b885 benchmarked code can be defining IHost so we need to provide full name (examp... (by @adamsitnik) b7104e Don't print parse errors to the output, fixes #862 (by @adamsitnik) 3a21b4 Make it easier to understand which process belongs to which benchmark, fixes ... (by @adamsitnik) 99ea2d Fix behavior of Baseline property of Benchmark attribute in integration with ... (by @Caballero77) 2e398c detect .NET Core 3.0 and use the appropriate target framework moniker, fixes ... (by @adamsitnik) ff1214 Update IntroSetupCleanupTarget.md (#876) (by @fredeil) 1721b4 Fixed typo in the NodaTime name (#877) (by @YohDeadfall) f411a5 Fix typo in example code (#869) (by @NRKirby) 21a007 Support method-job baseline pairs, fixes #880 (by @AndreyAkinshin) a78b38 Fix strange CPU Frequency values (#860) (by @Rizzen) 60eca0 Threshold API for WelchTTest; Improve Student accuracy for small n (by @AndreyAkinshin) 05cc8d Statistical testing improvements (by @AndreyAkinshin) 557752 Fix compilation (by @AndreyAkinshin) a03307 Enabled GcModeTests.CanEnableServerGcMode (#886) fixes #221 (by @dlemstra) add585 Fix duplicate example in RunStrategy guide (#888) (by @SteveDesmond-ca) d8b008 Use NoInlining for CommonExporterApprovalTests (by @AndreyAkinshin) eacfd7 Dependencies update (#887) (by @adamsitnik) 579986 improve the docs, explain how to use ArgumentsSource for single arugment, fix... (by @adamsitnik) 1ceee3 Fix compilation after merge (by @AndreyAkinshin) 9ff772 RPlotExporter: use https to download dependencies (#890) (by @xavero) 41d6b8 added xml docs, made some methods virtual/public to make it easier to write y... (by @adamsitnik) cd0791 restore --no-dependencies was good when we were generating multiple projects,... (by @adamsitnik) ad1feb expose KeepBenchmarkFiles as --keepFiles command line argument, #891 (by @adamsitnik) 6880b5 add DebugInProcessConfig and DebugBuildConfig to make troubleshooting easier,... (by @adamsitnik) 12e01a add Troubleshooting docs, fixes #891 (by @adamsitnik) 106777 make the filter case insensitive invariant culture, fixes #864 (by @adamsitnik) 1b8051 wrap * in '*' on Unix when showing users the help, fixes #842 (by @adamsitnik) 382a4a Fix GlobalCleanupAttributeTest.GlobalCleanupMethodRunsTest (#894) (by @dlemstra) 0f721c make it possible to specify runtimes using explicit tfms like net472 or netco... (by @adamsitnik) 1e3df7 make it possible to specify hardware counters from command line (by @adamsitnik) ba0d22 allow to configure the number of invocations and iterations from command line (by @adamsitnik) b90be6 Add workaround for Full framework on *NIX (#898) (by @mfilippov) 4afdb8 Fixing aspnet/KestrelHttpServer url (#900) (by @facundofarias) 3319ab Fixing SignalR and EntityFrameworkCore url as well (#901) (by @facundofarias) b72aab allow the users to specify programmatically custom default job settings and o... (by @adamsitnik) 2e7042 Merge pull request #902 from dotnet/moreCommandLineArgs (by @adamsitnik) 04a715 EtwProfiler Diagnoser (#878) (by @adamsitnik) 220bae DotNetCliGenerator.TargetFrameworkMoniker must be public (by @adamsitnik) 4e64c9 Ratio/RatioSD columns (by @AndreyAkinshin) 177c07 Add Windows 10 (1809) in OsBrandStringHelper (by @AndreyAkinshin) 4be28d fixes #904 Implement --info (#907) (by @lahma) c3b609 Add LINQPad logging (#903) (by @bgrainger) 922dff Added [ParamsAllValues] (#908), fixes #658 (by @gsomix) 1e6235 github markdown exporter for Disassembler, fixes #560 (by @adamsitnik) 330f66 Implement --list - fixes #905 (#914) (by @WojciechNagorski) 10fdd0 Use a monospaced font for LINQPad logging output. (#915) (by @bgrainger) 846d08 ParamsAllValuesValidator fixes (by @AndreyAkinshin) 1c581e .NET Core Toolchains improvements (#913) (by @adamsitnik) 8949df BenchmarkSwitcher should ask the user for choosing the benchmarks when the gl... (by @adamsitnik) fb8f89 Make WindowsDisassembler public to allow for late resutls filtering in diagno... (by @adamsitnik) 0bcbce allow configuring disasm recursive depth from console line arguments; --todo; (by @adamsitnik) 5e3cee make sure BenchmarkSwitcher handles all possible cases and gives nice errors (by @adamsitnik) 6c7521 Update console-args.md - add information about --list option (#916) (by @WojciechNagorski) 8773ff when user provides categories via command line to benchmark switcher we don't... (by @adamsitnik) 901616 when user provides CoreRun path and runtime in explicit way, we should use th... (by @adamsitnik) 5df1e6 Simplify AMD Ryzen CPU brand info (#910) (by @lahma) 1b4c7f OCD Whitespace and tabs cleanup (#920) (by @dlemstra) d917e6 don't parse the trace file if there are no counters configured, wait for dela... (by @adamsitnik) e0f7a6 Added support for async GlobalSetup. (#892) (by @dlemstra) 46bebf allow the users to run the same benchmarks using few different CoreRun.exe, f... (by @adamsitnik) a4f91a better handling of edge cases for parsing hardware counters from the console ... (by @adamsitnik) 98925b initial 0.11.2 release notes (by @adamsitnik) a971a4 async GlobalCleanup support (#923) (by @dlemstra) e4c7b8 Added support for async GlobalCleanup. (#926), fixes #521 (by @dlemstra) 92a786 Enables benchmarking betweeen different Nuget packages (#922) fixes #290 (by @Shazwazza) 601c66 Add Azure Pipelines support (#917) (by @Ky7m) f9ac68 Add build status badges (#929) (by @Ky7m) 8a2eec Fix minor spelling issues and typos (#930) (by @KonH) 510685 Partition benchmark run info based on added nuget packages (#932) (by @blairconrad) 1903a1 Improve Disassembly exporters and add PrettyGithubMarkdownDiffDisassemblyExpo... (by @WojciechNagorski) 48d193 Zero measurement analyser (#906) (by @Rizzen) cf84a4 NuGet casing fix (by @AndreyAkinshin) fd459f Remove remark about prerelease version in etwprofiler.md (by @AndreyAkinshin) db444c Add Timeout for dotnet cli build commands to our toolchains (#935) fixes #933 (by @adamsitnik) bb0b18 Detect correct version of .NET Core in Docker (#934), fixes #788 (by @Rizzen) dd103b Producing the asm diff reports on demand - fixes #936 (#937) (by @WojciechNagorski) 864400 Update v0.11.2 changelog (by @AndreyAkinshin) 15c035 Minor IntroSamples fixes (by @AndreyAkinshin) a5b692 Update v0.11.2 changelog (by @AndreyAkinshin) 2341c7 Set library version: 0.11.2 (by @AndreyAkinshin) Contributors (20) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Blair Conrad (@blairconrad) Bradley Grainger (@bgrainger) Caballero77 (@Caballero77) Dirk Lemstra (@dlemstra) Evgeniy Andreev (@gsomix) Facundo Farias (@facundofarias) Flavio Coelho (@xavero) Fredrik Eilertsen (@fredeil) Igor Fesenko (@Ky7m) KonH (@KonH) Mark Tkachenko (@Rizzen) Marko Lahma (@lahma) Mikhail Filippov (@mfilippov) Nick Kirby (@NRKirby) Shannon Deminick (@Shazwazza) Steve Desmond (@SteveDesmond-ca) Wojciech Nagórski (@WojciechNagorski) Yoh Deadfall (@YohDeadfall) Thank you very much! Additional details Date: November 1, 2018 Milestone: v0.11.2 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.2 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.2"
  },
  "changelog/v0.11.3.html": {
    "href": "changelog/v0.11.3.html",
    "title": "BenchmarkDotNet v0.11.3 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.11.3 Highlights This release is focused mainly on bug fixes that were affecting user experience. But don't worry, we have some new features too! Diagnosers ConcurrencyVisualizerProfiler (allows profiling benchmarks on Windows and exporting the data to a trace file which can be opened with Concurrency Visualizer) Command-line: --stopOnFirstError: Stops the benchmarks execution on first error. #947 --statisticalTest: Performs a Mann–Whitney Statistical Test for identifying regressions and improvements. #960 Bug fixes: Dry mode doesn't work because of the ZeroMeasurementHelper #943 MannWhitneyTest fails when comparing statistics of different sample size #948 and #950 Improve the dynamic loading of Diagnostics package #955 BenchmarkRunner.RunUrl throws NRE when Config is not provided #961 Don't require the users to do manual installation of TraceEvent when using Diagnostics package #962 Stop benchmark after closing application + Flush log after stopping benchmark #963 Diagnosers ConcurrencyVisualizerProfiler ConcurrencyVisualizerProfiler allows to profile the benchmarked .NET code on Windows and exports the data to a CVTrace file which can be opened with Concurrency Visualizer. ConcurrencyVisualizerProfiler uses EtwProfiler to get a .etl file which still can be opened with PerfView or Windows Performance Analyzer. The difference is that it also enables all Task and Thread related ETW Providers and exports a simple xml which can be opened with Visual Studio if you install Concurrency Visualizer plugin #964 Concurrency Visualizer Profiler Diagnoser (by @adamsitnik) dfb3c89 ConcurrencyVisualizerProfiler diagnoser! (by @adamsitnik) Command-line In this release, we have some new command-line arguments! --stopOnFirstError: Stops the benchmarks execution on first error When provided, BenchmarkDotNet is going to stop the benchmarks execution on first error. #947 Add option to stop running when the first benchmark fails (by @wojtpl2) --statisticalTest: Statistical Test To perform a Mann–Whitney U Test and display the results in a dedicated column you need to provide the Threshold via --statisticalTest. Examples: 5%, 10ms, 100ns, 1s. Example: run Mann–Whitney U test with relative ratio of 1% for all benchmarks for .NET 4.6 (base), .NET Core 2.0 and .NET Core 2.1. class Program { static void Main(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args); } public class MySample { [Benchmark] public void Sleep() { #if NETFRAMEWORK Thread.Sleep(50); #elif NETCOREAPP2_0 Thread.Sleep(45); #elif NETCOREAPP2_1 Thread.Sleep(55); #endif } [Benchmark] public void Same() => Thread.Sleep(50); } dotnet run -c Release -f netcoreapp2.1 --filter * --runtimes net46 netcoreapp2.0 netcoreapp2.1 --statisticalTest 1% Note: .NET 4.6 will be our baseline because it was provided as first on the runtimes list. Method Runtime Toolchain Mean Error StdDev Ratio MannWhitney(1%) Sleep Clr net46 50.51 ms 0.1833 ms 0.1714 ms 1.00 Base Sleep Core netcoreapp2.0 45.53 ms 0.1262 ms 0.1181 ms 0.90 Faster Sleep Core netcoreapp2.1 55.50 ms 0.1217 ms 0.1138 ms 1.10 Slower Same Clr net46 50.47 ms 0.1795 ms 0.1679 ms 1.00 Base Same Core netcoreapp2.0 50.55 ms 0.1873 ms 0.1752 ms 1.00 Same Same Core netcoreapp2.1 50.55 ms 0.2162 ms 0.2022 ms 1.00 Same Milestone details In the v0.11.3 scope, 10 issues were resolved and 10 pull requests were merged. This release includes 26 commits by 6 contributors. Resolved issues (10) #870 Error after adding OperationsPerInvoke (assignee: @AndreyAkinshin) #885 Closing application dot't stop benchmark (assignee: @WojciechNagorski) #933 Investigate hanging SingleBenchmarkCanBeExecutedForMultipleRuntimes test (assignee: @adamsitnik) #939 We need an option to stop running when the first benchmark fails. (assignee: @WojciechNagorski) #943 Dry mode doesn't work because of the ZeroMeasurementHelper (assignee: @AndreyAkinshin) #948 BenchmarkDotNet.Mathematics.StatisticalTesting.MannWhitneyTest.PValueForSmallN(int n, int m, double u) (assignee: @AndreyAkinshin) #950 MannWhitneyTest fails when comparing statistics of different sample size (assignee: @AndreyAkinshin) #955 Improve the dynamic loading of Diagnostics package (assignee: @WojciechNagorski) #961 BenchmarkRunner.RunUrl throws NRE when Config is not provided #964 Concurrency Visualizer Profiler (assignee: @adamsitnik) Merged pull requests (10) #941 Fix example code (isBaseline -> baseline) (by @PathogenDavid) #944 Fixed typo in IntroTagColumn sample (by @ahmedalejo) #947 Add option to stop running when the first benchmark fails (by @WojciechNagorski) #949 Add printDiff in DisassemblyDiagnoserAttribute (by @WojciechNagorski) #951 Add failing test for #948 (by @WojciechNagorski) #958 Use DependencyContext to load diagnostics assembly (by @WojciechNagorski) #960 Expose StatisticalTestColumn via command line arguments (by @adamsitnik) #962 Don't require the users to do manual installation of TraceEvent when using Diagnostics package (by @WojciechNagorski) #963 Stop benchmark after closing application + Flush log after stopping benchmark. (by @WojciechNagorski) #966 Fix typos in ConfigParser and CommandLineOptions (by @morgan-kn) Commits (26) d85a7e Postrelease update of v0.11.2 changelog (by @AndreyAkinshin) 8b2015 Fix ZeroMeasurementHelper for dry mode case, fixes #943 (by @AndreyAkinshin) ab8543 Fix example code (#941) (by @PathogenDavid) ec5fb2 Enable default analysers in BenchmarkTestExecutor (see #943) (by @AndreyAkinshin) fb251d Remove [DryJob] from IntroBasic (by @AndreyAkinshin) 1c1bdf Fix another problem in ZeroMeasurementAnalyser (see #943) (by @AndreyAkinshin) 348f87 make sure we prevent from inlining the benchmarks also in the dummy method ge... (by @adamsitnik) 80ecec when the parallel build fails, always try one more time in sequential way, ho... (by @adamsitnik) 042291 set the metrics unit to \"Count\", they should not be empty /cc @jorive (by @adamsitnik) 5b3657 Fixed typo in IntroTagColumn sample (#944) (by @ahmedalejo) 60ea17 Add printDiff in DisassemblyDiagnoserAttribute (#949) (by @WojciechNagorski) b6e8b1 Add failing test for #948 (#951) (by @WojciechNagorski) 3e9f73 Fix IndexOutOfRangeException in MannWhitneyTest, fixes #948 (by @AndreyAkinshin) 9f33f0 Add option to stop running when the first benchmark fails (#947) (by @WojciechNagorski) 376a97 Improve dynamic assembly loading fixes #955 (by @WojciechNagorski) 7dffd4 Handle another corner case in AdaptiveHistogramBuilder, fixes #870 (by @AndreyAkinshin) dfb3c8 ConcurrencyVisualizerProfiler diagnoser! (by @adamsitnik) 7e7dde Fix NRE in BenchmarkRunner.RunUrl, fixes #961 (by @AndreyAkinshin) 4e6531 Improve diagnostics dll (#962) (by @WojciechNagorski) 6c4a59 Stop benchmark after closing application + Flush log after stopping benchmark... (by @WojciechNagorski) 51a965 Expose StatisticalTestColumn via command line arguments (#960) (by @adamsitnik) ca188d 0.11.3 initial release notes (by @adamsitnik) adde64 Fix typos in ConfigParser and CommandLineOptions (#966) (by @morgan-kn) ab96ab make sure we cleanup the Logger after running the benchmark, otherwise AppDom... (by @adamsitnik) 91362d Update v0.11.3 changelog (by @AndreyAkinshin) e7e4b5 Set library version: 0.11.3 (by @AndreyAkinshin) Contributors (6) Adam Sitnik (@adamsitnik) Ahmed Alejo (@ahmedalejo) Andrey Akinshin (@AndreyAkinshin) David Maas (@PathogenDavid) Irina Ananeva (@morgan-kn) Wojciech Nagórski (@WojciechNagorski) Thank you very much! Additional details Date: November 20, 2018 Milestone: v0.11.3 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.3 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.3"
  },
  "changelog/v0.11.4.html": {
    "href": "changelog/v0.11.4.html",
    "title": "BenchmarkDotNet v0.11.4 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.11.4 It's been few months since our last release, but we have been working hard and have some new features for you! Highlights Features BenchmarkDotNet as a global tool: a new global tool which allows you to run benchmarks from given library. Now you can run benchmarks from the command line via dotnet benchmark. You can find more information about it in the documentation #1006 #213 InProcessEmitToolchain: new, full-featured InProcess toolchain which allows executing benchmarks in the current process without spawning additional process per benchmark. It supports [Arguments], [ArgumentsSource], passing the arguments by out, ref and returning stack-only types like Span<T>. #919, #921 #843 ARM support: BenchmarkDotNet supports now ARM and ARM64. #780, #979 #385 Mono AOT support: a new toolchain which allows running benchmarks using AOT version of Mono #940 NuGet symbol server support: BenchmarkDotNet publishes now the symbols to NuGet.org symbol server and you can easily debug it. #967 #968 Experimental support for .NET Core 3.0 WPF benchmarks #1066 For a working example please go to https://github.com/dotMorten/WPFBenchmarkTests Improvements: CoreRT Toolchain improvements - thanks to help from CoreRT Team we were able to make the CoreRT Toolchain work with the latest version of CoreRT #1001, #1057 Display the number of benchmarks to run: we now display how many benchmarks are going to be executed before running them and how many remained after running each of them #1048 Better list of suggested benchmarks for wrong filter #834 #957 Invalid assembly binding redirects generated by VS were a pain to many of our users, we have now implemented an approach that tries to work around this issue. #895, #667, #896, #942 Handling duplicates in IConfig #912, #938, #360, #463 Disassembly diagnoser should be kept in a separate directory to avoid dependency conflicts #1059 Give a warning when the [Benchmark] method is static - we now produce an error when users fail into this common issue #983 #985 C# keywords are prohibited as benchmark names #849 File names should be consistent across all OSes - < and > are valid on Unix, but not on Windows. We have unified that and now files produced on Unix and Windows have the same names. #981 Improve restore, build and publish projects #1002, #1013 Make it possible to disable OptimizationsValidator #988 Sort enum parameters by value instead of name #977 Detect .NET Core benchmark failures from LINQPad #980 Improved error logging #1008 Improved disassembly diff #1022 Using invariant culture for Roslyn Toolchain error messages #1042 Use only full names in the auto-generated code to avoid any possible conflicts with user code #1007, #1009 #1010 Write the GitHub table format to the console by default #1062 Proper cleanup on Ctrl+C/console Window exit #1061 Introduce StoppingCriteria - the first step to writing your own heuristic that determines when benchmarking should be stopped #984 Breaking changes: .NET Standard 2.0 only - BenchmarkDotNet has a single target now, which should help with some assembly resolving issues. We had to drop .NET 4.6 support because of that and .NET 4.6.1 is now the oldest supported .NET Framework. #1032 CustomCoreClrToolchain has been removed, it's recommended to use CoreRunToolchain instead #928 Bug fixes: NRE in Summary ctor #986 #987 ArgumentNullException when running benchmarks from published .NET Core app #1018 Dry jobs can eat iteration failures #1045 NullReferenceException in BenchmarkDotNet.Reports.SummaryTable after iteration failure #1046 Running the example throws NullReference #1049 Fix race condition in process output reader #1051 #1053 Fix a rare but really annoying bug where for some reason we were sometimes setting ForegroundColor to the same color as BackgroundColor and some parts of the logged output were invisible commit StopOnFirstError must be respected commit Milestone details In the v0.11.4 scope, 42 issues were resolved and 41 pull requests were merged. This release includes 99 commits by 18 contributors. Resolved issues (42) #213 Add a \"benchmark\" cmd to dotnet #343 FileNotFoundException on mono (assignee: @AndreyAkinshin) #360 Duplicates handling for IConfig (assignee: @adamsitnik) #385 Consider using S.R.InteropServices.RuntimeInformation.ProcessArchitecture instead pointer based detection of platform (assignee: @adamsitnik) #387 Add a mode to BenchmarkSwitcher that allows to run a method inline for profiling (assignee: @adamsitnik) #463 Review interface IConfig (assignee: @adamsitnik) #660 [Params] should not change the order of provided values #667 Does BenchMarkDotnet supports 4.7.1 Dotnet framework (assignee: @adamsitnik) #687 Implement [Arguments] support for InProcessToolchain (assignee: @ig-sinicyn) #714 Test BenchmarkDotNet against unstable/multimodal benchmarks from CoreCLR/CoreFX repo (assignee: @adamsitnik) #780 ARM support (assignee: @adamsitnik) #834 Better list of suggested benchmarks for wrong filter (assignee: @morgan-kn) #843 Exception when returning a stackonly structure in a benchmark case using in-process toolchain (assignee: @ig-sinicyn) #849 C# keywords are prohibited as benchmark names (assignee: @adamsitnik) #895 Could not load file or assembly 'System.ValueTuple, Version=4.0.2.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51' or one of its dependencies (assignee: @adamsitnik) #896 .NET 4.7.1 console app tries to use BenchmarkRunner, gets \"Could not load file or assembly 'System.Runtime, Version=4.1.2.0\" (assignee: @adamsitnik) #919 Feature proposal: full-featured inprocess toolchain (assignee: @ig-sinicyn) #928 Remove CustomCoreClrToolchain (assignee: @adamsitnik) #938 Run benchmark with DisasemblyDiagnoser with --disasam option from console (assignee: @adamsitnik) #942 System.IO.FileNotFoundException: Could not load file or assembly 'System.Runtime, Version=4.1.0.0' after adding BenchmarkDotNet.Diagnostics.Windows (assignee: @adamsitnik) #967 Publish a snupkg to the NuGet.org symbol server (assignee: @WojciechNagorski) #970 False alarm bug report #981 File names should be consistent across all OSes (assignee: @adamsitnik) #982 Invalid string representaiton of CPU Affinity on a machine with more than 32 cores on ARM64 (assignee: @adamsitnik) #983 Give a warning when the [Benchmark] method is static (assignee: @Rizzen) #986 NRE in Summary ctor #988 Make it possible to disable OptimizationsValidator (assignee: @adamsitnik) #998 Missing images in docs (assignee: @AndreyAkinshin) #1002 Multiple build/publish failure with --coreRun toolchain (assignee: @WojciechNagorski) #1007 benchmark cannot have type Action (assignee: @adamsitnik) #1010 Write unit tests which check that BenchmarkProgram.txt doesn't contain usings (assignee: @adamsitnik) #1018 ArgumentNullException when running benchmarks from published .NET Core app #1039 Some tests are broken on Net 461 (culture-dependent thing) (assignee: @ig-sinicyn) #1045 Dry jobs can eat iteration failures (assignee: @adamsitnik) #1046 NullReferenceException in BenchmarkDotNet.Reports.SummaryTable after iteration failure (assignee: @adamsitnik) #1048 Display the number of benchmarks to run (assignee: @adamsitnik) #1049 Running the example throws NullReference (assignee: @adamsitnik) #1051 Fix race condition in process output reader (assignee: @adamsitnik) #1056 Fails to build when targeting .NET Core 3.0 and .NET Framework (assignee: @adamsitnik) #1059 Disassembly diagnoser should be kept in a separate directory to avoid dependency conflicts (assignee: @adamsitnik) #1062 Write the GitHub table format to the console by default (assignee: @adamsitnik) #1065 Allow benchmarking .NET Core Desktop apps (assignee: @adamsitnik) Merged pull requests (41) #912 Duplicates handling for IConfig = big refactor, fixes #360 (by @adamsitnik) #921 InProcessEmitToolchain (by @ig-sinicyn) #940 Add support for mono AOT pass (by @alexanderkyte) #957 Better list of suggested benchmarks for wrong filter #834 (by @morgan-kn) #968 Support Nuget symbol server (by @WojciechNagorski) #969 Disable batch mode and explicitly enable build trigger for master branch (by @Ky7m) #977 sort enum parameters by value instead of name (by @kayle) #979 ARM support (by @adamsitnik) #980 Detect .NET Core benchmark failures from LINQPad (by @Turnerj) #984 Introduce StoppingCriteria (by @AndreyAkinshin) #985 Give a warning when the [Benchmark] method is static (by @Rizzen) #987 Fix NRE in MetricColumn (#986) (by @qbit86) #991 Fix typos (by @0x6a62) #992 Use .NET Standard 2.0 CommandLineParser, Update to net461 for NS2.0 support (by @glennawatson) #996 Rephrase Notes section and fix markdown (by @Maximusya) #997 Remove obsolete info from the docs (by @Maximusya) #999 Synchronize benchmark output with the code in docs (by @Maximusya) #1001 CoreRT toolchain update (by @adamsitnik) #1006 BenchmarkDotNet as global tool (by @CodeTherapist) #1008 Improve error logging to diagnose unstable tests (by @adamsitnik) #1009 Use only full names in the auto-generated code to avoid any possible conflicts with user code (by @adamsitnik) #1012 Changed TargetCount to IterationCount in docs (by @Sitiritis) #1013 Improve restore, build and publish projects - Fix for #1002 (by @WojciechNagorski) #1014 Update IntroRatioSD.md (by @fredeil) #1022 Improve diff disassembly (by @WojciechNagorski) #1032 Target .NET Standard 2.0 only (by @adamsitnik) #1033 BenchmarkDotNet as global tool (#1006), fixes #213 (by @adamsitnik) #1035 Improve global tool (by @WojciechNagorski) #1036 Remove InternalsVisibleTo for Samples application (by @WojciechNagorski) #1038 Change the name of the global tool (by @WojciechNagorski) #1040 Making the new InProcessEmitToolchain work after my recent refactor and .NET Standard 2.0 port (by @adamsitnik) #1041 InProcessEmitToolchain (by @adamsitnik) #1042 Use invariant culture for csc messages (by @ig-sinicyn) #1043 minor InProcess fix: diff now checks for implementation flags (by @ig-sinicyn) #1052 dotnet cli version update + reducing the number of long running tests (by @adamsitnik) #1053 read the process output in a thread safe way, fixes #1051 (by @adamsitnik) #1054 update Travis Ubuntu image from 14.04 to 16.04 (by @adamsitnik) #1055 Allow reflecting on DebuggableAttribute on CoreRT (by @MichalStrehovsky) #1057 CoreRT toolchain improvements (by @adamsitnik) #1061 Proper cleanup on Ctrl+C/console Window exit (by @adamsitnik) #1066 Add experimental support for .NET Core 3.0 WPF benchmarks (by @adamsitnik) Commits (99) 1fac9b Postrelease update of v0.11.3 changelog (by @AndreyAkinshin) 40fae8 Support Nuget symbol server (#968) (by @WojciechNagorski) 69b01f remove batch and explicitly enable build for master (#969) (by @Ky7m) 01992c better error messages for lack of Cli and invalid CoreRun path (by @adamsitnik) 767e02 sort enum parameters by value instead of name (#977), fixes #660 (by @kayle) 128e11 Better list of suggested benchmarks for wrong filter #834 (#957) (by @morgan-kn) c0910a Fix NRE in BaselineRatioColumn.GetRatioStatistics, fixes #970 (by @AndreyAkinshin) 67b675 Fix TimeSpan calculations in DotNetCliCommand.AddPackages (by @AndreyAkinshin) 847c27 Fix a few typos (by @AndreyAkinshin) 6fb830 ARM support (#979) (by @adamsitnik) 410d14 Detect .NET Core benchmark failures from LINQPad (#980), #975 (by @Turnerj) 138325 File names should be consistent across all OSes, fixes #981 (by @adamsitnik) add308 test fix for #981 (by @adamsitnik) 77ed41 expose OriginalValues and SortedValues in the Statistics type so they get exp... (by @adamsitnik) c0aac1 More tests for FolderNameHelper (by @AndreyAkinshin) 3497ae Better message in MinIterationTimeAnalyser (by @AndreyAkinshin) 91e16a Fix duplication of IsLinqPad check (by @AndreyAkinshin) 89255c Refactoring xUnit tests to avoid non-serializable objects in MemberData (by @AndreyAkinshin) 2cd06a Give a warning when the [Benchmark] method is static (#985) (by @Rizzen) 5070af Fix NRE in MetricColumn (#986) (#987) (by @qbit86) 17378d Fix typos (#991) (by @0x6a62) 2ce35a Fix path to logo in README (by @AndreyAkinshin) a20e4b always print the path, args and working dir of the auto-generated executable,... (by @adamsitnik) 27dd87 CoreRunToolchain: when the file exists, overwrite it (by @adamsitnik) 1b01f3 Remove obsolete info from the docs (#997) (by @Maximusya) 299e1f Synchronized benchmark output with the code in docs (#999) (by @Maximusya) 0da14b Rephrase Notes section and fix markdown (#996) (by @Maximusya) 9e791f CoreRT toolchain update (#1001) (by @adamsitnik) 04747a Use only full names in the auto-generated code to avoid any possible conflict... (by @adamsitnik) f35465 add unit test that prevents from adding using statements to the code, fixes #... (by @adamsitnik) fd0b8c Improve build error logging, increase the default timeout (by @adamsitnik) 8276be Changed TargetCount to IterationCount in docs (#1012) (by @Sitiritis) 3c98da Update IntroRatioSD.md (#1014) (by @fredeil) 286996 Improve restore, build and publish projects - Fix for #1002 (#1013) (by @WojciechNagorski) 923b23 BenchmarkDotNet as global tool (#1006), fixes #213 (by @CodeTherapist) 7ef5f6 Introduce StoppingCriteria (#984) (by @AndreyAkinshin) 5e4428 make SortedValues internal property, don't export it! (by @adamsitnik) 5c519f Use .NET Standard 2.0 CommandLineParser, Update to net461 for NS2.0 support (... (by @glennawatson) 6ee21b if we fail to do the full build, we try with --no-dependencies (by @adamsitnik) 8d9714 Support machines without .NET DevPack, fix #1018 (by @AndreyAkinshin) 573566 Add support for mono AOT pass (#940) (by @alexanderkyte) 011c79 + InProcessEmitToolchain (by @ig-sinicyn) 862e6e InProcessEmitToolchain cleanup (by @ig-sinicyn) 252d7a Fix StringCanBePassedToBenchmarkAsReadOnlySpan (by @ig-sinicyn) 7ec2f3 Check if there's something wrong with RoslynToolchain on .Net Core (by @ig-sinicyn) 57acd6 No NOPs (thanks to @Warpten!) (by @ig-sinicyn) bf362a Diff now compares nops (by @ig-sinicyn) aa9ff8 + emit correct IL (by @ig-sinicyn) 351ca5 Ignore NOPs for ldarg too (by @ig-sinicyn) fc530f Fix build after rebase (by @ig-sinicyn) 1577ba MonoAotToolchain refactoring, post #940 (by @adamsitnik) 6ccf45 Improve diff disassembly (#1022) (by @WojciechNagorski) ef090d if we fail to do the full build, we try with --no-dependencies (for the publi... (by @adamsitnik) c69934 Give a warning when the [Benchmark] method is static: handle some edge-cases,... (by @adamsitnik) 935ead use .NET 4.6.1 everywhere, we don't support 4.6 anymore. Cleanup after #992 (by @adamsitnik) 20a011 C# keywords are prohibited for benchmark names, print nice error message, fix... (by @adamsitnik) 2aec75 remove CustomCoreClrToolchain, it was causing too much trouble. We can run th... (by @adamsitnik) f10752 Duplicates handling for IConfig = big refactor, fixes #360, closes #464 and f... (by @adamsitnik) f9c8cc Target .NET Standard 2.0 (#1032), apply a workaround for assembly binding red... (by @adamsitnik) aa1ded Merge branch 'master' into tools (by @adamsitnik) ccee3e Merge pull request #1033 from dotnet/tools (by @adamsitnik) 1b9f9f almost no warnings ;) (by @adamsitnik) 3bd18f introduce ConfigOptions - an enum flag which make it easier to introduce new ... (by @adamsitnik) 66c264 reverting things that should not introduce problems but did... (by @adamsitnik) 33eaeb Merge branch 'master' into feature-inprocessemit (by @adamsitnik) a1df27 Merge pull request #921 from ig-sinicyn/feature-inprocessemit (by @adamsitnik) aac7a6 Improve global tool (#1035) (by @WojciechNagorski) c01bc5 Remove InternalsVisibleTo for Samples application (#1036) (by @WojciechNagorski) f6dbe4 Change the name of the global tool (#1038) (by @WojciechNagorski) 11d8cb Making the new InProcessEmitToolchain work after my recent refactor and .NET ... (by @adamsitnik) e935b5 minor InProcess fix: diff now checks for implementation flags, (#1043) (by @ig-sinicyn) da4128 Merge pull request #1041 from dotnet/newInProcess (by @adamsitnik) 82170f if global cleanup throws, we should report the problem but don't rethrow beca... (by @adamsitnik) 904ddd tests that ensure that when a benchmark throws the runner does not throw, fix... (by @adamsitnik) cbdf7b Use invariant culture for csc messages (#1042) (by @ig-sinicyn) 5215ee Display the number of benchmarks to run, fixes #1048 (by @adamsitnik) 84cc3e dotnet cli version update + reducing the number of long running tests (#1052)... (by @adamsitnik) 1c431a read the process output in a thread safe way, fixes #1051 (#1053) (by @adamsitnik) 41a367 update Travis Ubuntu image from 14.04 to 16.04 (by @adamsitnik) 20744e allow the user to choose the strategy from console line arguments (by @adamsitnik) 190b9b Allow reflecting on DebuggableAttribute on CoreRT (#1055) (by @MichalStrehovsky) 9dd9e7 Ctlr+C: we should kill the entire process tree, not only for the benchmarks b... (by @adamsitnik) d4249f Disassembly diagnoser should be kept in a separate directory to avoid depende... (by @adamsitnik) 0b83c9 CoreRT toolchain improvements (#1057) (by @adamsitnik) 9bc8f3 0.11.4 initial release notes (by @adamsitnik) 13bb97 if the user provide a custom value, we should use it, post #1057 (by @adamsitnik) ea3036 fix a rare but really annoying bug where for some reason we were sometimes se... (by @adamsitnik) cf3f8c Proper cleanup on Ctrl+C/console Window exit (#1061) (by @adamsitnik) 61f563 Write the GitHub table format to the console by default, fixes #1062 (by @adamsitnik) 87d281 StopOnFirstError must be respected (by @adamsitnik) 413d31 Add experimental support for .NET Core 3.0 WPF benchmarks (#1066), fixes #1065 (by @adamsitnik) 69a8aa copy UseWindowsForms too (thanks @onovotny for pointing this out), post #1066 (by @adamsitnik) d3379e Bump DocFX version (by @AndreyAkinshin) 423204 Remove Version ComboBox in docs (by @AndreyAkinshin) 1a8826 Update build-and-pack.cmd (by @AndreyAkinshin) 9068d6 Update copyrights in docs (by @AndreyAkinshin) c0c2bf Update v0.11.4 changelog (by @AndreyAkinshin) e26441 Highlight the first column separator in the console summary table (by @AndreyAkinshin) a704a4 Set library version: 0.11.4 (by @AndreyAkinshin) Contributors (18) Adam Sitnik (@adamsitnik) Alexander Kyte (@alexanderkyte) Andrey Akinshin (@AndreyAkinshin) Code Therapist (@CodeTherapist) Fredrik Eilertsen (@fredeil) Glenn (@glennawatson) ig-sinicyn (@ig-sinicyn) Igor Fesenko (@Ky7m) Irina Ananeva (@morgan-kn) James Turner (@Turnerj) Jeff B. (@0x6a62) kayle (@kayle) Maksim Yakimets (@Maximusya) Mark Tkachenko (@Rizzen) Michal Strehovský (@MichalStrehovsky) Tymur Lysenko (@Sitiritis) Viktor Ptitselov (@qbit86) Wojciech Nagórski (@WojciechNagorski) Thank you very much! Additional details Date: February 15, 2019 Milestone: v0.11.4 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.4 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.4 https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.11.4"
  },
  "changelog/v0.11.5.html": {
    "href": "changelog/v0.11.5.html",
    "title": "BenchmarkDotNet v0.11.5 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.11.5 Highlights Features and noticeable improvements Power plan management Now BenchmarkDotNet executes all benchmarks with enabled High-Performance power plan (configurable, Windows-only). You can find some details below. #68 #952 Better Environment Variables API Now we have some additional extension methods which allow defining environment variables in user jobs. In the previous version, users always had to set an array of environment variables like this: job.With(new[] { new EnvironmentVariable(\"a\", \"b\") }). Now it's possible to define an environment variable like job.With(new EnvironmentVariable(\"a\", \"b\")) or job.WithEnvironmentVariable(\"a\", \"b\"). Also, it's possible to clear the list of environment variables via job.WithoutEnvironmentVariables(). #1069 #1080 Better outlier messages The previous version of BenchmarkDotNet printed information about detected or removed outliers like this: \"3 outliers were detected\". It was nice, but it didn't provide additional information about these outliers (users had to read the full log to find the outliers values). Now BenchmarkDotNet prints additional information about outlier values like this: \"3 outliers were detected (2.50 us..2.70 us)\". e983cd31 Support modern CPU architecture names In the environment information section, BenchmarkDotNet prints not only the processor brand string, but also its architecture (e.g., \"Intel Core i7-4770K CPU 3.50GHz (Haswell)\"). However, it failed to recognize some recent processors. Now it's able to detect the architecture for modern Intel processors correctly (Kaby Lake, Kaby Lake R, Kaby Lake G, Amber Lake Y, Coffee Lake, Cannon Lake, Whiskey Lake). 995e053d Introduce BenchmarkDotNet.Annotations Currently, BenchmarkDotNet targets .NET Standard 2.0. It makes some users unhappy because they want to define benchmarks in projects with lower target framework. We decided to start working on the BenchmarkDotNet.Annotations NuGet package which targets .NET Standard 1.0 and contains classes that users need to define their benchmarks. However, it's not easy to refactor the full source code base and move all relevant public APIs to this package. In v0.11.5, we did the first step and moved some of these APIs to BenchmarkDotNet.Annotations. We want to continue moving classes to this package and get full-featured annotation package in the future. #1084 #1096 Use InProcessEmitToolchain by default in InProcess benchmarks In BenchmarkDotNet 0.11.4, we introduced InProcessEmitToolchain. It's a new, full-featured InProcess toolchain which allows executing benchmarks in the current process without spawning additional process per benchmark. It supports [Arguments], [ArgumentsSource], passing the arguments by out, ref and returning stack-only types like Span<T>. However, in v0.11.4, it can be activated only if InProcessEmitToolchain is declared explicitly. Now it's enabled by default when [InProcessAttribute] is used. #1093 Introduce an option which prevents overwriting results Currently, BenchmarkDotNet overwrites results each time when the benchmarks are executed. It allows avoiding tons of obsolete files in the BenchmarkDotNet.Artifacts folder. However, the behavior doesn't fit all use cases: sometimes users want to keep results for old benchmark runs. Now we have a special option for it. The option can be activated via --noOverwrite console line argument or DontOverwriteResults extension method for IConfig #1074 #1083 Other improvements and bug fixes Diagnostics and validation Better benchmark declaration error processing In the previous version, BenchmarkDotNet threw an exception when some benchmark methods had an invalid declaration (e.g., invalid signature or invalid access modifiers). Now it prints a nice error message without ugly stack traces. #1107 Better error message for users who want to debug benchmarks #1073 Don't show the same validation error multiple times Now each error will be printed only once. #1079 Restrict MemoryDiagnoserAttribute usage to class Now it's impossible to accidentally mark a method with this attribute. #1119 #1122 Export Better indentation in disassembly listings Now DissassemblyDiagnoser correctly process source code which contains tab as the indentation symbol #1110 Fix incorrect indentation for StackOverflow exporter Previously, StackOverflow exporter doesn't have a proper indent for job runtimes in the environment information. Now it's fixed. #826 #1104 Fix StackOverflowException in XmlExporter.Full #1086 #1090 Shortify MemoryDiagnoser column titles Now we use the following column titles: \"Allocated\" instead of \"Allocated Memory/Op\", \"Gen 0\" instead of \"Gen 0/1k Op\". The full description of each column can be found in the legend section below the summary table. #1081 Benchmark generation and execution Fixed broken Orderers The previous version has a nasty bug with custom orderers. Now it's fixed. #1070 #1109 Better overhead evaluation In the previous version, BenchmarkDotNet evaluated the benchmark overhead as a mean value of all overhead iteration. It was fine in most cases, but in some cases, the mean value can be spoiled by outliers. Now BenchmarkDotNet uses the median value. #1116 Respect CopyLocalLockFileAssemblies Now BenchmarkDotNet respect the CopyLocalLockFileAssemblies value and copies it to the generated benchmark project. #1068 #1108 Disable CodeAnalysisRuleSet for generated benchmarks Previously, generated benchmarks may fail if the CodeAnalysisRuleSet is defined in Directory.Build.Props. #1082 Supported undefined enum values #1020 #1071 Other minor improvements and bug fixes Power plans In #952, power plan management was implemented. It resolves a pretty old issue #68 which was created more than three years ago. Now BenchmarkDotNet forces OS to execute a benchmark on the High-Performance power plan. You can disable this feature by modifying PowerPlanMode property. Here is an example where we are playing with this value: [Config(typeof(Config))] public class IntroPowerPlan { private class Config : ManualConfig { public Config() { Add(Job.MediumRun.WithPowerPlan(PowerPlan.HighPerformance)); Add(Job.MediumRun.WithPowerPlan(PowerPlan.UserPowerPlan)); } } [Benchmark] public int IterationTest() { int j = 0; for (int i = 0; i < short.MaxValue; ++i) j = i; return j; } [Benchmark] public int SplitJoin() => string.Join(\",\", new string[1000]).Split(',').Length; } And here is an example of the summary table on plugged-off laptop: Method | PowerPlan | Mean | Error | StdDev | -------------- |---------------- |---------:|----------:|----------:| IterationTest | HighPerformance | 40.80 us | 0.4168 us | 0.6109 us | SplitJoin | HighPerformance | 13.24 us | 0.2514 us | 0.3763 us | IterationTest | UserPowerPlan | 79.72 us | 2.5623 us | 3.8352 us | SplitJoin | UserPowerPlan | 24.54 us | 2.1062 us | 3.1525 us | As you can see, the power plan produces a noticeable effect on the benchmark results. This feature is available on Windows only. Milestone details In the v0.11.5 scope, 16 issues were resolved and 16 pull requests were merged. This release includes 44 commits by 12 contributors. Resolved issues (16) #68 Power management #826 MarkdownExporter.StackOverflow fails to indent jobs' runtime descriptions (assignee: @alinasmirnova) #976 System.NotSupportedException: Line must start with GC (assignee: @adamsitnik) #1020 Errors using undefined enum values as benchmark arguments (assignee: @adamsitnik) #1068 The csproj setting CopyLocalLockFileAssemblies is ignored #1070 System.InvalidOperationException: Sequence contains more than one matching element after 0.11.4 (assignee: @AndreyAkinshin) #1071 Enum flags results into compiler errors (assignee: @adamsitnik) #1073 The error message for users who want to Debug benchmarks is not clear (assignee: @adamsitnik) #1074 Results should be exported to a file with unique name #1079 Dont display the same Validation Error many times (assignee: @adamsitnik) #1086 XmlExporter.Full fails with StackOverflowException #1107 Unhandled Exception: System.InvalidOperationException: Benchmark method '' has incorrect signature. Method shouldn't have any arguments. (assignee: @AndreyAkinshin) #1109 Issue with DefaultOrderer #1110 DisassemblyDiagnoser assumes indentation uses spaces (assignee: @AndreyAkinshin) #1116 Use Median instead of Mean whe deducing Overhead (assignee: @AndreyAkinshin) #1119 MemoryDiagnoserAttribute on methods (assignee: @Rizzen) Merged pull requests (16) #952 Implemented power-management, add docs (#68) (by @MarekM25) #1080 Improved Environment Variables API, resolves #1069 (by @AndreyAkinshin) #1081 Shortify MemoryDiagnoser column titles (by @AndreyAkinshin) #1082 Make it so that the code analysis settings are disabled. (by @glennawatson) #1083 make it possible to Don't Overwrite Results, fixes #1074 (by @adamsitnik) #1084 introduce BenchmarkDotNet.Annotations (by @adamsitnik) #1088 Typo (by @Stromberg90) #1090 XmlExporter.Full fails (by @daveMueller) #1093 make InProcessEmitToolchain the default one (by @adamsitnik) #1096 move more simple Attributes to BenchmarkDotNet.Annotations (by @adamsitnik) #1104 fix #826 (by @alinasmirnova) #1105 Just spell check (by @sungam3r) #1108 Fix #1068 - Copy value of CopyLocalLockFileAssemblies (by @WojciechNagorski) #1112 Fixed event wire-up before Session acquisition (by @jzabroski) #1122 Restrict MemoryDiagnoserAttribute usage to class (by @Rizzen) #1126 Styling in docfx fashion (by @robertmuehsig) Commits (44) 0a63e4 Postrelease update of v0.11.4 changelog (by @AndreyAkinshin) f94616 Fix namespace for JobTests (by @AndreyAkinshin) 995e05 Support modern CPUs in ProcessorBrandStringHelper (by @AndreyAkinshin) f946ba Repair custom orderers, fixes #1070 (by @AndreyAkinshin) 1d3783 allow passing Enum Flags and undefined enum values as benchmarks arguments/pa... (by @adamsitnik) dfe9ca make sure that we can pass undefined enum values and the bug never comes back... (by @adamsitnik) 76b467 improve the error message when users try to run the benchmarks in Debug, fixe... (by @adamsitnik) 98d9f8 Dont display the same Validation Error many times, fixes #1079 (by @adamsitnik) 03981c fix the unit test that I broke when I was fixing #1071 (by @adamsitnik) 877aba Throw exception about private benchmark method (by @AndreyAkinshin) e983cd Print some outlier values in OutliersAnalyser (by @AndreyAkinshin) b5d324 Shortify MemoryDiagnoser column titles (#1081) (by @AndreyAkinshin) c5c4c4 handle undefined negative enum values, #1020 (thanks @TylerBrinkley) (by @adamsitnik) 2f273c Improved Environment Variables API, resolves #1069 (#1080) (by @AndreyAkinshin) ff2847 Implement FrequencyTests.ParseTest (by @AndreyAkinshin) 5e25da Make it so that the code analysis settings are disabled for compiled builds (... (by @glennawatson) db701e make it possible to Don't Overwrite Results, fixes #1074 (#1083) (by @adamsitnik) a12d8c introduce BenchmarkDotNet.Annotations (#1084) (by @adamsitnik) dcc40a Typo (#1088) (by @Stromberg90) 2c392a XmlExporter.Full fails #1090 (by @daveMueller) 8968bb make InProcessEmitToolchain the default one (#1093) (by @adamsitnik) 4c9136 move more simple Attributes to BenchmarkDotNet.Annotations (#1096) (by @adamsitnik) 6f524f Added extra output lines for jobs in test (by @alinasmirnova) 27ed8a Logger with prefix works correctly with multiline input (by @alinasmirnova) a846b8 just spell check (#1105) (by @sungam3r) a2da9a Reverted reporter change (by @alinasmirnova) e1c9b9 Merge pull request #1104 from alinasmirnova/master (by @AndreyAkinshin) e45adc Fix #1068 - Copy value of CopyLocalLockFileAssemblies (#1108) (by @WojciechNagorski) 2f823c don't fail with exception if user has written something to output in GlobalCl... (by @adamsitnik) 8bc2cc Fixed event wire-up before Session acquisition (#1112) (by @jzabroski) db3a8f Better handling of benchmark with incorrect signature, fixes #1107 (by @AndreyAkinshin) 8a8e01 Fix GlobalSetupAttributeMethodsMustHaveNoParameters (by @AndreyAkinshin) 52eca7 Better disasm indentation, fixes #1110 (by @AndreyAkinshin) d9901b Use Median instead of Mean for overhead calculations, fixes #1116 (by @AndreyAkinshin) 1c1913 add dotnet/performance to the list of users (by @adamsitnik) e1d4d2 Restrict MemoryDiagnoserAttribute usage to class (#1122), fixes #1119 (by @Rizzen) 8aa6ad Implemented power-management, add docs (#68) (#952) (by @MarekM25) 9c6cad Improve ApplyUserPowerPlan message (by @AndreyAkinshin) d12414 Initial v0.11.5 changelog (by @AndreyAkinshin) 1babcb styling in docfx fashion (by @robertmuehsig) fb1286 Add netstandard2.0 target framework in BenchmarkDotNet.Annotations (by @AndreyAkinshin) b7118e Add BenchmarkDotNet.Annotations in build-and-pack.cmd (by @AndreyAkinshin) 8721a9 Prepare v0.11.5 changelog (by @AndreyAkinshin) 31ea3d Set library version: 0.11.5 (by @AndreyAkinshin) Contributors (12) Adam Sitnik (@adamsitnik) Alina Smirnova (@alinasmirnova) Andrey Akinshin (@AndreyAkinshin) David Müller (@daveMueller) Glenn (@glennawatson) Ivan Maximov (@sungam3r) John Zabroski (@jzabroski) Marek Moraczyński (@MarekM25) Mark Tkachenko (@Rizzen) Robert Muehsig (@robertmuehsig) Strømberg (@Stromberg90) Wojciech Nagórski (@WojciechNagorski) Thank you very much! Additional details Date: April 2, 2019 Milestone: v0.11.5 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.5 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.5 https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.11.5 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.11.5"
  },
  "changelog/v0.12.0.html": {
    "href": "changelog/v0.12.0.html",
    "title": "BenchmarkDotNet v0.12.0 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.12.0 It's been several months since our last release, but we have been working hard and have some new features for you! Highlights Features and major improvements Advanced multiple target frameworks support Now BenchmarkDotNet supports .NET Framework 4.8, .NET Core 3.1, and .NET Core 5.0. Also, we reworked our API that allows targeting several runtimes from the same config: the new API is more consistent, flexible, and powerful. For example, if you want to execute your benchmarking using .NET Framework 4.8 and .NET Core 3.1, you can use the SimpleJob(RuntimeMoniker.Net48), [SimpleJob(RuntimeMoniker.NetCoreApp31)] attributes or Job.Default.With(ClrRuntime.Net48), Job.Default.With(CoreRuntime.Core31) jobs in a manual config. You can find more details below. #1188, #1186, #1236 Official templates for BenchmarkDotNet-based projects With the help of the BenchmarkDotNet.Templates NuGet package, you can easily create new projects from the command line via dotnet new benchmark. This command has a lot of useful options, so you can customize your new project as you want. #1044 New NativeMemoryProfiler NativeMemoryProfiler measure the native memory traffic and adds the extra columns Allocated native memory and Native memory leak to the summary table. Internally, it uses EtwProfiler to profile the code using ETW. #457, #1131, #1208, #1214, #1218, #1219 New ThreadingDiagnoser ThreadingDiagnoser also adds two extra columns to the summary table: Completed Work Items (the number of work items that have been processed in ThreadPool per single operation) and Lock Contentions (the number of times there was contention upon trying to take a Monitor's lock per single operation). Internally, it uses new APIs exposed in .NET Core 3.0. #1154, #1227 Improved MemoryDiagnoser Now MemoryDiagnoser includes memory allocated by all threads that were live during benchmark execution: a new GC API was exposed in .NET Core 3.0 preview6+. It allows to get the number of allocated bytes for all threads. #1155, #1153, #723 LINQPad 6 support Now both LINQPad 5 and LINQPad 6 are supported! #1241, #1245 Fast documentation search We continue to improve the usability of our documentation. In this release, we improved the search experience in the documentation: now it works almost instantly with the help of Algolia engine! #1148, #1158 Minor summary and exporter improvements Improved presentation of the current architecture in the environment information In the previous version of BenchmarkDotNet, the reports always contained \"64bit\" or \"32bit\" which did not tell if it was ARM or not. Now it prints the full architecture name (x64, x86, ARM, or ARM64). For example, instead of .NET Framework 4.8 (4.8.3815.0), 64bit RyuJIT you will get .NET Framework 4.8 (4.8.3815.0), X64 RyuJIT or .NET Framework 4.8 (4.8.3815.0), ARM64 RyuJIT. #1213 Simplified reports for Full .NET Framework version Previous version: .NET Framework 4.7.2 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.3324.0. Current version: .NET Framework 4.7.2 (4.7.3362.0), 64bit RyuJIT. #1114, #1111 More reliable CPU info on Windows We added a workaround to for a bug in wmic that uses \\r\\r\\n as a line separator. #1144, #1145 Better naming for generated plots When [RPlotExporter] is used, BenchmarkDotNet generates a lot of useful plots in the BenchmarkDotNet.Artifacts folder. The naming of the plot files was improved: benchmarks without Params doesn't include a double dash (--) in their names anymore. 1183, 1212 Better density plot precision The previous version of BenchmarkDotNet used the rule-of-thumb bandwidth selector in RPlotExporter density plots. It was fine for unimodal distributions, but sometimes it produced misleading plots for multimodal distributions. Now, RPlotExporter uses the Sheather&Jones bandwidth selector that significantly improves the presentation of the density plots for complex distributions. 58fde64 Better alignment in HtmlExporter Now BenchmarkDotNet aligns the content exported by HtmlExporter to the right. #1189 dfa074 Better precision calculation in SummaryTable 4e9eb43 Better summary analysis BenchmarkDotNet warns the user when benchmark baseline value is too close to zero and the columns derived from BaselineCustomColumn cannot be computed. #1161, #600 Make log file datetime format 24-hour #1149 Improve AskUser prompt message The error messages will surround * by quotes on Linux and macOS. #1147 Minor API improvements ED-PELT algorithm for changepoint detection is now available You can find details in this blog post. f89091 Improved OutlierMode API BenchmarkDotNet performs measurement postprocessing that may remove some of the outlier values (it can be useful to remove upper outliers that we get because of the natural CPU noise). In the previous version, naming for the OutlierMode values was pretty confusing: None/OnlyUpper/OnlyLower/All. Now, these values were renamed to DontRemove/RemoveUpper/RemoveLower/RemoveAll. For example, if you want to remove all the outliers, you can annotate your benchmark with the [Outliers(OutlierMode.RemoveAll)] attribute. The old names still exist (to make sure that the changes are backward compatible), but they are marked as obsolete, and they will be removed in the future versions of the library. #1199, 0e4b8e Add the possibility to pass Config to BenchmarkSwitcher.RunAll and RunAllJoined #1194, ae23bd Improved command line experience When user uses --packages $path, the $path will be sent to the dotnet build command as well. 1187 Extend the list of supported power plans. Now it supports \"ultimate\", \"balanced\", and \"power saver\" plans. #1132, #1139 Make it possible to not enforce power plan on Windows. 1578c5c Guid support in benchmark arguments Now you can use Guid instances as benchmark arguments. 04ec20b Make ArgumentsSource support IEnumerable<object[]> for benchmarks accepting a single argument to mimic MemberData behaviour. ec296dc Make FullNameProvider public So it can be reused by the dotnet/performance repository. 6d71308 Extend Summary with LogFilePath #1135, 6e6559 Allow namespace filtering for InliningDiagnoser #1106, #1130 Option to configure MaxParameterColumnWidth #1269, 4ec888 Other improvements Misc improvements in the documentation #1175, #1173, #1180, #1203, #1204, #1206, #1209, #1219, #1225, #1279 Copy PreserveCompilationContext MSBuild setting from the project that defines benchmarks #1152, 063d1a Add System.Buffers.ArrayPoolEventSource to the list of default .NET Providers of EtwProfiler #1179, a106b1 Consume CoreRT from the new NuGet feed Because CoreRT no longer publishes to MyGet. #1129 Breaking changes: The [ClrJob], [CoreJob] and [CoreRtJob] attributes got obsoleted and replaced by a [SimpleJob] which requires the user to provide target framework moniker in an explicit way. (See the \"Advanced multiple target frameworks support\" section for details.) #1188, #1182, #1115, #1056, #993, The old InProcessToolchain is now obsolete. It's recommended to use InProcessEmitToolchain. If you want to use the old one on purpose, you have to use InProcessNoEmitToolchain. #1123 Bug fixes: Invalid arg passing in StreamLogger constructor. The append arg was not passed to the StreamWriter .ctor. #1185 Improve the output path of .etl files produced by EtwProfiler. EtwProfiler was throwing NRE for users who were using [ClrJob] and [CoreJob] attributes. #1156, #1072 Flush custom loggers at the end of benchmark session. #1134 Make ids for tag columns unique - when using multiple TagColumns only one TagColumn was printed in the results. #1146 Advanced multiple target frameworks support Now BenchmarkDotNet supports .NET Framework 4.8, .NET Core 3.1, and .NET Core 5.0. Also, we reworked our API that allows targeting several runtimes from the same config: the new API is more consistent, flexible, and powerful. For example, if you want to execute your benchmarking using .NET Framework 4.8 and .NET Core 3.1, you can use the SimpleJob(RuntimeMoniker.Net48), [SimpleJob(RuntimeMoniker.NetCoreApp31)] attributes or Job.Default.With(ClrRuntime.Net48), Job.Default.With(CoreRuntime.Core31) jobs in a manual config. Now let's discuss how to use it in detail. If you want to test multiple frameworks, your project file MUST target all of them and you MUST install the corresponding SDKs: <TargetFrameworks>netcoreapp3.0;netcoreapp2.1;net48</TargetFrameworks> If you run your benchmarks without specifying any custom settings, BenchmarkDotNet is going to run the benchmarks using the same framework as the host process (it corresponds to RuntimeMoniker.HostProcess): dotnet run -c Release -f netcoreapp2.1 # is going to run the benchmarks using .NET Core 2.1 dotnet run -c Release -f netcoreapp3.0 # is going to run the benchmarks using .NET Core 3.0 dotnet run -c Release -f net48 # is going to run the benchmarks using .NET 4.8 mono $pathToExe # is going to run the benchmarks using Mono from your PATH To run the benchmarks for multiple runtimes with a single command from the command line, you need to specify the runtime moniker names via --runtimes|-r console argument: dotnet run -c Release -f netcoreapp2.1 --runtimes netcoreapp2.1 netcoreapp3.0 # is going to run the benchmarks using .NET Core 2.1 and .NET Core 3.0 dotnet run -c Release -f netcoreapp2.1 --runtimes netcoreapp2.1 net48 # is going to run the benchmarks using .NET Core 2.1 and .NET 4.8 What is going to happen if you provide multiple Full .NET Framework monikers? Let's say: dotnet run -c Release -f net461 net472 net48 Full .NET Framework always runs every .NET executable using the latest .NET Framework available on a given machine. If you try to run the benchmarks for a few .NET TFMs, they are all going to be executed using the latest .NET Framework from your machine. The only difference is that they are all going to have different features enabled depending on the target version they were compiled for. You can read more about this here and here. This is .NET Framework behavior which can not be controlled by BenchmarkDotNet or any other tool. Note: Console arguments support works only if you pass the args to BenchmarkSwitcher: class Program { static void Main(string[] args) => BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args); // crucial to make it work } You can achieve the same thing using [SimpleJobAttribute]: using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [SimpleJob(RuntimeMoniker.Net48)] [SimpleJob(RuntimeMoniker.Mono)] [SimpleJob(RuntimeMoniker.NetCoreApp21)] [SimpleJob(RuntimeMoniker.NetCoreApp30)] public class TheClassWithBenchmarks Or using a custom config: using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { class Program { static void Main(string[] args) { var config = DefaultConfig.Instance .With(Job.Default.With(CoreRuntime.Core21)) .With(Job.Default.With(CoreRuntime.Core30)) .With(Job.Default.With(ClrRuntime.Net48)) .With(Job.Default.With(MonoRuntime.Default)); BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args, config); } } } The recommended way of running the benchmarks for multiple runtimes is to use the --runtimes console line argument. By using the console line argument, you don't need to edit the source code anytime you want to change the list of runtimes. Moreover, if you share the source code of the benchmark, other people can run it even if they don't have the exact same framework version installed. Official templates for BenchmarkDotNet-based projects Since v0.12.0, BenchmarkDotNet provides project templates to setup your benchmarks easily. The template exists for each major .NET language (C#, F# and VB) with equivalent features and structure. The templates require the .NET Core SDK. Once installed, run the following command to install the templates: dotnet new -i BenchmarkDotNet.Templates If you want to uninstall all BenchmarkDotNet templates: dotnet new -u BenchmarkDotNet.Templates The template is a NuGet package distributed over nuget.org: BenchmarkDotNet.Templates. To create a new C# benchmark library project from the template, run: dotnet new benchmark If you'd like to create F# or VB project, you can specify project language with -lang option: dotnet new benchmark -lang F# dotnet new benchmark -lang VB The template projects have five additional options - all of them are optional. By default, a class library project targeting netstandard2.0 is created. You can specify -f or --frameworks to change target to one or more frameworks: dotnet new benchmark -f netstandard2.0;net472 The option --console-app creates a console app project targeting netcoreapp3.0 with an entry point: dotnet new benchmark --console-app This lets you run the benchmarks from a console (dotnet run) or from your favorite IDE. The option -f or --frameworks will be ignored when --console-app is set. The option -b or --benchmarkName sets the name of the benchmark class: dotnet new benchmark -b Md5VsSha256 BenchmarkDotNet lets you create a dedicated configuration class (see Configs) to customize the execution of your benchmarks. To create a benchmark project with a configuration class, use the option -c or --config: dotnet new benchmark -c The option --no-restore if specified, skips the automatic NuGet restore after the project is created: dotnet new benchmark --no-restore Use the -h or --help option to display all possible arguments with a description and the default values: dotnet new benchmark --help The version of the template NuGet package is synced with the BenchmarkDotNet package. For instance, the template version 0.12.0 is referencing BenchmarkDotnet 0.12.0 - there is no floating version behavior. For more info about the dotnet new CLI, please read the documentation. New NativeMemoryProfiler NativeMemoryProfiler measure the native memory traffic and adds the extra columns Allocated native memory and Native memory leak to the summary table. Internally, it uses EtwProfiler to profile the code using ETW. Consider the following benchmark: [ShortRunJob] [NativeMemoryProfiler] [MemoryDiagnoser] public class IntroNativeMemory { [Benchmark] public void BitmapWithLeaks() { var flag = new Bitmap(200, 100); var graphics = Graphics.FromImage(flag); var blackPen = new Pen(Color.Black, 3); graphics.DrawLine(blackPen, 100, 100, 500, 100); } [Benchmark] public void Bitmap() { using (var flag = new Bitmap(200, 100)) { using (var graphics = Graphics.FromImage(flag)) { using (var blackPen = new Pen(Color.Black, 3)) { graphics.DrawLine(blackPen, 100, 100, 500, 100); } } } } private const int Size = 20; // Greater value could cause System.OutOfMemoryException for test with memory leaks. private int ArraySize = Size * Marshal.SizeOf(typeof(int)); [Benchmark] public unsafe void AllocHGlobal() { IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize); Span<byte> unmanaged = new Span<byte>(unmanagedHandle.ToPointer(), ArraySize); Marshal.FreeHGlobal(unmanagedHandle); } [Benchmark] public unsafe void AllocHGlobalWithLeaks() { IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize); Span<byte> unmanaged = new Span<byte>(unmanagedHandle.ToPointer(), ArraySize); } } It will produce the summary table like this one: Method Mean Error StdDev Gen 0 Gen 1 Gen 2 Allocated Allocated native memory Native memory leak BitmapWithLeaks 73,456.43 ns 22,498.10 ns 1,233.197 ns - - - 177 B 13183 B 11615 B Bitmap 91,590.08 ns 101,468.12 ns 5,561.810 ns - - - 180 B 12624 B - AllocHGlobal 79.91 ns 43.93 ns 2.408 ns - - - - 80 B - AllocHGlobalWithLeaks 103.50 ns 153.21 ns 8.398 ns - - - - 80 B 80 B As you can see, we have two additional columns Allocated native memory and Native memory leak that contain some very useful numbers! New ThreadingDiagnoser ThreadingDiagnoser also adds two extra columns to the summary table: Completed Work Items: The number of work items that have been processed in ThreadPool (per single operation) Lock Contentions: The number of times there was contention upon trying to take a Monitor's lock (per single operation) Internally, it uses new APIs exposed in .NET Core 3.0. It can be activated with the help of the [ThreadingDiagnoser] attribute: [ThreadingDiagnoser] public class IntroThreadingDiagnoser { [Benchmark] public void CompleteOneWorkItem() { ManualResetEvent done = new ManualResetEvent(initialState: false); ThreadPool.QueueUserWorkItem(m => (m as ManualResetEvent).Set(), done); done.WaitOne(); } } The above example will print a summary table like this one: Method Mean StdDev Median Completed Work Items Lock Contentions CompleteOneWorkItem 8,073.5519 ns 69.7261 ns 8,111.6074 ns 1.0000 - LINQPad 6 support Now both LINQPad 5 and LINQPad 6 are supported: Fast documentation search We continue to improve the usability of our documentation. In this release, we improved the search experience in the documentation: now it works almost instantly with the help of Algolia engine! That's how it looks: Milestone details In the v0.12.0 scope, 44 issues were resolved and 56 pull requests were merged. This release includes 110 commits by 25 contributors. Resolved issues (44) #198 [Feature request] No logger for benchmark run? (assignee: @CodeTherapist) #311 How to debug benchmarks that fail with exception on file system access operations (assignee: @adamsitnik) #457 Track Native Memory Allocations and more informations with our ETW Memory Diagnoser #600 Scaling issue #723 MemoryDiagnoser should include memory allocated by all Threads that were live during benchmark execution (assignee: @adamsitnik) #995 Running benchmark fails when targeting netcoreapp2.2 (assignee: @adamsitnik) #1028 Add new template for \"dotnet new benchmark\" (assignee: @CodeTherapist) #1072 EtwProfiler exports trace file only for a single runtime when Runtimes are controlled via attributes (assignee: @adamsitnik) #1106 Allow user defined namespace filter for InliningDiagnoser #1111 Change the format of printed Full .NET Framework Version (assignee: @adamsitnik) #1115 Running using dotnet benchmark uses wrong core runtime #1132 The power management feature extension #1134 StreamLogger is not properly flushed on shutdown (assignee: @AndreyAkinshin) #1135 The default file logger and summary title are out of sync (assignee: @adamsitnik) #1137 [Discussion] Improve search experience in the documentation #1144 Incorrect CPU info for .NET Core applications #1146 Only the first of multiple custom columns is included in the summary table (assignee: @AndreyAkinshin) #1147 Update benchmark switcher instructions to work on Linux (assignee: @AndreyAkinshin) #1149 Ambiguous hour component in log file name timestamp (assignee: @AndreyAkinshin) #1152 Failed to test Roslyn. (assignee: @adamsitnik) #1153 Use GC.GetTotalAllocatedBytes when available in MemoryDiagnoser (assignee: @adamsitnik) #1154 Add a ConcurrencyDiagnoser? (assignee: @adamsitnik) #1156 Crash when BenchmarkDotNet.Diagnostics.Windows.Session.GetFilePath throws NRE (assignee: @adamsitnik) #1158 \uD83D\uDD0D Improving search on docs with Algolia's DocSearch #1162 Incorrect value of BenchmarkDotNet.Toolchains.DotNetCli.NetCoreAppSettings.Default #1168 Consider using default value instead of hardcoded '-' in MetricColumn.GetValue() #1179 Add System.Buffers.ArrayPoolEventSource to the list of default .NET Providers of EtwProfiler (assignee: @adamsitnik) #1181 Log shows a wrong name for plot images #1182 Benchingmarking .NET 4.8 Causes Errors #1183 Plots of benchmarks without params have a double dash (--) in the name #1186 Add support for --runtimes net48 (assignee: @adamsitnik) #1187 When user uses --packages $path, the $path should be sent to dotnet build command as well (assignee: @adamsitnik) #1194 RunAll with ToolChains (assignee: @adamsitnik) #1195 LatestCoreRtVersionIsSupported fails on Mac Os #1202 BenchmarkDotNet Not Recognizing CPU #1220 [Docs] RScript / R_HOME setup #1235 NativeMemoryProfiler exception (assignee: @WojciechNagorski) #1236 Rework new API for target runtimes (assignee: @adamsitnik) #1241 Can BenchmarkDotNet be enabled for LINQPad 6? (assignee: @adamsitnik) #1269 Unable to show full param string in the report (assignee: @adamsitnik) #1280 Improvement in memory statistics (assignee: @WojciechNagorski) #1285 Issue with .Net Core version 3.0 #1289 How to config to not save .log files? #1291 MemoryDiagnoser reports weird results for .NET Core 3.0 Merged pull requests (56) #1044 Add \"dotnet new\" benchmark project template (by @CodeTherapist) #1114 simplify the reported Full .NET Framework version, fixes 1111 (by @adamsitnik) #1123 + InProcessNoEmitToolchain (obsoletes the InProcessToolchain) (by @ig-sinicyn) #1129 Consume CoreRT from the new NuGet feed (by @MichalStrehovsky) #1130 allow namespace filtering for InliningDiagnoser (#1106) (by @MarekM25) #1131 NativeMemoryDiagnoser (by @WojciechNagorski) #1139 Power-Management extension (#1132) (by @MarekM25) #1145 Added workaround to fix incorrect CPU info when using wmic (by @YohDeadfall) #1148 Improve search experience in the documentation (by @s-pace) #1155 Use new .NET Core 3.0 API to get the total number of allocated bytes for all threads (by @adamsitnik) #1161 Warn the user when benchmark baseline value is too close to zero and the columns derived from BaselineCustomColumn cannot be computed (by @mhmd-azeez) #1163 Make netcoreapp2.1 default (by @adamsitnik) #1169 Fix: broken link in readme.md (by @Ant-hem) #1173 Updated index.md and fixed Relative performance url (by @sergey-litvinov) #1175 Added information about what a Gen X column means (by @jigargandhi) #1180 Update docstring for IterationSetup/IterationCleanup (by @billwert) #1185 Invalid arg passing in StreamLogger constructor (by @ig-sinicyn) #1188 Enforce the users to provide full target framework moniker when using attributes to define multiple runtime jobs (by @adamsitnik) #1189 Update HtmlExporter.cs (by @chuuddo) #1196 Update Mac Os for Travis CI (by @WojciechNagorski) #1199 Rename OutlierMode values (by @AndreyAkinshin) #1201 print benchmark process id to the output (better profiler user story) (by @adamsitnik) #1203 Easier introduction of new benchmarks (by @Scooletz) #1204 Fix casing typo (by @antondahlin) #1206 add *.fsproj to the list of supported project types (by @JaggerJo) #1208 Support of --profiler NativeMemory command line argument (by @WojciechNagorski) #1209 Sorting examples list and adding missing pages (by @WojciechNagorski) #1212 Plots with a double dash (--) in the names (#1183) (by @marcnet80) #1213 print full architecture name (by @adamsitnik) #1214 Add documentation to NativeMemoryDiagnoser (by @WojciechNagorski) #1217 Log shows a wrong name for plot images #1181 (by @marcnet80) #1218 NativeMemoryProfiler -add count of allocated object (by @WojciechNagorski) #1219 Add links to blogs. (by @WojciechNagorski) #1222 Enhance rscript location (by @tebeco) #1225 Documentation: Fix some typos in the documentation (by @MSeifert04) #1227 Threading Diagnoser (by @adamsitnik) #1228 Support IEnumerable as benchmark argument (by @adamsitnik) #1230 further runtime detection improvements (by @adamsitnik) #1231 Fix iteration cleanup bug (by @adamsitnik) #1232 Fixed dots at the end (not used in other places) (by @cincuranet) #1233 try to read .NET Core version from all available information (by @adamsitnik) #1237 The null ArtifactsPath value causes exception for all EtwProfiler (by @WojciechNagorski) #1239 Add using statement to sample snippet (by @b8adamson) #1240 Amend SummaryStyle to support visualization of '0' in reports (by @sleemer) #1245 LINQPad 6 support using InProcessEmitToolchain (by @adamsitnik) #1252 Add possibility to disable the log file (by @CodeTherapist) #1255 Update Build Tools to use .NET Core SDK to 3.0.100 (by @CodeTherapist) #1257 Task remove unused nuget packages (by @WojciechNagorski) #1259 Task remove trailing whitespace (by @WojciechNagorski) #1260 Fix ca1825 rule - Avoid zero-length array allocations (by @WojciechNagorski) #1261 Fix CA2000 - Add missing using (by @WojciechNagorski) #1265 make it possible to configure MaxParamterColumnWidth (by @adamsitnik) #1268 Fix compilation error with post v3.3.1 Roslyn (by @stanciuadrian) #1277 change the runtimes API (by @adamsitnik) #1279 Improve documentation for version 0.12.0 (by @WojciechNagorski) #1281 Print GC and threading stats only if needed (by @WojciechNagorski) Commits (110) 881c6d Postrelease update of v0.11.5 changelog (by @AndreyAkinshin) a2bddf Fix release date for v0.11.5 in changelog (by @AndreyAkinshin) c0c91a Consume CoreRT from the new NuGet feed (#1129) (by @MichalStrehovsky) 40dcab allow namespace filtering for InliningDiagnoser (#1106) (#1130), fixes #1106 (by @MarekM25) 12fdbe + InProcessNoEmitToolchain (#1123) (by @ig-sinicyn) 62d6af Bump docfx version to 2.42.1 (by @AndreyAkinshin) 40901c Add sitemap generation in docfx.json (see #1137) (by @AndreyAkinshin) 04ec20 add Guid support to code templates (by @adamsitnik) 4e9eb4 Better precision calculation in SummaryTable (by @AndreyAkinshin) df6f91 Added workaround to fix incorrect CPU info when using wmic (#1145) (by @YohDeadfall) 9065c7 Make ids for tag columns unique, fixes #1146 (by @AndreyAkinshin) 527c95 Improve AskUser prompt message, fixes #1147 (by @AndreyAkinshin) 45253c Flush custom loggers at the end of benchmark session, fix #1134 (by @AndreyAkinshin) 21175b Make log file datetime format 24-hour, fix #1149 (by @AndreyAkinshin) 0dfa37 Power-Management extension (#1132) (#1139) (by @MarekM25) f54055 Use new .NET Core 3.0 API to get the total number of allocated bytes for all ... (by @adamsitnik) aa17ec improve the output path of .etl files produced by EtwProfiler, fixes #1156, f... (by @adamsitnik) ec296d make ArgumentsSource support IEnumerable<object[]> for benchmarks accepting a... (by @adamsitnik) 96f162 write \"Setup power plan\" in a separate line (by @adamsitnik) 063d1a copy PreserveCompilationContext MSBuild setting from the project that defines... (by @adamsitnik) 1578c5 make it possible to not enforce power plan, move the revert to finally, simpl... (by @adamsitnik) 0513a7 remove the test that requires a manual update every time we add a new charact... (by @adamsitnik) 6e6559 extend Summary with LogFilePath, fixes #1135 (by @adamsitnik) 6d7130 make FullNameProvider public so it can be reused by the dotnet/performance re... (by @adamsitnik) 6f91ea Drop netcoreapp2.0 TFM in sample and test projects (see #1141) (by @AndreyAkinshin) bfe676 Warn the user when benchmark baseline value is too close to zero and the colu... (by @mhmd-azeez) 4282b1 Update year in LICENSE.md (by @AndreyAkinshin) 29d01b Improve search experience in the documentation (#1148) (by Sylvain Pace) ddf1b8 Fixed: broken link in readme.md (by @Ant-hem) fc35f7 simplify the reported Full .NET Framework version, fixes 1111 (#1114) (by @adamsitnik) 0a4550 Updated index.md and fixed Relative performance (#1173) (by @sergey-litvinov) a106b1 Add System.Buffers.ArrayPoolEventSource to the list of default .NET Providers... (by @adamsitnik) c022e7 Update docstring for IterationSetup/IteraitonCleanup (by @billwert) 31cb34 Invalid arg passing in StreamLogger constructor (#1185) (by @ig-sinicyn) fc8867 Make netcoreapp2.1 default (#1163) (by @adamsitnik) 0f210c Add support for --runtimes net48, fixes #1186 (by @adamsitnik) 48a9de When user uses --packages $path, the $path should be sent to dotnet build com... (by @adamsitnik) dfa074 Update HtmlExporter.cs (#1189) (by @chuuddo) 8b018d doc update: InProc toolchain supports Arguments now, we use Median instead of... (by @adamsitnik) ae23bd add the possibility to pass config to BenchmarkSwitcher.RunAll and RunAllJoin... (by @adamsitnik) 94b788 Update Mac Os for Travis CI (#1196), fixes #1195 (by @WojciechNagorski) 58fde6 Use Sheather&Jones bandwidth selector for density plots in RPlotExporter (by @AndreyAkinshin) 0e4b8e Rename OutlierMode values (#1199) (by @AndreyAkinshin) 863c65 Added information about what a Gen X column means (#1175) (by @jigargandhi) 70c5b3 print benchmark process id to the output (better profiler user story) (#1201) (by @adamsitnik) 55cba0 Easier introduction of new benchmarks (#1203) (by @Scooletz) 31bb6f Fix casing typo (#1204) (by @antondahlin) e92abf NativeMemoryDiagnoser (#1131), fixes #457 (by @WojciechNagorski) d04a01 update list of supported project types (#1206) (by @JaggerJo) 5db67b Sorting examples list and add missing pagges (#1209) (by @WojciechNagorski) 6620cd print full architecture name (#1213) (by @adamsitnik) 705bc3 Add documentation to NativeMemoryDiagnouser (#1214) (by @WojciechNagorski) 9caa05 Support of --profiler NativeMemory command line argument (#1208) (by @WojciechNagorski) 5d7c78 Plots with a double dash (--) in the names (#1183) (#1212) (by @marcnet80) d0d883 Extend NativeMemoryProfiler with the number of allocated objects (#1218) (by @WojciechNagorski) 09aba3 Add links to blogs. (#1219) (by @WojciechNagorski) a200af Enforce the users to provide full target framework moniker when using attribu... (by @adamsitnik) f8ef67 add release notes for 0.11.6 (by @adamsitnik) 88ea5a Documentation: Fix some typos in the documentation (#1225) (by @MSeifert04) ea0468 Support IEnumerable as benchmark argument (#1228) (by @adamsitnik) 4080ab Threading Diagnoser (#1227) (by @adamsitnik) b6d0e0 further runtime detection improvements (#1230), (by @adamsitnik) bc9624 Fix iteration cleanup bug (#1231) (by @adamsitnik) cfccac Fixed dots at the end (not used in other places) (#1232) (by @cincuranet) 61feb7 try to read .NET Core version from all available information (#1233) (by @adamsitnik) c06ab7 Add using statement to sample snippet (#1239) (by @b8adamson) af9608 The null ArtifactsPath value causes exception for all EtwProfiler (#1237) (by @WojciechNagorski) 5f337d chore(tests): extract helper methods to MockFactory (by @sleemer) 03e9ce feat(CsvExproter): print '0' instead of '-' in the CSV report (by @sleemer) 06f0e7 Improuve link visibility for R installation (by @tebeco) a2d9e3 adding example of R_HOME value in the doc to understand it construction (by @tebeco) ce5ac8 Enhanced RScript detection, with a Fallback to the PATH if R_HOME points to a... (by @tebeco) b86845 not necessary to set rscriptPath to null since it's re-affected right after (by @tebeco) ee97ca Change access modifier to private, was not intended to be public (by @tebeco) 609eec Log shows a wrong name for plot images #1181 (by @marcnet80) 76096e Add \"dotnet new\" benchmark project template (#1044) (by @CodeTherapist) b7cbdf Update year in license (docs) (by @AndreyAkinshin) 29919d Remove extra spaces in template *proj files (by @AndreyAkinshin) 80ccfd Add some readonly modifiers (by @AndreyAkinshin) d6a697 Improve MannWhitneyTest precision for small samples (by @AndreyAkinshin) 9ba645 Fix CurrentRuntimeIsProperlyRecognized for NETFRAMEWORK case on Linux/macOS (by @AndreyAkinshin) 24fda9 LINQPad 6 support using InProcessEmitToolchain (#1245) (by @adamsitnik) e01e0d Fix typos in attribute messages (by @AndreyAkinshin) 56a71f Add possibility to disable the log file (#1252) (by @CodeTherapist) 3c4ec9 remove unused nuget packages (#1257) (by @WojciechNagorski) 61cc56 Add missing using (#1261) (by @WojciechNagorski) cd88ed Fix ca1825 rule - Avoid zero-length array allocations (#1260) (by @WojciechNagorski) 2ba303 Task remove trailing whitespace (#1259) (by @WojciechNagorski) e1c4aa Fix compilation error with post v3.3.1 Roslyn (#1268) (by @stanciuadrian) 4ec888 make it possible to configure MaxParamterColumnWidth (#1265), fixes #1269 (by @adamsitnik) 51f53a CombinedDisassemblyExporter output should be aligned to left, not right (by @adamsitnik) f89091 Add EdPeltChangePointDetector (by @AndreyAkinshin) da63e8 change the runtimes API (#1277) (by @adamsitnik) 5333d5 Change next version number from 0.11.6 to 0.12.0 (by @AndreyAkinshin) 52cc45 NativeMemoryProfiler instead of NativeMemoryDiagnoser (#1279) (by @WojciechNagorski) f86e13 Print GC and threading stats if needed (#1281) (by @WojciechNagorski) a08062 Rename some obsolete TargetFrameworkMoniker names to RuntimeMoniker (by @AndreyAkinshin) 7fdee8 Fix JitOptimizationsValidatorIsMandatoryByDefault in DEBUG mode (by @AndreyAkinshin) f2639e Move ImmutableConfigTests from IntegrationTests to regular unit tests (by @AndreyAkinshin) 4f6a6b Fix diagnoser tests in ImmutableConfigTests (by @AndreyAkinshin) 0768b7 Fix some typos in identifiers (by @AndreyAkinshin) 28bb7c Bump DocFX version from 2.42.1 to 2.46 (by @AndreyAkinshin) af9ff5 Fix mistakes in old changelogs (by @AndreyAkinshin) c5aa4f Prepare v0.12.0 changelog (by @AndreyAkinshin) cb1575 Add BenchmarkDotNet.Templates in build-and-pack.cmd (by @AndreyAkinshin) bc7cb8 Improve v0.12.0 release notes (by @AndreyAkinshin) c5ac2f Fix bug in BaselineCustomAnalyzer (by @AndreyAkinshin) d75b1b Add .NET Core 2.2 and .NET Core 3.0 support in BenchmarkDotNet.Tool (by @AndreyAkinshin) d582b5 Revert previous commit because of the CI Error (by @AndreyAkinshin) 7bdf6e Set library version: 0.12.0 (by @AndreyAkinshin) Contributors (25) Adam Sitnik (@adamsitnik) Adrian Stanciu (@stanciuadrian) Andrey Akinshin (@AndreyAkinshin) Antoine Hémery (@Ant-hem) Anton Dahlin (@antondahlin) b8adamson (@b8adamson) Bill Wert (@billwert) Code Therapist (@CodeTherapist) ig-sinicyn (@ig-sinicyn) Ilya Chudin (@chuuddo) Jigar (@jigargandhi) Jiri Cincura ↹ (@cincuranet) Josua Jäger (@JaggerJo) marcnet80 (@marcnet80) Marek Moraczyński (@MarekM25) Michael Seifert (@MSeifert04) Michal Strehovský (@MichalStrehovsky) Muhammad Azeez (@mhmd-azeez) Sergey Litvinov (@sergey-litvinov) Sylvain Pace Szymon Kulec (@Scooletz) TeBeCo (@tebeco) Vlad Kovalev (@sleemer) Wojciech Nagórski (@WojciechNagorski) Yoh Deadfall (@YohDeadfall) Thank you very much! Additional details Date: October 24, 2019 Milestone: v0.12.0 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.12.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.12.0 https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.12.0 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.12.0 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.12.0"
  },
  "changelog/v0.12.1.html": {
    "href": "changelog/v0.12.1.html",
    "title": "BenchmarkDotNet v0.12.1 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.12.1 Highlights .NET 5 support As you probably know, .NET Core 5 was officially rebranded to .NET 5. The new version of BenchmarkDotNet supports the new runtime after rebranding. #1399 465ebf Perfolizer adoption The internal statistical engine of BenchmarkDotNet became mature enough to be transformed into an independent project. Meet perfolizer — a toolkit for performance analysis! While BenchmarkDotNet focuses on obtaining reliable measurements, perfolizer focuses on the decent analysis of measured data. You still can use all the statistical algorithms from BenchmarkDotNet, but you can also install perfolizer as a standalone NuGet package. You can find more details in the official announcement. #1386 54a061 Cross-platform disassembler Now the DisassemblyDiagnoser is cross-platform! The disassembling logic was also improved, now it handles runtime helper methods and references to method tables properly. Internally, it uses the Iced library for formatting assembly code. Special thanks to @adamsitnik for the implementation and @0xd4d for Iced! #1332 #899 #1316 #1364 294320 EventPipe-based cross-platform profiler Now you can easily profiler your benchmarks on Windows, Linux, and macOS! Just mark your class with the [EventPipeProfiler(...)] attribute and get a .speedscope.json file that you can browse in SpeedScope. Special thanks to @WojciechNagorski for the implementation! #1321 #1315 c648ff New fluent API We continue to improve our API and make it easier for reading and writing. Special thanks to @WojciechNagorski for the implementation! #1273 #1234 640d88 Ref readonly support Now you can use ref readonly in benchmark signatures. Special thanks to @adamsitnik for the implementation! #1389 #1388 9ac777 Cross-platform disassembler Just mark your benchmark class with the [DisassemblyDiagnoser] attribute and you will get the disassembly listings for all the benchmarks. The formatting looks pretty nice thanks to Iced. It works like a charm on Windows, Linux, and macOS. [DisassemblyDiagnoser] public class IntroDisassembly { private int[] field = Enumerable.Range(0, 100).ToArray(); [Benchmark] public int SumLocal() { var local = field; // we use local variable that points to the field int sum = 0; for (int i = 0; i < local.Length; i++) sum += local[i]; return sum; } [Benchmark] public int SumField() { int sum = 0; for (int i = 0; i < field.Length; i++) sum += field[i]; return sum; } } .NET Core 2.1.16 (CoreCLR 4.6.28516.03, CoreFX 4.6.28516.10), X64 RyuJIT ; BenchmarkDotNet.Samples.IntroDisassembly.SumLocal() mov rax,[rcx+8] xor edx,edx xor ecx,ecx mov r8d,[rax+8] test r8d,r8d jle short M00_L01 M00_L00: movsxd r9,ecx add edx,[rax+r9*4+10] inc ecx cmp r8d,ecx jg short M00_L00 M00_L01: mov eax,edx ret ; Total bytes of code 35 .NET Core 2.1.16 (CoreCLR 4.6.28516.03, CoreFX 4.6.28516.10), X64 RyuJIT ; BenchmarkDotNet.Samples.IntroDisassembly.SumField() sub rsp,28 xor eax,eax xor edx,edx mov rcx,[rcx+8] cmp dword ptr [rcx+8],0 jle short M00_L01 M00_L00: mov r8,rcx cmp edx,[r8+8] jae short M00_L02 movsxd r9,edx add eax,[r8+r9*4+10] inc edx cmp [rcx+8],edx jg short M00_L00 M00_L01: add rsp,28 ret M00_L02: call CORINFO_HELP_RNGCHKFAIL int 3 ; Total bytes of code 53 Now we handle runtime helper methods and references to method tables properly. Example: Before: ; MicroBenchmarks.WithCallsAfter.Benchmark(Int32) push rsi sub rsp,20h mov rsi,rcx cmp edx,7FFFFFFFh jne M00_L00 call MicroBenchmarks.WithCallsAfter.Static() mov rcx,rsi call MicroBenchmarks.WithCallsAfter.Instance() mov rcx,rsi call MicroBenchmarks.WithCallsAfter.Recursive() mov rcx,rsi mov rax,qword ptr [rsi] mov rax,qword ptr [rax+40h] call qword ptr [rax+20h] mov rcx,rsi mov edx,1 mov rax,7FF8F4217050h add rsp,20h pop rsi jmp rax M00_L00: mov rcx,offset System_Private_CoreLib+0xa31d48 call coreclr!MetaDataGetDispenser+0x322a0 mov rsi,rax mov ecx,0ACFAh mov rdx,7FF8F42F4680h call coreclr!MetaDataGetDispenser+0x17140 mov rdx,rax mov rcx,rsi call System.InvalidOperationException..ctor(System.String) mov rcx,rsi call coreclr!coreclr_shutdown_2+0x39f0 int 3 add byte ptr [rax],al sbb dword ptr [00007ff9`26284e30],eax add dword ptr [rax+40h],esp add byte ptr [rax],al add byte ptr [rax],al add byte ptr [rax],al add byte ptr [rax-70BC4CCh],ah ; Total bytes of code 157 After: ; BenchmarkDotNet.Samples.WithCallsAfter.Benchmark(Int32) push rsi sub rsp,20 mov rsi,rcx cmp edx,7FFFFFFF jne M00_L00 call BenchmarkDotNet.Samples.WithCallsAfter.Static() mov rcx,rsi call BenchmarkDotNet.Samples.WithCallsAfter.Instance() mov rcx,rsi call BenchmarkDotNet.Samples.WithCallsAfter.Recursive() mov rcx,rsi mov rax,[rsi] mov rax,[rax+40] call qword ptr [rax+20] mov rcx,rsi mov edx,1 mov rax BenchmarkDotNet.Samples.WithCallsAfter.Benchmark(Boolean) add rsp,20 pop rsi jmp rax M00_L00: mov rcx MT_System.InvalidOperationException call CORINFO_HELP_NEWSFAST mov rsi,rax mov ecx,12D mov rdx,7FF954FF83F0 call CORINFO_HELP_STRCNS mov rdx,rax mov rcx,rsi call System.InvalidOperationException..ctor(System.String) mov rcx,rsi call CORINFO_HELP_THROW int 3 ; Total bytes of code 134 See also: Cross-runtime .NET disassembly with BenchmarkDotNet. Special thanks to @adamsitnik for the implementation and @0xd4d for Iced! EventPipe-based cross-platform profiler Now you can easily profiler your benchmarks on Windows, Linux, and macOS! If you want to use the new profiler, you should just mark your benchmark class with the [EventPipeProfiler(...)] attribute: [EventPipeProfiler(EventPipeProfile.CpuSampling)] // <-- Enables new profiler public class IntroEventPipeProfiler { [Benchmark] public void Sleep() => Thread.Sleep(2000); } Once the benchmark run is finished, you get a .speedscope.json file that can be opened in SpeedScope: The new profiler supports several modes: CpuSampling - Useful for tracking CPU usage and general .NET runtime information. This is the default option. GcVerbose - Tracks GC collections and samples object allocations. GcCollect - Tracks GC collections only at very low overhead. Jit - Logging when Just in time (JIT) compilation occurs. Logging of the internal workings of the Just In Time compiler. This is fairly verbose. It details decisions about interesting optimization (like inlining and tail call) Please see Wojciech Nagórski's blog post for all the details. Special thanks to @WojciechNagorski for the implementation! New fluent API We continue to improve our API and make it easier for reading and writing. The old API is still existing, but it is marked as obsolete and will be removed in the further library versions. The most significant changes: Changes in Job configuration Changes in IConfig/ManualConfig Full fluent API Special thanks to @WojciechNagorski for the implementation! Ref readonly support Now you can use ref readonly in benchmark signatures. Here is an example: public class RefReadonlyBenchmark { static readonly int[] array = { 1 }; [Benchmark] public ref readonly int RefReadonly() => ref RefReadonlyMethod(); static ref readonly int RefReadonlyMethod() => ref array[0]; } Special thanks to @adamsitnik for the implementation! Milestone details In the v0.12.1 scope, 31 issues were resolved and 42 pull requests were merged. This release includes 85 commits by 19 contributors. Resolved issues (31) #641 RPlotExporter hanging (assignee: @m-mccormick) #899 Tiered compilation and disassembler (assignee: @adamsitnik) #1023 Out of process benchmarks fail with ASP.NET Core SDK reference #1211 Binding Redirect Issues When Using Xml Serializers #1234 Strong type fluent API proposal (assignee: @WojciechNagorski) #1238 RunAllJoined Causing Exception (assignee: @gsomix) #1262 Params attribute doesn`t work in F# if you specify more than one enum value in constructor (assignee: @gsomix) #1295 Custom format/culture for report output values (for CSV, and maybe HTML, MD) #1305 Copy UserSecrets from benchmark project #1311 Spelling nit (assignee: @AndreyAkinshin) #1312 Add an option to pass environment variables to the default job #1315 Implement cross platform EventPipeProfiler diagnoser (assignee: @WojciechNagorski) #1316 Implement Unix Disassembler for .NET Core (assignee: @adamsitnik) #1318 use of NugetReference[] causes System.MissingMethodException: No parameterless constructor defined for this object. (assignee: @adamsitnik) #1323 DisassemblyDiagnoser index outside array bounds (assignee: @AndreyAkinshin) #1325 Surface native code size benchmarked code (assignee: @adamsitnik) #1326 BDN does not build using dotnet sdk from the command line in Linux #1339 Generated code and StyleCop.Analyzers (assignee: @adamsitnik) #1348 Different display text for arrays depending on a value source (assignee: @YohDeadfall) #1350 Warn the user if command line arguments were not passed to the BenchmarkSwitcher #1353 Show Length when param type is an array #1361 SimpleJobAttribute with RunStrategy and RuntimeMoniker #1363 Wrong assembly binding redirects for Microsoft.Data.SqlClient.resources ; using in Netcore3.0 project (assignee: @adamsitnik) #1364 Bug: Benchmark class with Console.WriteLine(1) fails for DisassemblyDiagnoser with 'Sequence contains no matching element' (assignee: @adamsitnik) #1369 Parameter column doesn't seem to respect culture info (assignee: @Tyrrrz) #1379 Unix CI builds are red (assignee: @AndreyAkinshin) #1385 Make BaselineCustomColumn.GetValue public #1388 'ref readonly' return is not supported (assignee: @adamsitnik) #1396 MacOS Azure Pipeline build is broken (assignee: @AndreyAkinshin) #1413 Plot with only one \"default\" Job (assignee: @AndreyAkinshin) #1416 EventPipeProfiler Documentation (assignee: @WojciechNagorski) Merged pull requests (42) #1258 Task add style cope and fxcop analyzers (by @WojciechNagorski) #1263 Configuration compatibility validation (by @gsomix) #1266 Add EnumParam preserving type information (by @gsomix) #1273 New fluent API (by @WojciechNagorski) #1287 EdPeltChangePointDetector improvements (by @jeanbern) #1300 Update link of \" official benchmarking guide\" to use the new recommended link (by @eriawan) #1301 Improve BenchmarkDotNet.Templates (by @AndreyAkinshin) #1302 CultureInfo Refactoring (by @AndreyAkinshin) #1307 Fix project file order (by @vilinski) #1309 Copy UserSecrets from benchmark project (by @kant2002) #1313 add possibility to specify env vars via console line arguments (by @adamsitnik) #1321 The EventPipeProfiler cross-platform profiler (by @WojciechNagorski) #1327 Add package-refs to reference assemblies for linux build (by @damageboy) #1329 Show information about docker (by @WojciechNagorski) #1331 Use 24-hour time in joined summary file name (by @jroessel) #1332 Improved and Cross platform disassembler (by @adamsitnik) #1335 Attribute improvements (by @WojciechNagorski) #1340 Improvement of csproj finding (by @WojciechNagorski) #1349 Fixed display text for array parameters and arguments (by @YohDeadfall) #1357 add the header at the top of the generated file to avoid static analysis tools from analyzing it, (by @adamsitnik) #1359 Warn if command line arguments were not passed to the BenchmarkSwitcher (by @suslovk) #1365 Use DirtyAssemblyResolveHelper only for Full .NET Framework (by @adamsitnik) #1366 add missing SimpleJobAttribute ctor (by @adamsitnik) #1367 Await non-generic ValueTask returning method (by @mayuki) #1372 Use CultureInfo when formatting parameter values (by @Tyrrrz) #1373 fixes #641 (by @m-mccormick) #1375 don't require the JitDiagnosers (TailCall & Inlining) to run benchmarks once again just to gather JIT info, the overhead is very small (by @adamsitnik) #1376 update TraceEvent to 2.0.49 to get TailCalls working again (by @adamsitnik) #1380 Bump Cake version from 0.30.0 to 0.37.0, fix #1379 (by @AndreyAkinshin) #1381 Minor event pipe profiler improvements (by @adamsitnik) #1384 Fix build after styleCop (by @WojciechNagorski) #1386 Switch to perfolizer (by @AndreyAkinshin) #1387 Make BaselineCustomColumn expose \"GetValue\" as a public API (by @damageboy) #1389 Ref readonly support (by @adamsitnik) #1394 Align homepage example with README (by @dahlbyk) #1397 Bump macOS Azure Pipeline vmImage to 10.14, fix #1396 (by @AndreyAkinshin) #1399 React to .NET 5 branding changes (by @jkotas) #1407 Improve warnings for small operations number (by @CodeFuller) #1410 Updating Document - Fixing a small grammar mistake (by @abhinavgalodha) #1417 Fix --profiler option description. (by @WojciechNagorski) #1418 EventPipeProfiler documentation (by @WojciechNagorski) #1419 Small fix in EventPipeProfiler documentation (by @WojciechNagorski) Commits (85) 396d4b #1262: Add EnumParam preserving type information (by @gsomix) 718b77 #1262: Add tests (by @gsomix) 33ec90 EdPeltChangePointDetector improvements (by @jeanbern) 7e3efc Postrelease update of v0.12.0 changelog (by @AndreyAkinshin) 8677b0 Update css in documentation (by @AndreyAkinshin) 919b7f Fix link to IntroThreadingDiagnoser in diagnoser.md (by @AndreyAkinshin) 4d15ea Update README.md (by @AndreyAkinshin) f2d081 Update link of \" official benchmarking guide\" to use the new recommended link... (by @eriawan) 05df0e Documentation: update article about command-line tool (by @AndreyAkinshin) d69505 Improve BenchmarkDotNet.Templates (#1301) (by @AndreyAkinshin) e23755 Speed up some integration tests (by @AndreyAkinshin) 3d96bf Update NuGet package descriptions (by @AndreyAkinshin) 351dae Update README.md (by @AndreyAkinshin) 5f07f4 Add Windows 10 brand string for 19H1 (by @AndreyAkinshin) fd92ff Update README.md (by @AndreyAkinshin) 5af5c5 Update README.md (by @AndreyAkinshin) 1b923f Fix project file order (#1307) (by @vilinski) 57b01f Copy UserSecrets from benchmark project (#1309) (by @kant2002) 2415fd Fix some typos, fix #1311 (by @AndreyAkinshin) e92d6d add possibility to specify env vars via console line arguments (#1313) (by @adamsitnik) b7054c WithNuGet should accept NuGetReferenceList, not IReadOnlyCollection<NuGetRefe... (by @adamsitnik) bb437b Remove curly braces for single statements (by @AndreyAkinshin) 76c675 Improve code readability (by @AndreyAkinshin) 8486e1 Merge pull request #1287 from jeanbern/patch-1 (by @AndreyAkinshin) d6bf40 Update README.md (by @AndreyAkinshin) 728c40 Support empty lines in disassembler/GetSmartPrefix, fix #1323 (by @AndreyAkinshin) 0c48c2 CultureInfo Refactoring (#1302) (by @AndreyAkinshin) 099550 Switch to using ms ref aseemblies for build (#1327) (by @damageboy) 55842b Merge pull request #1266 from gsomix/feature/1262-fsharp-enums (by @AndreyAkinshin) 35d358 Show information about docker (#1329) (by @WojciechNagorski) b6283c Use 24-hour time in joined summary file name (#1331) (by @jroessel) 640d88 New fluent API (#1273), fixes #1234 (by @WojciechNagorski) a3f76b Update README (by @AndreyAkinshin) 4a9697 Update copyright year (by @AndreyAkinshin) 5e7f01 add the header at the top of the generated file to avoid s... (by @adamsitnik) 07b512 Await non-generic ValueTask returning method (#1367) (by @mayuki) 479177 Display array length for array parameters and arguments (#1349), fixes #1348 ... (by @YohDeadfall) 3b8d2c Warn if command line arguments were not passed to the BenchmarkSwitcher (#135... (by @suslovk) 87d85a Use CultureInfo when formatting parameter values (#1372) (by @Tyrrrz) 310b5a add missing SimpleJobAttribute ctor, fixes #1361 (#1366) (by @adamsitnik) 6a1458 change the way RPlotExporter reads the R script output, fixes #641 (#1373) (by @m-mccormick) ff4c3d Attribute improvements (#1335) (by @WojciechNagorski) 29eafb Improvement of csproj finding (#1340) (by @WojciechNagorski) be2168 Use DirtyAssemblyResolveHelper only for Full .NET Framework (#1365) (by @adamsitnik) 664ab6 update TraceEvent to 2.0.49 to get TailCalls working again (#1376) (by @adamsitnik) b788bc don't require the JitDiagnosers (TailCall & Inlining) to run benchmarks once ... (by @adamsitnik) 8ad2a9 Bump Cake version from 0.30.0 to 0.37.0, fix #1379 (#1380) (by @AndreyAkinshin) 474047 Task add style cope and fxcop analyzers (#1258) (by @WojciechNagorski) c648ff The EventPipeProfiler cross-platform profiler (#1321) (by @WojciechNagorski) 19169a Add brand strings for latest Windows versions (by @AndreyAkinshin) 532f84 Update README (by @AndreyAkinshin) 3defd7 Minor event pipe profiler improvements (#1381) (by @adamsitnik) 294320 Improved and Cross platform disassembler (#1332) (by @adamsitnik) 1d63d6 Fix build after styleCop (#1384) (by @WojciechNagorski) b3ba08 Make BaselineCustomColumn expose \"GetValue\" as a public API (#1387) (by @damageboy) 54a061 Switch to perfolizer (by @AndreyAkinshin) 9ac777 Ref readonly support (#1389) (by @adamsitnik) c3286f Update CodeAnnotations.cs (by @AndreyAkinshin) 3223c9 Code cleanup (by @AndreyAkinshin) c19e54 Implement configurations compatibility validation (#1263), Closes #1238 (by @gsomix) df434e Align homepage example with README (#1394) (by @dahlbyk) 9a251a Bump macOS Azure Pipeline vmImage to 10.14, fix #1396 (#1397) (by @AndreyAkinshin) 465ebf React to .NET 5 branding changes (#1399) (by @jkotas) 6cca72 Updating a small grammar mistake (#1410) (by @abhinavgalodha) 27b32e Improve warnings for small operations number (#1407) (by @CodeFuller) 2d365b Fix --profiler option description. (#1417) (by @WojciechNagorski) 7902cd Add macOS Catalina support in OsBrandStringHelper (by @AndreyAkinshin) fd4c32 Update README (by @AndreyAkinshin) 6e13ba Resolving JobId in DefaultCharacteristicPresenter, fix #1413 (by @AndreyAkinshin) 35ebd2 Better job id generation in SimpleJobAttribute (by @AndreyAkinshin) bf4778 Use ASCII mode for Measurement presentation in terminal (by @AndreyAkinshin) f6b81f Display result path in RPlotExporter (by @AndreyAkinshin) 30b269 Disable plot printing in BuildPlots.R (by @AndreyAkinshin) 27887d Disable Rplots.pdf generation in BuildPlots.R (by @AndreyAkinshin) 338e40 Specify uid for how-to-run.md (by @AndreyAkinshin) f6dcd3 Add BenchmarkDotNet.Annotations in API documentation (by @AndreyAkinshin) b503fd Bump DocFX version from 2.46 to 2.51 (by @AndreyAkinshin) f457e7 Prepare v0.12.1 changelog (by @AndreyAkinshin) 53d090 Fix documentation.md (by @AndreyAkinshin) e72897 Add v0.12.1 highlights (by @AndreyAkinshin) 2de040 Bump perfolizer version from 0.2.0 to 0.2.1 (by @AndreyAkinshin) 76a070 EventPipeProfiler documentation (#1418) (by @WojciechNagorski) 928fb1 EventPipeProfiler doc improvements (#1419) (by @WojciechNagorski) 12798e Update documentation (by @AndreyAkinshin) 384d47 Set library version: 0.12.1 (by @AndreyAkinshin) Contributors (19) Abhinav Galodha (@abhinavgalodha) Adam Sitnik (@adamsitnik) Andreas Vilinski (@vilinski) Andrey Akinshin (@AndreyAkinshin) Andrii Kurdiumov (@kant2002) CodeFuller (@CodeFuller) damageboy (@damageboy) Eriawan Kusumawardhono (@eriawan) Evgeniy Andreev (@gsomix) Jan Kotas (@jkotas) Jean-Bernard Pellerin (@jeanbern) Johannes Rössel [yWorks] (@jroessel) Keith Dahlby (@dahlbyk) Konstantin (@suslovk) Matt McCormick (@m-mccormick) Mayuki Sawatari (@mayuki) Oleksii Holub (@Tyrrrz) Wojciech Nagórski (@WojciechNagorski) Yoh Deadfall (@YohDeadfall) Thank you very much! Additional details Date: April 6, 2020 Milestone: v0.12.1 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.12.1 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.12.1 https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.12.1 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.12.1 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.12.1"
  },
  "changelog/v0.13.0.html": {
    "href": "changelog/v0.13.0.html",
    "title": "BenchmarkDotNet v0.13.0 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.0 It's been a year since our last release. BenchmarkDotNet has been downloaded more than seven million times from nuget.org. It's more than we could have ever possibly imagined! Some could say, that it's also more than we can handle ;) That is why we wanted to once again thank all the contributors who helped us with 0.13.0 release! Highlights In BenchmarkDotNet v0.13.0, we have supported various technologies: .NET 5 and .NET 6 target framework monikers .NET SDK installed via snap SingleFile deployment Xamarin applications WASM applications Mono AOT We have also introduced new features and improvements including: Memory randomization Method-specific job attributes Sortable parameter columns Customizable ratio column Improved CoreRun and CoreRT support Improved Hardware Counters support Of course, this release includes dozens of other improvements and bug fixes! Supported technologies .NET 5, .NET 6, SingleFile and snap At some point in time, netcoreapp5.0 moniker was changed to net5.0, which required a fix on our side (#1479, btw we love this kind of changes). Moreover, .NET 5 introduced platform-specific TMFs (example: net5.0-windows10.0.19041.0) which also required some extra work: #1560, #1691. In #1523 support for .NET 6 was added. <TargetFrameworks>net5.0;net5.0-windows10.0.19041.0;net6.0<TargetFrameworks> In #1686 @am11 has implemented support for single file deployment (supported in .NET 5 onwards). Last, but not least in #1652 snap support has been implemented. adam@adsitnik-ubuntu:~/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples$ dotnet50 run -c Release -f net5.0 --filter BenchmarkDotNet.Samples.IntroColdStart.Foo // Validating benchmarks: // ***** BenchmarkRunner: Start ***** // ***** Found 1 benchmark(s) in total ***** // ***** Building 1 exe(s) in Parallel: Start ***** // start /snap/dotnet-sdk/112/dotnet restore /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in /home/adam/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples/bin/Release/net5.0/9a018ee4-0f33-46dd-9093-01d3bf31233b // command took 1.49s and exited with 0 // start /snap/dotnet-sdk/112/dotnet build -c Release --no-restore /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in /home/adam/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples/bin/Release/net5.0/9a018ee4-0f33-46dd-9093-01d3bf31233b // command took 2.78s and exited with 0 // ***** Done, took 00:00:04 (4.37 sec) ***** // Found 1 benchmarks: // IntroColdStart.Foo: Job-NECTOD(IterationCount=5, RunStrategy=ColdStart) // ************************** // Benchmark: IntroColdStart.Foo: Job-NECTOD(IterationCount=5, RunStrategy=ColdStart) // *** Execute *** // Launch: 1 / 1 // Execute: /snap/dotnet-sdk/112/dotnet \"9a018ee4-0f33-46dd-9093-01d3bf31233b.dll\" --benchmarkName \"BenchmarkDotNet.Samples.IntroColdStart.Foo\" --job \"IterationCount=5, RunStrategy=ColdStart\" --benchmarkId 0 in /home/adam/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples/bin/Release/net5.0/9a018ee4-0f33-46dd-9093-01d3bf31233b/bin/Release/net5.0 Xamarin support Thanks to the contributions of the amazing @jonathanpeppers BenchmarkDotNet supports Xamarin! The examples can be found in our repo: iOS, Android. #1360, #1429, #1434, #1509 WASM support Thanks to the work of @naricc you can now benchmark WASM using Mono Runtime! For more details, please refer to our docs. #1483, #1498, #1500, #1501, #1507, #1592, #1689. Mono AOT support In another awesome contribution (#1662) @naricc has implemented Mono AOT support. The new toolchain supports doing Mono AOT runs with both the Mono-Mini compiler and the Mono-LLVM compiler (which uses LLVM on the back end). For more details, please go to our docs. New features and improvements Memory randomization In #1587 @adamsitnik has introduced a new, experimental feature called \"Memory Randomization\". This feature allows you to ask BenchmarkDotNet to randomize the memory alignment by allocating random-sized byte arrays between iterations and call [GlobalSetup] before every benchmark iteration and [GlobalCleanup] after every benchmark iteration. Sample benchmark: public class IntroMemoryRandomization { [Params(512 * 4)] public int Size; private int[] _array; private int[] _destination; [GlobalSetup] public void Setup() { _array = new int[Size]; _destination = new int[Size]; } [Benchmark] public void Array() => System.Array.Copy(_array, _destination, Size); } Without asking for the randomization, the objects are allocated in [GlobalSetup] and their unmodified addresses (and alignment) are used for all iterations (as long as they are not promoted to an older generation by the GC). This is typically the desired behavior, as it gives you very nice and flat distributions: dotnet run -c Release --filter IntroMemoryRandomization -------------------- Histogram -------------------- [502.859 ns ; 508.045 ns) | @@@@@@@@@@@@@@@ --------------------------------------------------- But if for some reason you are interested in getting a distribution that is better reflecting the \"real-life\" performance you can enable the randomization: dotnet run -c Release --filter IntroMemoryRandomization --memoryRandomization true -------------------- Histogram -------------------- [108.803 ns ; 213.537 ns) | @@@@@@@@@@@@@@@ [213.537 ns ; 315.458 ns) | [315.458 ns ; 446.853 ns) | @@@@@@@@@@@@@@@@@@@@ [446.853 ns ; 559.259 ns) | @@@@@@@@@@@@@@@ --------------------------------------------------- Method-specific job attributes From now, all attributes that derive from JobMutatorConfigBaseAttribute (full list) can be applied to methods. You no longer have to move a method to a separate type to customize config for it. [Benchmark] [WarmupCount(1)] public void SingleWarmupIteration() [Benchmark] [WarmupCount(9)] public void NineWarmupIterations() Sortable parameter columns In order to sort columns of parameters in the results table, you can use the Property Priority inside the params attribute. The priority range is [Int32.MinValue;Int32.MaxValue], lower priorities will appear earlier in the column order. The default priority is set to 0. public class IntroParamsPriority { [Params(100)] public int A { get; set; } [Params(10, Priority = -100)] public int B { get; set; } [Benchmark] public void Benchmark() => Thread.Sleep(A + B + 5); } Method B A Mean Error StdDev Benchmark 10 100 115.4 ms 0.12 ms 0.11 ms This feature got implemented by @JohannesDeml in #1612. Customizable ratio column Now it's possible to customize the format of the ratio column. [Config(typeof(Config))] public class IntroRatioStyle { [Benchmark(Baseline = true)] public void Baseline() => Thread.Sleep(1000); [Benchmark] public void Bar() => Thread.Sleep(150); [Benchmark] public void Foo() => Thread.Sleep(1150); private class Config : ManualConfig { public Config() { SummaryStyle = SummaryStyle.Default.WithRatioStyle(RatioStyle.Trend); } } } | Method | Mean | Error | StdDev | Ratio | RatioSD | |--------- |-----------:|--------:|--------:|-------------:|--------:| | Baseline | 1,000.6 ms | 2.48 ms | 0.14 ms | baseline | | | Bar | 150.9 ms | 1.30 ms | 0.07 ms | 6.63x faster | 0.00x | | Foo | 1,150.4 ms | 5.17 ms | 0.28 ms | 1.15x slower | 0.00x | This feature was implemented in #731. Improved CoreRun support BenchmarkDotNet was reporting invalid .NET Core version number when comparing performance using CoreRuns built from dotnet/corefx and dotnet/runtime. Fixed by @adamsitnik in #1580 In #1552 @stanciuadrian has implemented support for all GcMode characteristics for CoreRunToolchain. Previously the settings were just ignored, now they are being translated to corresponding COMPlus_* env vars. Improved CoreRT support CoreRT has moved from https://github.com/dotnet/corert/ to https://github.com/dotnet/runtimelab/tree/feature/NativeAOT and we had to update the default compiler version and nuget feed address. Moreover, there was a bug in CoreRtToolchain which was causing any additional native dependencies to not work. Big thanks to @MichalStrehovsky, @jkotas and @kant2002 for their help and support! #1606, #1643, #1679 Command-line argument support in BenchmarkRunner So far only BenchmarkSwitcher was capable of handling console line arguments. Thanks to @chan18 BenchmarkRunner supports them as well (#1292): public class Program { public static void Main(string[] args) => BenchmarkRunner.Run(typeof(Program).Assembly, args: args); } New API: ManualConfig.CreateMinimumViable ManualConfig.CreateEmpty creates a completely empty config. Without adding a column provider and a logger to the config the users won't see any results being printed. In #1582 @adamsitnik has introduced a new method that creates minimum viable config: IConfig before = ManualConfig.CreateEmpty() .AddColumnProvider(DefaultColumnProviders.Instance) .AddLogger(ConsoleLogger.Default); IConfig after = ManualConfig.CreateMinimumViable(); Benchmarking NuGet packages from custom feeds In #1659 @workgroupengineering added the possibility to indicate the source of the tested nuget package and whether it is a pre-release version. Deterministic benchmark builds BenchmarkDotNet is now always enforcing Deterministic builds (#1489) and Optimizations enabled (#1494) which is a must-have if you are using custom build configurations. MSBuild enforces optimizations only for configurations that are named Release (the comparison is case-insensitive). <ItemGroup Condition=\" '$(Configuration)' == 'X' \"> <PackageReference Include=\"SomeLibThatYouWantToBenchmark\" Version=\"1.0.0\" /> </ItemGroup> <ItemGroup Condition=\" '$(Configuration)' == 'Y' \"> <PackageReference Include=\"SomeLibThatYouWantToBenchmark\" Version=\"2.0.0\" /> </ItemGroup> var config = DefaultConfig.Instance .AddJob(Job.Default.WithCustomBuildConfiguration(\"X\").WithId(\"X\").AsBaseline()) .AddJob(Job.Default.WithCustomBuildConfiguration(\"Y\").WithId(\"Y\")); #1489, #1494 Improved Hardware Counters support BenchmarkDotNet is being used by the .NET Team to ensure that .NET is not regressing. More than three thousand benchmarks (they can be found here) are being executed multiple times a day on multiple hardware configs. Recently, .NET Team started to use InstructionsRetired to help to filter unstable benchmarks that report regressions despite not changing the number of instructions retired. This has exposed few bugs in Hardware Counters support in BenchmarkDotNet, which all got fixed by @adamsitnik in #1547 and #1550. Moreover, we have removed the old PmcDiagnoser and extended EtwProfiler with the hardware counters support. It's just much more accurate and futureproof. For details, please go to #1548. How stable was PmcDiagnoser (same benchmarks run twice in a row on the same machine): Method Runtime InstructionRetired/Op Burgers_0 .NET 5.0 845,746 Burgers_0 .NET Core 2.1 30,154,151 Burgers_0 .NET Framework 4.6.1 4,230,848 Method Runtime InstructionRetired/Op Burgers_0 .NET 5.0 34,154,524 Burgers_0 .NET Core 2.1 246,534,203 Burgers_0 .NET Framework 4.6.1 2,607,686 How stable is EtwProfiler: Method Runtime InstructionRetired/Op Burgers_0 .NET 5.0 3,069,978,261 Burgers_0 .NET Core 2.1 3,676,000,000 Burgers_0 .NET Framework 4.6.1 3,468,866,667 Method Runtime InstructionRetired/Op Burgers_0 .NET 5.0 3,066,810,000 Burgers_0 .NET Core 2.1 3,674,666,667 Burgers_0 .NET Framework 4.6.1 3,468,600,000 Moreover, in #1540 @WojciechNagorski has added the removal of temporary files created by EtwProfiler. Improved Troubleshooting We have the possibility to ask BDN to stop on the first error: --stopOnFirstError true. The problem was when the users had not asked for that, tried to run n benchmarks, all of them failed to build, and BDN was printing the same build error n times. In #1672 @adamsitnik has changed that, so when all the build fails, BDN stops after printing the first error. Moreover, we have also changed the default behavior for the failed builds of the boilerplate code. If the build fails, we don't remove the files. Previously we have required the users to pass --keepFiles to keep them. See #1567 for more details and don't forget about the Troubleshooting docs! Docs and Samples improvements Big thanks to @lukasz-pyrzyk, @fleckert, @MarecekF, @joostas, @michalgalecki, @WojciechNagorski, @MendelMonteiro, @kevinsalimi, @cedric-cf, @YohDeadfall, @jeffhandley and @JohannesDeml who have improved our docs and samples! #1463, #1465, #1508, #1518, #1554, #1568, #1601, #1633, #1645, #1647, #1657, #1675, #1676, #1690. Template improvements Projects created out of our official templates might have been unexpectedly packed when running dotnet pack on the entire solution. In #1584 @kendaleiv has explicitly disabled packing for the template. The template had netcoreapp3.0 TFM hardcoded. This got fixed by @https://github.com/ExceptionCaught in #1630 and #1632. In #1667 @YohDeadfall has changed the default debug type from portable to pdbonly (required by DisassemblyDiagnoser). Bug fixes Very long string [Arguments] and [Params] were causing BenchmarkDotNet to crash. Fixed by @adamsitnik in #1248 and #1545. So far trace file names were containing full benchmark names and arguments. Now if the name is too long, the trace file name is a hash (consistent for multiple runs of the same benchmark). The same goes for passing benchmark name by the host process to the benchmark process via command-line arguments. LangVersion set to a non-numeric value like latest was crashing the build. Fixed by @martincostello in #1420. Windows 10 November 2019 was being recognized as 2018. Fixed by @kapsiR in #1437. Assemblies loaded via streams were not supported. Fixed by @jeremyosterhoudt in #1443. NativeMemoryProfiler was detecting small leaks that were false positives. Fixed by @WojciechNagorski in #1451 and #1600. DisassemblyDiagnoser was crashing on Linux. Fixed by @damageboy in #1459. Target framework moniker was being printed as toolchain name for Full .NET Framework benchmarks. Fixed by @svick in #1471. [ParamsSource] returning IEnumerable<object[]> was not working properly when combined with [Arguments]. Fixed by @adamsitnik in #1478. NullReferenceException in MultimodalDistributionAnalyzer. Fixed by @suslovk in #1488. NotSupportedException was being thrown if there was an encoding mismatch between host and benchmark process. Diagnosed by @ChristophLindemann in #1487, fixed by @lovettchris in #1491. MissingMethodException was being thrown in projects that referenced a newer version of Iced. Fixed by @Symbai in #1497 and in #1502. AppendTargetFrameworkToOutputPath set to false was not supported. Fixed by @adamsitnik in #1563 A locking finalizer could have hanged benchmark process which would just print // AfterAll and never quit. Fixed by @adamsitnik in #1571. To prevent other hangs from happening, a timeout of 250ms was added. If the process does not quit after running the benchmarks and waiting 250ms, it's being force killed. In some cases, JsonExporter was reporting NaN for some of the Statistics. This was breaking non-.NET JSON deserializers. Fixed by @marcnet80 in #1581. UnitType.Size metrics were not using the provided number format. Fixed by @jodydonetti in #1569 and #1618. MaxColumnWidth setting was not used for type names. Fixed by @JohannesDeml in #1609. Current culture was not respected when formatting Ratio column values. Fixed by @JohannesDeml in #1610. BenchmarkDotNet was redirecting Standard Error of the benchmark process, which was causing deadlocks for benchmarks that were writing to it. Fixed by @adamstinik in #1631 DisassemblyDiagnoser was failing to disassemble multiline source code. @YohDeadfall fixed that in #1674. In #1644 @adamstinik has fixed the inconsistency between benchmark filter and hint. Removal of the dotnet global tool In #1006 (0.11.4) we have introduced a new dotnet global tool. By looking at the number of reported bugs we got to the conclusion that the tool has not passed the test of time. Why? Because it was based entirely on dynamic assembly loading which is very hard to get right in .NET and the fact that we support all existing .NET Runtimes (.NET, .NET Core, Mono, CoreRT) made it even harder (if not impossible). We have removed it and the old versions are no longer supported. For more details, please refer to #1572. Milestone details In the v0.13.0 scope, 53 issues were resolved and 94 pull requests were merged. This release includes 111 commits by 37 contributors. Resolved issues (53) #721 Add possibility to customize BaselinedScaledColumn with provided func (assignee: @AndreyAkinshin) #1136 benchmark / beforeEverything fails when running in docker-win #1242 bug JSON Exporter exports NaN for some properties. This fails most JSON parsers (assignee: @marcnet80) #1247 Support benchmarks with very long string arguments (assignee: @adamsitnik) #1288 Fix Hardware Counters diagnoser (assignee: @adamsitnik) #1290 BenchmarkRunner should support parsing console line arguments (assignee: @chan18) #1333 Getting \"Unknown Processor\" Again #1427 NativeMemoryProfiler reports false positive leak (assignee: @WojciechNagorski) #1431 System.IO.FileNotFoundException with EtwProfiler #1433 Benchmarks work in .NET 4.7.2 but not .NET Core 3.1 #1436 Wrong OsBrandString for Windows 10 1909 #1448 NRE in MultimodalDistributionAnalyzer #1452 Setting LangVersion to Latest Causes an Error #1464 DisassemblyDiagnoserConfig.ExportDiff needs better description #1472 Add support of Wasm to Benchmark Dotnet (assignee: @naricc) #1474 docs: Getting started guide #1480 BenchmarkRunner not working from VSTS agent (assignee: @lovettchris) #1487 Benchmarks do not execute (as service process / VSTS agent) on non US systems #1493 Using WithCustomBuildConfiguration leads to always running with RyuJIT Debug (assignee: @adamsitnik) #1495 [GcServer(true)] is ignored with --corerun #1496 System.MissingMethodException: Method not found: 'Iced.Intel.MasmFormatter.get_MasmOptions()'. #1512 Template has hardcoded netcoreapp3.0 TFM (assignee: @ExceptionCaught) #1532 Auto-generated project has invalid XML #1535 Can't benchmark library that targets 'net5.0-windows' framework (assignee: @adamsitnik) #1537 Failed to run benchmarks on .net 5 RC1 and Preview LangVersion #1539 Inconsistency between benchmark filter and hint (assignee: @adamsitnik) #1544 [EtwProfiler] Merge operation failed return code 0x3 (assignee: @adamsitnik) #1546 Sometimes Hardware Counters per Op are reported as NaNs (assignee: @adamsitnik) #1549 InstructionPointerExporter has been broken for a while (assignee: @adamsitnik) #1559 [Docs] Update Console Args doc (assignee: @kevinsalimi) #1561 NativeMemoryProfiler doesn't report allocations in v0.12.1.1432 Nightly (assignee: @WojciechNagorski) #1564 error MSB4086: A numeric comparison was attempted on \"$(LangVersion)\" (assignee: @adamsitnik) #1565 More consistent formatting of results #1566 BDN should not delete temporary build directories for failed builds (assignee: @adamsitnik) #1570 Benchmark runs failing when using .NET 5 RC2 SDK installed via snap (assignee: @adamsitnik) #1576 Missing/misleading version number with corerun #1585 Non-optimized dependency #1591 Wasm Benchmark Runs Failing with Target Framework Error (assignee: @naricc) #1598 VB Net Framework project throws exception from command line tool #1605 CoreRT / NativeAOT version (assignee: @adamsitnik) #1607 Exporter approval tests has recently become unstable (assignee: @marcnet80) #1613 EventPipeProfiler generating invalid SpeedScope files. #1616 BenchmarkDotNet fail in WPF project with .NET 5.0-windows target #1620 NullReferenceException in v0.12.1 #1623 Can I run Full Framework benchmarks without having a Console App? (assignee: @adamsitnik) #1628 Installation uses legacy/archaic dotnetcore 2.1.503 (assignee: @adamsitnik) #1629 Writing to Console.Error in benchmarked code causes a deadlock (assignee: @adamsitnik) #1654 Update for 0.12.2 #1670 dotnet benchmark cli tool errors with .net5.0 assemblies (assignee: @adamsitnik) #1673 Source code provider incorrectly handles multiline source code #1685 Support for SingleFile && SelfContained apps #1692 Bug running wasm benchmarks - Broken Pipe in writeline #1693 Estimate Date for Supporting .NET 6 (assignee: @adamsitnik) Merged pull requests (94) #1097 Allow for Config per method, introduce OS and OSArchitecture filters (by @adamsitnik) #1248 Support very long string as benchmark arguments (by @adamsitnik) #1292 passed args to benchmark runner (by @chan18) #1360 Basic BenchmarkDotNet support for Xamarin (by @jonathanpeppers) #1420 Fix MSB4086 if LangVersion is a keyword (by @martincostello) #1426 Fix typo in log message (by @martincostello) #1429 [xamarin] fix Mono runtime version detection (by @jonathanpeppers) #1434 [samples] UI tweaks to Xamarin samples (by @jonathanpeppers) #1437 Fix wrongly reported os brand string for Windows 10 1909 (by @kapsiR) #1443 Handle assemblies loaded via a stream (by @jeremyosterhoudt) #1451 Fix native memory profiler (by @WojciechNagorski) #1454 always print full information about non-optimized dependencies (by @adamsitnik) #1458 Don't try to parse blank lines (by @TysonMN) #1459 Upgrades ClrMD to a version that will not crash on Linux :( (by @damageboy) #1463 Updated Disassembler docs (by @lukasz-pyrzyk) #1465 Improved doc description of the ExportDiff property (by @lukasz-pyrzyk) #1471 Clearly display names for .Net Framework (by @svick) #1478 ParamsSource returning IEnumerable<object[]> fixes (by @adamsitnik) #1479 net5.0 does not contain \"core\" word but it's a .NET Core moniker (by @adamsitnik) #1483 Add Wasm Tool Chain (by @naricc) #1488 Safe access to CultureInfo (by @suslovk) #1489 enforce Deterministic builds for auto-generated .NET Core projects (by @adamsitnik) #1490 be less strict about verifying the Acknowledgment (by @adamsitnik) #1491 set process output encoding to utf8 so BenchmarkRunnerDotNet works in self hosted VSTS agent. (by @lovettchris) #1492 allow the users to specify Platform via console args (by @adamsitnik) #1494 enforce Optimizations when using Custom Build Configurations (by @adamsitnik) #1497 Update to latest Iced 1.7.0 (by @Symbai) #1498 Pedantic WASM improvements (by @adamsitnik) #1500 Wasm: samples, docs and a bug fix (by @adamsitnik) #1501 Add Custom Runtime Pack option (by @naricc) #1502 Update to latest Iced (by @Symbai) #1503 Update MeasurementsStatistics.cs (by @skynode) #1507 Change mono-config.js format in the Wasm Tool Chain for ICU support (by @naricc) #1508 fixed typo (by @fleckert) #1509 [xamarin] fix for DebugConfig and read-only file system (by @jonathanpeppers) #1518 FactorialWithTailing - incorrect implementation (by @MarecekF) #1523 add .NET 6.0 support, rename .NET Core 5.0 to .NET 5.0 (by @adamsitnik) #1540 Remove unneeded files after etw profiler (by @WojciechNagorski) #1545 Fix Merge operation failed for EtwProfiler (by @adamsitnik) #1547 hardware counters: don't try to exclude non-existing overhead for long running benchmarks (by @adamsitnik) #1548 Remove the old PmcDiagnoser, EtwProfiler is much more accurate (by @adamsitnik) #1550 Bring instruction pointer exporter back to live (by @adamsitnik) #1552 Enable supported GcMode characteristics with corerun (by @stanciuadrian) #1554 Documentation: add --maxWidth description (by @joostas) #1556 Simplify code: remove sort before adding to HashSet (by @stanciuadrian) #1560 Add support for Platform-specific TFMs introduced in .NET 5 (by @adamsitnik) #1563 ensure that the auto-generated project alwas has tfm in the output path (by @adamsitnik) #1567 Dont remove artifacts when build fails (by @adamsitnik) #1568 Update getting-started.md (by @michalgalecki) #1569 Respect size number format in MetricColumn (by @jodydonetti) #1571 Dispose parameters, kill benchmarking process when it hangs after printing the results (by @adamsitnik) #1572 Remove the dotnet global tool (by @adamsitnik) #1573 Don't run the benchmark once per iteration if only the first ivocation lasts longer than IterationTime (by @adamsitnik) #1580 use Environment.Version to determine .NET 5+ versions (by @adamsitnik) #1581 Json exporter fix (by @marcnet80) #1582 introduce ManualConfig.CreateMinimumViable() method (by @adamsitnik) #1584 Prevent dotnet pack from packaging benchmark projects (by @kendaleiv) #1587 Memory Randomization (by @adamsitnik) #1590 Update message to not suggest an obsolete API (by @martincostello) #1592 Add wasmnet50 wasmnet60 monikers (by @naricc) #1600 fix issue #1561 (by @WojciechNagorski) #1601 Update README.md (by @WojciechNagorski) #1606 CoreRT feed and version update (by @adamsitnik) #1609 Fix #1604 - pass SummaryStyle to ParameterInstance.ToDisplayText() (by @JohannesDeml) #1610 Fix add missing culuture info to ToString in RatioStyle (by @JohannesDeml) #1612 Sorting parameter columns with parameter priority (by @JohannesDeml) #1618 Json indentation level fix (by @marcnet80) #1630 Update framework symbol on dotnet new template #1512 (by @ExceptionCaught) #1631 don't redirect Standard Error, as we don't read it and writing to it by benchmark can cause deadlocks (by @adamsitnik) #1632 update console app templating (by @ExceptionCaught) #1633 Update etwprofiler.md (by @MendelMonteiro) #1635 Install local SDK without sudo on Unix (by @am11) #1637 .NET Core 2.1 -> .NET 5.0 (by @adamsitnik) #1643 Remove CoreRT workaround (by @MichalStrehovsky) #1644 Filter hint improvements (by @adamsitnik) #1645 Update Console Args doc #1559 (by @kevinsalimi) #1647 Update API in documentation #1602 (by @kevinsalimi) #1652 Basic snap support (by @adamsitnik) #1657 1655 doc with options obsolete usage of with (by @cedric-cf) #1659 feat: Allowed to indicate the source of nuget package and whether it is a pre-release version. (by @workgroupengineering) #1662 Add tool chain for Netcore Mono AOT. (by @naricc) #1667 Changed default debug type to pdbonly (by @YohDeadfall) #1672 when all builds fail, BDN should stop after printing first error (by @adamsitnik) #1674 Fixed smart pointer for multiline source code (by @YohDeadfall) #1675 Updated disassembler contribution docs (by @YohDeadfall) #1676 Fix a docs typo (by @jeffhandley) #1679 Fix location for NativeAOT publish files (by @kant2002) #1686 Resolve assembly location for SingleFile (by @am11) #1689 Dont redirect standard input for WASM (by @naricc) #1690 Fix change runtime target to Core50 (by @JohannesDeml) #1691 don't remove OS version number from the platform-specifc TFM (by @adamsitnik) #1697 0.13.0 release notes (by @adamsitnik) #1698 Update \"View results\" from \"Getting started\" (by @rstm-sf) #1707 Set ValidateExecutableReferencesMatchSelfContained to false in aotllvm template (by @naricc) Commits (111) 117c37 Postrelease update of v0.12.1 changelog (by @AndreyAkinshin) 742f44 Fix typo (by @AndreyAkinshin) 82b15e Fix MSB4086 if LangVersion is a keyword (#1420) (by @martincostello) 9c0f52 Xamarin Support (#1360) (by @jonathanpeppers) e37c02 Fix typo in log message (#1426) (by @martincostello) ccdf22 [xamarin] fix Mono runtime version detection (#1429) (by @jonathanpeppers) d95493 [samples] UI tweaks to Xamarin samples (#1434) (by @jonathanpeppers) d07604 Fix wrongly reported os brand string for Windows 10 1909 (#1437) (by @kapsiR) 1efd5e Handle assemblies loaded via a stream (#1443) (by @jeremyosterhoudt) 502ad7 Update OsBrandStringHelper.cs (by @AndreyAkinshin) 67971e Update OsBrandStringTests.cs (by @AndreyAkinshin) ceef31 don't try to parse blank lines #1456 (#1458) (by @TysonMN) 9a3469 Upgrades ClrMD to a version that will not crash on Linux :( (#1459) (by @damageboy) bd1c93 Updated Disassembler settings (#1463) (by @lukasz-pyrzyk) 35f50f Improved doc description of the ExportDiff property (#1465) (by @lukasz-pyrzyk) dbbab9 Clearly display names for .Net Framework (#1471) (by @svick) 044591 ParamsSource returning IEnumerable<object[]> fixes (#1478) (by @adamsitnik) 703d54 Safe access to CultureInfo (by @suslovk) a4dd37 Update to latest Iced (#1497) (by @Symbai) 092889 Add Wasm Tool Chain (#1483) (by @naricc) 01455d set process output encoding to utf8 (#1491) (by @lovettchris) fa7da4 net5.0 does not contain \"core\" word but it's a .NET Core moniker (#1479) (by @adamsitnik) 254da4 enforce Optimizations when using Custom Build Configurations (#1494) (by @adamsitnik) 765d52 allow the users to specify Platform via console args (#1492) (by @adamsitnik) 908b09 always print full information about non-optimized dependencies (#1454) (by @adamsitnik) 1ff50a Pedantic WASM improvements (#1498) (by @adamsitnik) d57c4c enforce Deterministic builds for auto-generated .NET Core projects (#1489) (by @adamsitnik) 59080c Support very long string as benchmark arguments (#1248) (by @adamsitnik) 9c5663 Wasm: samples, docs and a bug fix (#1500) (by @adamsitnik) 13ee8b Add Custom Runtime Pack option to WasmToolchain (#1501) (by @naricc) b356ac Update to latest Iced (#1502) (by @Symbai) 797ced fixed typo (#1508) (by @fleckert) ef0ac7 Change mono-config.js format in the Wasm Tool Chain for ICU support (#1507) (by @naricc) eb20d3 Update README (by @AndreyAkinshin) 92474e make MeasurementsStatistics a readonly ref struct (#1503) (by @skynode) 64cc94 [xamarin] fix for DebugConfig and read-only file system (#1509) (by @jonathanpeppers) c8af03 FactorialWithTailing - fix incorrect sample implementation (#1518) (by @MarecekF) c9f158 add .NET 6.0 support, rename .NET Core 5.0 to .NET 5.0 (#1523) (by @adamsitnik) e4d37d Fix native memory profiler (#1451) (by @WojciechNagorski) 10abc4 Remove unneeded files after etw profiler (#1540) (by @WojciechNagorski) e8d085 Documentation: add --maxWidth description (#1554) (by @joostas) c6cd54 Update CorrectionsSuggester.cs (#1556) (by @stanciuadrian) be769f Enable supported GcMode characteristics with corerun (#1552) (by @stanciuadrian) 0a004a Update getting-started.md (#1568) (by @michalgalecki) cd0bda Respect size number format in MetricColumn (#1569), fixes #1565 (by @jodydonetti) 349e90 Introduce RatioStyle, fix #721 (by @AndreyAkinshin) 718031 hardware counters: don't try to exclude non-existing overhead for long runnin... (by @adamsitnik) fbd52c remove the old PmcDiagnoser, EtwProfiler is much more accurate (#1548) (by @adamsitnik) 152414 Bring instruction pointer exporter back to live (#1550) (by @adamsitnik) c6d6fb Fix Merge operation failed for EtwProfiler (#1545) (by @adamsitnik) 769090 Add support for Platform-specific TFMs introduced in .NET 5 (#1560) (by @adamsitnik) 8de321 ensure that the auto-generated project alwas has target framework moniker in ... (by @adamsitnik) 0f9bb3 Dont remove artifacts when build fails (#1567) (by @adamsitnik) b4bda1 Dispose parameters, kill benchmarking process when it hangs after printing th... (by @adamsitnik) c209b1 Remove the dotnet global tool (#1572) (by @adamsitnik) 178b6a Don't run the benchmark once per iteration if only the first ivocation lasts ... (by @adamsitnik) 8b2214 use Environment.Version to determine .NET 5+ versions (#1580) (by @adamsitnik) d5c158 Prevent dotnet pack from packaging benchmark projects (#1584) (by @kendaleiv) 8149c3 Json exporter fix for double.NaN (#1581), fixes #1242 (by @marcnet80) c63fe8 Update message to not suggest an obsolete API (#1590) (by @martincostello) 0de41c Added wasmnet50 wasmnet60 monikers. (#1592) (by @naricc) 992719 fix issue #1561 (#1600) (by @WojciechNagorski) 81c234 Update README.md (#1601) (by @WojciechNagorski) 641ffd Fix #1604 - pass SummaryStyle to ParameterInstance.ToDisplayText() (#1609) (by @JohannesDeml) e72ddf Fix add missing culuture info to ToString in RatioStyle (#1610) (by @JohannesDeml) d17926 Json indentation level fix (#1618) (by @marcnet80) 40f6e5 Update framework symbol on dotnet new template #1512 (#1630) (by @ExceptionCaught) ffc8dd use .AddDiagnoser instead of the obsolete .With in the EtwProfiler doc sample... (by @MendelMonteiro) 5d421c Install local SDK without sudo on Unix (#1635) (by @am11) d71a7e update console app templating (#1632) (by @ExceptionCaught) aef9cb Sorting parameter columns with parameter priority (#1612) (by @JohannesDeml) d5f7b9 Memory Randomization (#1587) (by @adamsitnik) 5b2167 don't redirect Standard Error, as we don't read it and writing to it by bench... (by @adamsitnik) a7af81 introduce ManualConfig.CreateMinimumViable() method (#1582) (by @adamsitnik) 852bb8 .NET Core 2.1 -> .NET 5.0 (#1637) (by @adamsitnik) e01312 Support latest Windows and macOS versions in OsBrandStringHelper (by @AndreyAkinshin) 502dc9 CoreRT feed and version update (#1606) (by @adamsitnik) 9f5d70 Remove CoreRT workaround (#1643) (by @MichalStrehovsky) 6a151f passed args to benchmark runner (#1292) (by @chan18) bf63b3 Update Console Args doc, fixes #1559 (#1645) (by @kevinsalimi) 970d28 Update API in documentation, fixes #1602 (#1647) (by @kevinsalimi) d758f6 Allow for Config per method, introduce OS and OSArchitecture filters (#1097) (by @adamsitnik) b4e2b6 1655 doc with options obsolete usage of with (#1657) (by @cedric-cf) 8c28c8 add basic snap support (#1652) (by @adamsitnik) e1c8cb Filter hint improvements (#1644) (by @adamsitnik) 349f9d feat: Allowed to indicate the source of nuget package and whether it is a pre... (by @workgroupengineering) 4a917d Add tool chain for Netcore Mono AOT. (#1662) (by @naricc) 314a27 [Templates] Changed default debug type to pdbonly (#1667) (by @YohDeadfall) 2616cd Updated disassembler contribution docs (#1675) (by @YohDeadfall) 02b907 Fix a typo (#1676) (by @jeffhandley) b67cfb Fix location for NativeAOT publish files (#1679) (by @kant2002) 63e28c when all builds fail, BDN should stop after printing first error (#1672) (by @adamsitnik) becc13 Dont redirect standard input for WASM (#1689) (by @naricc) b97bf6 Fix change runtime target to Core50 (#1690) (by @JohannesDeml) 0321a3 Fixed smart pointer for multiline source code (#1674) (by @YohDeadfall) 7265c1 Resolve assembly location for SingleFile (#1686) (by @am11) 626dcb don't remove OS version number from the platform-specifc TFM (#1691) (by @adamsitnik) 95608d 0.13.0 release notes (#1697) (by @adamsitnik) 4b5a65 Remove Allocated column from the \"View results\" doc page (#1698) (by @rstm-sf) b0683f Set ValidateExecutableReferencesMatchSelfContained to false in aotllvm templa... (by @naricc) 09afe7 Windows 21H1 support in OsBrandStringHelper (by @AndreyAkinshin) 77b58d Update old changelogs (by @AndreyAkinshin) 2f4b79 Improve AsyncBenchmarksTests.TaskReturningMethodsAreAwaited (by @AndreyAkinshin) a79339 Disable CoreRtToolchain.Core50 in ThreadingDiagnoserTests.GetToolchains on Unix (by @AndreyAkinshin) 18e292 Update README (by @AndreyAkinshin) 09a204 Update BenchmarkDotNet.sln.DotSettings (by @AndreyAkinshin) 85db95 Bump Cake version: 0.37.0->1.1.0 (by @AndreyAkinshin) 5c74d5 Bump docfx version: 2.51->2.57.2 (by @AndreyAkinshin) 2a2c0c Update copyright year (2021) (by @AndreyAkinshin) 396060 Prepare v0.13.0 changelog (by @AndreyAkinshin) 6dcf43 Set library version: 0.13.0 (by @AndreyAkinshin) Contributors (37) Adam Sitnik (@adamsitnik) Adeel Mujahid (@am11) Adrian Stanciu (@stanciuadrian) Andrey Akinshin (@AndreyAkinshin) Andrii Kurdiumov (@kant2002) Cédric Charière Fiedler (@cedric-cf) chan18 (@chan18) Chris Lovett (@lovettchris) damageboy (@damageboy) Dexter (@skynode) Florian Eckert (@fleckert) Jeff Handley (@jeffhandley) jeremyosterhoudt (@jeremyosterhoudt) Jody Donetti (@jodydonetti) Johannes Deml (@JohannesDeml) Jonathan Peppers (@jonathanpeppers) Jonathon Wei (@ExceptionCaught) Justas (@joostas) kapsiR (@kapsiR) Kaywan Salimi (@kevinsalimi) Ken Dale (@kendaleiv) Konstantin (@suslovk) Łukasz Pyrzyk (@lukasz-pyrzyk) marcnet80 (@marcnet80) MarecekF (@MarecekF) Martin Costello (@martincostello) Mendel Monteiro-Beckerman (@MendelMonteiro) Michał Gałecki (@michalgalecki) Michal Strehovský (@MichalStrehovsky) Nathan Ricci (@naricc) Petr Onderka (@svick) Rustam (@rstm-sf) Symbai (@Symbai) Tyson Williams (@TysonMN) Wojciech Nagórski (@WojciechNagorski) workgroupengineering (@workgroupengineering) Yoh Deadfall (@YohDeadfall) Thank you very much! Additional details Date: May 19, 2021 Milestone: v0.13.0 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.0 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.0 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.0"
  },
  "changelog/v0.13.1.html": {
    "href": "changelog/v0.13.1.html",
    "title": "BenchmarkDotNet v0.13.1 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.1 BenchmarkDotNet v0.13.1 is a service update with various bug fixes and improvements. Highlights S390x architecture support (#1712) Various WASM toolchain improvements (#1719, #1722, #1729, #1742, #1743, #1744, #1746, #1757, #1763) Support of CoreRT on 5.0.3XX SDK (#1725) Using Utf8 for reading from standard input (fixes a nasty encoding-related bug) (#1735) Adjusting WaitForExit timeouts (#1745) Support for returning unmanaged types from benchmarks with InProcessToolchain (#1750) Disabled Tiered JIT (#1751) A MemoryDiagnoser bug fix (#1762) Allow users to hide Gen X columns (#1764) Copy GC settings from host process to the benchmark process (#1765) Do not split surrogates in shortified parameter values (#1705) Milestone details In the v0.13.1 scope, 3 issues were resolved and 23 pull requests were merged. This release includes 36 commits by 10 contributors. Resolved issues (3) #1703 Unable to run benchmark when ParamsSource refers to string with surrogate pairs #1713 System.NotSupportedException: Unknown Acknowledgment: \uFEFFAcknowledgment when running in a github action (assignee: @adamsitnik) #1714 AwaitingTasksShouldNotInterfereAllocationResults is flaky (assignee: @adamsitnik) Merged pull requests (23) #1705 do not split surrogates in ParameterInstance.ToDisplayText() (by @novak-as) #1710 Fix typo (by @martincostello) #1712 add S390x architecture support (by @adamsitnik) #1719 Added UsingBrowserRuntimeWorkload (by @naricc) #1722 Add AOT options to wasm runtime (by @naricc) #1725 Add ValidateExecutableReferencesMatchSelfContained (by @kant2002) #1729 Naricc/validate executable references match self contained (by @naricc) #1735 Use Utf8 not just for writing to standard output, but also for reading from standard input (by @adamsitnik) #1739 Add support for returning unmanaged types from benchmarks (by @kant2002) #1742 Fix WasmAssembliesToBundle item is empty error (by @radekdoulik) #1743 Add linker description for wasm AOT (by @radekdoulik) #1744 Make mono/wasm run on Windows (by @radekdoulik) #1745 Fix #1731. (by @cgranade) #1746 Make PrepareForWasmBuild work with wasm workload (by @radekdoulik) #1748 Fix typo in docs (by @Jlobblet) #1750 Fix pointer-returning benchmarks support for InProcessToolchain (by @adamsitnik) #1751 disable TieredJit so it's background allocations don't show up in allocated memory reported by MemoryDiagnoser tests (by @adamsitnik) #1757 [wasm] Add WasmMainJSPath in interpreter projects (by @radekdoulik) #1762 MemoryDiagnoser fix (by @adamsitnik) #1763 Pr wasm set runtimesrcdir for interpreter (by @naricc) #1764 Allow users to hide Gen X columns (by @adamsitnik) #1765 Copy GC settings from host process (by @adamsitnik) #1768 Fix typo in README (by @eugene-g) Commits (36) fe1124 Postrelease update of v0.13.0 changelog (by @AndreyAkinshin) 0388db Update build-and-pack.cmd (by @AndreyAkinshin) 5c8469 Set release date for v0.13.0 (by @AndreyAkinshin) 601a1a Fix typo (#1710) (by @martincostello) 5bc925 do not split surrogates in ParameterInstance.ToDisplayText() (#1705) (by @novak-as) 891e57 Add unicode testcases in ParameterInstanceTests.MaxParameterColumnWidthCanBeC... (by @AndreyAkinshin) 5d2160 Update changelog files (by @AndreyAkinshin) bbc4b4 add S390x architecture support (#1712) (by @adamsitnik) bf54f0 Fix flakiness in ThreadingDiagnoserTests (by @AndreyAkinshin) 6ffdb2 [WASM] Added UsingBrowserRuntimeWorkload (#1719) (by @naricc) 5196e6 Add AOT options to wasm runtime (#1722) (by @naricc) d97285 Add ValidateExecutableReferencesMatchSelfContained (#1725) (by @kant2002) cb23e1 Delete .BenchmarkDotNet.Samples.csproj.swp (#1726) (by @naricc) 75f632 Set ValidateExecutableReferencesMatchSelfContained for Wasm (#1729) (by @naricc) 9e7e50 Added false to Wasm cs proj. (#1734) (by @naricc) e7ff4c Use Utf8 not just for witing to standard output, but also for reading from st... (by @adamsitnik) 081563 Added UsingBrowserRuntimeWorkload false. (#1741) (by @naricc) 2fefdb Fix WasmAssembliesToBundle item is empty error (#1742) (by @radekdoulik) 6b475f Add linker description for wasm AOT (#1743) (by @radekdoulik) acb6f2 Make mono/wasm run on Windows (#1744) (by @radekdoulik) 4b3d19 Make PrepareForWasmBuild work with wasm workload (#1746) (by @radekdoulik) 141ef7 handle processes that don't exit on time more gracefully, fixes #1731. (#1745) (by @cgranade) c3fb7b Add support for returning unmanaged types from benchmarks (#1739) (by @kant2002) 6f453b [wasm] Allow unsafe code (#1752) (by @radekdoulik) c2cee2 Fix the CI (by @radekdoulik) 19cbef Fix typo in docs (#1748) (by John Blundell) 1a94d4 [wasm] Add WasmMainJSPath in interpreter projects (#1757) (by @radekdoulik) 37ec19 Get rid of warning (#1760) (by @radekdoulik) 4bd433 use benchmark process runtime, not host process runtime when deciding whether... (by @adamsitnik) 8cb701 Update OsBrandStringHelper (by @AndreyAkinshin) 8f81b5 Copy GC settings from host process (#1765) (by @adamsitnik) f37266 Allow users to hide Gen X columns (#1764) (by @adamsitnik) f9a4c1 [WASM] set runtimesrcdir for interpreter (#1763) (by @naricc) 9e674d Fix typo in README (by @eugene-g) 708be4 Prepare v0.13.1 changelog (by @AndreyAkinshin) a93681 Set library version: 0.13.1 (by @AndreyAkinshin) Contributors (10) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Andrii Kurdiumov (@kant2002) Cassandra Granade (@cgranade) Evgenii Grebeniuk (@eugene-g) John Blundell Martin Costello (@martincostello) Nathan Ricci (@naricc) Oleksandr Novak (@novak-as) Radek Doulik (@radekdoulik) Thank you very much! Additional details Date: August 11, 2021 Milestone: v0.13.1 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.1 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.1 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.1 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.1"
  },
  "changelog/v0.13.10.html": {
    "href": "changelog/v0.13.10.html",
    "title": "BenchmarkDotNet v0.13.10 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.10 Highlights Initial support of .NET 9 and minor bug fixes. Milestone details In the v0.13.10 scope, 2 issues were resolved and 3 pull requests were merged. This release includes 10 commits by 4 contributors. Resolved issues (2) #2436 BenchmarkDotNet Access Denied Error on WSL2 when Writing to '/mnt/c/DumpStack.log.tmp' (assignee: @AndreyAkinshin) #2455 .NET 9 support (assignee: @adamsitnik) Merged pull requests (3) #2447 Add support for wasm/net9.0 (by @radical) #2453 feat: set RuntimeHostConfigurationOption on generated project (by @workgroupengineering) #2456 implement full .NET 9 support (by @adamsitnik) Commits (10) c27152 Set next BenchmarkDotNet version: 0.13.10 (by @AndreyAkinshin) 2e96d2 Don't show AssemblyInformationalVersion metadata in BDN BrandVersion (by @AndreyAkinshin) d17c6a Support Windows 11 23H2 (10.0.22631) in OsBrandStringHelper (by @AndreyAkinshin) af9c5c Exception handling in DotNetCliGenerator.GetRootDirectory, fix #2436 (by @AndreyAkinshin) e11136 [build] Bump Docfx.App: 2.71.0->2.71.1 (by @AndreyAkinshin) 7b342f Add support for wasm/net9.0 (#2447) (by @radical) e17068 Adjust 'Failed to set up high priority' message (by @AndreyAkinshin) 0a734a feat: set RuntimeHostConfigurationOption on generated project (#2453) (by @workgroupengineering) ae4914 implement full .NET 9 support (#2456) (by @adamsitnik) 40c414 Prepare v0.13.10 changelog (by @AndreyAkinshin) Contributors (4) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Ankit Jain (@radical) workgroupengineering (@workgroupengineering) Thank you very much! Additional details Date: November 01, 2023 Milestone: v0.13.10 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.10 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.10 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.10 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.10 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.10"
  },
  "changelog/v0.13.11.html": {
    "href": "changelog/v0.13.11.html",
    "title": "BenchmarkDotNet v0.13.11 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.11 Highlights Small improvements. Milestone details In the v0.13.11 scope, 4 issues were resolved and 8 pull requests were merged. This release includes 28 commits by 7 contributors. Resolved issues (4) #2060 NativeAOT benchmark started from .Net Framework host doesn't have all intrinsics enabled (assignee: @adamsitnik) #2233 Q: Include hardware counters in XML output (assignee: @nazulg) #2388 Include AVX512 in listed HardwareIntrinsics #2463 Bug. Native AOT .NET 7.0 doesn't work. System.NotSupportedException: X86Serialize (assignee: @adamsitnik) Merged pull requests (8) #2412 Add HardwareIntrinsics AVX-512 info (by @nietras) #2458 Adds Metrics Columns to Benchmark Report Output (by @nazulg) #2459 Enable MemoryDiagnoser on Legacy Mono (by @MichalPetryka) #2462 update SDK to .NET 8 (by @adamsitnik) #2464 Use \"native\" for .NET 8, don't use \"serialize\" for .NET 7 (by @adamsitnik) #2465 fix NativeAOT toolchain and tests (by @adamsitnik) #2468 Add OperationsPerSecondAttribute (by @DarkWanderer) #2475 Fix some tests (by @timcassell) Commits (28) bb55e6 Set next BenchmarkDotNet version: 0.13.11 (by @AndreyAkinshin) db4d8b Adds Metrics Columns to Benchmark Report Output (#2458) (by @nazulg) e93b2b Use \"native\" for .NET 8, don't use \"serialize\" for .NET 7 (#2464) (by @adamsitnik) 127157 [build] Fix spellcheck-docs workflow (by @AndreyAkinshin) 8a02ec [build] Use our .NET SDK on Windows (by @AndreyAkinshin) 1b39e8 Suppress NU1903 in IntegrationTests.ManualRunning.MultipleFrameworks (by @AndreyAkinshin) e90311 update SDK to .NET 8 (#2462) (by @adamsitnik) fc7afe Enable MemoryDiagnoser on Legacy Mono (#2459) (by @MichalPetryka) 630622 fix NativeAOT toolchain and tests (#2465) (by @adamsitnik) 536a28 Add HardwareIntrinsics AVX-512 info (#2412) (by @nietras) 3fa045 Add OperationsPerSecondAttribute (#2468) (by @DarkWanderer) 0583cb Bump Microsoft.NETCore.Platforms: 5.0.0->6.0.0 (by @AndreyAkinshin) 2e62b9 Remove netcoreapp2.0;net461 from TFMs for IntegrationTests.ManualRunning.Mult... (by @AndreyAkinshin) 92fa3f Bump xunit: 2.5.0->2.6.2 (by @AndreyAkinshin) 01e220 Bump xunit.runner.visualstudio: 2.5.0->2.5.4 (by @AndreyAkinshin) 29a94c Bump Verify.Xunit: 20.3.2->20.8.2 (by @AndreyAkinshin) 538e0e Bump Microsoft.NET.Test.SDK: 17.6.2->17.8.0 (by @AndreyAkinshin) 136e4b Remove explicit Microsoft.NETFramework.ReferenceAssemblies reference in Bench... (by @AndreyAkinshin) 423b84 [build] Bump Docfx.App: 2.71.1->2.74.0 (by @AndreyAkinshin) 718953 [build] Bump Octokit: 7.0.0->9.0.0 (by @AndreyAkinshin) 0cce91 [build] Bump Cake.Frosting: 3.2.0->4.0.0 (by @AndreyAkinshin) 4d5dc9 Fix Newtonsoft.Json v13.0.1 in BenchmarkDotNet.IntegrationTests (by @AndreyAkinshin) c7ec60 Enable UserCanSpecifyCustomNuGetPackageDependency test on Linux (by @AndreyAkinshin) a572db Bump C# LangVersion: 11.0->12.0 (by @AndreyAkinshin) b4ac9d Nullability cleanup (2023-11-26) (by @AndreyAkinshin) 5557ae [build] Bump Docfx.App: 2.74.0->2.74.1 (by @AndreyAkinshin) b987b9 Fixed some tests. (#2475) (by @timcassell) 05eb00 Prepare v0.13.11 changelog (by @AndreyAkinshin) Contributors (7) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Michał Petryka (@MichalPetryka) Nazul Grimaldo (@nazulg) nietras (@nietras) Oleg V. Kozlyuk (@DarkWanderer) Tim Cassell (@timcassell) Thank you very much! Additional details Date: December 06, 2023 Milestone: v0.13.11 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.11 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.11 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.11 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.11 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.11"
  },
  "changelog/v0.13.12.html": {
    "href": "changelog/v0.13.12.html",
    "title": "BenchmarkDotNet v0.13.12 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.12 Highlights The biggest highlight of this release if our new VSTest Adapter, which allows to run benchmarks as unit tests in your favorite IDE! The detailed guide can be found here. This release also includes to a minor bug fix that caused incorrect job id generation: fixed job id generation (#2491). Also, the target framework in the BenchmarkDotNet templates was bumped to .NET 8.0. Milestone details In the v0.13.12 scope, 3 issues were resolved and 4 pull requests were merged. This release includes 12 commits by 4 contributors. Resolved issues (3) #2473 Custom SimpleJob Id ignored when the MinIterationTime attribute is used. #2492 Packing of BenchmarkDotNet.TestAdapter is broken (assignee: @AndreyAkinshin) #2494 Rider and R# do not distinguish parametrized TestAdapter cases (assignee: @AndreyAkinshin) Merged pull requests (4) #2438 Add a VSTest Adapter (by @caaavik-msft) #2490 Update the default framework on the templates to net8.0 (by @julesrx) #2491 [Bug Fix] Custom SimpleJob Id ignored (by @MattFromRVA) #2493 Fix BenchmarkDotNet.TestAdapter packability (by @AndreyAkinshin) Commits (12) d49417 Set next BenchmarkDotNet version: 0.13.12 (by @AndreyAkinshin) b3b2d9 Add Sponsors to README (by @AndreyAkinshin) 91f3f7 Add a VSTest Adapter (#2438) (by @caaavik-msft) 41b23b Update default framework version to net8.0 (LTS) (by @julesrx) 5c4653 [build] Bump Octokit: 9.0.0->9.1.0 (by @AndreyAkinshin) 8b6bad [build] In the release workflow, automatically generate an announcement discu... (by @AndreyAkinshin) 9f7492 [build] Add test-pack job in run-tests workflow, see #2492 (by @AndreyAkinshin) b67b6b Update pack files layout for BenchmarkDotNet.TestAdapter, fix #2492 (by @AndreyAkinshin) 06fb24 Use different FQNs for parameterized cases in TestAdapter, fix #2494 (by @AndreyAkinshin) 299095 [Bug Fix] Custom SimpleJob Id ignored (#2491) (by @MattFromRVA) 0159b8 [docs] Update vstest (by @AndreyAkinshin) cdce32 Prepare v0.13.12 changelog (by @AndreyAkinshin) Contributors (4) Andrey Akinshin (@AndreyAkinshin) Cameron Aavik (@caaavik-msft) Jules Raffoux (@julesrx) Matt Chaulklin (@MattFromRVA) Thank you very much! Additional details Date: January 05, 2024 Milestone: v0.13.12 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.12 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.12 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.12 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.12 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.12 https://www.nuget.org/packages/BenchmarkDotNet.TestAdapter/0.13.12"
  },
  "changelog/v0.13.2.html": {
    "href": "changelog/v0.13.2.html",
    "title": "BenchmarkDotNet v0.13.2 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.2 Highlights In BenchmarkDotNet v0.13.2, we have implemented support for: .NET 7 NativeAOT .NET Framework 4.8.1 We have also introduced new features and improvements including: Possibility to hide selected columns, Allocation Ratio column, Logging progress and estimated finish time, ARM64 support for BenchmarkDotNet.Diagnostics.Windows package, Printing Hardware Intrinsics information, Glob filters support for DisassemblyDiagnoser. Of course, this release includes dozens of other improvements and bug fixes! Our special thanks go to @mawosoft, @YegorStepanov and @radical who fixed a LOT of really nasty bugs. Supported technologies .NET 7 and .NET Framework 4.8.1 .NET 4.8.1 has been released earlier this month, while .NET 7 should land in autumn this year. Now you can use BenchmarkDotNet to compare both! BenchmarkDotNet=v0.13.1.1845-nightly, OS=Windows 11 (10.0.22622.575) Microsoft SQ1 3.0 GHz, 1 CPU, 8 logical and 8 physical cores .NET SDK=7.0.100-preview.6.22352.1 [Host] : .NET 7.0.0 (7.0.22.32404), Arm64 RyuJIT AdvSIMD Job-QJVIDT : .NET 7.0.0 (7.0.22.32404), Arm64 RyuJIT AdvSIMD Job-FNNXOY : .NET Framework 4.8.1 (4.8.9032.0), Arm64 RyuJIT Method Runtime Mean Allocated BinaryTrees_2 .NET 7.0 193.6 ms 227.33 MB BinaryTrees_2 .NET Framework 4.8.1 192.8 ms 228.01 MB Credit for adding .NET 7 support in #1816 goes to @am11. @adamsitnik implemented .NET 4.8.1 support in #2044 and #2067. Big thanks to @MichalPetryka who was using preview versions of BenchmarkDotNet and reported a bug related to .NET 4.8.1 support: #2059 that got fixed before we released a new version. NativeAOT We are really excited to see the experimental CoreRT project grow and become officially supported by Microsoft (under new name: NativeAOT)! You can read more about it here. Implementing and improving the support was a combined effort of multiple contributors that spawned across multiple repositories: @MichalStrehovsky: #66290 in dotnet/runtime, #2020 in dotnet/BenchmarkDotNet, #2046 in dotnet/BenchmarkDotNet @hez2010: #66650 in dotnet/runtime @Beau-Gosse-dev: #1955 in dotnet/BenchmarkDotNet @adamsitnik: #1960 in dotnet/BenchmarkDotNet, #1965 in dotnet/BenchmarkDotNet, #1972 in dotnet/BenchmarkDotNet, #1973 in dotnet/BenchmarkDotNet, #1994 in dotnet/BenchmarkDotNet, #1997 in dotnet/BenchmarkDotNet, #2045 in dotnet/BenchmarkDotNet, #2068 in dotnet/BenchmarkDotNet @kant2002: #1976 in dotnet/BenchmarkDotNet, #1979 in dotnet/BenchmarkDotNet @jkotas: #68038 in dotnet/runtime, #68142 in dotnet/runtime, #68249 in dotnet/runtime, #68308 in dotnet/runtime, #68375 in dotnet/runtime @MichalPetryka: #2065 in dotnet/BenchmarkDotNet As every AOT solution, NativeAOT has some limitations like limited reflection support or lack of dynamic assembly loading. Because of that, the host process (what you run from command line) is never an AOT process, but just a regular .NET process. This process (called Host process) uses reflection to read benchmarks metadata (find all [Benchmark] methods etc.), generates a new project that references the benchmarks and compiles it using ILCompiler. The boilerplate code is not using reflection, so the project is built with TrimmerDefaultAction=link (we have greatly reduced build time thanks to that). Such compilation produces a native executable, which is later started by the Host process. This process (called Benchmark or Child process) performs the actual benchmarking and reports the results back to the Host process. By default BenchmarkDotNet uses the latest version of Microsoft.DotNet.ILCompiler to build the NativeAOT benchmark according to this instructions. Moreover, BenchmarkDotNet by default uses current machines CPU features (change: #1994, discussion: #2061) and if you don't like this behavior, you can disable it. This is why you need to: install pre-requisites required by NativeAOT compiler target .NET to be able to run NativeAOT benchmarks (example: <TargetFramework>net7.0</TargetFramework> in the .csproj file) run the app as a .NET process (example: dotnet run -c Release -f net7.0). specify the NativeAOT runtime in an explicit way, either by using console line arguments --runtimes nativeaot7.0 (the recommended approach), or by using[SimpleJob] attribute or by using the fluent Job config API Job.ShortRun.With(NativeAotRuntime.Net70): dotnet run -c Release -f net7.0 --runtimes nativeaot7.0 For more examples please go to docs. BenchmarkDotNet=v0.13.1.1845-nightly, OS=Windows 11 (10.0.22000.856/21H2) AMD Ryzen Threadripper PRO 3945WX 12-Cores, 1 CPU, 24 logical and 12 physical cores .NET SDK=7.0.100-rc.1.22423.16 [Host] : .NET 7.0.0 (7.0.22.42223), X64 RyuJIT AVX2 Job-KDVXET : .NET 7.0.0 (7.0.22.42223), X64 RyuJIT AVX2 Job-HFRAGK : .NET 7.0.0-rc.1.22424.9, X64 NativeAOT AVX2 Method Runtime Mean Ratio Allocated BinaryTrees_2 .NET 7.0 95.06 ms 1.00 227.33 MB BinaryTrees_2 NativeAOT 7.0 90.32 ms 0.96 227.33 MB Some of .NET features are not supported by Native AOT, that is why you may want to filter them out using new [AotFilter] attribute: [AotFilter(\"Currently not supported due to missing metadata.\")] public class Xml_FromStream<T> New features and improvements Hiding Columns In #1621 @marcnet80 has reduced the number of columns displayed when multiple runtimes are being compared. In #1890 @YegorStepanov has implemented a set of new APIs that allow for hiding columns. It's also exposed via -h and --hide command line arguments. [MemoryDiagnoser] // adds Gen0, Gen1, Gen2 and Allocated Bytes columns [HideColumns(Column.Gen0, Column.Gen1, Column.Gen2)] // dont display GenX columns public class IntroHidingColumns { [Benchmark] public byte[] AllocateArray() => new byte[100_000]; } Sample results without [HideColumns]: Method Mean Error StdDev Gen0 Gen1 Gen2 Allocated AllocateArray 3.303 us 0.0465 us 0.0435 us 31.2462 31.2462 31.2462 97.69 KB With: Method Mean Error StdDev Allocated AllocateArray 3.489 us 0.0662 us 0.0763 us 97.69 KB Imagine how much time @YegorStepanov has saved to all the people who so far were removing the columns manually from the results before publishing them on GitHub! Allocation Ratio Column In #1859 @YegorStepanov has added Allocation Ratio Column. It's enabled by default when MemoryDiagnoser is used and one of the benchmarks is marked as [Benchmark(Baseline = true)] or when there are multuple jobs defined and one of them is marked as baseline. [MemoryDiagnoser] public class AllocationColumnSample { [Benchmark(Baseline = true)] [Arguments(\"test\")] public string Builder(string value) { StringBuilder sb = new (value); for (int i = 0; i < 10; i++) sb.Append(value); return sb.ToString(); } [Benchmark] [Arguments(\"test\")] public string Concatenation(string value) { string result = value; for (int i = 0; i < 10; i++) result += value; return result; } } Method value Mean Error StdDev Ratio Gen 0 Allocated Alloc Ratio Builder test 127.9 ns 0.49 ns 0.43 ns 1.00 0.0544 456 B 1.00 Concatenation test 120.2 ns 0.94 ns 0.88 ns 0.94 0.0908 760 B 1.67 Progress and estimated finish time In #1909 @adamsitnik has added logging of progress and estimated finish time. // ** Remained 5211 (99.9%) benchmark(s) to run. Estimated finish 2022-08-25 22:26 (9h 7m from now) ** arm64 support for BenchmarkDotNet.Diagnostics.Windows package Due to the update to TraceEvent 3.0 BenchmarkDotNet.Diagnostics.Windows package has now arm64 support. Which means that you can use EtwProfiler and other ETW-based diagnosers on Windows arm64. It would not be possible without @brianrob who implemented arm64 support for TraceEvent in #1533! Hardware Intrinsics information In #2051 @adamsitnik has extended the hardware information printed in the Summary table with Hardware Intrinsics information. Sine the space in Summary table is quite limited, we full information is printed only in the log: Special thanks to @tannergooding who provided a lot of very valuable feedback and @MichalPetryka who contributed an improvement #2066 for older runtimes. Other improvements WASM toolchain has received a lot of improvements from various .NET Team members: #1769, #1936, #1938, #1982. Dependencies and TFMs updates: #1805, #1978, #2012, #2019, #2035. Ensure proper SummaryStyle handling implemented by @mawosoft in #1828. Preserving EnablePreviewFeatures project setting which gives the possibility to benchmark preview .NET features. Implemented by @kkokosa in #1842. CI: Using non-deprecated macOS pool on Azure Pipelines, implemented by @akoeplinger in #1847 CI: Updating Cake to 2.0.0, adopting frosting project style. Implemented by @AndreyAkinshin in #1865. Detecting ReSharper's Dynamic Program Analysis. Implemented by @adamsitnik in #1874. Preventing benchmark failure when some of the exporters fail. Implemented by @epeshk in #1902. Don't use the diagnosers when benchmarking has failed. Implemented by @adamsitnik in #1903. Ensuring the default order of benchmarks is the same as declared in source code. Implemented by @adamsitnik in #1907. Making BuildTimeout configurable. Implemented by @adamsitnik in #1906. Notify users about private methods with Setup/Cleanup attributes. Implemented by @epeshk in #1912. Don't run Roslyn Analyzers for the generated code. Implemented by @adamsitnik in #1917. Ensure WorkloadActionUnroll and similar are optimized if possible. Implemented by @AndyAyersMS in #1935. Don't use blocking acknowledgments when there is no need to. Implemented by @adamsitnik in #1940. Executor: Don't use Process.ExitCode, unless the process has exited. Implemented by @radical in #1947. Revise heuristic for initial jitting. Implemented by @AndyAyersMS in #1949. Allow logging build commands output. Implemented by @radical in #1950. Change Mono AOT mode to Normal AOT with LLVM JIT fall back. Implemented by @fanyang-mono in #1990. Glob filters support for DisassemblyDiagnoser So far, the disassembler was always loading the type that was generated by BDN, searching for the benchmark method, disassembling it and when encountered direct method calls, disassembling the called methods as well (if their depth was lesser or equal to max configured depth). This was working fine, but only for direct method calls. For indirect, the disassembly was incomplete. In #2072 @adamsitnik has added the possibility to filter methods disassembled by the DisassemblyDiagnoser. The users can now pass --disasmFilter $globPattern and it's going to be applied to full signatures of all methods available for disassembling. Examples: --disasmFilter *System.Text* - disassemble all System.Text methods. --disasmFilter * - disassemble all possible methods. Moreover, ClrMD was updated to v2 (#2040) and few disassembler bugs have been fixed (#2075, #2078). We are expecting that the disassembler will be more reliable now. Docs and Samples improvements Big thanks to @SnakyBeaky, @Distinctlyminty, @asaf92, @adamsitnik and @eiriktsarpalis who have improved our docs, samples and error messages! #1776, #1797, #1850, #1861, #1939, #1974, #1997, #2042, #2050, #2068. Bug fixes WASM: #1811, #1846, #1916, #1926, #1932. Diagnoser-provided Analysers weren't automatically added to Config. Fixed by @mawosoft in #1790. Exportes could been duplicated. Fixed by @workgroupengineering in #1796. Small bug in SummaryStyle. Fixed by @mawosoft in #1801. InvalidOperationException/NullReferenceException in SmartParaemter. Fixed by @mawosoft in #1810. Failures caused by colons in benchmark name. Fixed by @ronbrogan in #1823. Some benchmark arugments were not properly escaped and were causing process launcher to crush. Fixed by @adamsitnik in #1841 Invalid size specifiers for Memory and Disassembly diagnosers. Fixed by @YegorStepanov in #1854 and #1855. Respect LogicalGroup order in DefaultOrderer. Fixed by @AndreyAkinshin in #1866. Endless loop in user interaction with redirected input. Fixed by @tmds in #. Broken power plan support. Fixed by @YegorStepanov in #1885. BytesAllocatedPerOperation was not being output by the JSON and XML exporters. Fixed by #martincostello in #1919. Incorrect default InvocationCount in the summary table. Fixed by @AndreyAkinshin in #1929. Failed build output was printed in reverse order. Fixed by @radical in #1945. Build failures due to NETSDK1150. Fixed by @OlegOLK in #1981. MetricCoumn was not respecting provided units when formatting values. Fixed by @mawosoft in #2033. Generating invalid code that was causing benchmark failures. Fixed by @mawosoft in #2041. CI: non-master build branches were publishing artifacts to the CI feed. Fixed by @mawosoft in #2047. Comments in the project files were causing build failures. Fixed by @mawosoft in #2056. Milestone details In the v0.13.2 scope, 50 issues were resolved and 124 pull requests were merged. This release includes 147 commits by 34 contributors. Resolved issues (50) #299 Add API to remove columns for baseline comparison (assignee: @AndreyAkinshin) #384 Print Vector .Count as part of machine info (assignee: @adamsitnik) #722 Add scaled column for Allocated Memory #837 Problems with default UnrollFactor in V0.11.0 (assignee: @adamsitnik) #1177 Public types missing from reference assemblies don't work with ParamsSource #1506 BenchmarkDotNet does not force to High Performance Mode during running (assignee: @YegorStepanov) #1603 Don't display Job and Toolchain column when running benchmarks for multiple runtimes #1669 --buildTimeout does not seem to work (assignee: @adamsitnik) #1680 Cannot override RD.xml for NativeAOT #1711 Add support for IBM Z architecture (assignee: @adamsitnik) #1727 Unhelpful rounding in MemoryDiagnoser #1753 \"call: command not found\" in .sh build script (assignee: @AndreyAkinshin) #1755 EventPipeProfiler: File names are very verbose #1756 EventPipeProfile: speedscope.app cannot parse result file (assignee: @adamsitnik) #1774 Ability to compare --corerun with --runtimes (assignee: @adamsitnik) #1775 Please add an easy way to remove columns #1789 Small bug in ImmutableConfigbuilder (assignee: @mawosoft) #1794 typo in error message #1800 Small bug in SummaryStyle (assignee: @mawosoft) #1803 Benchmark exception stops entire suite run (assignee: @adamsitnik) #1809 Exception when using ParamsSource with (null) objects #1812 Invalid codegen for Enumerable.Empty returned from ParamsSource #1819 How to change exporter output path? #1836 [Bug] System.InvalidOperationException: There is an error in XML document (0, 0). #1857 Github actions ubuntu-latest \"Unable to load shared library 'advapi32.dll' or one of its dependencies\" when profiling dotnet 5 #1864 Is there a way to join summaries as if the benchmarks were run separately? (assignee: @AndreyAkinshin) #1871 Detect ReSharper's Dynamic Program Analysis (assignee: @adamsitnik) #1872 BenchmarkDontNet should make allowance for projects where Preview Features are enabled #1887 MonoAotLLVM runtime is not actually AOTing things (assignee: @naricc) #1900 Failed to benchmark .NET 7 in release mode #1908 BenchmarkRunner.RunSource and BenchmarkRunner.RunUrl doesn't work #1929 Incorrect default InvocationCount in the summary table (assignee: @AndreyAkinshin) #1934 Ensure WorkloadActionUnroll and similar are optimized if possible #1937 PR builds should not be published to BDN nightly feed (assignee: @mawosoft) #1943 GitHub Actions Windows CI leg failing due to lack of native tools (assignee: @adamsitnik) #1948 questions to help with future PRs #1957 Broken pipe (assignee: @adamsitnik) #1977 More Data for JSON and XML Export #1989 Way to summarize all the params results (assignee: @YegorStepanov) #1992 API Docs on website empty (assignee: @AndreyAkinshin) #2000 DisassemblyDiagnoser broken on Linux (assignee: @adamsitnik) #2009 Cleanup the dependencies (assignee: @martincostello) #2011 Release-only build error when using ParamsSource with a LINQ method: Cannot implicitly convert type 'object' (assignee: @mawosoft) #2016 Support for .NET 7? #2028 Trying to build BDN on a windows arm64 host (assignee: @adamsitnik) #2039 Support .NET Framework 4.8.1 (assignee: @adamsitnik) #2055 Comment after breaks generated project #2059 BenchmarkDotNet misreports .Net Framework as 4.8.1 (assignee: @adamsitnik) #2063 BenchmarkDotNet nightly fails to disassemble .Net 7.0 properly #2074 DisassemblyDiagnoser producing invalid disassembly (assignee: @adamsitnik) Merged pull requests (124) #1621 Hide columns for multiple runtime (by @marcnet80) #1769 Make wasm-interpreter work like wasm-aot (by @naricc) #1776 Clarify effects of IterationSetup on UnrollFactor and InvocationCount (by @SnakyBeaky) #1790 Bugfix in ImmutableConfigBuilder. Fixes #1789 (by @mawosoft) #1796 fixes(configuration): Not unique exporter for exporter type (by @workgroupengineering) #1797 Update DotNetCliCommandExecutor.cs (by @Distinctlyminty) #1801 Include RatioStyle in SummaryStyle.Equals()/GetHashCode(). Fixes #1800. (by @mawosoft) #1805 Update PackageReference for System.Management to latest (5.0.0). (by @mawosoft) #1810 Fix null reference exceptions in SmartParameter. Fixes #1809 (by @mawosoft) #1811 [WASM][AOT] Do not include KernelTraceControl in WasmAssembliesToBundle (by @naricc) #1816 Add net70 runtime support (by @am11) #1823 Replace colon if present in folder name (by @ronbrogan) #1828 Ensure proper SummaryStyle handling (by @mawosoft) #1835 Enable mono llvmaot tool chain to work with net7 (by @naricc) #1841 Fix argument escaping (by @adamsitnik) #1842 Preserve EnablePreviewFeatures csproj setting (by @kkokosa) #1846 [wasm] fix perf after test renames (by @pavelsavara) #1847 Use non-deprecated macOS pool on Azure Pipelines (by @akoeplinger) #1848 align both Executors to use the same timeout (2s) (by @adamsitnik) #1850 Added exporter custom path to docs #1819 (by @asaf92) #1854 Fix size specifier (by @YegorStepanov) #1855 Change DisassemblyDiagnoser to use byte unit always (by @YegorStepanov) #1858 Bugfix for merged PR #1855 (by @mawosoft) #1859 Add Allocation Ratio column (by @YegorStepanov) #1861 JitDiagnosers should print an error when run on non-Windows OS (by @adamsitnik) #1865 Bump Cake to 2.0.0, adopt frosting project style (by @AndreyAkinshin) #1866 Respect LogicalGroup order in DefaultOrderer (see #1864) (by @AndreyAkinshin) #1870 UserInteraction: don't loop when reaching the input end. (by @tmds) #1873 add EnablePreviewFeatures to the list of settings copied by BDN to the auto-generated project (by @adamsitnik) #1874 disable ReSharper's Dynamic Program Analysis by default (by @adamsitnik) #1885 Comeback of power management (by @YegorStepanov) #1888 Added IntermediateOutputPath option to MonoAotCompiler task parameters (by @naricc) #1890 Hiding columns (by @YegorStepanov) #1896 Fix warnings (by @adamsitnik) #1897 set TreatWarningsAsErrors to true (by @adamsitnik) #1902 Handled exceptions from exporters in CompositeExporter (by @epeshk) #1903 don't use diagnosers when running the benchmark has failed (by @adamsitnik) #1906 Improve BuildTimeout (by @adamsitnik) #1907 ensure the default order of benchmarks is the same as declared in source code (by @adamsitnik) #1909 Log progress and estimated finish time (by @adamsitnik) #1910 Make FromUrl and FromSource more friendly (by @YegorStepanov) #1912 Notified users about private methods with Setup/Cleanup attributes (by @epeshk) #1915 JsonExporter: make Json export more extensible. (by @ptr1120) #1916 [WASM] Fix rename of main.js to test-main.js (by @naricc) #1917 Don't run Analyzers for the generated project + Roslyn workaround (by @adamsitnik) #1919 Restore BytesAllocatedPerOperation for JSON and XML (by @martincostello) #1921 Improve failure handling and finish time estimation (by @adamsitnik) #1926 Fix typo in WasmCsProj.txt (by @lewing) #1930 Display correct default InvocationCount in SummaryTable, fixes #1929 (by @AndreyAkinshin) #1932 [wasm] Set the right runtime moniker (by @radekdoulik) #1935 Fix optimization of action methods for coreclr (by @AndyAyersMS) #1936 [wasm] Improve the autogenerated project (by @radical) #1938 [wasm] Add a --wasmDataDir parameter (by @radical) #1939 Update contributing docs (by @adamsitnik) #1940 Don't use blocking acknowledgments when there is no need to (by @adamsitnik) #1945 AsyncProcessOutputReader: Use ConcurrentQueue instead of ConcurrentStack (by @radical) #1946 improve error message for users who pass path to Core_Root instead of CoreRun (by @adamsitnik) #1947 Executor: Don't use Process.ExitCode, unless the process has exited (by @radical) #1949 Revise heuristic for initial jitting. (by @AndyAyersMS) #1950 DotNetCli*: Allow logging command output (by @radical) #1953 add possibility to enable build output logging via command line args (by @adamsitnik) #1955 Cleaning up argument spacing in CLI calls. Add output path for publish. CoreRT (by @Beau-Gosse-dev) #1958 fix broken pipe issue (by @adamsitnik) #1959 add --justBuild for users who want to reuse code produced by BDN without running the benchmarks (by @adamsitnik) #1960 Improve support for NativeAOT (by @adamsitnik) #1961 disable AwaitingTasksShouldNotInterfereAllocationResults test (by @adamsitnik) #1965 Rename CoreRT to NativeAOT (by @adamsitnik) #1966 Actually AOT things in AOT mode; prevent JIT fall back (by @naricc) #1969 Fixed FreeBSD shared library extension in MonoAOTLLVM tool chain. (by @naricc) #1970 Add new --generateBinLog to generate msbuild binlogs, with names (by @radical) #1972 [NativeAOT] Set TrimmerDefaultAction to link (by @adamsitnik) #1973 don't place DynamicallyAccessedMembers on an array (by @adamsitnik) #1974 Update ArtifactFileNameHelper error message (by @eiriktsarpalis) #1975 Addressing code review suggestions (by @adamsitnik) #1976 Add support for Rd.xml file around project file (by @kant2002) #1978 Migrate from .NET 5 to .NET 6.0 (by @kant2002) #1979 Remove CPP codegen for NativeAOT (by @kant2002) #1981 Fix for issue NETSDK1150 (by @OlegOLK) #1982 DotNetCliCommand: Add new RetryFailedBuildWithNoDeps property (by @radical) #1984 Reduce generated code size (by @adamsitnik) #1985 don't emit debug symbols on platforms where it does not work well (by @adamsitnik) #1986 the CI must run net6.0, not net5.0 tests (by @adamsitnik) #1987 Fix AppVeyor build (by @adamsitnik) #1988 re-enable NativeAOT tests on GitHub Actions Windows (by @adamsitnik) #1990 [Mono] Change AOT mode to Normal AOT with LLVM JIT fall back (by @fanyang-mono) #1994 NativeAOT: IlcOptimizationPreference & IlcInstructionSet (by @adamsitnik) #1996 use AnyCPU for S390x (by @adamsitnik) #1997 Update NativeAOT docs, fix the support for local NativeAOT builds (by @adamsitnik) #2002 when user specifies both --runtimes and --corerun, multiple independent jobs should be created (by @adamsitnik) #2006 when Host process is not .NET Core, CoreRunToolchain should use latest available TFM (by @adamsitnik) #2008 Use PackageIcon property (by @martincostello) #2012 Cleanup dependencies and add net6.0 TFM (by @martincostello) #2019 Update Iced to its latest version. (by @teo-tsirpanis) #2020 Opt out of metadata trimming (by @MichalStrehovsky) #2023 don't run NativeAOT tests on AppVeyor Windows (by @adamsitnik) #2029 don't emit debug symbols for samples and test projects (by @adamsitnik) #2030 update TraceEvent to 3.0.1 to have a proper ARM64 support for Diagnostics package (by @adamsitnik) #2033 Bugfix MetricColumn: Respect unit when formatting values. (by @mawosoft) #2035 net461->net462 in Samples, Diagnosers, Tests (by @AndreyAkinshin) #2040 Port the .NET (Core) disassembler to ClrMd v2 (by @adamsitnik) #2041 Bugfix SmartParameter source code generation (by @mawosoft) #2042 Fix WmicCpuInfoProvider documentation (by @msitt) #2043 restore Microsoft.DotNet.PlatformAbstraction dependency (by @adamsitnik) #2044 add .NET 4.8.1 support (by @adamsitnik) #2045 adopt to recent NativeAOT changes (by @adamsitnik) #2046 Make a bit of BenchmarkDotNet trimmable (by @MichalStrehovsky) #2047 Restrict what's published to AppVeyor NuGet feed (BDN nightly) (by @mawosoft) #2050 Fix DocFx configuration and build (by @mawosoft) #2051 extend printed Runtime Info with simple Hardware Intrinsics information (by @adamsitnik) #2052 Address code review feedback (by @adamsitnik) #2056 Bugfix copied project settings (by @mawosoft) #2065 Add serialize to NativeAOT (by @MichalPetryka) #2066 Print Vector width in summary on older runtimes (by @MichalPetryka) #2067 fix .NET 4.8.1 detection (by @adamsitnik) #2068 print error when users try DisassemblyDiagnoser with NativeAOT (by @adamsitnik) #2071 use ClrMd v2 disassembler on Windows whenever possible (by @adamsitnik) #2072 Add glob filters support to disassembler to allow disassembling specific methods (by @adamsitnik) #2073 add two fallbacks to CoreRun copying (by @adamsitnik) #2075 Fix disassembler (by @adamsitnik) #2078 More disassembler improvements (by @adamsitnik) #2079 fix the CI (by @adamsitnik) #2081 JsonExporter: make Json export more extensible. (by @ptr1120) #2082 remove last warning (by @adamsitnik) #2084 Release notes for 0.13.2 (by @adamsitnik) Commits (147) 4de165 Postrelease v0.13.1 update (by @AndreyAkinshin) 74e3c4 Make wasm-interpreter work like wasm-aot (#1769) (by @naricc) 1a8296 Better snap support, fix #1753 (by @AndreyAkinshin) aa9167 Clarify effects of IterationSetup on UnrollFactor and InvocationCount (#1776) (by @SnakyBeaky) 937865 Set allow unsafe blocks to true. (#1779) (by @naricc) e08b79 Bugfix in ImmutableConfigBuilder. Fixes #1789 (#1790) (by @mawosoft) 156fd6 Fix an logger message typo in the DotNetCliCommandExecutor Execute method, fi... (by @Distinctlyminty) d312ed Include RatioStyle in SummaryStyle.Equals()/GetHashCode(). Fixes #1800. (#1801) (by @mawosoft) 38b99b Update PackageReference for System.Management to latest (5.0.0). (#1805) (by @mawosoft) e9a569 [WASM][AOT] Do not include KernelTraceControl in WasmAssembliesToBundle (#1811) (by @naricc) 80044a Fix null reference exceptions in SmartParameter. Fixes #1809 (#1810) (by @mawosoft) 273113 Add tests for the case when ParamsSource contains null (by @AndreyAkinshin) a5176a Add net7.0 runtime support (#1816) (by @am11) 7e757d Replace colon if present in folder name (#1823) (by @ronbrogan) 24e041 Use non-deprecated Azure Pipelines Ubuntu pool (#1829) (by @akoeplinger) beb543 Enable mono llvmaot tool chain to work with net7 (#1835) (by @naricc) 8a88b4 Ensure proper SummaryStyle handling (#1828) (by @mawosoft) 559d18 Fix argument escaping (#1841) (by @adamsitnik) 5927a6 Preserve EnablePreviewFeatures csproj setting (#1842) (by @kkokosa) db0a88 [wasm] fix perf after test renames (#1846) (by @pavelsavara) dddc1e Use non-deprecated macOS pool on Azure Pipelines (#1847) (by @akoeplinger) e62dc2 align both Executors to use the same timeout (2s) (#1848) (by @adamsitnik) 7d5a8f Added exporter custom path to docs #1819 (#1850) (by @asaf92) 7b0211 Fix size specifier (#1854), fixes #1727 (by @YegorStepanov) 34817b Change DisassemblyDiagnoser to use byte unit always (#1855) (by @YegorStepanov) 0c03e8 Bugfix for merged PR #1855 (#1858) (by @mawosoft) f00f7c JitDiagnosers should print an error when run on non-Windows OS (#1861) (by @adamsitnik) 956051 Add Allocation Ratio column (#1859) (by @YegorStepanov) 42c718 Categories should have the highest priority in logical group order, fixes #1864 (by @AndreyAkinshin) 6f6de0 Introduce BenchmarkRunner.Run(Type[] types) (by @AndreyAkinshin) 408786 Use Cake.FileHelpers 4.0.1 (by @AndreyAkinshin) 130f0f Additional diagnostics in WindowsDisassembler (see #1836) (by @AndreyAkinshin) 189e68 Fix GroupExporterTest (by @AndreyAkinshin) 61c447 Remove travis badges (by @AndreyAkinshin) e17992 Bump Cake to 2.0.0, adopt frosting project style (#1865) (by @AndreyAkinshin) bb180a Remove .travis.yml (by @AndreyAkinshin) f188f7 Respect LogicalGroup order in DefaultOrderer (see #1864) (#1866) (by @AndreyAkinshin) 7e19f3 Enable GitHub actions (by @AndreyAkinshin) ed53a3 Add GitHub Actions build status badge (by @AndreyAkinshin) 195cfd Support Windows 11 in OsBrandStringHelper (by @AndreyAkinshin) 5145d1 Fix documentation build tasks (by @AndreyAkinshin) 988dbf Update docs/articles/contributing/documentation.md (by @AndreyAkinshin) f17453 UserInteraction: don't loop when reaching the input end. (#1870) (by @tmds) 23d115 force High Performance Mode by default, fixes #1506 (#1885) (by @YegorStepanov) 328573 Added IntermediateOutputPath option to MonoAotCompiler task parameters (#1888) (by @naricc) 26ed31 set JETBRAINS_DPA_AGENT_ENABLE by default to 0 to disable ReSharper's Dynamic... (by @adamsitnik) 625b2c Fix warnings (#1896) (by @adamsitnik) 4b8821 Handled exceptions from exporters in CompositeExporter. Preventing benchmark ... (by @epeshk) 6ca6c6 don't use diagnosers when running the benchmark has failed (#1903) (by @adamsitnik) 6d2739 Improve BuildTimeout (#1906) (by @adamsitnik) 3ea212 ensure the default order of benchmarks is the same as declared in source code... (by @adamsitnik) 05bb3d Log progress and estimated finish time (#1909) (by @adamsitnik) 11751a Don't run Analyzers for the generated project + Roslyn workaround (#1917) (by @adamsitnik) 80f45c [WASM] Fix rename of main.js to test-main.js (#1916) (by @naricc) 32bb2d Improve failure handling and finish time estimation (#1921) (by @adamsitnik) 9ff0f9 Restore BytesAllocatedPerOperation for JSON and XML (#1919) (by @martincostello) 569f4f Add macOS Monterey test case in OsBrandStringTests (by @AndreyAkinshin) 63c0ce Notified users about private methods with Setup/Cleanup attributes (#1912) (by @epeshk) c1f210 fixes(configuration): Not unique exporter for exporter type (#1796) (by @workgroupengineering) bd0872 Rollback logicalGroupRules to List (by @AndreyAkinshin) c303ad Fix typo in WasmCsProj (#1926) (by @lewing) f1aefb Display correct default InvocationCount in SummaryTable, fixes #1929 (#1930) (by @AndreyAkinshin) ca5103 [wasm] Set the right runtime moniker (#1932) (by @radekdoulik) fa5984 [wasm] Improve the autogenerated project (#1936) (by @radical) b78ec9 Fix optimization of action methods for coreclr (#1935) (by @AndyAyersMS) 13f4ea Don't use blocking acknowledgments when there is no need to (#1940) (by @adamsitnik) 8ce19e [wasm] Add a --wasmDataDir parameter (#1938) (by @radical) 9b990d AsyncProcessOutputReader: Use ConcurrentQueue instead of ConcurrentStack (#1945) (by @radical) 937311 Revise heuristic for initial jitting. (#1949) (by @AndyAyersMS) 228a6a improve error message for users who pass path to Core_Root instead of CoreRun... (by @adamsitnik) 1d34f8 DotNetCli*: Allow logging command output (#1950) (by @radical) 01ead5 Executor: Don't use Process.ExitCode, unless the process has exited (#1947) (by @radical) 8e3d13 add possibility to enable build output logging via command line args (#1953) (by @adamsitnik) 6fa333 Cleaning up argument spacing in CLI calls. Add output path for publish. CoreR... (by @Beau-Gosse-dev) 010ac2 don't redirect standard input and don't write Acknowledgment to it if acknowl... (by @adamsitnik) d66289 Improve support for NativeAOT (#1960) (by @adamsitnik) 0868da disable AwaitingTasksShouldNotInterfereAllocationResults for InProcess toolch... (by @adamsitnik) 41a151 Rename CoreRT to NativeAOT (#1965) (by @adamsitnik) 9c1c27 [Mono] Actually AOT things in AOT mode; prevent JIT fall back (#1966) (by @naricc) ed6529 Fixed FreeBSD shared library extension in MonoAOTLLVM tool chain. (#1969) (by @naricc) 19679d Set TrimmerDefaultAction to link to ensure that trimmer only analyzes the par... (by @adamsitnik) e2d41b don't place DynamicallyAccessedMembers on an array (#1973) (by @adamsitnik) 09d939 Update ArtifaceFileNameHelper error message (#1974) (by @eiriktsarpalis) cac918 Add new --generateBinLog to generate msbuild binlogs, with names (#1970) (by @radical) 5f0db4 Add support for LoongArch64. (#1971) (by @LuckyXu-HF) 56556a Add support for Rd.xml file around project file (#1976) (by @kant2002) 804ed9 Remove CPP codegen for NativeAOT (#1979) (by @kant2002) 190d07 Fix for issue NETSDK1150 (#1981) (by @OlegOLK) a57819 Migrate from .NET 5 to .NET 6.0 (#1978) (by @kant2002) 74086a Addressing code review suggestions (#1975) (by @adamsitnik) 5fdafb Update contributing docs (#1939) (by @adamsitnik) ca43aa DotNetCliCommand: Add new RetryFailedBuildWithNoDeps property (#1982) (by @radical) bbe6ab Reduce generated code size (#1984) (by @adamsitnik) 31de77 the CI must run net6.0, not net5.0 tests (#1986) (by @adamsitnik) 554127 Fix AppVeyor build (#1987) (by @adamsitnik) a0035f re-enable NativeAOT tests on GitHub Actions Windows (#1988) (by @adamsitnik) 163f40 don't emit debug symbols (#1985) (by @adamsitnik) 35ba9d Change aot mode to normal aot with LLVM JIT fall back (#1990) (by @fanyang-mono) 1c935d NativeAOT: IlcOptimizationPreference & IlcInstructionSet (#1994) (by @adamsitnik) c165ba use AnyCPU for S390x, fixes #1711 (#1996) (by @adamsitnik) f4e8de Update NativeAOT docs, fix the support for local NativeAOT builds (#1997) (by @adamsitnik) 9e173d Fix typo in README (by @AndreyAkinshin) a79881 when user specifies both --runtimes and --corerun, multiple independent jobs ... (by @adamsitnik) 5e6275 when Host process is not .NET Core, CoreRunToolchain should use latests avail... (by @adamsitnik) b09431 Opt out of metadata trimming (#2020) (by @MichalStrehovsky) 5448d4 Update Iced to its latest version. (#2019) (by @teo-tsirpanis) fcda33 Use PackageIcon property (#2008) (by @martincostello) 72fce9 don't run NativeAOT tests on AppVeyor, as one of them takes 3 minutes and we ... (by @adamsitnik) 14f9cf don't emit debug symbols for samples and test projects as it breaks arm64 win... (by @adamsitnik) fd4a9c update TraceEvent to 3.0.1 to have a proper ARM64 support for Diagnostics pac... (by @adamsitnik) 8deec6 Bugfix MetricColumn: Respect unit when formatting values. (by @mawosoft) 9216a7 Add MetricColumnTests (by @AndreyAkinshin) 23f995 net461->net462 in Samples, Diagnosers, Tests (#2035) (by @AndreyAkinshin) 762b76 Cleanup dependencies and add net6.0 TFM (#2012) (by @martincostello) d24ea3 Port the .NET (Core) disassembler to ClrMd v2 (#2040) (by @adamsitnik) 6eb280 Fix WmicCpuInfoProvider comment (#2042) (by @msitt) f72e61 restore Microsoft.DotNet.PlatformAbstraction dependency (#2043) (by @adamsitnik) 99ef3f add .NET 4.8.1 support (#2044) (by @adamsitnik) 118135 adopt to recent NativeAOT changes (#2045) (by @adamsitnik) 96b376 Make a bit of BenchmarkDotNet trimmable (#2046) (by @MichalStrehovsky) e4ff20 Bugfix SmartParameter source code generation (#2041) (by @mawosoft) 461b70 Added the kernel keyword as a parameter to the ETWConfig (#2049) (by @mrsharm) d6020e Restrict what's published to AppVeyor NuGet feed (BDN nightly) (#2047) (by @mawosoft) 32ddeb provide Hardware Intrinsics information (#2051) (by @adamsitnik) 2e943e Fix DocFx configuration and build (by @mawosoft) 8c963b Reverting DocFX_Build dependency on Build (by @mawosoft) 48ecbc add missing hardware intrinsic info (#2052) (by @adamsitnik) b4c44c Bugfix copied project settings (#2056) (by @mawosoft) 2dc6c9 Add serialize to NativeAOT (#2065) (by @MichalPetryka) 7fb872 Print Vector width in summary on older runtimes (#2066) (by @MichalPetryka) 8e355b fix .NET 4.8.1 detection (#2067) (by @adamsitnik) 0f457d print error when users try DisassemblyDiagnoser with NativeAOT (#2068) (by @adamsitnik) b79282 use ClrMd2Disassembler on Windows whenever possible (#2071) (by @adamsitnik) a5b0e9 Add glob filters support to disassembler to allow disassembling specific meth... (by @adamsitnik) cab43e add two fallbacks to CoreRun copying (#2073) (by @adamsitnik) 4924f0 Fix few new disassembler bugs caused by update to ClrMd v2 (#2075) (by @adamsitnik) c99ba3 More disassembler improvements (#2078) (by @adamsitnik) 6bb61c Make FromUrl and FromSource more friendly (#1910) (by @YegorStepanov) 387ca0 fix the CI (#2079) (by @adamsitnik) 52d770 set TreatWarningsAsErrors to true (#1897) (by @adamsitnik) a11b49 JsonExporter: make Json export more extensible. (#2081) (by @ptr1120) 1424cf remove last warning that happens during pack command for master branch build ... (by @adamsitnik) 838000 Hide columns for multiple runtime (#1621) (by @marcnet80) 8ec00d Hiding columns (#1890) (by @YegorStepanov) e0dbce Release notes for 0.13.2 (#2084) (by @adamsitnik) f6f335 Prepare v0.13.2 changelog (by @AndreyAkinshin) 186998 Set library version: 0.13.2 (by @AndreyAkinshin) Contributors (34) Adam Sitnik (@adamsitnik) Adeel Mujahid (@am11) Alexander Köplinger (@akoeplinger) Andrey Akinshin (@AndreyAkinshin) Andrii Kurdiumov (@kant2002) Andy Ayers (@AndyAyersMS) Ankit Jain (@radical) Asaf Agami (@asaf92) Beau Gosse (@Beau-Gosse-dev) Eirik Tsarpalis (@eiriktsarpalis) Evgeny Peshkov (@epeshk) Fan Yang (@fanyang-mono) James MIllar (@Distinctlyminty) Konrad Kokosa (@kkokosa) Larry Ewing (@lewing) marcnet80 (@marcnet80) Marland Sitt (@msitt) Martin Costello (@martincostello) Matthias Wolf (@mawosoft) Michał Petryka (@MichalPetryka) Michal Strehovský (@MichalStrehovsky) Mukund Raghav Sharma (Moko) (@mrsharm) Nathan Ricci (@naricc) OlegOLK (@OlegOLK) Oriol Mesa (@SnakyBeaky) Pavel Savara (@pavelsavara) Peter Bruch (@ptr1120) Radek Doulik (@radekdoulik) Ron Brogan (@ronbrogan) Theodore Tsirpanis (@teo-tsirpanis) Tom Deseyn (@tmds) workgroupengineering (@workgroupengineering) Xu Liangyu (@LuckyXu-HF) Yegor Stepanov (@YegorStepanov) Thank you very much! Additional details Date: August 26, 2022 Milestone: v0.13.2 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.2 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.2 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.2 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.2"
  },
  "changelog/v0.13.3.html": {
    "href": "changelog/v0.13.3.html",
    "title": "BenchmarkDotNet v0.13.3 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.3 Highlights New supported technologies Add arm64 disassembler #1422 #2127 #2107 #2123 #2070 #2118 #2119 #2234 #2222 #2212 9ee1/Capstone.NET#37 Initial .NET 8 support #2192 .NET 6/7 MonoVM support #2064 #2142 #2227 #2230 Armv6 and Ppc64le architectures support #2216 #2219 Improved support Improved WASM support #2201 #2099 #2154 #2112 Improved NativeAOT support #2095 #2221 Improved Android support #2231 32-bit benchmarks can now handle addresses larger than 2GB with the help of LargeAddressAware #1469 #2145 Support 64bit affinity masks #2211 #2228 New features Add ExceptionDiagnoser #1736 #2169 #2182 Add PerfCollectProfiler #2117 Incremental benchmark execution with the help of --resume #1799 #2164 Taskbar progress #2102 #2158 #2140 Support --noForcedGCs to avoid forced GC between benchmark runs #2101 Added apples to apples comparison mode #2116 #2193 Communication between the host process and the benchmark process is now using pipes instead of output parsing #2092 #1933 #2189 #2207 #2200 Dozens of bugfixes Special Thanks We would like to highlight some important contributors who helped us with this release: OpenHack'22 (devexperts.com) hackathon sponsored by the DevExperts company. As part of this hackathon we have received following PRs: #2132 fix: include argument and param names in --filter (by @blouflashdb) #2140 Update console title with benchmark information (by @franciscomoloureiro) #2142 Issue 2064: Mono70 moniker (by @Serg046) #2148 adding validation errors when the benchmarks are unsupported (by @emanuel-v-r) #2160 Corrected logic to restore foreground color in ConsoleLogger.cs (by @farQtech) #2164 1799 adding resume arg (by @melias) #2169 Issue #1736: Add ExceptionDiagnoser (by @Serg046) #2161 add quiet logger (by @franciscomoloureiro) (not merged yet) #2171 Issue #1024: Calculate baseline by the fastest benchmark (by @Serg046) (not merged yet) Jan Vorlicek helped to implement arm64 disassembler during an internal Microsoft Hackathon: #2107 Implement TryGetReferencedAddress for relative branches (by @janvorli) #2123 Added other arm64 constant form extraction plus other changes (by @janvorli) Ahmed Garhy (maintainer of Capstone.NET) helped to improve Capstone.NET, which was need to implement arm64 disassembler: 9ee1/Capstone.NET#37 Sign Assembly with a Strong Name (by @9ee1) Milestone details In the v0.13.3 scope, 29 issues were resolved and 71 pull requests were merged. This release includes 87 commits by 22 contributors. Resolved issues (29) #989 [Suggestion] add API for detecting benchmark run failures. (assignee: @emanuel-v-r) #1422 --disasm switch on ARM64 throws Exception (assignee: @adamsitnik) #1469 Host exe marked /largeaddressaware #1521 Iteration setup and cleanup causes job baseline error with multiple runtimes passed to BenchmarkSwitcher #1684 Getting System.FormatException when passing certain string as params. (assignee: @YegorStepanov) #1709 BenchmarkSwitcher executes all benchmarks that share a base class (assignee: @YegorStepanov) #1736 Consider adding an ExceptionDiagnoser (assignee: @Serg046) #1737 runtime knobs broken link (assignee: @YegorStepanov) #1799 Enable interactive, incremental runs through the terminal (assignee: @melias) #1839 Markdown output should escape the output #1867 Trailing newline characters in input value break summary table #1933 how to debug reflection error #2064 Running with .Net 6/7 Mono JIT (assignee: @Serg046) #2070 BenchmarkDotNet crashing on Linux with DisassemblyDiagnoser (assignee: @adamsitnik) #2088 Running on Linux leaves terminal colors changed (assignee: @farQtech) #2099 WASM is recognized as NativeAOT #2102 Add benchmarking progress to console title (assignee: @franciscomoloureiro) #2125 Tests Just Stop Running During Run (assignee: @adamsitnik) #2126 DotNet 6 - VB - Error: The type or namespace name 'DeserializingBenchmarks' could not be found in the global namespace (are you missing an assembly reference?) #2131 --filter should include argument/params names (assignee: @blouflashdb) #2146 Build warning MSB3245: Could not locate the assembly Mono.Posix #2167 Site: No vertical bar should be displayed for the Main page #2185 WarmupCount=0 doesn't work (assignee: @AndreyAkinshin) #2187 Reports for InProcess jobs don't include non-Result measurements (assignee: @AndreyAkinshin) #2189 broker.ProcessData() hangs if something wrong is the spawned process (assignee: @adamsitnik) #2210 Broken integration tests on Ubuntu 22.04 (assignee: @adamsitnik) #2211 Setting affinity does not work for Environment.ProcessorCount >= 32 (assignee: @Donis-) #2216 ppc64le architecture support required for running benchmarks on Power Systems (assignee: @adamsitnik) #2223 Disassembler fails to disassemble some methods on Linux when using recursive mode (assignee: @adamsitnik) Merged pull requests (71) #2018 Port JetBrains' nullability annotations and clean-up code. (by @teo-tsirpanis) #2085 Use latest AzDO macOS pool (by @adamsitnik) #2087 Nit: fix broken link (by @YegorStepanov) #2092 Use Pipes for host and benchmark process communication (by @adamsitnik) #2095 [NativeAOT] use PublishAot and don't reference ILCompiler in explicit way (by @adamsitnik) #2096 ExecuteResult: Surface a Data property so the full output can be acce… (by @radical) #2101 Added a command line arg for not inducing any GCs while running Benchmarks (by @mrsharm) #2104 Fix invalid pre-requisites NativeAOT link in the 0.13.2 changelog (by @KeterSCP) #2107 Implement TryGetReferencedAddress for relative branches (by @janvorli) #2112 Disambiguate NativeAOT, and Wasm identification in BenchmarkDotNet.Po… (by @radical) #2116 Implement apples to apples comparison mode (by @adamsitnik) #2117 PerfCollect diagnoser (by @adamsitnik) #2118 Resolve indirect addresses in disassembly (by @adamsitnik) #2119 Initial version of the Arm64 instruction formatter (by @adamsitnik) #2120 Roslyn Toolchain does not support .NET Core (by @YegorStepanov) #2123 Added other arm64 constant form extraction plus other changes (by @janvorli) #2127 arm64 disassembler (by @adamsitnik) #2132 fix: include argument and param names in --filter (by @blouflashdb) #2133 ensure CompositeLogger is synchronized (by @adamsitnik) #2134 [Mono] Disable LLVM JIT (by @fanyang-mono) #2135 Escape Param data for the exporters (by @YegorStepanov) #2136 Pass non escaped strings to generated project (by @YegorStepanov) #2137 Update doc links and reduce redirects (by @YegorStepanov) #2140 Update console title with benchmark information (by @franciscomoloureiro) #2142 Issue 2064: Mono70 moniker (by @Serg046) #2143 throw an exception when multiple benchmark projects with the same name are found (by @adamsitnik) #2144 Automated spellcheck for docs via GitHub Actions (and address all raised issues) (by @SeanKilleen) #2145 Handle addresses larger than 2GB for 32-bit benchmarks #1469 (by @leonvandermeer) #2148 adding validation errors when the benchmarks are unsupported (by @emanuel-v-r) #2150 Update StaThread intro documentation (by @norepro) #2151 Fix user input matching (by @YegorStepanov) #2152 Make ParamsAllValues validator mandatory (by @YegorStepanov) #2154 remove dependency to Mono.Posix.NETStandard to unblock WASM benchmarks runs (by @adamsitnik) #2158 Add taskbar progress (by @timcassell) #2160 Corrected logic to restore foreground color in ConsoleLogger.cs (by @farQtech) #2164 1799 adding resume arg (by @melias) #2168 Fix bugs and typos (by @YegorStepanov) #2169 Issue #1736: Add ExceptionDiagnoser (by @Serg046) #2172 Cleanup NuGet.config (by @Youssef1313) #2174 Added the ability to not run with Evaluation Overhead (by @mrsharm) #2175 Rename TargetCount to IterationCount in SimpleJob attribute (by @johanvts) #2176 Fix #1521 (by @YegorStepanov) #2177 Simplify GetHashCode() (by @YegorStepanov) #2180 Fix race in AsyncProcessOutputReader (by @AndreyAkinshin) #2181 Fix #2167 - Give main page a title. Then the tab displays 'Home | Be…' (by @leonvandermeer) #2182 Fix a threading issue in ExceptionDiagnoser #1736 (by @leonvandermeer) #2183 Remove allowMultiple=true from column attributes (by @YegorStepanov) #2186 Fix EngineStage.Run for warmupCount=0 (fixes #2185) (by @AndreyAkinshin) #2188 Engine.Run() should return the full list of performed measurements (fixes #2187) (by @AndreyAkinshin) #2192 Add net8.0 support to all existing runtimes and toolchains (by @adamsitnik) #2193 use ImmutableConfig when doing apples-to-apples comparison (by @adamsitnik) #2196 Docs: Add note for ETW Profiling regarding Intel TDT (by @rbanks54) #2200 Fix resources leak (by @adamsitnik) #2201 fix WASM support (by @adamsitnik) #2202 Fix job filtering (by @YegorStepanov) #2204 Deprecate RunSource/RunUrl methods (by @YegorStepanov) #2207 Avoid hangs when starting benchmark process fails (by @adamsitnik) #2208 Fix Full Framework tests (by @adamsitnik) #2209 Update SDK to .NET 7, re-enable tests (by @adamsitnik) #2212 use the new, strong-name signed Capstone.NET (by @adamsitnik) #2217 Bump Newtonsoft.Json (by @YegorStepanov) #2219 add Armv6 and Ppc64le architectures support (by @adamsitnik) #2220 Remove duplicate reference (by @YegorStepanov) #2221 NuGet.org should be the default feed for NativeAOT 7.0 ILCompiler (by @adamsitnik) #2222 arm64 disassembler tests (by @adamsitnik) #2227 Add support for MonoVM to MemoryDiagnoser (by @adamsitnik) #2228 Increase max supported affinity from 31 to 64 (#2211) (by @Donis-) #2230 Add support for .NET SDK that uses Mono instead CLR as a default VM (by @adamsitnik) #2231 improve Android support (by @adamsitnik) #2234 Disassembler realiability fixes (by @adamsitnik) #2235 tests can't assume x64 hardware (by @adamsitnik) Commits (87) 33b288 Use latest AzDO macOS pool (#2085) (by @adamsitnik) 83750b Postrelease v0.13.2 update (by @AndreyAkinshin) 188c11 Nit: fix broken link (#2087) (by @YegorStepanov) 3a18b1 use PublishAot and don't reference ILCompiler in explicit way (#2095) (by @adamsitnik) 8ed521 Added a command line arg for not inducing any GCs while running Benchmarks (#... (by @mrsharm) 8514b2 ExecuteResult: Surface a Data property so the full output can be accessed (#2... (by @radical) 58f2d1 Use Pipes for host and benchmark process communication (#2092) (by @adamsitnik) b525ba Fix invalid pre-requisites NativeAOT links in the docs (#2104) (by @KeterSCP) 0cee16 Disambiguate NativeAOT, and Wasm identification in BenchmarkDotNet.Portabilit... (by @radical) 21a294 Implement apples to apples comparison mode (#2116) (by @adamsitnik) 37d0cf Roslyn Toolchain does not support .NET Core (#2120) (by @YegorStepanov) dbccef Add workflows/docs-stable.yaml (by @AndreyAkinshin) d03287 PerfCollect diagnoser (#2117) (by @adamsitnik) de5cf4 Bump docfx 2.59.3->2.59.4 (by @AndreyAkinshin) 7e87e8 Update workflows/docs-stable.yaml (by @AndreyAkinshin) ff443a Update workflows/docs-stable.yaml (by @AndreyAkinshin) a78c2e Add write-all permissions to workflows/docs-stable.yaml (by @AndreyAkinshin) f4d99a arm64 disassembler (#2127) (by @adamsitnik) 97c2d1 ensure access to logger is synchronized for async output reader (#2133) (by @adamsitnik) 9938c3 include argument and param names in --filter (#2132) (by @blouflashdb) 7f9590 Update doc links and reduce redirects (#2137) (by @YegorStepanov) 95bb2a Escape Param data for the exporters (#2135) (by @YegorStepanov) ecb25b Pass non escaped strings to generated project (#2136) (by @YegorStepanov) 5ed46d [Mono] Disable LLVM JIT (#2134) (by @fanyang-mono) 1f5637 throw an exception when multiple benchmark projects with the same name are fo... (by @adamsitnik) 095975 Handle addresses larger than 2GB for 32-bit benchmarks #1469 (#2145) (by @leonvandermeer) 8d2379 Update console title with benchmark information (#2140) (by @franciscomoloureiro) f8e0a5 Automated spellcheck for docs via GitHub Actions (and address all raised issu... (by @SeanKilleen) db8f8d Fix spelling warning in docs/articles/configs.jobs.md (by @AndreyAkinshin) adf9d6 Fix BenchmarkSwitcher user input matching (#2151) (by @YegorStepanov) b758d2 Update StaThread intro documentation (#2150) (by @norepro) eda1a4 remove dependency to Mono.Posix.NETStandard to unblock WASM benchmarks runs (... (by @adamsitnik) 58d4ba Make ParamsAllValues validator mandatory (#2152) (by @YegorStepanov) 28bf21 adding validation errors when the benchmarks are unsupported (#2148) (by @emanuel-v-r) 1fb101 Corrected logic to restore foreground color in ConsoleLogger.cs (#2160) (by @farQtech) c02c3d Fix bugs and typos (#2168) (by @YegorStepanov) 0f7eb2 Implement --resume support (#2164), fixes #1799 (by @melias) 7d8375 Issue #1736: Add ExceptionDiagnoser (#2169) (by @Serg046) 64c3a3 Implement MonoVM toolchain for net6.0 and net7.0 monikers (#2142) fixes #2064 (by @Serg046) c69895 Add taskbar progress (#2158) (by @timcassell) 163899 Cleanup NuGet.config (#2172) (by @Youssef1313) f4c0a7 Added the ability to not run with Evaluation Overhead from command line (#2174) (by @mrsharm) ce1b74 Rename TargetCount to IterationCount in SimpleJob attribute (#2175) (by @johanvts) 18c6ff Fix #1521 (#2176) (by @YegorStepanov) 4eb6d3 Bump Build.csproj TFM to net6.0 (by @AndreyAkinshin) 279c96 Bump actions/checkout v2->v3 (by @AndreyAkinshin) a1c62c Bump actions/checkout v2->v3 for spellcheck.yml (by @AndreyAkinshin) 7ba989 Automatically generate redirects in documentation (by @AndreyAkinshin) d55c47 Remove old redirect files in documentation (by @AndreyAkinshin) b6d329 Bump System.Drawing.Common in BenchmarkDotNet.Samples.csproj: 4.5.1->4.7.2 (by @AndreyAkinshin) ee8125 Remove allowMultiple=true from column attributes (#2183) (by @YegorStepanov) ddd2f3 Fix a threading issue in ExceptionDiagnoser #1736 (#2182) (by @leonvandermeer) 276f1a Fix EngineStage.Run for warmupCount=0 (fixes #2185) (#2186) (by @AndreyAkinshin) 681a63 Fix #2167 - Give main page a title. Then the tab displays 'Home | BenchmarkDo... (by @leonvandermeer) 00f693 Fix race in AsyncProcessOutputReader (#2180) (by @AndreyAkinshin) 36e998 Disable MemoryDiagnoserSupportsNativeAOT on osx-arm64 (by @AndreyAkinshin) 9e759f Disable ThreadingDiagnoserTests with ILCompiler 6.0.0-rc.1.21420.1 on osx-arm64 (by @AndreyAkinshin) e75bdd Engine.Run() should return the full list of performed measurements (fixes #21... (by @AndreyAkinshin) 28a8e7 Simplify GetHashCode() (#2177) (by @YegorStepanov) 36f9e7 Set net6.0 as the first TFM for BenchmarkDotNet.Tests (by @AndreyAkinshin) 761590 Add net8.0 support to all existing runtimes and toolchains (#2192) (by @adamsitnik) 8b6159 use ImmutableConfig when doing apples-to-apples comparison (#2193) (by @adamsitnik) a4ab68 Docs: Add note for ETW Profiling regarding Intel TDT and Windows Defender (#2... (by @rbanks54) 9c32a8 fix resources leak (#2200) (by @adamsitnik) ad8e9b fix WASM support (#2201) (by @adamsitnik) ccbaf0 Remove duplicated jobs when creating immutable config (#2202) (by @YegorStepanov) 90c82b Deprecate methods (#2204) (by @YegorStepanov) 47b8b7 Avoid hangs when starting benchmark process fails (#2207) (by @adamsitnik) 7982b8 Fix Full Framework tests (#2208) (by @adamsitnik) 61b3c5 Update SDK to .NET 7, re-enable NativeAOT tests, fix some other tests (#2209) (by @adamsitnik) d38313 use the new, strong-name signed Capstone.NET (#2212) (by @adamsitnik) b40150 add Armv6 and Ppc64le architectures support (#2219) (by @adamsitnik) 5ce28b Bump Newtonsoft.Json (#2217) (by @YegorStepanov) 3531c1 Port JetBrains' nullability annotations and clean-up code. (#2018) (by @teo-tsirpanis) 5ef855 Remove duplicate reference (#2220) (by @YegorStepanov) ee24d7 NuGet.org should be the default feed for NativeAOT 7.0 ILCompiler package (#2... (by @adamsitnik) 530d00 arm64 disassembler tests (#2222) (by @adamsitnik) 699285 Add support for MonoVM to MemoryDiagnoser (#2227) (by @adamsitnik) 0c90af change something small just to triegger the CI (by @adamsitnik) 2cce42 improve Android support (#2231) (by @adamsitnik) a6ef73 don't run Long Running Test on AppVeyor, try to avoid 1h timeouts (by @adamsitnik) bf8b53 Increase max supported affinity from 31 to 64 (#2211) (#2228) (by @Donis-) 82f03f Add support for .NET SDK that uses Mono instead CLR as a default VM (#2230) (by @adamsitnik) 968448 Disassembler realiability fixes (#2234) (by @adamsitnik) a098bc tests can't assume x64 hardware (#2235) (by @adamsitnik) 2665ac Prepare v0.13.3 changelog (by @AndreyAkinshin) 0714f5 Set library version: 0.13.3 (by @AndreyAkinshin) Contributors (22) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Ankit Jain (@radical) blouflashdb (@blouflashdb) Donis- (@Donis-) Emanuel Ramos (@emanuel-v-r) Fan Yang (@fanyang-mono) farQtech (@farQtech) franciscomoloureiro (@franciscomoloureiro) Johan von Tangen Sivertsen (@johanvts) leonvandermeer (@leonvandermeer) Maykon Elias (@melias) Mukund Raghav Sharma (Moko) (@mrsharm) norepro (@norepro) Richard Banks (@rbanks54) Sean Killeen (@SeanKilleen) Sergey Aseev (@Serg046) Sergiusz Zalewski (@KeterSCP) Theodore Tsirpanis (@teo-tsirpanis) Tim Cassell (@timcassell) Yegor Stepanov (@YegorStepanov) Youssef Victor (@Youssef1313) Thank you very much! Additional details Date: December 26, 2022 Milestone: v0.13.3 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.3 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.3 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.3 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.3"
  },
  "changelog/v0.13.4.html": {
    "href": "changelog/v0.13.4.html",
    "title": "BenchmarkDotNet v0.13.4 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.4 Highlights Fixed LINQPad support #2237 #2238 New JitStatsDiagnoser #2243 Minor documentation improvements #2206 #2218 JitStatsDiagnoser This new diagnoser introduced in (#2243) allows getting advanced JIT statistics. Sample usage: dotnet run -c Release -f net7.0 --filter *IntroBasic.Sleep --profiler jit Result: Method Mean Error StdDev Methods JITted Methods Tiered JIT allocated memory Sleep 15.53 ms 0.034 ms 0.032 ms 1,102 15 221,736 B Milestone details In the v0.13.4 scope, 1 issues were resolved and 4 pull requests were merged. This release includes 9 commits by 5 contributors. Resolved issues (1) #2237 Version 0.13.3 breaks LINQPad (and any non-Console application) Merged pull requests (4) #2206 Add single quote when use pattern with filters (by @erlangxk) #2218 Improve getting started guide (by @reflectronic) #2238 Fix IOException when Console window unavailable (#2237) (by @albahari) #2243 JitStatsDiagnoser (by @adamsitnik) Commits (9) dc7734 Postrelease v0.13.3 update (by @AndreyAkinshin) e04e2d Fix IOException when Console window unavailable (#2237) (#2238) (by @albahari) 7694d0 Update copyright year (by @AndreyAkinshin) 5e8a31 Revert comments in DocFxChangelogDownloadTask (by @AndreyAkinshin) ea0eb2 Add single quote when use pattern with filters (#2206) (by @erlangxk) 0cf185 Improve getting started guide (#2218) (by @reflectronic) 12bf22 JitStatsDiagnoser (#2243) (by @adamsitnik) 858a86 Prepare v0.13.4 changelog (by @AndreyAkinshin) 0dbc1f Set library version: 0.13.4 (by @AndreyAkinshin) Contributors (5) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) erlangxk (@erlangxk) Joe Albahari (@albahari) John Tur (@reflectronic) Thank you very much! Additional details Date: January 13, 2023 Milestone: v0.13.4 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.4 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.4 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.4 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.4"
  },
  "changelog/v0.13.5.html": {
    "href": "changelog/v0.13.5.html",
    "title": "BenchmarkDotNet v0.13.5 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.5 Highlights Improved JitStatsDiagnoser. This diagnoser was added in v0.13.4, it shows various stats from the JIT compiler that were collected during entire benchmark run (amount of JITted methods, amount of tiered methods, how much memory JIT allocated during the benchmark). In this release, we improved metric collection (#2246, e715d5) and added the [JitStatsDiagnoser] attribute (#2250 512413). Enable strong-named assemblies in the released NuGet packages #2258 #2263 5cd288 Avoid keeping referenced values returned from a benchmark in memory #1942 #2191 ff5dbe Keep generated files when MSBuild bin log is requested #2252 #2254 d3fbc0 Add Id for UnresolvedDiagnoser (an exception fix) #2251 a992b5 Add brand names for Windows 22H2 and macOS 13 86f212 0c2699 Remove deprecated InProcessToolchain #2248 615384 Milestone details In the v0.13.5 scope, 3 issues were resolved and 11 pull requests were merged. This release includes 16 commits by 4 contributors. Resolved issues (3) #1942 Consider changing Consume to not hold onto references for very long (assignee: @timcassell) #2252 msbuild binlog for the benchmark projects gets cleaned up too, making diagnosis of build impossible (assignee: @adamsitnik) #2258 Strong name validation failed Merged pull requests (11) #2178 Introduce MockToolchain (by @AndreyAkinshin) #2191 Don't hold onto references in Consumer (by @timcassell) #2246 improve the numbers reported for Tiered JIT (by @adamsitnik) #2248 Remove deprecated InProcessToolchain (by @timcassell) #2250 Add JitStatsDiagnoserAttribute (by @KeterSCP) #2251 UnresolvedDiagnoser needs to have an Id as well (by @adamsitnik) #2254 Keep generated files when MSBuild bin log is requested (by @adamsitnik) #2263 Enabled strong-named assemblies on all OS, fix #2258 (by @AndreyAkinshin) #2267 Bump Cake to 3.0.0 (by @AndreyAkinshin) #2268 simplify the MockRunner design (by @adamsitnik) #2269 bump SDK version to pick up .NET Runtime fix that should fix disassembler test issues (by @adamsitnik) Commits (16) 9193d4 Postrelease v0.13.4 update (by @AndreyAkinshin) 7b1f29 Set net7.0 as primary TFM for BenchmarkDotNet.Samples (by @AndreyAkinshin) 86f212 Support macOS 13 (Ventura) in OsBrandStringHelper (by @AndreyAkinshin) 0c2699 Support Windows 22H2 in OsBrandStringHelper (by @AndreyAkinshin) e715d5 improve JitStatsDiagnoser based on feedback from @kouvel (#2246) (by @adamsitnik) a992b5 UnresolvedDiagnoser needs to have an Id as well, otherwise CompositeDiagnoser... (by @adamsitnik) 512413 Add JitStatsDiagnoserAttribute (#2250) (by @KeterSCP) 5cd288 Enabled strong-named assemblies on all OS, fix #2258 (by @AndreyAkinshin) 615384 Removed deprecated InProcessToolchain. (#2248) (by @timcassell) d3fbc0 Keep generated files when MSBuild bin log is requested (#2254) (by @adamsitnik) ff5dbe Don't hold onto references in Consumer (#2191) (by @timcassell) 59e17f Bump Cake: 2.0.0->3.0.0 (#2267) (by @AndreyAkinshin) f76c68 Introduce MockToolchain (#2178) (by @AndreyAkinshin) 9e88e4 bump SDK version to pick up .NET Runtime fix that should fix disassembler tes... (by @adamsitnik) e2593c Prepare v0.13.5 changelog (by @AndreyAkinshin) ec962b Set library version: 0.13.5 (by @AndreyAkinshin) Contributors (4) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Sergiusz Zalewski (@KeterSCP) Tim Cassell (@timcassell) Thank you very much! Additional details Date: February 17, 2023 Milestone: v0.13.5 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.5 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.5 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.5 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.5"
  },
  "changelog/v0.13.6.html": {
    "href": "changelog/v0.13.6.html",
    "title": "BenchmarkDotNet v0.13.6 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.6 Highlights New BenchmarkDotNet.Diagnostics.dotTrace NuGet package. Once this package is installed, you can annotate your benchmarks with the [DotTraceDiagnoser] and get a dotTrace performance snapshot at the end of the benchmark run. #2328 Updated documentation website. We migrated to docfx 2.67 and got the refreshed modern template based on bootstrap 5 with dark/light theme switcher. Updated BenchmarkDotNet.Templates. Multiple issues were resolved, now you can create new benchmark projects from terminal or your favorite IDE. #1658 #1881 #2149 #2338 Response file support. Now it's possible to pass additional arguments to BenchmarkDotNet using @filename syntax. #2320 #2348 Custom runtime support. #2285 Introduce CategoryDiscoverer, see IntroCategoryDiscoverer. #2306 #2307 Multiple bug fixes. Milestone details In the v0.13.6 scope, 19 issues were resolved and 33 pull requests were merged. This release includes 127 commits by 14 contributors. Resolved issues (19) #1658 Pass arguments to runner in dotnet new templates #1694 Length cannot be less than zero #1783 MemoryDiagnoser table output invalid symbol #1856 Not Set Hardware Counter throws Argument Null Exception #1877 Any combination of Params/ParamsSource/ParamsAllValues is broken #1881 broken template for Rider #2036 Publish changelog for each BenchmarkDotNet versions using GitHub releases (assignee: @AndreyAkinshin) #2149 BenchmarkDotNet.Templates not showing in VS2022(17.3.6) new project dialog #2249 BenchmarkSwitcher.Run nullability check warnings in .NET 7 (assignee: @AndreyAkinshin) #2259 CSproj code generator produces invalid syntax after incorrectly parsing .targets file #2264 Benchmarkdotnet crashes when flushing the logger #2266 Incompatible Microsoft.CodeAnalysis.CSharp versioning with Razor #2271 'Unknown processor' yet again (assignee: @br3aker) #2279 Endless compile errors (assignee: @AndreyAkinshin) #2282 TimeUnit Setting Not Being Used in Excel Report #2306 Allow for benchmark categories composition using inheritance (assignee: @AndreyAkinshin) #2312 CodeAnalysisTreatWarningsAsErrors=true in Directory.Build.props breaks auto-generated benchmark assembly build (assignee: @viktorz) #2333 Cannot benchmark netcoreapp3.0 #2358 System.MissingMethodException: Method not found: 'System.String Perfolizer.Horology.TimeInterval.ToString(System.Globalization.CultureInfo, System.String, Perfolizer.Common.UnitPresentation)' Merged pull requests (33) #1879 adjust defaultBenchmarkDotNetVersion on build (by @askazakov) #2086 Tell the user about the asterisk (by @YegorStepanov) #2106 If a metric value could not be calculated, display ? instead of -. (by @timcassell) #2124 Fix crash when using HardwareCounter.NotSet (by @YegorStepanov) #2141 Add support for nested generic types (by @YegorStepanov) #2272 Try to shorten the log file name to avoid TooLongPath on Windows (by @AndreyAkinshin) #2274 Add Android specific GetNetCoreVersion Runtime Information capabilities. (by @LoopedBard3) #2276 Fix nullability issues in runner method signatures, fix #2249 (by @AndreyAkinshin) #2277 Bump xunit 2.4.1->2.4.2 (by @AndreyAkinshin) #2278 lock all access to CompositeLogger (by @adamsitnik) #2280 Add ParamsValidator (by @AndreyAkinshin) #2283 Improve ParamsValidator (by @AndreyAkinshin) #2285 Allow custom runtimes to use Executor (by @tgjones) #2286 Use config summary style in CsvExporter by default, fix #2282 (by @AndreyAkinshin) #2288 update Microsoft.CodeAnalysis.CSharp, fixes #2266 (by @dennishermann) #2300 Fix typos in good-practices.md (by @mrahhal) #2302 Fix net8.0 tfm detection (by @adamsitnik) #2304 IComparable for complex params (by @mrahhal) #2307 Introduce CategoryDiscoverer, fix #2306 (by @AndreyAkinshin) #2316 Updated CsProj.txt, set CodeAnalysisTreatWarningsAsErrors=false (by @viktorz) #2320 Add support for response files (by @kant2002) #2328 Add BenchmarkDotNet.Diagnostics.dotTrace (by @AndreyAkinshin) #2329 Bump Microsoft.NET.Test.Sdk: 16.11.0->17.6.2 (by @AndreyAkinshin) #2330 Use Verify library for approval tests (by @alinasmirnova) #2338 Improve templates (by @YegorStepanov) #2339 Add the args parameter to RunAll and RunAllJoined (by @YegorStepanov) #2343 Fix JitOptimizationsValidator when ran in NativeAOT (by @timcassell) #2347 Copy PackageReferences to generated csproj (by @timcassell) #2348 Add docs for RSP file support (by @kant2002) #2352 Fix netcoreapp3.0 and older builds (by @timcassell) #2359 Fix netcoreapp3.0 builds (by @timcassell) #2360 Fix MosCpuInfoProvider (by @timcassell) #2362 Cancel old CI jobs (by @timcassell) Commits (127) 401030 Postrelease v0.13.5 update (by @AndreyAkinshin) e2de0e Try to shorten the log file name to avoid TooLongPath on Windows (#2272) (by @AndreyAkinshin) fb7f1b Add Android specific NetCoreVersion. (#2274) (by @LoopedBard3) 6c128c Fix nullability issues in runner method signatures, fix #2249 (by @AndreyAkinshin) d9ecba Bump xunit 2.4.1->2.4.2 (by @AndreyAkinshin) cb571d Move ChangeLogBuilder.cs to the build project (by @AndreyAkinshin) c0b592 Remove scripts in docs (by @AndreyAkinshin) b26471 Bump docfx: 2.59.4 -> 2.62.1 (by @AndreyAkinshin) 0772ce log all access to CompositeLogger (#2278) (by @adamsitnik) 5148fe ReflectionExtensions cleanup (by @AndreyAkinshin) e07363 Add ParamsValidator for readonly/const fields (see #2279) (by @AndreyAkinshin) 4b6e83 Add validation for multiple Params* attributes, fix #1877 (by @AndreyAkinshin) b846d5 Add validation for Params* attributes on init-only properties, fix #1877 (by @AndreyAkinshin) 975a0e Fix crash when using HardwareCounter.NotSet (#2124) (by @YegorStepanov) 6162e9 Improve HardwareCounters validation, see #1856 (by @AndreyAkinshin) 565870 Allow custom runtimes to use Executor (#2285) (by @tgjones) 2d04a2 Use config summary style in CsvExporter by default, fix #2282 (#2286) (by @AndreyAkinshin) 809fed Add user help about asterisk (#2086) (by @YegorStepanov) ec429a update Microsoft.CodeAnalysis.CSharp, fixes #2266 (#2288) (by @dennishermann) 9b3186 Add twitter badge in README (by @AndreyAkinshin) 56c66d Create FUNDING.yml (by @AndreyAkinshin) bfb192 Fix net8.0 tfm detection (#2302) (by @adamsitnik) 492e58 Improve ParamsValidator (#2283) (by @AndreyAkinshin) f32a2e IComparable for complex params (#2304) (by @mrahhal) 960289 Enabled category inheritance, fix #2306 (by @AndreyAkinshin) 521b7f Introduce CategoryDiscoverer, fix #2306 (by @AndreyAkinshin) 40305b Add support for nested generic types (#2141) (by @YegorStepanov) 572dd1 Updated CsProj.txt, set CodeAnalysisTreatWarningsAsErrors=false (#2316) (by @viktorz) 43815d Improve timeouts for InProcessEmitExecutor under profiling (by @AndreyAkinshin) 7c4241 Fix nullability issues in AssemblyExtensions (by @AndreyAkinshin) fc7490 Enable verbose xunit logs for CI tests (by @AndreyAkinshin) e1f1d4 Ignore \"Platform linker not found\" in local runs (by @AndreyAkinshin) 40dca9 Fix compilation (by @AndreyAkinshin) c3a0f8 Workaround for xunit+ApprovalTests integration issues (by @AndreyAkinshin) adf72c Fix MemoryDiagnoserSupportsNativeAOT (by @AndreyAkinshin) b1baa7 Better assert message for AllSetupAndCleanupMethodRunsTest (by @AndreyAkinshin) 775ad4 Increase FinishEventTimeout in AsyncProcessOutputReader (by @AndreyAkinshin) 567562 Fix local DisassemblyDiagnoserTests run on macOS (by @AndreyAkinshin) a260bd Improve 'command took' log line format (by @AndreyAkinshin) ff6e8d Add BenchmarkDotNet.Diagnostics.dotTrace (by @AndreyAkinshin) 1c5597 Fix links in docs (by @AndreyAkinshin) 4b265c Fix generation of the docs/api (by @AndreyAkinshin) bb46d8 Bump .NET SDK: 7.0.200->7.0.302 (by @AndreyAkinshin) 6553e0 Bump docfx: 2.62.1->2.67.3 (by @AndreyAkinshin) e2c321 Simplify api generation via cake+docfx (by @AndreyAkinshin) 88beb2 Fix building doc specifying .net 4.6.2 as requirement (by @JobaDiniz) 43ae33 Bump .NET SDK: 7.0.302->7.0.304 (security fix) (by @AndreyAkinshin) 862617 Make formatting DotSettings consistent with Roslyn analyzer (by @AndreyAkinshin) bfbcec Fix ConfigCompatibilityValidatorTests on Linux (by @AndreyAkinshin) bed071 Bump Microsoft.NET.Test.Sdk: 16.11.0->17.6.2 (by @AndreyAkinshin) 73f8fd Use Verify library for approval tests (#2330) (by @alinasmirnova) b725ac Fix PackTask.ShouldRun (by @AndreyAkinshin) 2e1774 Catch the NotSupportedException thrown in NativeAOT for `GetReferencedAssem... (by @timcassell) 58ee5c Add the args parameter to RunAll and RunAllJoined (#2339) (by @YegorStepanov) 977c05 Add support for response files (#2320) (by @kant2002) 17df12 Add docs for RSP file support (#2348) (by @kant2002) dc3cef Improve templates (#2338) (by @YegorStepanov) d6e080 Move RedirectGenerator to the build project (by @AndreyAkinshin) b797cf Update versioning in build scripts (by @AndreyAkinshin) ebe925 Revert \"Update versioning in build scripts\" (by @AndreyAkinshin) b91501 Update versioning in build scripts (by @AndreyAkinshin) 68bedd Update changelog builder (by @AndreyAkinshin) d46c32 Update contributors names and count in changelogs (by @AndreyAkinshin) 319f0e Remove hardcoded markdown from code, generate dynamically (by @AndreyAkinshin) 6d005a Update UID in changelog generation (by @AndreyAkinshin) fb6f43 Fix full.md generation (by @AndreyAkinshin) 124476 Bump Cake.FileHelpers: 6.0.0->6.1.3 (by @AndreyAkinshin) 0286c4 Split MsBuildSettings to separate tasks in the Build project (by @AndreyAkinshin) a519b6 Copy PackageReferences to generated csproj (#2347) (by @timcassell) 74c1e1 Added platform property to MsBuildSettingsBuild (by @AndreyAkinshin) 4e9edb Update Pack workflow (by @AndreyAkinshin) 9b8227 Move generated changelog details to a separate branch (by @AndreyAkinshin) 562a80 Add workflows/docs-changelog-generate.yaml (by @AndreyAkinshin) f519a5 Exclude 'docs-changelog-details' from builds (by @AndreyAkinshin) 152ad7 Update changelog download strategy in workflows (by @AndreyAkinshin) fbc0d7 Fix changelog downloading workflow (by @AndreyAkinshin) 748448 Add UpdateStats task (by @AndreyAkinshin) 609e48 Generate index.md from README.md (by @AndreyAkinshin) c4debe adjust defaultBenchmarkDotNetVersion on build (#1879) (by @askazakov) 88cb48 If a metric value could not be calculated, display ? instead of -. (#2106) (by @timcassell) 3af22c Prepare v0.13.6 changelog (by @AndreyAkinshin) 2d5156 Remove Ben.Demystifier from Build project (by @AndreyAkinshin) ee1ae7 Bump Octokit: 6.2.1->7.0.0 (by @AndreyAkinshin) dc54ac Bump docfx: 2.67.3->2.67.5 (by @AndreyAkinshin) 7986ce Remove excessive logs in cleanup (by @AndreyAkinshin) c352b3 Improve RScript discover strategy in RPlotExporter (by @AndreyAkinshin) 7dc098 Handle exceptions in GetDebuggableAttribute (by @AndreyAkinshin) 5065bc Bump C#: 9.0->11.0 (by @AndreyAkinshin) 48a7b6 Support Linux brand versions (by @AndreyAkinshin) 03ebe4 Simplify the environment info presentation (by @AndreyAkinshin) 0978d0 Support macOS 14 Sonoma in OsBrandStringHelper (by @AndreyAkinshin) a6edfe Fix CPU frequency detection on Linux (by @AndreyAkinshin) 144f5c Fix CPU detection on Windows when wmic is not available via PATH, fix #2271 (by @AndreyAkinshin) 6291a7 Huge build project refactoring (by @AndreyAkinshin) 47bd6d Bump JetBrains.Profiler.SelfApi: 2.4.2->2.5.0 (by @AndreyAkinshin) f5777b Disable net462 integration tests on non-windows os (by @AndreyAkinshin) c78b7d Fix race in Broker, workaround for #2317 (#2318) (by @AndreyAkinshin) 389908 Suppress dependency rebuilding in integration tests on windows+net7.0 (by @AndreyAkinshin) 469b43 Update test-reporter (by @AndreyAkinshin) 2b8bc8 Fix netcoreapp3.0 and older builds (#2352) (by @timcassell) c0cbd2 Add version history to BuildContext (by @AndreyAkinshin) 41f86e Rework documentation generation (by @AndreyAkinshin) 4243a6 Improve build script option parsing (by @AndreyAkinshin) 210020 Rework GitHub workflows (by @AndreyAkinshin) c5fd22 Fix DocsUpdate (by @AndreyAkinshin) b6cbad Fix report-test-results.yaml (by @AndreyAkinshin) 519537 report-test-results.yaml: fix artifact download (by @AndreyAkinshin) 81cf9f report-test-results.yaml: fix permissions (by @AndreyAkinshin) e42dae GitHub workflow rename (by @AndreyAkinshin) 554b00 Update report-test-results.yaml (by @AndreyAkinshin) f3a799 Update Github Actions workflow files (by @AndreyAkinshin) cca009 Update report-test-results.yaml (by @AndreyAkinshin) 28a196 Disable AppVeyor integration (by @AndreyAkinshin) bd89a0 Disable Azure Pipelines integration (by @AndreyAkinshin) 1e9c99 Update version handling in build properties (by @AndreyAkinshin) d4c70e Update version prefix to 0.13.6 (by @AndreyAkinshin) bf020e Automatically update changelog footer (by @AndreyAkinshin) 3b361e Add Release build task (by @AndreyAkinshin) f43495 Fix documentation generation (by @AndreyAkinshin) 30887e Update team.md (by @AndreyAkinshin) 28e003 Update license.md (by @AndreyAkinshin) d883fd Suppress running publish-nightly on forked repositories (by Andrey Akinshin) ca9d8b Fix MosCpuInfoProvider (#2360) (by @timcassell) 3e7334 Cancel old CI jobs when a new push is done. (#2362) (by @timcassell) 9171cf Lock perfolizer reference, fix #2358 (by @AndreyAkinshin) 278549 Add MyGet badge in README (by @AndreyAkinshin) e85fe2 Fix netcoreapp3.0 builds (#2359) (by @timcassell) Contributors (14) Adam Sitnik (@adamsitnik) Alina Smirnova (@alinasmirnova) Andrey Akinshin Andrey Akinshin (@AndreyAkinshin) Andrii Kurdiumov (@kant2002) askazakov (@askazakov) dennishermann (@dennishermann) Joberto Diniz (@JobaDiniz) Mohammad Rahhal (@mrahhal) Parker Bibus (@LoopedBard3) Tim Cassell (@timcassell) Tim Jones (@tgjones) ViktorZ (@viktorz) Yegor Stepanov (@YegorStepanov) Thank you very much! Additional details Date: July 11, 2023 Milestone: v0.13.6 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.6 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.6 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.6 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.6 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.6"
  },
  "changelog/v0.13.7.html": {
    "href": "changelog/v0.13.7.html",
    "title": "BenchmarkDotNet v0.13.7 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.7 Highlights This release contains important bug fixes listed below. Milestone details In the v0.13.7 scope, 12 issues were resolved and 13 pull requests were merged. This release includes 38 commits by 9 contributors. Resolved issues (12) #1773 Ability to recompile for each target runtime #2311 Detect when MonoAOT compilation fails and abort the benchmark run #2346 Can't use latest version of BenchmarkDotNet #2356 Add tests for expected results (assignee: @timcassell) #2364 Benchmark project using paket dependency manager fails to build auto-generated projects (assignee: @timcassell) #2369 Unable to use variables for PackageReferences after #2347 #2373 Regression in parsing arguments with spaces (assignee: @kant2002) #2377 Multiple nuget warnings/errors after moving to 0.13.6 breaking the build #2378 BenchmarkDotNet requires dotnet cli to be installed #2382 -p perf doesn't seem to work right with locally built runtime (assignee: @adamsitnik) #2389 PlatformNotSupportedException thrown on Android in ConsoleTitler #2391 Benchmark fails build with imported project Merged pull requests (13) #2335 AggressiveOptimization in InProcess toolchains (by @timcassell) #2361 Add expected results tests (by @timcassell) #2365 Don't copy PackageReference in csproj (by @timcassell) #2367 Improve build for mono aot (by @radical) #2368 IComparable fallback for Tuple/ValueTuple (by @mrahhal) #2370 Rebuild .Net Framework projects (by @timcassell) #2375 Fix regression in parsing arguments with spaces Closes #2373 (by @kant2002) #2379 [chore]: fix error message (by @ErtanTaner) #2380 Cancel old jobs on push (by @timcassell) #2381 Support --cli argument for CsProjClassicNetToolchain (by @timcassell) #2384 perfcollect: don't restore symbols for local builds (by @adamsitnik) #2385 Fix missing import on Debug build (by @caaavik-msft) #2390 Fix PlatformNotSupportedException thrown on Android in ConsoleTitler (by @Adam--) Commits (38) c9347c Set next BenchmarkDotNet version: 0.13.7 (by @AndreyAkinshin) df4ced Fix generate-gh-pages.yaml (by @AndreyAkinshin) 142a89 DotNetCliCommand.cs: Fail the build if no-dependencies retry build fails (by @radical) c0311b MonoAOTLLVMCsProj.txt: Add auto-imports for extension props/targets (by @radical) f42b97 MonoAOTLLVMCsProj.txt: Imports the props file early enough to allow (by @radical) f6bc29 MonoAOTLLVMCsProj.txt: Add SelfContained=true (by @radical) e4c4f6 [build] Specify NuGet source to PushNupkg (by @AndreyAkinshin) 7de12a [build] rework command line argument parsing (by @AndreyAkinshin) 3f890f [build] Rename tasks (by @AndreyAkinshin) c780b3 [build] Rework examples (by @AndreyAkinshin) 398ae6 [build] Rework ReleaseTask (by @AndreyAkinshin) 8a7caa [build] Rework ReadmeUpdater (by @AndreyAkinshin) 7a8135 IComparable fallback for Tuple/ValueTuple (#2368) (by @mrahhal) fd2639 Removed PackageReference from copied settings. (#2365) (by @timcassell) 6f471c Fix package version in BenchmarkDotNet.Templates (by @AndreyAkinshin) dc9b80 Fix regression in parsing arguments with spaces Closes #2373 (#2375) (by @kant2002) bc59d4 AggressiveOptimization in InProcess toolchains (#2335) (by @timcassell) 70ebf6 Update file layout (by @AndreyAkinshin) ab1794 Recover cSpell location (by @AndreyAkinshin) 28809a Rework environment-specific custom xUnit attributes (by @AndreyAkinshin) c682d5 Skip UserCanSpecifyCustomBuildConfiguration on .NET Framework, see #2376 (by @AndreyAkinshin) 55a337 Move cSpell.json to build (by @AndreyAkinshin) 293627 Add expected results tests (#2361) (by @timcassell) 60c302 Fix attribute usage in IntegrationTests.ManualRunning (by @AndreyAkinshin) 6fa7a9 change dotnet \"cli\" to \"SDK\" in error message (#2379) (by @ErtanTaner) 4d6f16 Update run-tests.yaml (#2380) (by @timcassell) 64d05c Support --cli argument for CsProjClassicNetToolchain (#2381) (by @timcassell) d93490 Rebuild .Net Framework projects (#2370) (by @timcassell) f8ab51 Enable nullable annotations for the whole solution (by @AndreyAkinshin) b912a8 Code cleanup (by @AndreyAkinshin) dc365e Add snupkg to nightly workflow artifacts (by @AndreyAkinshin) a89ad2 Fix path in dotnet nuget push command (by @AndreyAkinshin) da02fd Upgrade setup-node in spellcheck-docs workflow (by @AndreyAkinshin) 657342 Bump xUnit: 2.4.2->2.5.0 (by @AndreyAkinshin) 90ef2a Fix debug build (#2385) (by @caaavik-msft) 914ee7 perfcollect: don't restore symbols for local builds (#2384) (by @adamsitnik) fd5b76 Fix PlatformNotSupportedException thrown on Android in ConsoleTitler (#2390) (by @Adam--) c02aea Prepare v0.13.7 changelog (by @AndreyAkinshin) Contributors (9) Adam Anderson (@Adam--) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Andrii Kurdiumov (@kant2002) Ankit Jain (@radical) Cameron Aavik (@caaavik-msft) Ertan Taner (@ErtanTaner) Mohammad Rahhal (@mrahhal) Tim Cassell (@timcassell) Thank you very much! Additional details Date: August 04, 2023 Milestone: v0.13.7 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.7 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.7 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.7 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.7 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.7"
  },
  "changelog/v0.13.8.html": {
    "href": "changelog/v0.13.8.html",
    "title": "BenchmarkDotNet v0.13.8 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.8 Highlights This release contains important bug fixes. Milestone details In the v0.13.8 scope, 5 issues were resolved and 9 pull requests were merged. This release includes 15 commits by 8 contributors. Resolved issues (5) #1995 Left Justification option for summary table columns #2394 Multiple MarkdownExporters not possible (assignee: @bstordrup) #2399 Custom MarkdownExporter (assignee: @nietras) #2400 Should StreamLogger be TextWriterLogger? (assignee: @nietras) #2405 0.13.7 BenchmarkDotNet.Autogenerated project fails build (assignee: @timcassell) Merged pull requests (9) #2395 Issue2394 multiple markdown exporters not possible even with different names (by @bstordrup) #2406 Refactor out base TextLogger from StreamLogger (by @nietras) #2407 Make MarkdownExporter ctor and Dialect protected (by @nietras) #2409 Default to RoslynToolchain (by @timcassell) #2410 feat: add text justification style (by @Vahdanian) #2415 - update the templates install command to reflect dotnet cli updates (by @baywet) #2416 Update stub decoding for .NET 8 for disassemblers (by @janvorli) #2418 Enable nullability for BenchmarkDotNet.Annotations (by @alinasmirnova) #2419 Nullability In BenchmarkDotNet project (by @alinasmirnova) Commits (15) e1122c Set next BenchmarkDotNet version: 0.13.8 (by @AndreyAkinshin) b2235a [build] Remove explicit snupkg pushing (by @AndreyAkinshin) 2c999b [build] Fix ReleaseTask console help info (by @AndreyAkinshin) d058c7 Issue2394 multiple markdown exporters not possible even with different names ... (by @bstordrup) 9da449 Make MarkdownExporter ctor and Dialect protected (#2407) (by @nietras) c35dcb Refactor out base TextLogger from StreamLogger (#2406) (by @nietras) e0c667 - update the templates install command to reflect dotnet cli updates (#2415) (by @baywet) d39108 Update stub decoding for .NET 8 for disassemblers (#2416) (by @janvorli) 2d763c Enable nullability for BenchmarkDotNet.Annotations (by @alinasmirnova) 83fc5e Updated CodeAnnotations to the actual version (by @alinasmirnova) 3860e4 Removed redundant check (by @alinasmirnova) 2a8bab Fixed nullability warnings for some files from BenchmarkDotNet project (by @alinasmirnova) b035d9 feat: add text justification style (#2410) (by @Vahdanian) e2e888 Use Roslyn Toolchain by default if no build settings are changed. (by @timcassell) f8de1e Prepare v0.13.8 changelog (by @AndreyAkinshin) Contributors (8) Alina Smirnova (@alinasmirnova) AmirHossein Vahdanian (@Vahdanian) Andrey Akinshin (@AndreyAkinshin) Benny Tordrup (@bstordrup) Jan Vorlicek (@janvorli) nietras (@nietras) Tim Cassell (@timcassell) Vincent Biret (@baywet) Thank you very much! Additional details Date: September 08, 2023 Milestone: v0.13.8 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.8 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.8 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.8 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.8 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.8"
  },
  "changelog/v0.13.9.html": {
    "href": "changelog/v0.13.9.html",
    "title": "BenchmarkDotNet v0.13.9 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.13.9 Highlights This release contains bug fixes. Milestone details In the v0.13.9 scope, 3 issues were resolved and 7 pull requests were merged. This release includes 26 commits by 5 contributors. Resolved issues (3) #2054 Custom logging/visualization during the benchmark run (assignee: @caaavik-msft) #2404 Using DisassemblyDiagnoser in GitHub Actions (assignee: @timcassell) #2432 Something went wrong with outliers when using --launchCount (assignee: @AndreyAkinshin) Merged pull requests (7) #1882 use coalesce instead of join (by @askazakov) #2413 Fix linux crash from disassembler (by @timcassell) #2420 Add event processor functionality (by @caaavik-msft) #2421 More nullability warnings fixes (by @alinasmirnova) #2433 Fix build errors with latest sdk (by @timcassell) #2434 Fix Event Processors not being copied in ManualConfig.Add (by @caaavik-msft) #2435 Treat warnings not as errors in manual test project (by @timcassell) Commits (26) ece5cc Set next BenchmarkDotNet version: 0.13.9 (by @AndreyAkinshin) ad9376 Add event processor functionality (#2420) (by @caaavik-msft) 8227bb Address PR feedback (#2434) (by @caaavik-msft) 46b3c0 Fix linux crash from disassembler (#2413) (by @timcassell) 967a97 Fix build errors with latest sdk. (#2433) (by @timcassell) dd7a9b Treat warnings not as errors in manual test project (#2435) (by @timcassell) 583874 Print full stacktrace for GenerateException, see #2436 (by @AndreyAkinshin) 6e3a15 Support WSL detection in RuntimeInformation (by @AndreyAkinshin) 8986e0 Update myget url in README (by @AndreyAkinshin) 516bd6 Enabled nullability for BenchmarkDotNet.Diagnostics.dotTrace.csproj (by @alinasmirnova) 5428eb Fixed nullability warnings in methods signatures (by @alinasmirnova) 7fbbc9 Removed CanBeNull attribute (by @alinasmirnova) 9d7350 Fixed warnings on null assignments (by @alinasmirnova) b43d28 Fixed warnings in EngineEventLogParser (by @alinasmirnova) 148165 Removed an unnecessary check (by @alinasmirnova) 465aaf Fixed empty catch warning (by @alinasmirnova) 9a7bb7 [build] Bump: Microsoft.DocAsCode.App 2.67.5 -> Docfx.App 2.71.0 (by @AndreyAkinshin) 9dd7b6 Fix license badge link in README (by @AndreyAkinshin) 134b8e [build] Automatic NextVersion evaluation (by @AndreyAkinshin) 8090d9 Suppress NETSDK1138 (TFM out of support warning) (by @AndreyAkinshin) af610e Bump .NET SDK: 7.0.305->7.0.401 (by @AndreyAkinshin) 8838ed [build] Fix docfx build warnings (by @AndreyAkinshin) 2d379b Remove outlier consistency check, fix #2432 (by @AndreyAkinshin) 00628a use coalesce instead of join (by @askazakov) 411a6e Prepare v0.13.9 changelog (by @AndreyAkinshin) 228a46 Rollback docfx.json (by @AndreyAkinshin) Contributors (5) Alina Smirnova (@alinasmirnova) Andrey Akinshin (@AndreyAkinshin) askazakov (@askazakov) Cameron Aavik (@caaavik-msft) Tim Cassell (@timcassell) Thank you very much! Additional details Date: October 05, 2023 Milestone: v0.13.9 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.9 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.9 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.13.9 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.9 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.9"
  },
  "changelog/v0.14.0.html": {
    "href": "changelog/v0.14.0.html",
    "title": "BenchmarkDotNet v0.14.0 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.14.0 Highlights Introduce BenchmarkDotNet.Diagnostics.dotMemory #2549: memory allocation profile of your benchmarks using dotMemory, see BenchmarkDotNet.Samples.IntroDotMemoryDiagnoser Introduce BenchmarkDotNet.Exporters.Plotting #2560: plotting via ScottPlot (initial version) Multiple bugfixes The default build toolchains have been updated to pass IntermediateOutputPath, OutputPath, and OutDir properties to the dotnet build command. This change forces all build outputs to be placed in a new directory generated by BenchmarkDotNet, and fixes many issues that have been reported with builds. You can also access these paths in your own .csproj and .props from those properties if you need to copy custom files to the output. Bug fixes Fixed multiple build-related bugs including passing MsBuildArguments and .Net 8's UseArtifactsOutput. Breaking Changes DotNetCliBuilder removed retryFailedBuildWithNoDeps constructor option. DotNetCliCommand removed RetryFailedBuildWithNoDeps property and BuildNoRestoreNoDependencies() and PublishNoBuildAndNoRestore() methods (replaced with PublishNoRestore()). Milestone details In the v0.14.0 scope, 18 issues were resolved and 28 pull requests were merged. This release includes 55 commits by 16 contributors. Resolved issues (18) #946 Copy to $(OutDir) does not copy to benchmarkdotnet output folder (assignee: @timcassell) #1270 Docs for SummaryStyle #1377 Forward msbuild properties to project reference (assignee: @timcassell) #1457 Directory.Build.props hijacking generated csproj output path (assignee: @timcassell) #1595 ValueTask-returning benchmarks are not being called correctly (assignee: @timcassell) #1795 'BenchmarkDotNet.Autogenerated\\project.assets.json' not found. (assignee: @timcassell) #2203 Consider adding tests for WASM support #2253 TaskbarProgressCom is not supported when benchmarking Native AOT #2310 Bug: Getting an error loading BenchmarkDotNet.Diagnostics.Windows.dll for a benchmark that is not windows specific #2366 default(object) takes more time than expected in net7.0 #2466 Add support for true (assignee: @timcassell) #2477 MSBuild Params Not Applied to Benchamrk (assignee: @timcassell) #2524 Reference assemblies are searched in the wrong location #2540 Unable to use wasm or monoaotllvm as runtime (assignee: @LoopedBard3) #2542 InvalidMeasurementUnitException when using --statisticalTest argument when comparing private builds (assignee: @AndreyAkinshin) #2545 HideColumns + custom corerun = incorrect table markdown #2554 Question about visibility of DotTraceDiagnoser's second constructor (assignee: @AndreyAkinshin) #2570 BenchmarkDotNet test adapter not running tests with dotnet test Merged pull requests (28) #2108 Fix consume ValueTask backed by IValueTaskSource (by @timcassell) #2255 Fix TaskbarProgress (by @timcassell) #2374 stackalloc in separate method (by @timcassell) #2393 Fix MsBuildArguments (by @timcassell) #2498 Enhance Diagnoser Loading Behavior for Non-Critical Assemblies (by @MattFromRVA) #2500 Mark test adapter entry points as autogenerated (by @molesmoke) #2503 Update MsBuildErrorMapper (by @timcassell) #2504 Fix some tests (by @timcassell) #2510 Docs for SummaryStyle (by @MattFromRVA) #2517 fix: Spelling mistake (by @BenjaminMichaelis) #2522 Fix benchmarks with same class but different namespace having same ID (by @caaavik-msft) #2523 .Net SDK Validation (by @MattFromRVA) #2525 Update toolchain docs (by @MattFromRVA) #2526 Bump Octokit version (by @adamsitnik) #2531 Fix wasm toolchain (by @timcassell) #2532 Add Integration Test for WASM (by @caaavik-msft) #2534 Update Microsoft.Diagnostics.Tracing.TraceEvent (by @sbomer) #2538 Add support for wasm and Mono AOT LLVM monikers to SDK Validator (by @caaavik-msft) #2539 Fix Mono AOT LLVM (by @caaavik-msft) #2541 Add Wasm and MonoAOTLLVM to DotNetSdkVersionValidator (by @LoopedBard3) #2549 DotMemoryDiagnoser implementation (by @martinothamar) #2560 Initial ScottPlotExporter with just Bar Plot and Unit Tests (by @FlatlinerDOA) #2565 Fix - incorrect table markdown #2545 (by @AumkarGorde) #2566 Fix names of instructions sets for PublishAot scenarios (by @MichalStrehovsky) #2571 Fix BenchmarkDotNet test adapter not running tests with dotnet test (by @sheffer21) #2572 Add Support for Warning Logging and Integrate with Visual Studio Test Logging (by @sheffer21) #2583 Updated readme to make it clear that experienced performance engineers are also welcome (by @iCodeSometime) #2605 fix(CI): Deprecation issues (by @workgroupengineering) Commits (55) f8ac9c Set next BenchmarkDotNet version: 0.13.13 (by @AndreyAkinshin) 5dd1a9 [docs] Update cSpell.json (by @AndreyAkinshin) 7dacb1 [docs] Update cSpell.json (by @AndreyAkinshin) aa85d8 Added new Exception (by @MattFromRVA) e8cf48 Update copyright year (by @AndreyAkinshin) 688913 [build] Bump .NET SDK: 8.0.100 -> 8.0.101 (by @AndreyAkinshin) 3cf7b8 [build] Reduce verbosity of RestoreTask (by @AndreyAkinshin) 96d8f5 [docs] Update vstest.md (by @AndreyAkinshin) cf14d5 Mark test adapter entry points as autogenerated (by @jeremy-visionaid) 570eee [build] Bump Docfx.App: 2.74.1->2.75.0 (by @AndreyAkinshin) c4c204 Fixed some tests. (by @timcassell) f32166 Update MsBuildErrorMapper. (by @timcassell) d2f690 Update tests. (by @timcassell) 1d95e5 [build] Bump Docfx.App: 2.75.0->2.75.1 (by @AndreyAkinshin) e6fdc6 Pass OutputPath, IntermediateOutputPath, OutDir properties to dotnet ... (by @timcassell) 33e9e9 fix: Spelling mistake (by @BenjaminMichaelis) 109528 Fix benchmarks with same class but different namespace having same ID (#2522) (by @caaavik-msft) c20fd5 Update toolchain docs (#2525) (by @MattFromRVA) 0a41e1 Bump Octokit version (by @adamsitnik) 863165 Fix wasm toolchain (#2531) (by @timcassell) f4c39e Update Microsoft.Diagnostics.Tracing.TraceEvent (#2534) (by @sbomer) 59647c .Net SDK Validation (#2523) (by @MattFromRVA) f17d40 Add support for wasm and Mono AOT LLVM monikers to SDK Validator (#2538) (by @caaavik-msft) 443579 Add Integration Test for WASM (#2532) (by @caaavik-msft) b5fc05 [build] Make build.sh more portable (by @AndreyAkinshin) 63626b [tests] Add docs for WasmTests (by @AndreyAkinshin) 9a9d7e Fix Mono AOT LLVM (#2539) (by @caaavik-msft) 3305b3 Add System.Runtime.CompilerServices.Unsafe to BenchmarkDotNet.Tests (by @AndreyAkinshin) 306210 Bump Perfolizer: 0.2.1->0.3.16 (by @AndreyAkinshin) 036f46 Add Wasm and MonoAOTLLVM to DotNetSdkVersionValidator (#2541) (by @LoopedBard3) ad0240 Bump Perfolizer: 0.3.16->0.3.17 (by @AndreyAkinshin) 7a1c10 Fix bugs in statistical tests, fix #2542 (by @AndreyAkinshin) 0d3099 Fix StatisticalTestColumnTests.NoDifferenceIfValuesAreTheSame (by @AndreyAkinshin) 7306ee Fix consume ValueTask backed by IValueTaskSource (#2108) (by @timcassell) 4ab69b Moved stackalloc to separate method. (#2374) (by @timcassell) c7b7ab DotMemoryDiagnoser implementation (#2549) (by @martinothamar) 55ce92 Bump JetBrains.Profiler.SelfApi: 2.5.0->2.5.2 (by @AndreyAkinshin) a24d68 Fix DotTrace/DotMemory attribute ctors, fix #2554 (by @AndreyAkinshin) d98a1d Fix names of instructions sets for PublishAot scenarios (#2566) (by @MichalStrehovsky) 205ce6 Fix - incorrect table markdown #2545 (#2565) (by @AumkarGorde) 063d2f Fix BenchmarkDotNet test adapter not running tests with dotnet test (#2571) (by @sheffer21) 6a7244 Add warning support (#2572) (by @sheffer21) 01d9b7 Update README.md (#2583) (by @iCodeSometime) 20e2ee Docs for SummaryStyle (#2510) (by @MattFromRVA) e933bb Initial ScottPlotExporter with just Bar Plot and Unit Tests (#2560) (by @FlatlinerDOA) f8082a Fix IntroSummaryStyle compilation (by @AndreyAkinshin) 834417 Improve logging in ScottPlotExporterTests (by @AndreyAkinshin) 15200d [build] Add BenchmarkDotNet.Exporters.Plotting.Tests to unit-tests (by @AndreyAkinshin) 027564 \uFEFFFixed crash from TaskbarProgress when BuiltInComInteropSupport is disabled. ... (by @timcassell) bf0a49 fix(CI): Deprecation issues (#2605) (by @workgroupengineering) 3d34ed Bump JetBrains.Profiler.SelfApi: 2.5.2->2.5.9 (by @AndreyAkinshin) 23e6c5 Fix InvalidOperationException in DotMemoryDiagnoser (by @AndreyAkinshin) b3fbe7 Set next BenchmarkDotNet version: 0.14.0 (by @AndreyAkinshin) 17cf3b [docs] Prepare v0.14.0 changelog (by @AndreyAkinshin) cf882d Add macOS Sequoia in OsBrandStringHelper (by @AndreyAkinshin) Contributors (16) Adam Sitnik (@adamsitnik) Alon Sheffer (@sheffer21) Andrew Chisholm (@FlatlinerDOA) Andrey Akinshin (@AndreyAkinshin) Benjamin Michaelis (@BenjaminMichaelis) Cameron Aavik (@caaavik-msft) Jeremy Powell (@jeremy-visionaid) Kenneth Cochran (@iCodeSometime) Martin Othamar (@martinothamar) Matt Chaulklin (@MattFromRVA) Michal Strehovský (@MichalStrehovsky) Omkar Gorde (@AumkarGorde) Parker Bibus (@LoopedBard3) Sven Boemer (@sbomer) Tim Cassell (@timcassell) workgroupengineering (@workgroupengineering) Thank you very much! Additional details Date: August 06, 2024 Milestone: v0.14.0 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.14.0 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.14.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotMemory/0.14.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.14.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.14.0 https://www.nuget.org/packages/BenchmarkDotNet.Exporters.Plotting/0.14.0 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.14.0 https://www.nuget.org/packages/BenchmarkDotNet.TestAdapter/0.14.0"
  },
  "changelog/v0.15.0.html": {
    "href": "changelog/v0.15.0.html",
    "title": "BenchmarkDotNet v0.15.0 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.15.0 Milestone details In the v0.15.0 scope, 25 issues were resolved and 43 pull requests were merged. This release includes 62 commits by 25 contributors. Resolved issues (25) #1067 Conditions in Directory.Build.props fail (assignee: @timcassell) #1120 Large Spike from WorkloadWarmup to WorkloadActual (assignee: @timcassell) #1738 Async GlobalSetup does not work with InProcess toolchain (assignee: @timcassell) #2236 Benchmarks sporadically failing on Executable Emitted.dll not found (assignee: @timcassell) #2383 DisassemblyDiagnoser does not work in InProcessEmitToolchain (assignee: @timcassell) #2411 Jobs can mess up builds with --keepFiles (assignee: @timcassell) #2425 WithCustomBuildConfiguration breaks build (assignee: @timcassell) #2483 Pressing Ctrl-C does not reset power plan back #2516 Add validation warning for sealed classes containing benchmarks (assignee: @ketanpkolte) #2520 If a test run fails, the report shows it passed. (assignee: @ketanpkolte) #2533 MonoAOTLLVM run failed to build properly but still ran (assignee: @timcassell) #2577 Processor model is not detected on Azure arm64 (assignee: @AndreyAkinshin) #2591 Not possible to compute the (Ratio, RatioSD) #2599 Generic benchmarks in one report #2611 ScottPlotExporter is incorrectly calculating mean on measurements from all iteration stages (assignee: @FlatlinerDOA) #2629 Feature Request: Add ability to automatically hide metric columns if value is not set #2638 Missing disassembly on .NET 9 (assignee: @timcassell) #2652 Build problems with BenchmarkDotNet 0.14.0 and Grpc.Tools 2.67.0 (assignee: @timcassell) #2654 [Documentation] console-args.md is out of date (assignee: @5AIPAVAN) #2664 Starting CLI Commands no longer works via the dotnet-runtime-host \".exe\" (assignee: @timcassell) #2677 Release changes for #2651 (assignee: @AndreyAkinshin) #2678 Getting assembly conflict warnings on net471 after updating to 0.14.0 from 0.13.12 (assignee: @adamsitnik) #2701 InProcessNoEmitToolchain + NativeAOT Support? #2712 BenchmarkDotNet should warn if there are no benchmarks (assignee: @AvishaiDotan) #2721 Feature Request: Add options to disable build in parallel. Merged pull requests (43) #2109 Fix async GlobalSetup/Cleanup with InProcessEmit toolchain (by @timcassell) #2423 Fix builds when --keepFiles is specified (by @timcassell) #2488 Update clrmd to 3.1 (by @timcassell) #2505 Remove support for old core runtimes (by @timcassell) #2535 Always fail if dotnet command failed (by @timcassell) #2579 Support required properties (by @aelij) #2612 Fix #2611 - Add Iteration mode and stage filtering to ScottPlotExporter (by @FlatlinerDOA) #2613 Fix known high severity vulnerabilities (by @adamsitnik) #2614 Feature: Box Plot support for ScottPlotExporter (by @FlatlinerDOA) #2616 Clean up unsupported native AOT flags (by @MichalStrehovsky) #2618 Update good-practices.md (by @SteveDunn) #2622 Fix deadlock in GetDotNetSdkVersion (by @Korexio) #2626 Bump Perfolizer + Initial Phd adoption (by @AndreyAkinshin) #2627 Refactor dotTrace and dotMemory diagnosers (by @AndreyAkinshin) #2642 Add .NET 10 support (by @am11) #2643 Add DOTNET_ environment vars (by @am11) #2645 Change .NET SDK Validator to account for backwards compatibility (by @caaavik-msft) #2646 Get full parsable version part in .NET SDK Validator (by @caaavik-msft) #2647 add RiscV64 support (by @adamsitnik) #2650 improve BaselineCustomAnalyzer warning message, fixes #2591 (by @znxftw) #2653 Fixed GitHub workflow report for failed tests (by @ketanpkolte) #2657 Update console-args.md (by @5AIPAVAN) #2660 Fixed: Add validation warning for sealed classes containing benchmarks (by @ketanpkolte) #2661 Prevent premature end of the Benchmark process at Ctrl-C, fixes #2483 (by @leonvandermeer) #2665 Native AOT projects should also copy SettingsWeWantToCopy (by @keegan-caruso) #2667 Remove obsolete API usage in articles (by @keegan-caruso) #2670 Implement WakeLock so that the system does not enter sleep (by @leonvandermeer) #2672 Add documentation for VS Profiler (by @karpinsn) #2673 Feature Request: Add ability to automatically hide metric columns if value is not set (by @AvishaiDotan) #2674 add HostSignal.AfterProcessStart to allow the users to obtain ID of a process that was started suspended (by @adamsitnik) #2676 Use ArtifactsPath (by @timcassell) #2680 Cleanup templates (by @timcassell) #2681 Fix Windows path too long (by @timcassell) #2686 Some minor fixes before new version release (by @adamsitnik) #2688 Constant stack size (by @timcassell) #2692 Revert remove old runtimes (by @timcassell) #2702 Basic support of InProcessNoEmitRunner for NativeAOT. (by @eliphatfs) #2703 Missing dotnet 9.0 support. (by @VAllens) #2709 Exporters.Plotting: Move to ScottPlot 5.0.54 (by @bclehmann) #2716 Allow to set ParamsAttribute's values from derived class (by @filzrev) #2718 Log a warning when an empty benchmark is run (by @AvishaiDotan) #2725 feat: Add option to disable parallel build (by @filzrev) #2731 Added Measurements to DiagnoserResults (by @persn) Commits (62) a739e2 Set next BenchmarkDotNet version: 0.14.1 (by @AndreyAkinshin) c8105a Fix deadlock in GetDotNetSdkVersion (#2622) (by @Korexio) 29a0eb Update good-practices.md (#2618) (by @SteveDunn) 3927ce Fix #2611 - Add Iteration mode and stage filtering to ScottPlotExporter (#2612) (by @FlatlinerDOA) cd9e4e Feature - Added Box plots (by @FlatlinerDOA) d2f73e Bump .NET SDK: 8.0.101->8.0.401 (by @AndreyAkinshin) 64b3d8 Refactor CpuInfo detection, fix #2577 (by @AndreyAkinshin) 5e9b35 Fix lscpu cpu frequency parsing (by @AndreyAkinshin) a58872 Make lscpu call language-invariant, fix #2577 (by @AndreyAkinshin) ae4bb9 Bump Perfolizer + Initial Phd adoption (by @AndreyAkinshin) 296c99 Remove ConfigCompatibilityValidator, fix #2599 (by @AndreyAkinshin) 92f33f Refactor dotTrace and dotMemory diagnosers (by @AndreyAkinshin) 475ab4 Move Smoke benchmarks to BenchmarkDotNet.Samples (by @AndreyAkinshin) ca5dfd Clean up unsupported native AOT flags (#2616) (by @MichalStrehovsky) bc3abf \uFEFFUpdate clrmd to 3.1 (#2488) (by @timcassell) 3a2d11 \uFEFFRemoved support for netcoreapp3.0 and older runtimes. (#2505) (by @timcassell) adf8e6 Add DOTNET_ environment vars (#2643) (by @am11) 5fe0c7 Change .NET SDK Validator to account for backwards compatibility (#2645) (by @caaavik-msft) 52485e Get full parsable version part (#2646) (by @caaavik-msft) 9040e4 add RiscV64 support, fixes #2644 (#2647) (by @adamsitnik) 9ff49c Fixed GitHub workflow report for failed tests (#2653) (by @ketanpkolte) 1f7cab Update console-args.md (#2657) (by @5AIPAVAN) 6248e8 improve baseline warning message (#2650) (by @znxftw) af8bde Fix known high severity vulnerabilities (#2613) (by @adamsitnik) 346bba Fixed: Add validation warning for sealed classes containing benchmarks (#2660) (by @ketanpkolte) b9d69a Prevent premature end of the Benchmark process at Ctrl-C, fixes #2483 (#2661) (by @leonvandermeer) 25308b Native AOT projects should also copy SettingsWeWantToCopy (#2665) (by @keegan-caruso) c7ed71 Remove obsolete API usage in articles (#2667) (by @keegan-caruso) 5f0c47 \uFEFFFix async GlobalSetup/GlobalCleanup not being awaited with InProcessEmit too... (by @timcassell) 6367ad Add documentation for VS Profiler (#2672) (by @karpinsn) fe5b2f Fix builds when --keepFiles is specified (#2423) (by @timcassell) cd50f7 add HostSignal.AfterProcessStart to allow the users to obtain ID of a process... (by @adamsitnik) cac4f6 Feature Request: Add ability to automatically hide metric columns if value is... (by @AvishaiDotan) 3337a0 Add .NET 10 support (#2642) (by @am11) 1aab1c Add support for user-supplied project file detection (#2684) (by @Genbox) 390463 Some minor fixes before new version release (#2686) (by @adamsitnik) 804482 Revert \"Add support for user-supplied project file detection (#2684)\" (#2687) (by @adamsitnik) de8fb9 Implement WakeLock so that the system does not enter sleep (#2670) (by @leonvandermeer) e7e758 Revert remove old runtimes (#2692) (by @timcassell) 021fc6 Missing dotnet 9.0 support. (#2703) (by @VAllens) 6ce979 Basic support of InProcessNoEmitRunner for NativeAOT. (#2702) (by @eliphatfs) 1c62b2 Fix URLs in documentation (#2705) (by @WojciechNagorski) ce6eb7 Exporters.Plotting: Move to ScottPlot 5.0.54 (#2709) (by @bclehmann) c4bc75 Support required properties (#2579) (by @aelij) 30c730 Add test for required properties in InProcess (#2713) (by @aelij) 21da33 chore: allow to set ParamsAttribute values from derived class (#2716) (by @filzrev) f4bfcd Fix publish-nightly failures (#2695) (by @timcassell) 8af544 Bump Perfolizer: 0.4.0->0.4.1 (needed for #2688) (by @AndreyAkinshin) 49514c [build] Bump BenchmarkDotNet.Build dependencies (by @AndreyAkinshin) 250f9b Bump dawidd6/action-download-artifact from 2 to 6 in /.github/workflows (by @dependabot[bot]) 42c32f Removed unnecessary output path properties from csproj templates. (#2680) (by @timcassell) 602c5f [build] Update InTestsCoreTask description (by @AndreyAkinshin) 43c7b5 Log a warning when an empty benchmark is run (#2718) (by @AvishaiDotan) 924ca6 Always fail if dotnet command failed. (#2535) (by @timcassell) ee248c feat: Add option to disable parallel build (#2725) (by @filzrev) 0a5c82 [docs] Prepare v0.15.0 changelog (by @AndreyAkinshin) 3afc4e Use ArtifactsPath (#2676) (by @timcassell) 8b14cb Constant stack size (#2688) (by @timcassell) 5045ea Added Measurements to DiagnoserResults (#2731) (by @persn) c7cbbf Bump Perfolizer: 0.4.1->0.5.2 (and update API usage) (by @AndreyAkinshin) 56610b Fix Windows path too long (#2681) (by @timcassell) 4c839d Update README and template.json files (by @AndreyAkinshin) Contributors (25) Adam Sitnik (@adamsitnik) Adeel Mujahid (@am11) Allen Cai (@VAllens) Andrew Chisholm (@FlatlinerDOA) Andrey Akinshin (@AndreyAkinshin) Avishai Dotan (@AvishaiDotan) Benjamin Lehmann (@bclehmann) Cameron Aavik (@caaavik-msft) dependabot[bot] (@dependabot[bot]) Eli Arbel (@aelij) filzrev (@filzrev) Ian Qvist (@Genbox) Keegan (@keegan-caruso) Ketan Pramod Kolte (@ketanpkolte) Korexio (@Korexio) leonvandermeer (@leonvandermeer) Michal Strehovský (@MichalStrehovsky) Nik Karpinsky (@karpinsn) Per Olav Flaten (@persn) Ruoxi (@eliphatfs) Saipavan Lingamallu (@5AIPAVAN) Steve Dunn (@SteveDunn) Tim Cassell (@timcassell) Vishnu Bhagyanath (@znxftw) Wojciech Nagórski (@WojciechNagorski) Thank you very much! Additional details Date: May 22, 2025 Milestone: v0.15.0 (List of commits) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.15.0 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.15.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotMemory/0.15.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.dotTrace/0.15.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.15.0 https://www.nuget.org/packages/BenchmarkDotNet.Exporters.Plotting/0.15.0 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.15.0 https://www.nuget.org/packages/BenchmarkDotNet.TestAdapter/0.15.0"
  },
  "changelog/v0.7.0.html": {
    "href": "changelog/v0.7.0.html",
    "title": "BenchmarkDotNet v0.7.0 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.7.0 Milestone details In the v0.7.0 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 59 commits by 2 contributors. Resolved issues (0) Merged pull requests (0) Commits (59) 7f1c49 Add ShiftVsMultiplyBenchmark (by @AndreyAkinshin) 21298c Renaming (by @AndreyAkinshin) 86aada Add ReverseSortProgram (by @AndreyAkinshin) 5830ef Add MakeRefVsBoxingProgram (by @AndreyAkinshin) fe121e Automatic adjustment WarmUpIterationCount (by @AndreyAkinshin) d3dd9c Improved console output (by @AndreyAkinshin) 5e5df2 Update IncrementProgram (by @AndreyAkinshin) dca61d Change Average statistic to Median (by @AndreyAkinshin) 9d57e6 Update README.md (by @AndreyAkinshin) 7cca77 StaticFieldProgram -> ArrayIterationProgram (by @AndreyAkinshin) e02906 Add ForeachArray and ForeachList programs (by @AndreyAkinshin) 8e3f6e Add StandardDeviation calculation (by @AndreyAkinshin) 8b0c50 Add BenchmarkSettings singleton with DetailedMode property (by @AndreyAkinshin) eae5bf Add useful arguments for console application (by @AndreyAkinshin) 6f15f0 Update README.md (by @AndreyAkinshin) c1c44b Add StackFrameProgram (by @AndreyAkinshin) bbc6e7 Update StackFrameProgram (by @AndreyAkinshin) 5f8121 Set version number and add NuGet package metadata (by @AndreyAkinshin) 9425cb Add ProcessorAffinity to settings (by @AndreyAkinshin) bcc037 Add single result benchmark mode (--single) and disable warmup mode (--disabl... (by @AndreyAkinshin) 4ce0b4 Add build.bat for Benchmarks project (by @AndreyAkinshin) 69fbc7 Add --output-file option (by @AndreyAkinshin) df2092 Update build system (by @AndreyAkinshin) addd25 Update run.bat (by @AndreyAkinshin) b5c154 Add Mono support to run.bat (by @AndreyAkinshin) a4b42a Update build system (by @AndreyAkinshin) 65bbf7 Benchmarks: add support of selecting target program via number (by @AndreyAkinshin) d4317b Add MedianTicks to CompetitionResult report in DetailedMode fixed #1 (by @AndreyAkinshin) 3999e0 Update README.md (by @AndreyAkinshin) bd7452 Update EnvironmentTickCount hack (by @AndreyAkinshin) cf7aa6 Add CultureInfo setting (by @AndreyAkinshin) 16bb5e Set BenchmarkDotNet version: 0.5.1 (by @AndreyAkinshin) 07cf52 Add CompetitionBase: now competitions can be created in form of unit tests. (by @mijay) 284b78 Full refactoring (by @AndreyAkinshin) 2943d9 Add BenchmarkDotNet.Samples project (by @AndreyAkinshin) 572483 Merge branch 'dev' (by @AndreyAkinshin) 324d99 Remove ReflectionVsExpressionCompetition (by @AndreyAkinshin) ce5c67 Add CacheConsiousBinarySearchCompetition (by @AndreyAkinshin) ba8725 Add SelectVsConvertAllCompetition (by @AndreyAkinshin) 60b002 Set BenchmarkDotNet version: 0.5.2 (by @AndreyAkinshin) 3a4213 Fix in GetBenchmarkMethodClean (by @AndreyAkinshin) 73ee56 Add BitCountCompetition (by @AndreyAkinshin) 72836a Add missed Clean in BenchmarkCompetitionTask, Fixed #4 (by @AndreyAkinshin) 1258cb Big refactoring (by @AndreyAkinshin) 03bf14 Attributes renaming (by @AndreyAkinshin) 98a3cd Improved environment info (by @AndreyAkinshin) fe6e4e New benchmarks: ArrayBoundEliminationCompetition, InstructionLevelParallelism... (by @AndreyAkinshin) c89054 Fix in EnvironmentHelper.GetConfiguration() (by @AndreyAkinshin) 90d260 Add icon (by @AndreyAkinshin) beb681 Improved WarmUp (by @AndreyAkinshin) 7a63b6 Big refactoring (by @AndreyAkinshin) 8197e5 Update samples (by @AndreyAkinshin) c8d348 Add BenchmarkProperties (by @AndreyAkinshin) 97c73a Update Cpu_InstructionLevelParallelism (by @AndreyAkinshin) 957714 Small fixes (by @AndreyAkinshin) fdf4dd Update README (by @AndreyAkinshin) 8ac1ab Merge branch 'big-refactoring' (by @AndreyAkinshin) 18a256 Small fixes (by @AndreyAkinshin) 20df13 NuGet version: 0.7.0 (by @AndreyAkinshin) Contributors (2) Andrey Akinshin (@AndreyAkinshin) Mitya Kononchuk (@mijay) Thank you very much!"
  },
  "changelog/v0.7.1.html": {
    "href": "changelog/v0.7.1.html",
    "title": "BenchmarkDotNet v0.7.1 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.7.1 Milestone details In the v0.7.1 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 4 commits by 1 contributors. Resolved issues (0) Merged pull requests (0) Commits (4) b2bc76 A bugfix (MSBuild fail case) (by @AndreyAkinshin) ce7f58 Improved SingleRun (by @AndreyAkinshin) 295cc2 Current values for JitVersion, Platform, and Framework (by @AndreyAkinshin) 744eba Set library version: 0.7.1 (by @AndreyAkinshin) Contributors (1) Andrey Akinshin (@AndreyAkinshin) Thank you very much!"
  },
  "changelog/v0.7.2.html": {
    "href": "changelog/v0.7.2.html",
    "title": "BenchmarkDotNet v0.7.2 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.7.2 Milestone details In the v0.7.2 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 2 commits by 1 contributors. Resolved issues (0) Merged pull requests (0) Commits (2) 19f1e2 Add templates for BenchmarkProjectGenerator (by @AndreyAkinshin) 043c04 v0.7.2: BenchmarkMode.Throughput, OperationCountAttribute, minor improvements... (by @AndreyAkinshin) Contributors (1) Andrey Akinshin (@AndreyAkinshin) Thank you very much!"
  },
  "changelog/v0.7.3.html": {
    "href": "changelog/v0.7.3.html",
    "title": "BenchmarkDotNet v0.7.3 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.7.3 Milestone details In the v0.7.3 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 1 commits by 1 contributors. Resolved issues (0) Merged pull requests (0) Commits (1) 42e13b v0.7.3: Small bug fixes (by @AndreyAkinshin) Contributors (1) Andrey Akinshin (@AndreyAkinshin) Thank you very much!"
  },
  "changelog/v0.7.4.html": {
    "href": "changelog/v0.7.4.html",
    "title": "BenchmarkDotNet v0.7.4 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.7.4 Milestone details In the v0.7.4 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 2 commits by 1 contributors. Resolved issues (0) Merged pull requests (0) Commits (2) c5e924 Update README (by @AndreyAkinshin) 641c95 v0.7.4: New benchmark Invoker, new samples, refactoring, minor fixes (by @AndreyAkinshin) Contributors (1) Andrey Akinshin (@AndreyAkinshin) Thank you very much!"
  },
  "changelog/v0.7.5.html": {
    "href": "changelog/v0.7.5.html",
    "title": "BenchmarkDotNet v0.7.5 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.7.5 Milestone details In the v0.7.5 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 4 commits by 1 contributors. Resolved issues (0) Merged pull requests (0) Commits (4) 957a01 Update samples (by @AndreyAkinshin) 118e2f Add the Cpu_Ilp_RyuJit sample (by @AndreyAkinshin) b7e564 Update copyrights (by @AndreyAkinshin) b6cce3 v0.7.5: Improved project building (by @AndreyAkinshin) Contributors (1) Andrey Akinshin (@AndreyAkinshin) Thank you very much!"
  },
  "changelog/v0.7.6.html": {
    "href": "changelog/v0.7.6.html",
    "title": "BenchmarkDotNet v0.7.6 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.7.6 Milestone details In the v0.7.6 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 9 commits by 5 contributors. Resolved issues (0) Merged pull requests (0) Commits (9) 8e9942 Update README.md (by @NN---) 51ef26 Merge pull request #11 from NN---/patch-2 (by @AndreyAkinshin) db8791 Fixed link to samples. (by @redknightlois) 14ddf4 Merge pull request #12 from redknightlois/patch-1 (by @mattwarren) d70b4c Accessibility and genericness checks added for benchmark methods. (by @krk) 04ce12 Benchmark methods defined in nested classes are supported. (by @krk) a5caba Improvements in log parser (by @AndreyAkinshin) d750b9 Merge pull request #13 from krk/master (by @AndreyAkinshin) eab4bd Set library version: 0.7.6 (by @AndreyAkinshin) Contributors (5) Andrey Akinshin (@AndreyAkinshin) Federico Andres Lois (@redknightlois) Kerem Kat (@krk) Matt Warren (@mattwarren) NN (@NN---) Thank you very much!"
  },
  "changelog/v0.7.7.html": {
    "href": "changelog/v0.7.7.html",
    "title": "BenchmarkDotNet v0.7.7 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.7.7 Milestone details In the v0.7.7 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 14 commits by 2 contributors. Resolved issues (0) Merged pull requests (0) Commits (14) c94525 Add Cpu_BranchPerdictor (by @AndreyAkinshin) 44cbb0 Add Algo_Md5VsSha256 (by @AndreyAkinshin) 4d789c Most significant bit and bool to int conversions. (by @redknightlois) 09446b Updated to avoid using an array. (by @redknightlois) b16153 Fixed a bug where converting a bool to int instead to byte (which is the nati... (by @redknightlois) 52acca Merge pull request #15 from redknightlois/master (by @AndreyAkinshin) 66cce4 Fix troubles with inlining (by @AndreyAkinshin) a8e641 Fixes in Jit_BoolToInt (by @AndreyAkinshin) cfbb88 Rename task parameters: Current -> Host (by @AndreyAkinshin) 209b4f Rename Task to BenchmarkTask, fix #9 (by @AndreyAkinshin) 74be9d Fix typos (by @AndreyAkinshin) adc6c2 Fix Intro_01_MethodTasks (by @AndreyAkinshin) 438042 Add BenchmarkRunner.RunUrl (by @AndreyAkinshin) 72d606 Set library version: 0.7.7 (by @AndreyAkinshin) Contributors (2) Andrey Akinshin (@AndreyAkinshin) Federico Andres Lois (@redknightlois) Thank you very much!"
  },
  "changelog/v0.7.8.html": {
    "href": "changelog/v0.7.8.html",
    "title": "BenchmarkDotNet v0.7.8 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.7.8 Milestone details In the v0.7.8 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 36 commits by 5 contributors. Resolved issues (0) Merged pull requests (0) Commits (36) 6ede76 Reporting: better number formats for ops/sec. (by @ppanyukov) 118bc9 Merge pull request #17 from ppanyukov/feature/report-num-align (by @AndreyAkinshin) 994cbc Markdown friendly reporting (by @AndreyAkinshin) 91bbb4 Reporting: use fixed precision for AvrTime and StdDev. (by @ppanyukov) e9b8fe Merge pull request #18 from ppanyukov/feature/report-num-align (by @AndreyAkinshin) 121c3d Reporting: uniform time units across all benchmarks. (by @ppanyukov) 1cb520 Merge pull request #21 from ppanyukov/feature/report-num-align (by @AndreyAkinshin) a4f53e Reporting: refactor use of BenchmarkTimeSpan. (by @ppanyukov) 7fbf63 Merge pull request #24 from ppanyukov/feature/report-num-align (by @AndreyAkinshin) c8c893 message for Obsolete warning which tells what to use now + updated README (by @adamsitnik) b48756 Merge pull request #26 from adamsitnik/master (by @AndreyAkinshin) 36f849 Add Jit_RegistersVsStack (by @AndreyAkinshin) 32cafc Allow a [Setup] method to be used on Benchmarks (by @mattwarren) 8a14a8 Missed out of last commit (by @mattwarren) 0103b7 Integration tests for [Setup] method closes #23, closes #7 (by @mattwarren) 1e7c25 Display MSBuild errors in the console output, see #22 (by @mattwarren) 876303 Added new benchmark for Stopwatch v DateTime (by @mattwarren) e5f748 New ReportExporter system (by @AndreyAkinshin) e0fdbc Add BenchmarkDotNet.Visualizer (by @AndreyAkinshin) 954d08 Fix bug in op/s reporting (by @mattwarren) d9dcf4 Tidying up BenchmarkDotNet.Samples layout see #29 (by @mattwarren) 7abb1b Making Visualizer samples point to the new location (see #29) (by @mattwarren) 96d5b9 Speed up the integration tests, closes #23 (by @mattwarren) 2568a1 Initial work on Params attribute (see #8) (by @mattwarren) 47fad8 Ensure Benchmarks with Params show up properly in Reports (by @mattwarren) 36e060 Integration tests and sample for Params attribute (by @mattwarren) 76ad88 Fixing some spelling mistakes (by @mattwarren) 81e6eb Update BenchmarkProgram.txt (by @mattwarren) 4008cf Merge pull request #32 from PerfDotNet/mattwarren-exception-handling (by @mattwarren) 9e893e Statistic improvements (by @AndreyAkinshin) 9ce9f9 Ensure that Params attribute can work with static fields/properties (by @mattwarren) 7c3782 Update README.md (by @AndreyAkinshin) 5a1783 Update Array_HeapAllocVsStackAlloc.cs (by @mattwarren) 50ff16 Allow just number param in RunCompetitions. (by @vkkoshelev) 04c306 Merge pull request #34 from vedun-z/master (by @AndreyAkinshin) a630dc Set library version: 0.7.8 (by @AndreyAkinshin) Contributors (5) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Matt Warren (@mattwarren) Philip Panyukov (@ppanyukov) vkkoshelev (@vkkoshelev) Thank you very much!"
  },
  "changelog/v0.8.0.html": {
    "href": "changelog/v0.8.0.html",
    "title": "BenchmarkDotNet v0.8.0 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.8.0 Milestone details In the v0.8.0 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 67 commits by 5 contributors. Resolved issues (0) Merged pull requests (0) Commits (67) 042631 Atomics sample (by @redknightlois) 6ce693 Merge pull request #35 from redknightlois/master (by @AndreyAkinshin) e73ce4 Update Intro_03_SingleRun (by @AndreyAkinshin) add75c Samples: add Js_AsVsCast (by @AndreyAkinshin) 1d4653 Samples: updates Js_AsVsCast (by @AndreyAkinshin) 73f48f BenchmarkRuntime support (by @AndreyAkinshin) 8e9fec BenchmarkRuntime: fix a bug (by @AndreyAkinshin) 0d8a86 Added RotateBits (will be interested when https://github.com/dotnet/coreclr/i... (by @redknightlois) 724970 Added and special case which we know it must not be optimized at all (for com... (by @redknightlois) 30ba93 Merge pull request #43 from redknightlois/master (by @AndreyAkinshin) a2338c Big refactoring (by @AndreyAkinshin) dc8d02 Make the \"Getting Started\" guide read better (by @mattwarren) 9883ca Update README.md (by @mattwarren) 3cd76b Update README.md (by @mattwarren) 6a3d00 Update README.md (by @mattwarren) 7de832 Better way of generating Benchmark competition list (by @mattwarren) 10ded0 Add Jit_GenericsMethod (by @AndreyAkinshin) e5538b Fix for #42 (make benchmarks work in LINQPad) (by @mattwarren) 873450 Make logging robust when strings contain '{' or '} (by @mattwarren) 2ee55a Create a batch file that builds the benchmark (by @mattwarren) d14b18 Adding \"Advanced Features\" section (by @mattwarren) deb1a9 Sample benchmark for different types of loops (by @mattwarren) 26e7b0 Move sample to correct namespace (by @mattwarren) 505711 Grouping parameter results together (fixes #36) (by @mattwarren) 1ee786 Merge branch 'master' of https://github.com/PerfDotNet/BenchmarkDotNet (by @mattwarren) 496ae1 Add support for benchmarking methods of generic classes (#44) (by @mattwarren) ad12e1 Return of the Params (by @AndreyAkinshin) f80613 Little cleanup (by @AndreyAkinshin) 52a076 Little refactoring (Flow -> Toolchain) (by @AndreyAkinshin) 2f383e Moar samples (by @mattwarren) 30b162 Initial work on code for asm/IL viewing (by @mattwarren) 6a8873 Initial support for printing Assembly code (by @mattwarren) 8cd841 Print diagnostic info (with flag \"-printDiagnostics\") (by @mattwarren) 236043 Adding missing CLRMD dependancies (by @mattwarren) 58b7a3 Print the method when we have a \"call\" asm instruction (by @mattwarren) 1dae2b Change Jit_GenericsMethod benchmark to reproduce on x64 both Legacy & RuyJit (by @alexandrnikitin) 6ae157 Merge pull request #47 from alexandrnikitin/samples-Jit_GenericsMethod-x64repro (by @AndreyAkinshin) c39b7c README: add gitter link (by @AndreyAkinshin) b0768e Ensure we \"close\" the code section in the markdown we generate (by @mattwarren) 6c9ae7 Merge branch 'master' of https://github.com/PerfDotNet/BenchmarkDotNet (by @mattwarren) 9ed66d Show how you can write \"Performance\" Unit Tests (by @mattwarren) 7c9c6d Helper methods for Performance Unit Tests (by @mattwarren) 3a2c75 Make Perf Unit Test more robust!! (by @mattwarren) d1ddd3 Ensure the Description is used when sorting (if available) (by @mattwarren) 27d662 Moving assembly viewer into BenchmarkDotNet.Diagnostics (by @mattwarren) 1ef961 Load BenchmarkDotNet.Diagnostics dynamically (by @mattwarren) 7eb70a New plugin system (by @AndreyAkinshin) 2114d7 Fix typos in API (by @AndreyAkinshin) e0a488 Fix in PerformanceUnitTest (by @AndreyAkinshin) 02cddd BenchmarkDotNet.Tests: upgrade xunit to 2.1 (by @AndreyAkinshin) 3d8ff2 IntegrationTests: replace GetTestOutput by AccumulationLogger (by @AndreyAkinshin) 5ebf69 IntegrationTests: upgrade xunit to 2.1 (by @AndreyAkinshin) 280834 Diagnostic refactoring (by @AndreyAkinshin) 79ee42 Custom toolchains (by @AndreyAkinshin) 527df6 Analysers (by @AndreyAkinshin) 3d8199 Fix in BuildTable (by @AndreyAkinshin) 699588 Tidy up of Source Diagnoser code (part of #53) (by @mattwarren) 5ab029 Better way of getting the called method name (part of #53) (by @mattwarren) 37f468 Integration test for Source Diagnostics (see #53) (by @mattwarren) da0093 Spelling mistakes and remove unused using stmts (by @mattwarren) fbf409 Fix typo in README (by @ForNeVeR) 4895c6 Merge pull request #61 from ForNeVeR/patch-1 (by @AndreyAkinshin) dd5f1f Rename: exec -> execute (by @AndreyAkinshin) 6826a9 BenchmarkSwitcher: update the promt message (by @AndreyAkinshin) f2a63f Update README.md (by @AndreyAkinshin) 54cfdc Samples/Program.cs: small fix (by @AndreyAkinshin) a927e9 Set library version: 0.8.0 (by @AndreyAkinshin) Contributors (5) Alexandr Nikitin (@alexandrnikitin) Andrey Akinshin (@AndreyAkinshin) Federico Andres Lois (@redknightlois) Friedrich von Never (@ForNeVeR) Matt Warren (@mattwarren) Thank you very much!"
  },
  "changelog/v0.8.1.html": {
    "href": "changelog/v0.8.1.html",
    "title": "BenchmarkDotNet v0.8.1 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.8.1 Milestone details In the v0.8.1 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 12 commits by 2 contributors. Resolved issues (0) Merged pull requests (0) Commits (12) 79ee93 README.md: small fixes (by @AndreyAkinshin) a3e2dc Adding missing CLRMD binary dependencies (by @mattwarren) 7492c1 Merge branch 'master' of https://github.com/PerfDotNet/BenchmarkDotNet (by @mattwarren) ddae06 Lazy-load the Diagnostic plug-ins, fixes #63 (by @mattwarren) 5df0df More robust version of the Diagnostic Library (see #53) (by @mattwarren) 9f3ba0 Ensure that non-void SingleRun Benchmarks work (by @mattwarren) de5bca Allow Benchmarks that use Inner classes (see #55) (by @mattwarren) 5d000f Ensure we can run Benchmarks produced by F# (see #59) (by @mattwarren) 8b0563 Added missing binary dependency (part of #59) (by @mattwarren) 60047e Fixing #45 (by @mattwarren) 3bede9 Implemented Ctrl-C handling in the Console (Fixes #50) (by @mattwarren) 719391 Set library version: 0.8.1 (by @AndreyAkinshin) Contributors (2) Andrey Akinshin (@AndreyAkinshin) Matt Warren (@mattwarren) Thank you very much!"
  },
  "changelog/v0.8.2.html": {
    "href": "changelog/v0.8.2.html",
    "title": "BenchmarkDotNet v0.8.2 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.8.2 Changes in the Summary table Summary table now supports ResultExtenders that can add new column to the table Now we use StandardError (aka Error) as the main accuracy metric Columns op/s, StdDev are disabled by default (you can add it via ResultExtenders) Statistic improvements, now you have detailed statistic in the console log like follows: Mean = 118.5298 us, StdError = 1.2863 us (N = 30, StdDev = 7.0454 us) Min = 109.1602 us, Median = 117.1794 us, Max = 132.5764 us IQR = 10.1244 us, LowerFence = 98.0834 us, UpperFence = 138.5810 us ConfidenceInterval = [116.0086 us; 121.0510 us] (CI 95%) Added the Baseline feature, see #64 Export improvements, now you have files <BenchmarkName>-report-github.md, <BenchmarkName>-report-stackoverflow.md for easy publishing results on GitHub and StackOverflow. Basic plotting. Added new BenchmarkRPlotExporter that creates BuildPlots.R in the bin directory. It is an R script that generates boxplot and barplot for your benchmarks (you should have installed R with defined R_HOME environment variable) Updated environment info Added Stopwatch Frequency and Resolution Split common benchmark properties (like Mode, Platform, Runtime) in several lines (3 properties per line) Log improvements: add total time, statistics, list of exported files Bug fixes Milestone details In the v0.8.2 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 34 commits by 3 contributors. Resolved issues (0) Merged pull requests (0) Commits (34) de0140 Add BenchmarkEnvironmentAnalyser (by @AndreyAkinshin) 9ea78f Improved confidence intervals (by @AndreyAkinshin) b8d4b6 Rename: PreWarmup -> Pilot (by @AndreyAkinshin) 988efc Reporting: change StandardDeviation to StandardError (by @AndreyAkinshin) 4da39d Big refactoring (by @AndreyAkinshin) 6a0caa Add BenchmarkRPlotExporter (by @AndreyAkinshin) 3a6ea4 Allow plugins to extend the Results Table (by @mattwarren) 7a7991 Create a \"Result Extender\" plug-in for #64 (by @mattwarren) 70ea89 Integration tests for #64 (by @mattwarren) a2d0ec Separate class for string extensions. (by @alinasmirnova) 5d6c78 Multiline prefix string extension. (by @alinasmirnova) bdd84e New logger type for adding prefix. StackOverflow markdowns. (by @alinasmirnova) ba9ec5 Move ExportToFile to ExporterBase. Add file suffix. (by @alinasmirnova) 38cd8c GitHub markdown support. (by @alinasmirnova) 732420 Markdown readme edits (by @alinasmirnova) 541eef Merge pull request #71 from alinasmirnova/refactoring (by @AndreyAkinshin) c53618 Merge remote-tracking branch 'refs/remotes/origin/develop' into refactoring (by @AndreyAkinshin) e3f420 Samples: add Intro_08_Baseline (by @AndreyAkinshin) 145b78 README: add NuGet badge (by @AndreyAkinshin) b0e108 Minor fixes (by @AndreyAkinshin) 565c25 Update README (by @AndreyAkinshin) 045e2a Add BenchmarkStatResultExtender (by @AndreyAkinshin) 20c6d2 Minor fixes (by @AndreyAkinshin) f80edc Update README (by @AndreyAkinshin) 3d2309 README: links to wiki (by @AndreyAkinshin) d60d0f Fix bug in TimeUnit (by @AndreyAkinshin) 034961 Unit tests for TimeUnit (by @AndreyAkinshin) f2c6f1 Logs: add total time (by @AndreyAkinshin) 140dec Merge branch 'refs/heads/refactoring' into develop (by @AndreyAkinshin) 9e16e8 Ensure that the DeltaResultExtender doesn't throw (by @mattwarren) 60f7c9 Merge branch 'develop' of https://github.com/PerfDotNet/BenchmarkDotNet into ... (by @mattwarren) 77b24b Rollback of bad changes from the last merge (by @AndreyAkinshin) 3df71a More robust way of wiring up BenchmarkBaselineDeltaResultExtender (by @mattwarren) 8e5a0e Set library version: 0.8.2 (by @AndreyAkinshin) Contributors (3) Alina Smirnova (@alinasmirnova) Andrey Akinshin (@AndreyAkinshin) Matt Warren (@mattwarren) Thank you very much! Additional details Date: January 19, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.8.2"
  },
  "changelog/v0.9.0.html": {
    "href": "changelog/v0.9.0.html",
    "title": "BenchmarkDotNet v0.9.0 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.9.0 New API Autodetermination of amount iteration for warmup/target idle/main iterations, duration of iteration, amount of CLR launches. Milestone details In the v0.9.0 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 34 commits by 4 contributors. Resolved issues (0) Merged pull requests (0) Commits (34) 71369d Add benchmarks to tests different ways of accessing arrays. Copypasted from h... (by @alexandrnikitin) 9a5930 Merge pull request #79 from alexandrnikitin/samples-array-access (by @AndreyAkinshin) 1b8cf9 MathSummaryTests: fix output (by @AndreyAkinshin) 92503b BenchmarkSwitcher improvements (by @AndreyAkinshin) ebaeea Big API refactoring (by @AndreyAkinshin) f149cb Big API refactoring, Part 2 (by @AndreyAkinshin) 380d9a Big API refactoring, Part 3 (by @AndreyAkinshin) 6cd2ce Big API refactoring, Part 4 (by @AndreyAkinshin) 1665d8 Big API refactoring, Part 5 (by @AndreyAkinshin) 140312 A better way of running a F# integration test (by @mattwarren) 8e58ab Big API refactoring, Part 6 (by @AndreyAkinshin) 9ec71b Add html export, resolved #75 (by @alinasmirnova) 7ae4ed Merge pull request #86 from alinasmirnova/refactoring (by @AndreyAkinshin) bfbc80 Big API refactoring, Part 7 (by @AndreyAkinshin) 256ed4 Re-design of the IDiagnoser API (by @mattwarren) f4bad8 Initial work on ETW Diagnostic Providers (by @mattwarren) da2e3f Big API refactoring, Part 8 (by @AndreyAkinshin) 5df553 Big API refactoring, Part 9 (by @AndreyAkinshin) 120b7c Big API refactoring, Part 10 (by @AndreyAkinshin) e61425 Big API refactoring, Part 11 (by @AndreyAkinshin) 171ba0 Big API refactoring, Part 12 (by @AndreyAkinshin) 854633 Big API refactoring, Part 13 (by @AndreyAkinshin) caafa9 Fix a bug in Templates/BenchmarkProgram.txt (by @AndreyAkinshin) 568c44 Add BenchmarkDotNet.Samples.FSharp (by @AndreyAkinshin) 2fa773 Fix a bug in Generator (by @AndreyAkinshin) 30e855 Update README (by @AndreyAkinshin) 1164ef Update README (by @AndreyAkinshin) 9c357c Improved plots for benchmarks with Params (by @AndreyAkinshin) ef41f6 Fix a bug in ClassicBuilder (by @AndreyAkinshin) 02babc Add BaselineDiffColumn.Scaled (by @AndreyAkinshin) 4388c8 Remove construction with description in BenchmarkAttribute (by @AndreyAkinshin) c9c25f Update README (by @AndreyAkinshin) 1cef82 RPlotExporter improvements (by @AndreyAkinshin) 173abf Set library version: 0.9.0 (by @AndreyAkinshin) Contributors (4) Alexandr Nikitin (@alexandrnikitin) Alina Smirnova (@alinasmirnova) Andrey Akinshin (@AndreyAkinshin) Matt Warren (@mattwarren) Thank you very much! Additional details Date: February 9, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.0"
  },
  "changelog/v0.9.1.html": {
    "href": "changelog/v0.9.1.html",
    "title": "BenchmarkDotNet v0.9.1 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.9.1 Milestone details In the v0.9.1 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 5 commits by 2 contributors. Resolved issues (0) Merged pull requests (0) Commits (5) a0cfba use benchmarkSwitcher and 0.9.0 api features (by @cloudRoutine) a88fc0 Merge pull request #89 from cloudRoutine/patch-1 (by @AndreyAkinshin) 99d7c5 Improved ReflectionExtensions.GetCorrectTypeName; Fixed #90 (by @AndreyAkinshin) 770510 Improved work with idle method that returns a value type; Fixed #70 (by @AndreyAkinshin) 3c4410 Set library version: 0.9.1 (by @AndreyAkinshin) Contributors (2) Andrey Akinshin (@AndreyAkinshin) Jared Hester (@cloudRoutine) Thank you very much! Additional details Date: February 10, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.1"
  },
  "changelog/v0.9.2.html": {
    "href": "changelog/v0.9.2.html",
    "title": "BenchmarkDotNet v0.9.2 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.9.2 Dnx451 support (Closed #51, Merged #87) Milestone details In the v0.9.2 scope, 1 issues were resolved and 1 pull requests were merged. This release includes 48 commits by 2 contributors. Resolved issues (1) #51 DNX Compatibility Merged pull requests (1) #87 DNX451 support (by @adamsitnik) Commits (48) f25427 road to DNX: part I: moving from csproj to xproj (by @adamsitnik) 2fe5cf road to DNX: part II: added dnx451 target (DNX SDK running on .Net 4.5.1) (by @adamsitnik) 6b4400 road to DNX: part II: the moment when Unit Test has shown up in VS! (by @adamsitnik) c97792 road to DNX: part II: able to debug Samples (by @adamsitnik) f901d6 road to DNX: part II: the moment when Integration Test has shown up in VS! (by @adamsitnik) f46296 road to DNX: part II: including *.txt files as resources, excluding auto-gene... (by @adamsitnik) cfc1b6 updated gitignore to exclude files created during integration tests run (by @adamsitnik) 60b343 Road to DNX: benchmark execution : building project.json instead of .csproj (by @adamsitnik) 0d41cb Road to DNX: benchmark execution : compiling project.json with Microsoft.Dnx.... (by @adamsitnik) 31bc59 updated versions in .json files after sync with master, (by @adamsitnik) c8e826 road to DNX: compilation: adding MetadataReferences for dlls required to comp... (by @adamsitnik) 2ebe6c road to DNX: compilation: adding executing assembly as dependency to project.... (by @adamsitnik) 76a74e Road to DNX: removing dependencies to BenchmarkDotNet.Diagnostics for DNX451 ... (by @adamsitnik) 40419a road to DNX: handling \"nuget-like\" package versions that can contain text (as... (by @adamsitnik) 8f06a7 it should have never happened but it does when debugging: DirectoryNotFoundEx... (by @adamsitnik) 7c2a96 Road to DNX: reusing MS dnu to restore and build. Simple solution that just w... (by @adamsitnik) e51d4d Road to DNX: alternative to MS dnu. reuses nuget and roslyn but as for now it... (by @adamsitnik) ada7cb Road to DNX: replacing dnu build with dnx run. +putting files in a folder tha... (by @adamsitnik) 18e969 road to DNX: referencing the right thing, bitness the same as hosting process (by @adamsitnik) 8e870c road to DNX: setting the compiler EXPLICIT to finally make it WORKING (at lea... (by @adamsitnik) 466d13 Road to DNX: removing failed PoC,dependencies cleanup, added some comments (by @adamsitnik) 5b3675 Road to DNX: removing dependencies to MSBuild for DNX target, some project.js... (by @adamsitnik) 3e65e8 road to DNU: reference project during development, but package when released (by @adamsitnik) 617a61 road to DNX: logging output from dnu restore/dnx run + default timeout (by @adamsitnik) 075cdc road to DNX: new value for toolchain enum: DNX451 (by @adamsitnik) bd3fea road to DNX: being able to debug NET40 from VS (by @adamsitnik) da5a9a road to DNX: copying all files that used to be copied in \".csproj times\" (by @adamsitnik) 5d8717 road to DNX: new debug profile with DNX trace mode ON, use when troubleshooti... (by @adamsitnik) 8272f6 road to DNX: fixing tests (by @adamsitnik) 96bcf8 road to DNX: make sure that our child process get the right priority and affi... (by @adamsitnik) cd0ba8 road to DNX: respecting specified benchmark processor architecture (by @adamsitnik) b1eb28 road to DNX: added all output files from integration tests to .gitignore (by @adamsitnik) aa62d1 fix for 4.0 (was passing arguments in wrong order) (by @adamsitnik) 0c1251 merge (by @adamsitnik) 46cd5e F# support, limited to existing tools possibilities (can not run from VS, onl... (by @adamsitnik) 74020c Merge remote-tracking branch 'upstream/master' (by @adamsitnik) 3402f0 replacing dnx with dotnet cli (by @adamsitnik) d634f4 road to DNX: final cleanup (by @adamsitnik) 24cd3a removing project.lock.json files (by @adamsitnik) 80becb removing all .csproj & packages.config file + keeping only single .sln file (by @adamsitnik) 9633d5 removing nuspec (now auto-generated by VS based on project.json) + version in... (by @adamsitnik) 617d82 running Classic Framework tests from console + minor cleanup (by @adamsitnik) fc9d98 DNX: running once compiled assembly directly without dotnet cli (perf+abble t... (by @adamsitnik) 8adad8 dnx: Diagnosers support. Currently only these which do not need umanaged libs... (by @adamsitnik) 34c3c9 DNX: changed folder of the auto-generated files to benchmark-specific + samples (by @adamsitnik) 9cf009 DNX: description for development (by @adamsitnik) 43af33 update to dotnet cli changes: output path and exit codes , now we set output... (by @adamsitnik) f59d3e Merge pull request #87 from adamsitnik/master (by @AndreyAkinshin) Contributors (2) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Thank you very much! Additional details Milestone: v0.9.2 Date: March 5, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.2"
  },
  "changelog/v0.9.3.html": {
    "href": "changelog/v0.9.3.html",
    "title": "BenchmarkDotNet v0.9.3 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.9.3 CoreCLR support (Closed #52, Merged #113) Milestone details In the v0.9.3 scope, 2 issues were resolved and 1 pull requests were merged. This release includes 12 commits by 2 contributors. Resolved issues (2) #52 CoreCLR Compatibility #114 Update NETStandard.Library dependency Merged pull requests (1) #113 Core Clr support (by @adamsitnik) Commits (12) 5b6460 Core: compilable main project (by @adamsitnik) cfdde6 Core: compilable samples and tests projects (by @adamsitnik) ab8b26 Core: new profile for running Samples from VS (by @adamsitnik) 9e1372 Core: new toolchain implementation with dnx451 code reuse (by @adamsitnik) de8bcc Core: tests: script to run both dnx and core (by @adamsitnik) 05d50f Core: dotnet cli supports only x64 now, workaround (by @adamsitnik) 726c66 Core: executing only supported benchmarks (x86 and Legacy Jit are not supported) (by @adamsitnik) de3371 Core: Dnx and Core as Runtimes, removed Toolchain configuration (by @adamsitnik) e7a3a8 Core: generating path in Linux-friendly way ;) (by @adamsitnik) fede7c Core: notify user when the process.Priority can not be set and continue execu... (by @adamsitnik) d59827 Merge pull request #113 from PerfDotNet/coreclr (by @AndreyAkinshin) 939891 Set library version: 0.9.3 (by @AndreyAkinshin) Contributors (2) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Thank you very much! Additional details Milestone: v0.9.3 Date: March 13, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.3 https://www.nuget.org/packages/BenchmarkDotNet/0.9.3-beta"
  },
  "changelog/v0.9.4.html": {
    "href": "changelog/v0.9.4.html",
    "title": "BenchmarkDotNet v0.9.4 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.9.4 Improved messages about error in benchmarks, see #104 Natural sort order, see #92, #95, #97 Improved double/float/decimal/enum support for Params, see #96, #105, #116 Now environment info includes information about HardwareTimerKind and JitModules Added DryConfig Improved export performance, closed #119, merged #124 Better cmd-line discoverability (see #78), e.g. run Benchmark.exe --help and some useful information will be printed Supporting all kinds of references for generated project (exact version, custom paths, GAC, sub-folders, dependent assemblies not copied), closed #41, #49, #72, #123, merged #125 Friendliness to LinqPad restored, closed #66, merged #125 Milestone details In the v0.9.4 scope, 13 issues were resolved and 2 pull requests were merged. This release includes 55 commits by 4 contributors. Resolved issues (13) #41 Seems, not supported \"sub-folder\" #49 Dependent assemblies are not copied or added to the project file. #72 Referenced assembly dll-file (directly via file) not referenced in generated Program.csproj #78 Better command line discoverability (assignee: @mattwarren) #92 Results in the R graphs aren't displayed in a \"Natural Sort Order\" #95 Results should preserve the order of param values definition #96 Implement enums as valid Param for test #97 Params changes an order #104 System.InvalidOperationException: StatSummary: Sequence contains no elements #105 Params Attribute bug with float type #116 Issue when ParamAttribute decorated property is double and current system culture has comma as decimal separator #119 For large benchmarks report exporting is very, very slow and has a massive Gen2 heap #123 Can not run benchmark that references custom framework library (like WindowsBase) Merged pull requests (2) #124 Faster export (by @adamsitnik) #125 supporting all kinds of references for generated project (by @adamsitnik) Commits (55) 74789d Sort results by Parameter, in a Natural Sort Order (by @mattwarren) fec115 ParameterComparer refacotring (by @AndreyAkinshin) 9d3856 Add information about JIT modules in EnvironmentHelper (by @AndreyAkinshin) 7667ee Adding TraceEvent library for parsing ETW Events (by @mattwarren) ae71f2 More work on the GC/Allocation diagnostics (by @mattwarren) efa739 Allow diagnosers to be run from cmd line or via [Config(..)] (by @mattwarren) 633f1c Throw an error when invalid Config(..) options are specified (by @mattwarren) 04678a Add information about HardwareTimerKind (by @AndreyAkinshin) 7f3cf0 Fix in GetCorrectTypeNameTest (by @AndreyAkinshin) d9b890 Fix in HardwareTimerKind (by @AndreyAkinshin) 416e36 Natural sort order for CsvMeasurementsExporter and plots, Fixed #92 (by @AndreyAkinshin) dfc54a Ensure we sort the results by Method Name/Description (by @mattwarren) fa6c62 Changed GCDiagnoser to inspect live ETW event stream instead of recording to ... (by @goldshtn) d3f7ce Params: float/double/decimal support, Fixed #105 (by @AndreyAkinshin) 7bce9b Params: enum support, Fixed #96 (by @AndreyAkinshin) 4890dd Merge pull request #106 from goldshtn/develop (by @mattwarren) 9072b9 More robust when a benchmark throws an exception (see #104) (by @mattwarren) 2b9162 Work on #73 - highlighting in the Console output (by @mattwarren) f62483 Work on #73 - highlighting in the Console output (by @mattwarren) a639d5 Work on #73 - highlighting in Markdown output (by @mattwarren) 1457fe Changing [ConfigWithDryJobs] -> [DryConfig] (by @mattwarren) 396b7d Diagnostics for \"JIT In-lining\" events (by @mattwarren) 7a1027 Merge remote-tracking branch 'origin/master' into develop (by @adamsitnik) 6ec7f0 GC Diagnosers: reference to nuget package, unit test for both CLASSIC and DNX (by @adamsitnik) 9e7059 Proper XML Doc comment for DryConfig attribute (by @mattwarren) ad6be7 README.md: update (by @AndreyAkinshin) a4d0b8 Merge branch 'master' into develop (by @adamsitnik) 71e911 perf: CSV export: less allocations, reusing JobShortInfo (by @adamsitnik) 409b5e perf: logging with less allocations (by @adamsitnik) be6bfc perf: simpified LoggerWithPrefix, no need to check for multiple lines because... (by @adamsitnik) ade8a1 perf: avoid string.Concat and string.PadLeft (by @adamsitnik) f070eb perf: reuse AllProperties, reduced complexity (by @adamsitnik) 57c88b perf: deffer export to enable continuous progress updates instead of single l... (by @adamsitnik) 40071d loggers: final cleanup and fix for doubled new lines for diagnosers (by @adamsitnik) c46854 supporting all kinds of references for generated project. This closes #49, cl... (by @adamsitnik) a36e34 Initial work on better cmd line discoverability (part of #78) (by @mattwarren) 3f0752 Better formatting in the Baseline column (by @mattwarren) 8ab1a2 More samples (by @mattwarren) 1981a3 Refactoring of ConfigParser code (part of #78) (by @mattwarren) 3d1eba Allows \"Exporters\" and \"Analysers\" to be specified via cmd line (part of #78) (by @mattwarren) 5d195a Allow \"all\" option, i.e. \"exporters=all\" (part of #78) (by @mattwarren) 2146b8 Added some tests for ConfigParser (by @mattwarren) 582e08 Merge pull request #124 from PerfDotNet/perf (by @AndreyAkinshin) 84e67d README: Update team section (by @AndreyAkinshin) 4d6001 README: add FAQ question (by @AndreyAkinshin) 43ade3 BenchmarkDotNet.Samples: add #CLASSIC_RELEASE in launchSettings (by @AndreyAkinshin) e3c2d1 README: some improvements (by @AndreyAkinshin) c416c4 use the highest used target framework version to avoid framework mismatches +... (by @adamsitnik) 8a49b3 Merge branch 'develop' into references (by @adamsitnik) 23b2ea integration tests for complex references scenarios (by @adamsitnik) ddfa4a classic: specify full name and use newer msbuild dlls to avoid calling extra bat (by @adamsitnik) 79e8eb code cleanup after LINQPad 4 & 5 verification (by @adamsitnik) 445137 Merge pull request #125 from PerfDotNet/references (by @AndreyAkinshin) 4f1e1f Update package description (by @AndreyAkinshin) 0f5531 Set library version: 0.9.4 (by @AndreyAkinshin) Contributors (4) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Matt Warren (@mattwarren) Sasha Goldshtein (@goldshtn) Thank you very much! Additional details Milestone: v0.9.4 Date: March 24, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.4 https://www.nuget.org/packages/BenchmarkDotNet/0.9.4-beta"
  },
  "changelog/v0.9.5.html": {
    "href": "changelog/v0.9.5.html",
    "title": "BenchmarkDotNet v0.9.5 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.9.5 Added validators, JitOptimizationsValidator detects all non-optimzied dlls that were referenced #134 Strong naming #101 Add IOrderProvider #107 Putting all the generated artifacts in a separate folder: ./BenchmarkDotNet.Artifacts/results and ./BenchmarkDotNet.Artifacts/bin #94 Printing dotnet cli version for .NET Core and Dnx451, informing user when not installed. Closed #128 Supporting assembly redirects #67 Changed used msbuild version: 12 for .NET 4.5 (VS 2013), 14 for .NET 4.6 (VS 2015). Closed #132 and #137 Switched to new ‘dotnet’ target framework monikers (dotnet5.4 instead of dnxcore50), why dnx452, dnx46, net462 support added Executing single Benchmark for multiple Runtimes also with Diagnoser attached (see #117) Misc minor changes Milestone details In the v0.9.5 scope, 13 issues were resolved and 0 pull requests were merged. This release includes 45 commits by 4 contributors. Resolved issues (13) #67 F# requiring assembly binding redirects for FSharp.Core #94 Put all the generated artifacts in a separate folder #101 Strong naming? #107 Specify benchmark method order #122 Reports: Move params columns next to Method column #128 Print dotnet cli version in EnvironmentInfo #129 Improve DnxAndCoreTests #132 [Bug] FileNotFoundException On 0.9.4. #134 [Feature request] Release builds only? #137 Brand new machine with VS 2015 only b0rks #142 [Suggestion] BenchmarkDotNet.Analyzers.IAnalyser - use same spelling for namespace and type? #148 Crash on [Params] with a string value that contains an invalid path char #150 Declaring nested enums and using them as parameter value make incorrectly generated code/ Merged pull requests (0) Commits (45) 2645ef use AutoGenerateBindingRedirects to avoid assembly conflicts, fixes #67 (by @adamsitnik) 693b21 warn user if dotnet cli is not installed and print it's version in summary, f... (by @adamsitnik) bfb017 target NET46 to reference msbuild 14 that comes with VS 2015 to make BDN work... (by @adamsitnik) fceb3c fallback to bat if MSBuild dlls are not found + generate bat when needed (by @adamsitnik) 49bdf0 restore: generating build script file (now for all runtimes) (by @adamsitnik) b9b0bc scripts: cleanup -> build -> show failed tests if any ->cleanup, fixes #129 (by @adamsitnik) ad64d8 Put all the generated artifacts in a separate folder, fixes #94 (by @adamsitnik) 902de6 F# samples targeting .NET Core +classic F# part reorganization (by @adamsitnik) b31c0b supported languages: updated readme & integration tests for Visual Basic (by @adamsitnik) 24ade7 handle missing MSBuild.dll, get latest msbuild in fallback script scenario, s... (by @adamsitnik) d371de Spelling mistake in errors message (see #139) (by @mattwarren) c882dd core: dependencies cleanup + getting rid of warnings (by @adamsitnik) b14e35 Add IOrderProvider, fixes #107 (by @AndreyAkinshin) c95267 warn user if non-optimized dll is used, fixes #134 (by @adamsitnik) 5876f5 Strong naming, fixes #101 (by @adamsitnik) 036168 Analys(z)ers unification, lets use single spelling, fixes #142 (by @adamsitnik) 2fa5c0 Update README.md (by @JohanLarsson) 8b8641 Merge pull request #145 from JohanLarsson/master (by @AndreyAkinshin) 734533 introducing Validators: validate benchmarks before running, return errors in ... (by @adamsitnik) eaa943 ExecutionValidator: allow users to verify that all their benchmarks are runna... (by @adamsitnik) e4fa4b support overriding with 'stronger' validators, eliminate duplicates (by @adamsitnik) 57666a Add column order for SummaryTable, fixes #122 (by @AndreyAkinshin) 62af92 Minor fixes in README (by @AndreyAkinshin) 5e6877 updated README (by @adamsitnik) 1255a4 Initial work on BenchmarkDotNet.Diagnostics.Windows rename (by @mattwarren) 59ca8c Ensure renamed diagnostics dll is loaded (BenchmarkDotNet.Diagnostics.Windows... (by @mattwarren) 825193 Added info about Diagnosers (by @mattwarren) b836c5 Spelling/formatting (by @mattwarren) 3f74c7 Fixing project.json (after I overwrite previous changes) (by @mattwarren) c24a78 Merge branch 'develop' of https://github.com/PerfDotNet/BenchmarkDotNet into ... (by @mattwarren) 8c678f reflecting recent Diagnosers->Diagnostics.Windows changes (by @adamsitnik) 9bcdca Executing single Benchmark for multiple Runtimes [with Diagnoser attached] #117 (by @adamsitnik) 4dffdb Switching to new ‘dotnet’ target framework monikers (by @adamsitnik) 81b1e4 improved Runtimes descriptions + .NET 4.6.2 support (by @adamsitnik) 8e92e1 dnx452 and dnx46 support (by @adamsitnik) 06efde Fix in BaselineDiffColumnTest, see also #122 (by @AndreyAkinshin) f79f83 DEVELOPING.md: use stable version of dotnet cli (by @AndreyAkinshin) c2206d BenchmarkDotNet/project.json: correct version for System.IO.FileSystem (by @AndreyAkinshin) 1b650d Support for nested Enums as Params values, fixes #150 (by @adamsitnik) 76ef44 characters as Params support, including invalid path characters, fixes #148 (by @adamsitnik) 14e45c Distinct jobs to avoid possible duplication when config is doubled (by @adamsitnik) 837254 cleanup (by @adamsitnik) d0cf6b added NETCore.Platforms dependency to make dotnet cli restore our Core projects (by @adamsitnik) f7a20e replacing the chars that are invalid for file names, not only paths #148 (by @adamsitnik) e31872 Set library version: 0.9.5 (by @AndreyAkinshin) Contributors (4) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Johan Larsson (@JohanLarsson) Matt Warren (@mattwarren) Thank you very much! Additional details Milestone: v0.9.5 Date: May 02, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.5 https://www.nuget.org/packages/BenchmarkDotNet/0.9.5-beta"
  },
  "changelog/v0.9.6.html": {
    "href": "changelog/v0.9.6.html",
    "title": "BenchmarkDotNet v0.9.6 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.9.6 Added Percentiles (see #164) Added support for Json export (see #84) Bugfixes Milestone details In the v0.9.6 scope, 11 issues were resolved and 2 pull requests were merged. This release includes 40 commits by 5 contributors. Resolved issues (11) #100 Code generation doesn't support generic classes #112 Generic benchmark classes are not supported #140 Readd an ability to define and to use custom Toolchain #141 [Request for comments] Assembly-level config attribute? #151 Crash during benchmark with baseline #152 MarkdownExporter.Default.ExportToLog fails with NRE for Summary with Critical Validation Errors #153 ManualConfig.Add(IConfig config) does not add the validators. #156 Cleanup benchmark folders #158 BaselineDiffColumn: NullReferenceException if one of the benchmark methods was failed. #161 Build warnings after update to 0.9.5 #171 Problem with ExceptionDispatchInfo (assignee: @AndreyAkinshin) Merged pull requests (2) #138 Percentiles added into Statistics, StatisticColumn, BaselineDiffColumn (by @ig-sinicyn) #164 Percentiles added into Statistics, StatisticColumn, BaselineDiffColumn (by @ig-sinicyn) Commits (40) 9e625a copying validators when merging configs, fixes #153 (by @adamsitnik) 5d0a7d returning empty objects instead of nulls, fixes #152 (by @adamsitnik) cfff3b switching back to the old moniker that is supported not only by dnx and dotne... (by @adamsitnik) 522fde Initial work on Json export (#84) (by @mattwarren) 31452f Make SimpleJson build under \"DNXCore,Version=v5.0\" - (#84) (by @mattwarren) 48b17a Merge branch 'develop' of github.com:PerfDotNet/BenchmarkDotNet into develop (by @mattwarren) d8dad6 removing ClrMD dependencies that were causing troubles with nuget package rel... (by @adamsitnik) 0a81d4 removing ClrMd diagnosers, they are kept in clrmd branch (by @adamsitnik) 972ea2 setting BenchmarkDotNet version to one that is not in the Nuget yet to get do... (by @adamsitnik) 1e6581 Removing final traces or Runtime and Source SourceDiagnosers (by @mattwarren) 3576d4 Make BaselineDiffColumn more robust - fixes #158 and #151 (by @mattwarren) 3f0d7b Exclude \"BenchmarkDotNet.Artifacts\" folder (can get in the way when building) (by @mattwarren) 00995d Percentiles added into Statistics, StatisticColumn, BaselineDiffColumn (by @ig-sinicyn) 2410d4 Update project.json files (by @AndreyAkinshin) ed75f6 Assembly-level config attribute, Fixes #141 (by @AndreyAkinshin) 6f3a0c Add a BenchmarkSwitcher constructor for assembly, see #141 (by @AndreyAkinshin) 4124d0 Catch InvalidOperationException in ClassicBuilder (by @AndreyAkinshin) 9c8513 Cleanup benchmark folders (by default!), fixes #156 (by @adamsitnik) d0179f merge KeepBenchmarkFiles and allow fluent api usage, #156 (by @adamsitnik) b8130a Readd an ability to define and to use custom Toolchain, fixes #140 (by @adamsitnik) 8a263b moving KeepBenchmarkFiles merge logic to Add method (by @adamsitnik) e1e5c7 Sample & documentation for percentiles (by @ig-sinicyn) 0d4262 Merge commit '00995dfac270ae71e81897348ec379cd97fb01c3' into feature-percentiles (by @ig-sinicyn) 54b4f0 Merge pull request #164 from ig-sinicyn/feature-percentiles (by @AndreyAkinshin) f8278c Generic benchmark support, fixes #100, fixes #112 (by @AndreyAkinshin) c28056 Support Mono+.NET4.6 in CommonExtensions.ToStr. (by @AndreyAkinshin) 285f77 set dependencies to MSBuild dlls as \"type\": \"build\" to make them implicit dep... (by @adamsitnik) 42abd1 Merge remote-tracking branch 'refs/remotes/origin/develop' into develop (by @mattwarren) 030d6c Rename \"GCDiagnoser\" -> \"MemoryDiagnoser\" (by @mattwarren) 4e96e6 give compilation error instead of warning or exception at runtime (by @adamsitnik) 0fbe10 Revert \"give compilation error instead of warning or exception at runtime\" (by @adamsitnik) 19708a Tidy up of the Integration tests (by @mattwarren) f7b3a4 Thread safe jobs, fixes #171 (by @AndreyAkinshin) edf293 DisableTestParallelization for Classic integration tests to avoid races (by @adamsitnik) 89165f moving dll that is required for custom path integration tests out of root folder (by @adamsitnik) cbaa3b README: Add additional info about RPlotExprter (by @AndreyAkinshin) 1cc936 The benchmark is improperly testing the Max operation because as all the numb... (by @redknightlois) 40a1ea Merge pull request #173 from redknightlois/develop (by @AndreyAkinshin) a9bf3b README: add information about the diagnostics package (by @AndreyAkinshin) 5191bc Set library version: 0.9.6 (by @AndreyAkinshin) Contributors (5) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Federico Andres Lois (@redknightlois) ig-sinicyn (@ig-sinicyn) Matt Warren (@mattwarren) Thank you very much! Additional details Milestone: v0.9.6 Date: May 11, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.6 https://www.nuget.org/packages/BenchmarkDotNet/0.9.6-beta https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.6"
  },
  "changelog/v0.9.7.html": {
    "href": "changelog/v0.9.7.html",
    "title": "BenchmarkDotNet v0.9.7 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.9.7 .NET Core RC2 support (see #187) Bugfixes Milestone details In the v0.9.7 scope, 8 issues were resolved and 0 pull requests were merged. This release includes 27 commits by 3 contributors. Resolved issues (8) #168 Unable to run tests locally #170 Error handling in the spawned Benchmark process (assignee: @mattwarren) #172 Ensure CsvMeasurementsExporter is enabled when RPlotExporter is used (assignee: @mattwarren) #179 Job.GetAllProperties(): old property names are used #181 CompositeValidator: some validators will be skipped #183 [Suggestion] Make ValidationError public #187 .NET Core RC2 (assignee: @adamsitnik) #192 Avoid creating .cs files at execution time Merged pull requests (0) Commits (27) 7568c0 Initial work on #130 (currently just matching existing behaviour) (by @mattwarren) 34965e Fixes #170 (by @mattwarren) 4d6d32 Remove \"@\" from the ProcessorName (by @AndreyAkinshin) 57b402 Specify HintPath for all referenced assemblies (for mono support) (by @AndreyAkinshin) 0d065b Merge branch 'develop' of github.com:PerfDotNet/BenchmarkDotNet into develop (by @mattwarren) c24a9c Less \"magic\" strings - Fixes #179 (by @mattwarren) 1371ea Allow Exporters to have dependencies, fixes #172 (by @mattwarren) d6a55c Further work on #130 (by @mattwarren) e0ebd4 Tidy up of the Json exporter code (part of #189) (by @mattwarren) ae330c Allow formatted/indented Json (see #189) (by @mattwarren) 83fd20 Also allow args with \"--\", i.e. --exporters=json (see #189) (by @mattwarren) 78af45 File missing from previous check-in \"ae330c4\" (#189) (by @mattwarren) 9352d0 \"Measurments\" -> \"Measurements\" (by @mattwarren) a34507 .NET Core RC2 support, fixes #187 (by @adamsitnik) 0c9524 remove IValidationError interface, make the implementation public, fixes #183 (by @adamsitnik) 30a6ec Avoid creating .cs files at execution time, fixes #192 (by @adamsitnik) 792176 hiding CompositeValidator, fix few typos, fixes #181 (by @adamsitnik) a345e7 Use short, hard coded name for folders to avoid PathTooLongEx if user does no... (by @adamsitnik) 354b28 minor cleanup after moving to RC2 (by @adamsitnik) 53b7ff dotnet cli bug workaround, Tornhoof's idea (by @adamsitnik) 8e6d30 added missing Nuget feeds to NuGet.Config, removed launchSettings which we do... (by @adamsitnik) 9addd0 Improvements in MethodInvoker (by @AndreyAkinshin) ccd91d Update Chronometer.HardwareTimerKind (by @AndreyAkinshin) e9db3d Update year in LICENSE.md (by @AndreyAkinshin) acd019 updated docs for .NET Core RC2 #187 (by @adamsitnik) 605aa1 README.md: add a link to BenchmarkDotNet.Diagnostics.Windows (by @AndreyAkinshin) 571b3d Set library version: 0.9.7 (by @AndreyAkinshin) Contributors (3) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Matt Warren (@mattwarren) Thank you very much! Additional details Milestone: v0.9.7 Date: May 29, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.7 https://www.nuget.org/packages/BenchmarkDotNet/0.9.7-beta https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.7"
  },
  "changelog/v0.9.8.html": {
    "href": "changelog/v0.9.8.html",
    "title": "BenchmarkDotNet v0.9.8 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.9.8 CoreCLR RTM support (see #216). Breaking change: we have dropped dnx451 and dnxcore50 support. Migration from MSBuild to Roslyn, which supports Mono on Linux and MacOS (see #149). Breaking change: we have dropped .NET 4.0 support. Ability to manage GC mode: turn on/off the Server/Concurrent GC modes, extend to CPU groups, set gcAllowVeryLargeObjects and avoid BenchmarkDotNet from forcing GC.Collect (see #188, #76 and #211) Support CopyToOutput (see #212). Now you can use native dependencies as well as custom files. Copying custom settings from app.config (see #108). It means we support assembly binding redirects as well as custom connection strings etc. AsciiDocExporter (see #169) Framework setting in Job has been removed (see #194) Minor bugfixes and improvements Milestone details In the v0.9.8 scope, 21 issues were resolved and 1 pull requests were merged. This release includes 69 commits by 5 contributors. Resolved issues (21) #57 Make Benchmark, Setup and Params attribute sealed in explicit way #76 Allow users to set gcAllowVeryLargeObjects for Runtime Settings (assignee: @AndreyAkinshin) #77 Implement a C.I build (assignee: @mattwarren) #108 Copy custom setting from app.config #131 [Mono] BenchmarkDotNet doesn't work on Mac OS #149 Migrate from MSBuild to Roslyn #174 NRE in Summary indexer property. #176 Split and simplify printed summaries #188 Ability to manage GC mode: turn on/off the Server/Concurrent GC modes and extend to CPU groups #191 MSBuild dependency - best way of fixing? #194 Framework settings in Jobs (assignee: @mattwarren) #196 Allow specifying a gist url to RunUrl #197 Regression in 0.9.7: --help option fails under dotnet run #203 Third-party libraries must be explicitly included in test context to be loaded by runner #209 Fix appveyor bug #211 Possibility to turn off GC.Collect after each benchmark run (assignee: @adamsitnik) #212 Support CopyToOutput #214 Benchmark ignores binding redirects #216 Update to .NET Core RTM (assignee: @adamsitnik) #218 Errors in BenchmarkDotNet.Samples.FSharp.Core/projects.json #222 A problem with System.Threading.Tasks Merged pull requests (1) #169 Support export to asciidoc (by @russcam) Commits (69) fcf48e Support export to asciidoc (by @russcam) 590a0a Road to Roslyn: first attempt (by @AndreyAkinshin) 704605 Added appveyor ci build (by @gigi81) 3859a1 Catch exception when accessing Console.WindowWidth, fixes #197 (by @mattwarren) 7b92eb Filter tests by attribute (see #130) (by @mattwarren) dd3464 Merge pull request #202 from gigi81/appveyor-build-2 (by @adamsitnik) 29d106 Added missing 'build dependency' (by @gigi81) 2e8209 Merge pull request #205 from gigi81/fix-missing-dependency (by @AndreyAkinshin) ff298d Appveyor build improvements (by @gigi81) 600cdd Merge pull request #206 from gigi81/appveyor-4 (by @AndreyAkinshin) 68b070 Fixed tests not using OutputLogger (by @gigi81) 7d0501 Renamed _output to output (by @gigi81) ae5eab Merge pull request #207 from gigi81/fix-outputlogger (by @AndreyAkinshin) dfe110 Small cleanup: remove compilation warnings (by @AndreyAkinshin) ffe9f7 Clean up, part 2 (by @AndreyAkinshin) 559f20 appveyor specific test fixes (by @AndreyAkinshin) 38af24 MemoryDiagnoserTests: double.Parse Culture fix (by @AndreyAkinshin) 02048d StatResultExtenderTests: SpeedUp (by @AndreyAkinshin) f2b21f Clean up, part 3 (by @AndreyAkinshin) d32328 SpeedUp: BaselineScaledColumnsTest, StatResultExtenderTests (by @AndreyAkinshin) 5e37fa MemoryDiagnoserTests: additional parsing fixes (by @AndreyAkinshin) 45c66f Merge branch 'develop' into Roslyn (by @adamsitnik) a4cb8c MemoryDiagnoserTests: Temporarily suppressed (by @AndreyAkinshin) ae38a5 README: add the appveyor badge (by @AndreyAkinshin) 77bd64 README: update badges (by @AndreyAkinshin) a74f82 README: update badges, part 2 (by @AndreyAkinshin) 453a49 merging recent changes from develop with Roslyn branch to get it working again (by @adamsitnik) ce4af5 add dependencies in recursive way, fixes #203 (by @adamsitnik) a36af4 farewell MSBuid (by @adamsitnik) d2dd83 Workaround for xunit bug (by @gigi81) 46f2b7 Merge pull request #210 from gigi81/xunit-workaround-2 (by @AndreyAkinshin) c5b4ae Merge remote-tracking branch 'refs/remotes/origin/develop' into Roslyn (by @AndreyAkinshin) 54109b copy custom settings from app.config file, fixes #108 (by @adamsitnik) 20c41f enable GC settings customization, fixes #188 (by @adamsitnik) dd0bc4 tests fix ;) (by @adamsitnik) 0726b5 Possibility to turn off GC.Collect after each benchmark run, fixes #211 (by @adamsitnik) da24b4 rename GC to GarbageCollection to avoid conflicts with System.GC (by @adamsitnik) 3bf420 gcAllowVeryLargeObjects, fixes #76 (by @adamsitnik) bdce98 split EnvironmentInfo into Host and Benchmark specific, make expensive method... (by @adamsitnik) e819c8 added GC info to BenchmarkEnvironmentInfo (by @adamsitnik) 9e0480 change GC settings display order (Workstation Concurrent => Concurrent Workst... (by @adamsitnik) d03d17 support CopyToOutput: build in output directory + some refacotring, fixes #212 (by @adamsitnik) 237370 minor bug fix: support spaces in parameters representation (by @adamsitnik) 06349a Update to .NET Core RTM, drop DNX* support, fixes #216 (by @adamsitnik) 106477 Merge branch 'develop' of https://github.com/russcam/BenchmarkDotNet into rus... (by @AndreyAkinshin) 2e18db Merge branch 'russcam-develop' into develop (by @AndreyAkinshin) 388155 Fix a NRE bug in Summary indexer, fixes #174 (by @AndreyAkinshin) d448b4 Now RunUrl can work with non-raw github and gist urls, fixes #196 (by @AndreyAkinshin) 7e1b95 Welch's Two Sample t-test (by @AndreyAkinshin) cc70cb specify version of F# compiler in explicit way to workaround nuget bug, fixes... (by @adamsitnik) e21373 use Roslyn's managed API for compilation, drop .NET 4.0 support!! fixes #149 (by @adamsitnik) cd25cc use single reflection api after update to .NET 4.5 (by @adamsitnik) 785d92 make Benchmark, Setup and Params Attribute sealed #57 (by @adamsitnik) 8a3212 hopefully a workaround for appveyor build (by @adamsitnik) ef7e35 hopefully a workaround for appveyor build, which does not have the latest dot... (by @adamsitnik) 918a6d Remove xmlns for packages.config in IntegrationTests.Classic (by @AndreyAkinshin) b897ed Merge branch 'Roslyn' into develop (by @adamsitnik) 742a16 skip test that fails for Core on appveyor, #221 (by @adamsitnik) a94a8b skip test that fails for Classic on appveyor, #221 (by @adamsitnik) fec206 Fix incorrect xml-docs in MathHelper (by @AndreyAkinshin) 1567d9 DEVELOPING.md: add a section about develop NuGet feed (by @AndreyAkinshin) 5c3c31 appveyor: add BenchmarkDotNet.Diagnostics.Windows.nupkg to artifacts (by @AndreyAkinshin) a69188 DEVELOPING.md: fix a typo (by @AndreyAkinshin) 4e99b4 project.json: add tags (by @AndreyAkinshin) 61b4c1 use System.Threading.Tasks as nuget package to fix nuget installation problem... (by @adamsitnik) 976118 remove Framework settings from Jobs, fixes #194 (by @adamsitnik) be0b71 try to remove the directory few more times when it's still not released to ma... (by @adamsitnik) 0647a0 use the Configuration from the hosting process, not BDN dll (by @adamsitnik) c6405a Set library version: 0.9.8 (by @AndreyAkinshin) Contributors (5) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Luigi Grilli (@gigi81) Matt Warren (@mattwarren) Russ Cam (@russcam) Thank you very much! Additional details Milestone: v0.9.8 Date: July 07, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.8 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.8"
  },
  "changelog/v0.9.9.html": {
    "href": "changelog/v0.9.9.html",
    "title": "BenchmarkDotNet v0.9.9 | BenchmarkDotNet",
    "summary": "BenchmarkDotNet v0.9.9 Attribute config style (see #166) Online documentation (see #219) Mono LLVM support (see #226) Async method support (see #236) NuGet packages and repo layout restructuring (see #225, #228) [Cleanup] attribute (see #215) New statistics columns: Skewness, Kurtosis, WelchTTestPValue, Improved math for the Scaled column Now current default branch is master Minor improvements and bug fixes Milestone details In the v0.9.9 scope, 14 issues were resolved and 1 pull requests were merged. This release includes 46 commits by 4 contributors. Resolved issues (14) #166 Suggestion: Attribute Config style (assignee: @AndreyAkinshin) #215 Allow a [Cleanup] method to be specified #219 Online documentation and API reference #223 Add support for System.Type in Params #224 [Breaking change] BenchmarkAttribute become sealed. #225 Refactoring the roslyn dependency into another package #226 Support Mono/LLVM as a runtime/jit #227 Suggestion: change default branch (assignee: @AndreyAkinshin) #228 Suggestion: clean up the root folder #231 Add references to default framework assemblies (System.Runtime etc) #232 Make all tests use OutputLogger (assignee: @adamsitnik) #235 Don't show non-error output of dotnet cli (assignee: @adamsitnik) #236 Possibility to benchmark asynchronous methods (assignee: @adamsitnik) #240 Total Time reports hour rounded up Merged pull requests (1) #233 Add support of Cleanup attribute #215 (by @DenisIstomin) Commits (46) f9f748 Improved \"Scaled\" column (by @AndreyAkinshin) 5d7ba9 Warmup improvements (by @AndreyAkinshin) 664c64 Add Skewness, Kurtosis, and WelchTTestPValue columns and configs (by @AndreyAkinshin) c9e802 Attribute Config style, fixes #166 (by @AndreyAkinshin) 378173 README: add supported OS (by @AndreyAkinshin) 50ac57 Make Benchmark, Params and Setup attributes non-sealed again, fixes #224, #57 (by @adamsitnik) b9c815 Support Mono/LLVM as a runtime/jit, fixes #226 (by @adamsitnik) cdfbd5 Update info about default branch, see #227 (by @AndreyAkinshin) 42e9b9 Add System.Type support in Params, fixes #223 (by @AndreyAkinshin) db3dc3 Suggestion: clean up the root folder, fixes #228 (by @adamsitnik) 4e1db3 use shorter names for test for xunit test runner (method name instead of full... (by @adamsitnik) a35b22 make sure all framework assemblies are referenced, #231 (by @adamsitnik) 19426a spliting BenchmarkDotNet.dll to few dlls to avoid mandatory Roslyn dependency... (by @adamsitnik) 356a39 move BenchmarkRunner's core to separate class to .Core project so it can be ... (by @adamsitnik) 0121a6 minor cleanup: rename LLVM => Llvm, remove [Obsolete] things (by @adamsitnik) fb8047 Make all tests use OutputLogger, fixes #232 (by @adamsitnik) ae17a7 Add support of Cleanup attribute, fix #215 (by @DenisIstomin) 3bf9c0 Merge branch 'master' of https://github.com/PerfDotNet/BenchmarkDotNet (by @adamsitnik) 355c6f Don't show non-error output of dotnet cli, fixes #235 (by @adamsitnik) 76df80 Possibility to benchmark asynchronous methods #236 (by @adamsitnik) 3ab578 use GetAwaiter().GetResult() for Tasks instead of .Wait or .Result, #236 (by @adamsitnik) d1db7d Added documentation source and output based on readme.md (by @FransBouma) ac8cf2 Updated folder structure, removed html output, updated gitignore (by @FransBouma) bed0f9 Removed unused folder copy directive from docnet.json (by @FransBouma) 650fca Merge pull request #239 from FransBouma/master (by @AndreyAkinshin) aceb96 Added Api docs generation directives (by @FransBouma) a9ee7c Fix in total time formatting, fix #240 (by @AndreyAkinshin) 1d2141 Update README.md (by @AndreyAkinshin) 7b9fdb Fixed a couple of issues with api doc generation (by @FransBouma) 682837 Merge pull request #243 from FransBouma/master (by @AndreyAkinshin) 9a2cf2 docs improvements (by @AndreyAkinshin) 334925 Rename: GarbageCollection -> GcMode (by @AndreyAkinshin) 7a740a SummaryTableTests and minor refactorings (by @AndreyAkinshin) c9d358 Transform GcModeColumn with null values to a trivial column (by @AndreyAkinshin) cb6359 Improved HardwareTimerKind detection (by @AndreyAkinshin) 04f736 Fix references in the IntegrationTests project files (by @AndreyAkinshin) a9403a Fix warnings (by @AndreyAkinshin) 691a05 BenchmarkDotNet.Tests: Remove the System.Globalization dependency (by @AndreyAkinshin) 9e97d7 Show JitModules in EnvInfo only for the classic toolchain (by @AndreyAkinshin) 823518 Improved docs (by @AndreyAkinshin) 5fb854 Update README (by @AndreyAkinshin) 5ebf8b Minor fixes (by @AndreyAkinshin) 086dfd generic wrapper for config values (by @adamsitnik) cf58b0 Merge branch 'gc' (by @adamsitnik) bbccbe docs: add informations about NuGet packages (by @AndreyAkinshin) 60bea3 Set library version: 0.9.9 (by @AndreyAkinshin) Contributors (4) Adam Sitnik (@adamsitnik) Andrey Akinshin (@AndreyAkinshin) Denis Istomin (@DenisIstomin) Frans Bouma (@FransBouma) Thank you very much! Additional details Date: August 18, 2016 Milestone: v0.9.9 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.9 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.9.9 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.9.9 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.9 Online Documentation: https://perfdotnet.github.io/BenchmarkDotNet/"
  },
  "index.html": {
    "href": "index.html",
    "title": "Home | BenchmarkDotNet",
    "summary": "Features · Getting started · Documentation · Learn more about benchmarking BenchmarkDotNet helps you to transform methods into benchmarks, track their performance, and share reproducible measurement experiments. It's no harder than writing unit tests! Under the hood, it performs a lot of magic that guarantees reliable and precise results thanks to the perfolizer statistical engine. BenchmarkDotNet protects you from popular benchmarking mistakes and warns you if something is wrong with your benchmark design or obtained measurements. The results are presented in a user-friendly form that highlights all the important facts about your experiment. BenchmarkDotNet is already adopted by 26000+ GitHub projects including .NET Runtime, .NET Compiler, .NET Performance, and many others. It's easy to start writing benchmarks, check out the following example (copy-pastable version is here): [SimpleJob(RuntimeMoniker.Net472, baseline: true)] [SimpleJob(RuntimeMoniker.NetCoreApp30)] [SimpleJob(RuntimeMoniker.NativeAot70)] [SimpleJob(RuntimeMoniker.Mono)] [RPlotExporter] public class Md5VsSha256 { private SHA256 sha256 = SHA256.Create(); private MD5 md5 = MD5.Create(); private byte[] data; [Params(1000, 10000)] public int N; [GlobalSetup] public void Setup() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark] public byte[] Sha256() => sha256.ComputeHash(data); [Benchmark] public byte[] Md5() => md5.ComputeHash(data); } BenchmarkDotNet automatically runs the benchmarks on all the runtimes, aggregates the measurements, and prints a summary table with the most important information: BenchmarkDotNet=v0.12.0, OS=Windows 10.0.17763.805 (1809/October2018Update/Redstone5) Intel Core i7-7700K CPU 4.20GHz (Kaby Lake), 1 CPU, 8 logical and 4 physical cores [Host] : .NET Framework 4.7.2 (4.7.3468.0), X64 RyuJIT Net472 : .NET Framework 4.7.2 (4.7.3468.0), X64 RyuJIT NetCoreApp30 : .NET Core 3.0.0 (CoreCLR 4.700.19.46205, CoreFX 4.700.19.46214), X64 RyuJIT NativeAot70 : .NET 7.0.0-preview.4.22172.7, X64 NativeAOT Mono : Mono 6.4.0 (Visual Studio), X64 | Method | Runtime | N | Mean | Error | StdDev | Ratio | |------- |-------------- |------ |-----------:|----------:|----------:|------:| | Sha256 | .NET 4.7.2 | 1000 | 7.735 us | 0.1913 us | 0.4034 us | 1.00 | | Sha256 | .NET Core 3.0 | 1000 | 3.989 us | 0.0796 us | 0.0745 us | 0.50 | | Sha256 | NativeAOT 7.0 | 1000 | 4.091 us | 0.0811 us | 0.1562 us | 0.53 | | Sha256 | Mono | 1000 | 13.117 us | 0.2485 us | 0.5019 us | 1.70 | | | | | | | | | | Md5 | .NET 4.7.2 | 1000 | 2.872 us | 0.0552 us | 0.0737 us | 1.00 | | Md5 | .NET Core 3.0 | 1000 | 1.848 us | 0.0348 us | 0.0326 us | 0.64 | | Md5 | NativeAOT 7.0 | 1000 | 1.817 us | 0.0359 us | 0.0427 us | 0.63 | | Md5 | Mono | 1000 | 3.574 us | 0.0678 us | 0.0753 us | 1.24 | | | | | | | | | | Sha256 | .NET 4.7.2 | 10000 | 74.509 us | 1.5787 us | 4.6052 us | 1.00 | | Sha256 | .NET Core 3.0 | 10000 | 36.049 us | 0.7151 us | 1.0025 us | 0.49 | | Sha256 | NativeAOT 7.0 | 10000 | 36.253 us | 0.7076 us | 0.7571 us | 0.49 | | Sha256 | Mono | 10000 | 116.350 us | 2.2555 us | 3.0110 us | 1.58 | | | | | | | | | | Md5 | .NET 4.7.2 | 10000 | 17.308 us | 0.3361 us | 0.4250 us | 1.00 | | Md5 | .NET Core 3.0 | 10000 | 15.726 us | 0.2064 us | 0.1930 us | 0.90 | | Md5 | NativeAOT 7.0 | 10000 | 15.627 us | 0.2631 us | 0.2461 us | 0.89 | | Md5 | Mono | 10000 | 30.205 us | 0.5868 us | 0.6522 us | 1.74 | The measured data can be exported to different formats (md, html, csv, xml, json, etc.) including plots: Supported runtimes: .NET 5+, .NET Framework 4.6.1+, .NET Core 2.0+, Mono, NativeAOT Supported languages: C#, F#, Visual Basic Supported OS: Windows, Linux, macOS Supported architectures: x86, x64, ARM, ARM64, Wasm and LoongArch64 Features BenchmarkDotNet has tons of features that are essential in comprehensive performance investigations. Four aspects define the design of these features: simplicity, automation, reliability, and friendliness. Simplicity You shouldn't have to be an experienced performance engineer if you want to write benchmarks. You can design very complicated performance experiments in the declarative style using simple APIs. For example, if you want to parameterize your benchmark, mark a field or a property with [Params(1, 2, 3)]: BenchmarkDotNet will enumerate all of the specified values and run benchmarks for each case. If you want to compare benchmarks with each other, mark one of the benchmarks as the baseline via [Benchmark(Baseline = true)]: BenchmarkDotNet will compare it with all of the other benchmarks. If you want to compare performance in different environments, use jobs. For example, you can run all the benchmarks on .NET 8.0 and Mono via [SimpleJob(RuntimeMoniker.Net80)] and [SimpleJob(RuntimeMoniker.Mono)]. If you don't like attributes, you can call most of the APIs via the fluent style and write code like this: ManualConfig.CreateEmpty() // A configuration for our benchmarks .AddJob(Job.Default // Adding first job .WithRuntime(ClrRuntime.Net472) // .NET Framework 4.7.2 .WithPlatform(Platform.X64) // Run as x64 application .WithJit(Jit.LegacyJit) // Use LegacyJIT instead of the default RyuJIT .WithGcServer(true) // Use Server GC ).AddJob(Job.Default // Adding second job .AsBaseline() // It will be marked as baseline .WithEnvironmentVariable(\"Key\", \"Value\") // Setting an environment variable .WithWarmupCount(0) // Disable warm-up stage ); If you prefer command-line experience, you can configure your benchmarks via the console arguments in any console application (other types of applications are not supported). Automation Reliable benchmarks always include a lot of boilerplate code. Let's think about what you should do in a typical case. First, you should perform a pilot experiment and determine the best number of method invocations. Next, you should execute several warm-up iterations and ensure that your benchmark achieved a steady state. After that, you should execute the main iterations and calculate some basic statistics. If you calculate some values in your benchmark, you should use it somehow to prevent dead code elimination. If you use loops, you should care about the effect of the loop unrolling on your results (which may depend on the processor architecture). Once you get results, you should check for some special properties of the obtained performance distribution like multimodality or extremely high outliers. You should also evaluate the overhead of your infrastructure and deduct it from your results. If you want to test several environments, you should perform the measurements in each of them and manually aggregate the results. If you write this code from scratch, it's easy to make a mistake and spoil your measurements. Note that it's a shortened version of the full checklist that you should follow during benchmarking: there are a lot of additional hidden pitfalls that should be handled appropriately. Fortunately, you shouldn't worry about it because BenchmarkDotNet will perform this boring and time-consuming stuff for you. Moreover, the library can help you with some advanced tasks that you may want to perform during the investigation. For example, BenchmarkDotNet can measure the managed and native memory traffic and print disassembly listings for your benchmarks. Reliability A lot of hand-written benchmarks produce wrong numbers that lead to incorrect business decisions. BenchmarkDotNet protects you from most of the benchmarking pitfalls and allows achieving high measurement precision. You shouldn't worry about the perfect number of method invocation, the number of warm-up and actual iterations: BenchmarkDotNet tries to choose the best benchmarking parameters and achieve a good trade-off between the measurement prevision and the total duration of all benchmark runs. So, you shouldn't use any magic numbers (like \"We should perform 100 iterations here\"), the library will do it for you based on the values of statistical metrics. BenchmarkDotNet also prevents benchmarking of non-optimized assemblies that were built using DEBUG mode because the corresponding results will be unreliable. The library will print a warning if you have an attached debugger, if you use a hypervisor (HyperV, VMware, VirtualBox), or if you have any other problems with the current environment. During 6+ years of development, we faced dozens of different problems that may spoil your measurements. Inside BenchmarkDotNet, there are a lot of heuristics, checks, hacks, and tricks that help you to increase the reliability of the results. Friendliness Analysis of performance data is a time-consuming activity that requires attentiveness, knowledge, and experience. BenchmarkDotNet performs the main part of this analysis for you and presents results in a user-friendly form. After the experiments, you get a summary table that contains a lot of useful data about the executed benchmarks. By default, it includes only the most important columns, but they can be easily customized. The column set is adaptive and depends on the benchmark definition and measured values. For example, if you mark one of the benchmarks as a baseline, you will get additional columns that will help you to compare all the benchmarks with the baseline. By default, it always shows the Mean column, but if we detected a vast difference between the Mean and the Median values, both columns will be presented. BenchmarkDotNet tries to find some unusual properties of your performance distributions and prints nice messages about it. For example, it will warn you in case of multimodal distribution or high outliers. In this case, you can scroll the results up and check out ASCII-style histograms for each distribution or generate beautiful png plots using [RPlotExporter]. BenchmarkDotNet doesn't overload you with data; it shows only the essential information depending on your results: it allows you to keep the summary small for primitive cases and extend it only for complicated cases. Of course, you can request any additional statistics and visualizations manually. If you don't customize the summary view, the default presentation will be as much user-friendly as possible. :) Learn more about benchmarking BenchmarkDotNet is not a silver bullet that magically makes all of your benchmarks correct and analyzes the measurements for you. Even if you use this library, you still should know how to design benchmark experiments and how to make correct conclusions based on the raw data. If you want to know more about benchmarking methodology and good practices, it's recommended to read a book by Andrey Akinshin (the BenchmarkDotNet project lead): \"Pro .NET Benchmarking\". Use this in-depth guide to correctly design benchmarks, measure key performance metrics of .NET applications, and analyze results. This book presents dozens of case studies to help you understand complicated benchmarking topics. You will avoid common pitfalls, control the accuracy of your measurements, and improve the performance of your software. Contributions are welcome! BenchmarkDotNet is already a stable full-featured library that allows performing performance investigation on a professional level. And it continues to evolve! We add new features all the time, but we have too many new cool ideas. Any help will be appreciated. You can develop new features, fix bugs, improve the documentation, or do some other cool stuff. If you want to contribute, check out the Contributing guide and up-for-grabs issues. If you have new ideas or want to complain about bugs, feel free to create a new issue. Let's build the best tool for benchmarking together! Code of Conduct This project has adopted the code of conduct defined by the Contributor Covenant to clarify expected behavior in our community. For more information, see the .NET Foundation Code of Conduct."
  }
}